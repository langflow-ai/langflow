language: en-US
tone_instructions: ""
early_access: true
enable_free_tier: true
reviews:
  profile: chill
  request_changes_workflow: false
  high_level_summary: true
  high_level_summary_placeholder: "@coderabbitai summary"
  high_level_summary_in_walkthrough: false
  auto_title_placeholder: "@coderabbitai"
  auto_title_instructions: Use conventional commits structure
  review_status: true
  commit_status: true
  fail_commit_status: false
  collapse_walkthrough: false
  changed_files_summary: true
  sequence_diagrams: true
  assess_linked_issues: true
  related_issues: true
  related_prs: true
  suggested_labels: true
  auto_apply_labels: false
  suggested_reviewers: true
  auto_assign_reviewers: false
  poem: false
  labeling_instructions: []
  path_filters:
    - "!src/backend/base/langflow/initial_setup/starter_projects"
  path_instructions: []
  abort_on_close: true
  disable_cache: false
  auto_review:
    enabled: true
    auto_incremental_review: false
    ignore_title_keywords: []
    labels: []
    drafts: false
    base_branches: []
  finishing_touches:
    docstrings:
      enabled: true
    unit_tests:
      enabled: true
  pre_merge_checks:
    custom_checks:
      - name: "Test Coverage for New Implementations"
        instructions: |
          Check if the PR includes new or updated test files that correspond to the code changes:
          1. For new components or functionality, ensure corresponding tests are included in the PR
          2. For bug fixes, verify that regression tests are included
          3. For new features, ensure both unit and integration tests are present where appropriate
          4. Check that test files follow the project's naming conventions (test_*.py for backend, *.test.ts for frontend)
          5. Verify that tests actually test the new functionality, not just placeholder tests
        mode: "error"
      - name: "Test Quality and Coverage"
        instructions: |
          Evaluate the quality and comprehensiveness of tests for new implementations:
          1. Tests should cover the main functionality being implemented
          2. For async functions, ensure proper async testing patterns are used (pytest for backend)
          3. Check that tests are not just smoke tests but actually validate behavior
          4. Ensure tests follow the project's testing patterns (pytest for backend, Playwright for frontend)
          5. For API endpoints, verify both success and error response testing
        mode: "warning"
      - name: "Test File Naming and Structure"
        instructions: |
          Verify that test files follow the correct patterns and structure:
          1. Backend tests: test_*.py with proper pytest structure
          2. Frontend tests: *.test.ts or *.test.tsx using Playwright
          3. Integration tests should be clearly marked and in appropriate directories
          4. Test files should have descriptive test function names that explain what is being tested
          5. Tests should be organized logically with proper setup and teardown
          6. Consider including edge cases and error conditions for comprehensive coverage
          7. Verify tests cover both positive and negative scenarios where appropriate
        mode: "warning"
      - name: "Excessive Mock Usage Warning"
        instructions: |
          Review test files for excessive use of mocks that may indicate poor test design:
          1. Check if tests have too many mock objects that obscure what's actually being tested
          2. Warn when mocks are used instead of testing real behavior and interactions
          3. Suggest using real objects or test doubles when mocks become excessive
          4. Ensure mocks are used appropriately for external dependencies, not core logic
          5. Recommend integration tests when unit tests become overly mocked
        mode: "warning"
  tools:
    ast-grep:
      rule_dirs: []
      util_dirs: []
      essential_rules: true
      packages: []
    shellcheck:
      enabled: true
    ruff:
      enabled: true
    markdownlint:
      enabled: true
    github-checks:
      enabled: true
      timeout_ms: 90000
    languagetool:
      enabled: true
      enabled_rules: []
      disabled_rules: []
      enabled_categories: []
      disabled_categories: []
      enabled_only: false
      level: default
    biome:
      enabled: true
    hadolint:
      enabled: true
    swiftlint:
      enabled: true
    phpstan:
      enabled: true
      level: default
    golangci-lint:
      enabled: true
    yamllint:
      enabled: true
    gitleaks:
      enabled: true
    checkov:
      enabled: true
    detekt:
      enabled: true
    eslint:
      enabled: true
    rubocop:
      enabled: true
    buf:
      enabled: true
    regal:
      enabled: true
    actionlint:
      enabled: true
    pmd:
      enabled: true
    cppcheck:
      enabled: true
    semgrep:
      enabled: true
    circleci:
      enabled: true
    clippy:
      enabled: true
    sqlfluff:
      enabled: true
    prismaLint:
      enabled: true
    pylint:
      enabled: true
    oxc:
      enabled: true
    shopifyThemeCheck:
      enabled: true
    luacheck:
      enabled: true
    brakeman:
      enabled: true
    dotenvLint:
      enabled: true
    htmlhint:
      enabled: true
    checkmake:
      enabled: true
chat:
  auto_reply: true
  integrations:
    jira:
      usage: auto
    linear:
      usage: auto
knowledge_base:
  opt_out: false
  code_guidelines:
    enabled: true
  web_search:
    enabled: true
  learnings:
    scope: auto
  issues:
    scope: auto
  jira:
    usage: auto
    project_keys: []
  linear:
    usage: auto
    team_keys: []
  pull_requests:
    scope: auto
code_generation:
  docstrings:
    language: en-US
    path_instructions: []
  unit_tests:
    path_instructions:
      - path: src/backend/tests/**/*.py
        instructions: We already have a client fixture and use pytest
      - path: src/frontend/tests/**.ts
        instructions: We use Playwright
