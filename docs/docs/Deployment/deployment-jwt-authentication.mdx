---
title: JWT Authentication Configuration
slug: /deployment-jwt-authentication
description: Configure JWT authentication in Langflow with HS256, RS256, or RS512 algorithms for secure token-based authentication.
sidebar_position: 5
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# JWT Authentication Configuration

This guide explains how to configure JSON Web Token (JWT) authentication in Langflow, including the different signing algorithms available, their security implications, and step-by-step configuration instructions.

## What is JWT?

JSON Web Token (JWT) is an open standard ([RFC 7519](https://tools.ietf.org/html/rfc7519)) for securely transmitting information between parties as a JSON object. JWTs are commonly used for authentication and authorization in web applications.

A JWT consists of three parts separated by dots (`.`):

```
header.payload.signature
```

- **Header**: Contains the token type and signing algorithm
- **Payload**: Contains claims (user data, expiration time, etc.)
- **Signature**: Ensures the token hasn't been tampered with

## Understanding JWT Signing Algorithms

Langflow supports three JWT signing algorithms. Each algorithm has different security characteristics and use cases.

### Algorithm Comparison

| Algorithm | Type | Key Type | Security Level | Best For |
|-----------|------|----------|----------------|----------|
| **HS256** | Symmetric | Single secret key | Good | Single-server deployments |
| **RS256** | Asymmetric | Public/Private key pair | Excellent | Distributed systems, microservices |
| **RS512** | Asymmetric | Public/Private key pair | Excellent | High-security environments |

### HS256 (HMAC with SHA-256)

**HS256** is a **symmetric** algorithm, meaning the same secret key is used for both signing and verifying tokens.

**How it works:**

```
┌─────────────────────────────────────────────────────────────┐
│                     HS256 (Symmetric)                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌─────────────┐                     ┌─────────────┐       │
│   │   Server    │                     │   Server    │       │
│   │  (Sign)     │                     │  (Verify)   │       │
│   └──────┬──────┘                     └──────┬──────┘       │
│          │                                   │              │
│          │         SECRET_KEY                │              │
│          │    ┌─────────────────┐            │              │
│          └───►│  Same Key Used  │◄───────────┘              │
│               │  for Both       │                           │
│               └─────────────────┘                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**Advantages:**
- Simple to set up and use
- Faster signing and verification
- Only one key to manage

**Disadvantages:**
- The same key must be shared across all services that need to verify tokens
- If the key is compromised, attackers can both read AND create tokens
- Not suitable for scenarios where you want to separate token creation from verification

**When to use HS256:**
- Single-server deployments
- Development and testing environments
- When all services are trusted and managed by the same team

### RS256 (RSA Signature with SHA-256)

**RS256** is an **asymmetric** algorithm that uses a key pair: a private key for signing and a public key for verification.

**How it works:**

```
┌─────────────────────────────────────────────────────────────┐
│                    RS256 (Asymmetric)                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌─────────────┐                     ┌─────────────┐       │
│   │Auth Server  │                     │API Service  │       │
│   │  (Sign)     │                     │  (Verify)   │       │
│   └──────┬──────┘                     └──────┬──────┘       │
│          │                                   │              │
│          ▼                                   ▼              │
│   ┌─────────────┐                     ┌─────────────┐       │
│   │ PRIVATE_KEY │                     │ PUBLIC_KEY  │       │
│   │  (Secret)   │                     │ (Shareable) │       │
│   └─────────────┘                     └─────────────┘       │
│          │                                   ▲              │
│          │         Creates Token             │              │
│          └───────────────────────────────────┘              │
│                    Can Verify                               │
│                  (Cannot Create)                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**Advantages:**
- More secure for distributed systems
- Public key can be safely shared without compromising security
- Services can verify tokens without being able to create them
- Compromising the public key doesn't allow token creation

**Disadvantages:**
- Slightly slower than HS256
- Two keys to manage
- More complex initial setup

**When to use RS256:**
- Production environments
- Microservices architectures
- When third-party services need to verify tokens
- When you want to separate authentication from authorization

### RS512 (RSA Signature with SHA-512)

**RS512** works the same as RS256 but uses SHA-512 instead of SHA-256 for the hash function.

**Advantages over RS256:**
- Larger hash output (512 bits vs 256 bits)
- Theoretically more resistant to collision attacks

**Disadvantages compared to RS256:**
- Slightly slower
- Larger signature size
- In practice, RS256 is already secure enough for most applications

**When to use RS512:**
- High-security environments with strict compliance requirements
- When regulations require stronger cryptographic algorithms
- Long-lived tokens that need extended security guarantees

## Configuration

### Environment Variables

Configure JWT authentication using the following environment variables:

| Variable | Description | Default | Required |
|----------|-------------|---------|----------|
| `LANGFLOW_ALGORITHM` | JWT signing algorithm (`HS256`, `RS256`, or `RS512`) | `HS256` | No |
| `LANGFLOW_SECRET_KEY` | Secret key for HS256 signing | Auto-generated | No (for HS256) |
| `LANGFLOW_PRIVATE_KEY` | RSA private key for RS256/RS512 signing | Auto-generated | No (for RS256/RS512) |
| `LANGFLOW_PUBLIC_KEY` | RSA public key for RS256/RS512 verification | Derived from private key | No |
| `LANGFLOW_ACCESS_TOKEN_EXPIRE_SECONDS` | Access token expiration time | `3600` (1 hour) | No |
| `LANGFLOW_REFRESH_TOKEN_EXPIRE_SECONDS` | Refresh token expiration time | `604800` (7 days) | No |

### Configuration Examples

<Tabs>
<TabItem value="hs256" label="HS256 (Default)" default>

HS256 is the default algorithm. You can use it with minimal configuration:

**Option 1: Auto-generated secret key (simplest)**

```bash
# The secret key will be automatically generated and persisted
export LANGFLOW_ALGORITHM="HS256"
```

**Option 2: Custom secret key**

```bash
export LANGFLOW_ALGORITHM="HS256"
export LANGFLOW_SECRET_KEY="your-super-secret-key-at-least-32-characters-long"
```

:::warning
When using a custom secret key, ensure it is:
- At least 32 characters long
- Randomly generated
- Kept secret and never committed to version control
:::

**Generate a secure secret key:**

```bash
# Using Python
python -c "import secrets; print(secrets.token_urlsafe(32))"

# Using OpenSSL
openssl rand -base64 32
```

</TabItem>
<TabItem value="rs256" label="RS256 (Recommended for Production)">

RS256 provides better security for production deployments.

**Option 1: Auto-generated key pair (recommended)**

```bash
export LANGFLOW_ALGORITHM="RS256"
# Keys will be automatically generated and stored in CONFIG_DIR
```

When Langflow starts, it will:
1. Check if RSA keys exist in the configuration directory
2. If not, generate a new 2048-bit RSA key pair
3. Save the keys to `private_key.pem` and `public_key.pem`
4. Reuse the same keys on subsequent startups

**Option 2: Custom private key**

```bash
export LANGFLOW_ALGORITHM="RS256"
export LANGFLOW_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEF...
-----END PRIVATE KEY-----"
# PUBLIC_KEY will be automatically derived from the private key
```

**Option 3: Custom key pair**

```bash
export LANGFLOW_ALGORITHM="RS256"
export LANGFLOW_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEF...
-----END PRIVATE KEY-----"
export LANGFLOW_PUBLIC_KEY="-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOC...
-----END PUBLIC KEY-----"
```

**Generate RSA keys manually:**

```bash
# Generate private key
openssl genrsa -out private_key.pem 2048

# Extract public key from private key
openssl rsa -in private_key.pem -pubout -out public_key.pem

# View the keys
cat private_key.pem
cat public_key.pem
```

</TabItem>
<TabItem value="rs512" label="RS512 (High Security)">

RS512 provides the highest level of security.

**Option 1: Auto-generated key pair**

```bash
export LANGFLOW_ALGORITHM="RS512"
# Keys will be automatically generated
```

**Option 2: Custom keys**

```bash
export LANGFLOW_ALGORITHM="RS512"
export LANGFLOW_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEF...
-----END PRIVATE KEY-----"
```

:::info
RS512 uses the same RSA key format as RS256. The difference is in the hashing algorithm used during signing (SHA-512 vs SHA-256).
:::

</TabItem>
</Tabs>

### Docker Configuration

<Tabs>
<TabItem value="docker-hs256" label="Docker with HS256">

```yaml
# docker-compose.yml
version: "3.8"
services:
  langflow:
    image: langflowai/langflow:latest
    environment:
      - LANGFLOW_ALGORITHM=HS256
      - LANGFLOW_SECRET_KEY=${JWT_SECRET_KEY}  # Set in .env file
    volumes:
      - langflow_data:/app/langflow

volumes:
  langflow_data:
```

```bash
# .env file (DO NOT commit to version control)
JWT_SECRET_KEY=your-super-secret-key-here-at-least-32-chars
```

</TabItem>
<TabItem value="docker-rs256" label="Docker with RS256">

**Option 1: Auto-generated keys (recommended)**

```yaml
# docker-compose.yml
version: "3.8"
services:
  langflow:
    image: langflowai/langflow:latest
    environment:
      - LANGFLOW_ALGORITHM=RS256
    volumes:
      - langflow_data:/app/langflow  # Keys stored here

volumes:
  langflow_data:
```

**Option 2: Mount existing keys**

```yaml
# docker-compose.yml
version: "3.8"
services:
  langflow:
    image: langflowai/langflow:latest
    environment:
      - LANGFLOW_ALGORITHM=RS256
    volumes:
      - ./keys/private_key.pem:/app/langflow/private_key.pem:ro
      - ./keys/public_key.pem:/app/langflow/public_key.pem:ro
      - langflow_data:/app/langflow

volumes:
  langflow_data:
```

</TabItem>
</Tabs>

### Kubernetes Configuration

```yaml
# jwt-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: langflow-jwt-keys
type: Opaque
stringData:
  algorithm: "RS256"
  private-key: |
    -----BEGIN PRIVATE KEY-----
    MIIEvgIBADANBgkqhkiG9w0BAQEF...
    -----END PRIVATE KEY-----
  public-key: |
    -----BEGIN PUBLIC KEY-----
    MIIBIjANBgkqhkiG9w0BAQEFAAOC...
    -----END PUBLIC KEY-----
---
# langflow-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: langflow
spec:
  template:
    spec:
      containers:
        - name: langflow
          image: langflowai/langflow:latest
          env:
            - name: LANGFLOW_ALGORITHM
              valueFrom:
                secretKeyRef:
                  name: langflow-jwt-keys
                  key: algorithm
            - name: LANGFLOW_PRIVATE_KEY
              valueFrom:
                secretKeyRef:
                  name: langflow-jwt-keys
                  key: private-key
            - name: LANGFLOW_PUBLIC_KEY
              valueFrom:
                secretKeyRef:
                  name: langflow-jwt-keys
                  key: public-key
```

## Key Storage and Persistence

### Automatic Key Generation and Storage

When Langflow starts with RS256 or RS512 algorithm and no keys are provided:

1. **New Installation**: Langflow generates a new RSA key pair
2. **Key Storage**: Keys are saved to the configuration directory:
   - `{CONFIG_DIR}/private_key.pem` - Private key (keep secret!)
   - `{CONFIG_DIR}/public_key.pem` - Public key
3. **Subsequent Startups**: Langflow loads existing keys from files

### Configuration Directory Location

The configuration directory (`CONFIG_DIR`) is typically:
- **Linux/macOS**: `~/.langflow/` or `/app/langflow/`
- **Docker**: `/app/langflow/` (mount a volume to persist)
- **Custom**: Set via `LANGFLOW_CONFIG_DIR` environment variable

### Key File Permissions

Ensure proper permissions for key files:

```bash
# Private key should only be readable by the owner
chmod 600 private_key.pem

# Public key can be readable by others
chmod 644 public_key.pem
```

## Security Best Practices

### General Recommendations

1. **Use RS256/RS512 in Production**: Asymmetric algorithms provide better security for production deployments.

2. **Protect Private Keys**: Never expose private keys or secret keys in logs, error messages, or version control.

3. **Use Environment Variables or Secrets Management**: Store keys in environment variables or use a secrets management solution (AWS Secrets Manager, HashiCorp Vault, etc.).

4. **Rotate Keys Periodically**: Implement a key rotation strategy for long-running deployments.

5. **Set Appropriate Token Expiration**: Balance security and user experience with reasonable expiration times.

### Algorithm Selection Guide

```
┌─────────────────────────────────────────────────────────────┐
│                  Algorithm Selection Guide                   │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Is this a production deployment?                           │
│           │                                                 │
│           ├── No ──► Use HS256 (simpler setup)              │
│           │                                                 │
│           └── Yes ──► Do you have strict security           │
│                       compliance requirements?              │
│                              │                              │
│                              ├── No ──► Use RS256           │
│                              │                              │
│                              └── Yes ──► Use RS512          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Token Expiration Configuration

```bash
# Short-lived access tokens (recommended: 15 minutes to 1 hour)
export LANGFLOW_ACCESS_TOKEN_EXPIRE_SECONDS=3600  # 1 hour

# Longer-lived refresh tokens (recommended: 7 to 30 days)
export LANGFLOW_REFRESH_TOKEN_EXPIRE_SECONDS=604800  # 7 days
```

:::tip
Shorter access token lifetimes improve security by limiting the window of opportunity for token theft. Refresh tokens allow users to obtain new access tokens without re-authenticating.
:::

## Troubleshooting

### Common Issues

<details>
<summary><strong>Error: "Authentication failure: Verify authentication settings"</strong></summary>

This error occurs when:
- The secret key is not set (for HS256)
- The public key is not set or is invalid (for RS256/RS512)

**Solution:**
1. Check that the correct algorithm is configured
2. Verify that keys are properly set in environment variables
3. Check file permissions if using key files
4. Ensure keys are in valid PEM format

</details>

<details>
<summary><strong>Error: "Could not validate credentials"</strong></summary>

This error can occur when:
- The token is malformed
- The token was signed with a different key
- The token has expired

**Solution:**
1. Clear browser cookies and try logging in again
2. Verify that the same keys are used across all instances
3. Check if the token has expired

</details>

<details>
<summary><strong>Keys not persisting after restart</strong></summary>

**Solution:**
1. Ensure `CONFIG_DIR` is set to a persistent location
2. For Docker, mount a volume to persist the configuration directory
3. Check file permissions on the configuration directory

</details>

<details>
<summary><strong>Invalid key format errors</strong></summary>

**Solution:**
1. Ensure keys are in PEM format
2. Private keys should start with `-----BEGIN PRIVATE KEY-----`
3. Public keys should start with `-----BEGIN PUBLIC KEY-----`
4. Check for extra whitespace or line breaks in environment variables

</details>

### Verifying Your Configuration

```bash
# Check current algorithm
echo $LANGFLOW_ALGORITHM

# Verify key files exist (for RS256/RS512)
ls -la ${CONFIG_DIR}/private_key.pem ${CONFIG_DIR}/public_key.pem

# Test key validity
openssl rsa -in private_key.pem -check -noout
openssl rsa -in private_key.pem -pubout | diff - public_key.pem
```

## Migration Guide

### Migrating from HS256 to RS256

1. **Plan the migration** during a maintenance window
2. **Generate new RSA keys** before starting
3. **Update configuration** to use RS256
4. **Restart Langflow** - all existing sessions will be invalidated
5. **Users will need to log in again** to get new tokens

```bash
# 1. Generate new keys
openssl genrsa -out private_key.pem 2048
openssl rsa -in private_key.pem -pubout -out public_key.pem

# 2. Update environment variables
export LANGFLOW_ALGORITHM="RS256"
export LANGFLOW_PRIVATE_KEY="$(cat private_key.pem)"

# 3. Restart Langflow
```

:::warning
Changing the JWT algorithm or keys will invalidate all existing tokens. Users will need to log in again after the change.
:::

## Additional Resources

- [JWT.io](https://jwt.io/) - Debugger and introduction to JWT
- [RFC 7519](https://tools.ietf.org/html/rfc7519) - JWT Specification
- [OWASP JWT Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html)
- [Langflow Security Best Practices](/security)
