---
title: Langflow best practices on Kubernetes
slug: /deployment-prod-best-practices
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

This guide provides best practices for deploying Langflow in production environments on Kubernetes.

## Resource requirements and scaling

Langflow's minimum resource requirements vary by deployment type:

* **IDE (development)**: Deploy both the Langflow visual editor (frontend) and API (backend). Typically, this is used for development environments where developers use the visual editor to create and manage flows before packing and serving them through a production runtime deployment.

    The frontend service requires a minimum of 512Mi RAM and 0.3 CPU per instance with 1 replica.

    The backend service requires a minimum of 1Gi RAM and 0.5 CPU per instance with 1 replica.

* **Runtime (production)**: Deploy the Langflow runtime for production flows, which is headless and focused on serving the Langflow API. This is used for production environments where flows are executed programmatically without the need for the visual editor.

    Minimum requirements include 2Gi RAM and 1000m (1 CPU) per instance with 3 replicas.

### Estimate, test, and adjust

Start with the minimum recommended resources and replicas, then monitor and scale as needed based on your deployment's requirements and performance testing.
Consider the following factors in your resource estimation and performance testing:

* Flow complexity.
* Volume of concurrent users and requests.

   For IDE (development) deployments, consider that frontend activity also pings the backend service, so you typically need to scale both the frontend and backend together.

* Request payload content and size, particularly for file uploads in production deployments.
* Storage requirements for cache, file management, and the Langflow database.

    An [external PostgreSQL database](#use-an-external-postgresql-database) is recommended for production deployments.

* Infrastructure options that might require more resources, such as multi-core CPUs.

### Use an external PostgreSQL database

An external PostgreSQL database is recommended for production deployments to improve scalability and reliability as compared to the default SQLite database.

Your resource allocation and replication strategy must be able to support the PostgreSQL service and storage.
For example, for a runtime (production) deployment, you might allocate 4Gi RAM, 2 CPU, and multiple replicas for high availability.

Persistent storage is recommended.

For multi-instance deployments, set up a shared database to ensure that all instances can access the same data.

For more information, including multi-instance databases, see [Configure an external PostgreSQL database](/configuration-custom-database) and [Memory management options](/memory).

### Use HPA for dynamic scaling

Load balancing and dynamic scaling are recommended for runtime (production) deployments.

For example, consider using Horizontal Pod Autoscaler (HPA) in Kubernetes to dynamically scale based on CPU or memory usage.
The following example shows a Langflow HPA configuration with CPU-based scaling:

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: langflow-runtime-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: langflow-runtime
  minReplicas: 1
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 80
```

## Failure Points

Langflow's reliability in production depends on mitigating key failure points, particularly around the database, file system, and instance availability.

### Database failure

* **Impact**: Disrupts flow retrieval, saving, user authentication, user management, project collection access, configuration updates, and log writing.
* **Mitigation**: Use a replicated PostgreSQL setup with high availability and regular backups. Flows already loaded in memory may continue to function.

### File system issues

* **Impact**: Concurrency issues in file caching, such as `/app/data/.cache`, can cause IO errors in multi-instance setups.
* **Mitigation**: Use a shared, POSIX-compliant file system or cloud storage. Avoid ramdisk solutions due to data loss on container shutdown.

### Instance failures

* **Impact**: A single instance failure can disrupt service if not replicated.
* **Mitigation**: Deploy multiple replicas with Kubernetes to ensure availability. Use health checks to detect and replace failed pods.

### Network and dependency failures

* **Impact**: External APIs or services used in flows may fail, causing flow errors.
* **Mitigation**: Implement retry logic and error handling in flows. Monitor network latency and dependency health.

## Monitoring recommendations

Effective monitoring ensures Langflow operates reliably and performs well under varying loads.

### Database health

* Monitor availability, query performance, and resource usage (CPU, memory, disk).
* Use tools like pgAdmin or cloud-native monitoring for PostgreSQL.

### Application logs

* Collect and analyze logs for errors, warnings, and flow execution issues.
* Centralize logs using tools like ELK Stack or Fluentd.

### Resource usage

* Track CPU, memory, and disk usage of Langflow instances.
* Use Prometheus and Grafana for real-time monitoring in Kubernetes.

### API performance

* Monitor response times, error rates, and request throughput.
* Set alerts for high latency or error spikes.

### Observability tools

* Integrate with LangSmith or LangFuse for detailed flow tracing and metrics.
* Use these tools to debug flow performance and optimize execution.

### Example monitoring setup

* Deploy Prometheus for metrics collection.
* Use Grafana dashboards to visualize resource usage and API performance.
* Configure alerts for critical thresholds (e.g., 90% memory usage, 500ms API latency).

## Security implications

Running Langflow in production requires robust security measures to protect the application, data, and users.

### Container security

* Enable `readOnlyRootFilesystem: true` in runtime containers to prevent unauthorized modifications.
* Only disable if necessary and with compensating controls.

### Secrets management

* Store sensitive data like API keys in Kubernetes secrets or external secret managers.
* Avoid embedding secrets in flow JSON files.

### Authentication and authorization

* Implement strong authentication for the visual editor and API like OAuth or API tokens.
* Enforce role-based access control to limit user permissions.

### Data privacy

* Ensure compliance with regulations like GDPR if handling personal data.
* Encrypt sensitive data at rest and in transit.

### Encryption

* Use HTTPS for all communications to secure data in transit.
* Configure TLS for PostgreSQL connections.

### Additional security measures

* Conduct regular security audits and apply software updates.
* Restrict network access to Langflow services using firewalls or network policies.
* Monitor for suspicious activity using intrusion detection systems.

## See also

* [Deploy the Langflow production environment on Kubernetes](/deployment-kubernetes-prod)
* [Langflow Helm Charts repository](https://github.com/langflow-ai/langflow-helm-charts)
* [Langflow database guide for enterprise DBAs](/enterprise-database-guide)