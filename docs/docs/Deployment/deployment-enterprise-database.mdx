---
title: Langflow database guide for enterprise DBAs
slug: /deployment-enterprise-database
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

This guide is designed for enterprise database administrators (DBAs) and operators responsible for deploying and managing Langflow in production environments.

Langflow relies on a database to store critical data such as flow configurations, user accounts, project collections, configuration settings, and execution logs.
While SQLite is the default database, PostgreSQL is recommended for production due to its scalability, performance, and robustness.

## Langflow database usage

Langflow uses its database to manage core internal functions essential for both the IDE (used by developers through the Langflow UI) and runtime (for production flows). The database is integral to the application's operation because it stores the following information:

* **Flow Configurations**: Definitions of flows, including nodes, edges, and components, stored as JSON or database records.
* **User Data**: User accounts, permissions, and settings for multi-user environments.
* **Project Collections**: Metadata for community and custom projects shared across users.
* **Configuration Settings**: Application settings, such as API keys and environment variables.
* **Execution Logs**: Records of flow execution and system activity for monitoring and debugging.

The database is accessed during startup, flow execution, user interactions, and administrative tasks. Its availability critical for most Langflow operations.

## Configure Langflow with PostgreSQL

Langflow defaults to SQLite but supports PostgreSQL for production environments, offering better performance and scalability. Below are the steps to configure Langflow to use PostgreSQL, suitable for standalone or containerized deployments.

1. Set up PostgreSQL:
   Deploy a PostgreSQL instance (version 12 or higher recommended) using a local server, Docker, or a managed cloud service. Create a database for Langflow and a user with appropriate permissions.

2. Obtain the connection string in the format `postgresql://user:password@host:port/dbname`, such as`postgresql://langflow:securepassword@postgres:5432/langflow`.

   For High Availability setups, use a virtual IP or proxy hostname. For more information, see [High Availability for PostgreSQL](#high-availability-ha-for-postgresql).

3. Configure Langflow with the `.env` or `docker-compose.yml` files.

    <Tabs groupId="environment">
      <TabItem value=".env" label=".env" default>

        i. Create a `.env` file in the Langflow directory: `touch .env`.

        ii. Add the connection string to the `.env` file: `LANGFLOW_DATABASE_URL="postgresql://langflow:securepassword@postgres:5432/langflow"`.

        Reference the `.env.example` file from the Langflow GitHub Repository for additional settings.

      </TabItem>
      <TabItem value="docker-compose.yml" label="docker-compose.yml">

        Use or modify the example `docker-compose.yml` from the Langflow GitHub Repository.

        ```yaml
        version: '3'
        services:
          langflow:
            image: langflowai/langflow:latest
            ports:
              - "7860:7860"
            environment:
              - LANGFLOW_DATABASE_URL=postgresql://langflow:langflow@postgres:5432/langflow
          postgres:
            image: postgres:16
            ports:
              - "5432:5432"
            environment:
              - POSTGRES_USER=langflow
              - POSTGRES_PASSWORD=langflow
              - POSTGRES_DB=langflow
            volumes:
              - langflow-postgres:/var/lib/postgresql/data
        volumes:
          - langflow-postgres:
        ```

      </TabItem>
    </Tabs>


4. Start Langflow with the value for the connection string.

    <Tabs groupId="environment">
      <TabItem value=".env" label=".env" default>

      `uv run langflow run --env-file .env`

      </TabItem>
      <TabItem value="docker-compose.yml" label="docker-compose.yml">

      Navigate to the directory containing `docker-compose.yml` and run `docker-compose up`.

      </TabItem>
    </Tabs>

5. Optional: Run migrations.
   Langflow uses SQLAlchemy and Alembic to manage its database schema. When you first connect to PostgreSQL, Langflow will automatically run migrations to create the necessary tables. To manually run migrations, use `langflow migration --no-test`. To preview changes before applying them, use `langflow migration --test`.

5. To verify the configuration, create a test flow using the UI or API and inspect the PostgreSQL database to confirm new tables and activity. You can query the database container with `docker exec -it <postgres-container> psql -U langflow -d langflow` or use `SELECT * FROM pg_stat_activity WHERE datname = 'langflow';` to verify connectivity.

## High Availability (HA) for PostgreSQL

In production, PostgreSQL must be configured for high availability to ensure continuous operation, especially in active-active Langflow deployments where multiple instances rely on the same database.

### High Availability configuration

* **Streaming Replication**:
  * Set up one primary database for writes and one or more replicas for reads and failover.
  * Configure synchronous or asynchronous replication based on latency and consistency needs.
* **Automatic Failover**:
  * Use tools like [Patroni](https://patroni.readthedocs.io/en/latest/) with etcd or [Consul](https://developer.hashicorp.com/consul) for automatic failover, typically switching to a replica in seconds.
  * Alternatively, use [Pgpool-II](https://www.pgpool.net/docs/46/en/html/index.html) for connection pooling and failover.
  * Managed services like AWS RDS or Google Cloud SQL provide built-in HA with automatic failover.
* **Load Balancing**:
  * For read-heavy workloads, distribute read queries across replicas using a connection pooler like [PgBouncer](https://www.pgbouncer.org/) or a load balancer.
  * Configure Langflow to use a single connection string pointing to the primary PostgreSQL database or to a proxy.

### Connection string for HA

* Use a virtual IP or DNS name that resolves to the current primary database.
* Example: `postgresql://langflow:securepassword@db-proxy:5432/langflow?sslmode=require`.
* For managed services, use the provided endpoint, such as `langflow.cluster-xyz.us-east-1.rds.amazonaws.com`.
* Langflow, through [SQLAlchemy](https://docs.sqlalchemy.org/en/20/), supports reconnection attempts and ensures recovery after failover.

### Example HA setup with Patroni

* Deploy a PostgreSQL cluster with Patroni, etcd, and [HAProxy](https://www.haproxy.org/).
* Configure Langflow's `LANGFLOW_DATABASE_URL` to point to HAProxy's virtual IP.
* Monitor failover events and ensure replicas are in sync.

| Component | Role | Configuration |
|-----------|------|----------------|
| PostgreSQL | Primary/Replica | Streaming replication, WAL enabled |
| Patroni | Failover Management | Monitors nodes, promotes replica on failure |
| etcd | Consensus | Stores cluster state |
| HAProxy | Load Balancing | Directs connections to primary |

## Active-Active HA for Langflow

Langflow supports active-active HA by running multiple instances, with all instances connected to the same HA PostgreSQL database behind a load balancer.
This ensures scalability and resilience for both the IDE (developer UI) and runtime (production flows).

### Deployment strategy

* **Multiple Instances**:
  * Deploy Langflow using Kubernetes or Docker Swarm with multiple replicas.
  * Example: 3 runtime replicas for production flows, 2 IDE backend replicas for developers.
* **Load Balancer**:
  * Use a load balancer (e.g., NGINX, AWS ALB) to distribute requests across instances.
  * Configure health checks to route traffic away from failed instances.
* **Shared Database**:
  * All instances connect to the same HA PostgreSQL database using the connection string.
  * Ensure the database can handle concurrent connections (e.g., set `max_connections` appropriately).

### Example Kubernetes configuration

    ```yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: langflow-runtime
    spec:
      replicas: 3
      selector:
        matchLabels:
          app: langflow-runtime
      template:
        metadata:
          labels:
            app: langflow-runtime
        spec:
          containers:
          - name: langflow
            image: langflowai/langflow:latest
            ports:
            - containerPort: 7860
            env:
            - name: LANGFLOW_DATABASE_URL
              value: "postgresql://langflow:securepassword@db-proxy:5432/langflow?sslmode=require"
    ---
    apiVersion: v1
    kind: Service
    metadata:
      name: langflow-runtime
    spec:
      selector:
        app: langflow-runtime
      ports:
      - port: 80
        targetPort: 7860
      type: LoadBalancer
    ```

### Considerations

* **Concurrency**: PostgreSQL handles concurrent connections well, but monitor for contention or deadlocks during high load.
* **Session Management**: For the IDE, ensure session persistence or stateless authentication (e.g., JWT) to avoid issues with load balancing.
* **File Storage**: Large files are stored on disk, for example at `/opt/langflow/data/`, and require shared storage such as NFS or cloud storage for multi-instance setups.

## Impact of database failure

If the PostgreSQL database becomes unavailable, the following Langflow functions will fail:

| Function | Impact |
|----------|--------|
| Flow Retrieval | Cannot load new or existing flows from the database. |
| Flow Saving | Unable to save new flows or updates to existing flows. |
| User Authentication | Login and user management functions fail. |
| Project Collection Access | Cannot access or share community/custom project collections. |
| Configuration Retrieval | Unable to load application settings. |
| Configuration Updates | Changes to settings cannot be saved. |
| Execution Log Access | Cannot retrieve historical flow execution logs. |
| Log Writing | New execution or system activity logs cannot be recorded. |
| Multi-User Collaboration | Sharing flows or projects across users fails. |
| API Flow Loading | API requests to load new flows (non-cached) fail. |

Flows already loaded in memory may continue to function, as their configurations are cached.
However, any operation requiring database access will fail until the database is restored.

### Mitigation strategies

* **Minimize Downtime**: Use HA configurations with rapid failover, such as Patroni or managed services, to restore access quickly.
* **Reconnection Handling**: Langflow, through SQLAlchemy, attempts to reconnect to the database after a failure and reduces disruption once the database is back online.
* **Caching**: Explore caching strategies for frequently accessed data, though not natively supported by Langflow.
* **Backups**: Implement regular database backups and test restore procedures to recover from catastrophic failures.

## Monitoring and maintenance

Database administrators must monitor and maintain the PostgreSQL database to ensure optimal performance and reliability.

### Monitoring

* **Performance Metrics**:
  * CPU, memory, and disk I/O usage.
  * Use `pg_stat_statements` to monitor query performance and slow queries.
  * Use `pg_stat_activity` to monitor connection counts and contention.
* **Replication Health**:
  * Check replica lag and synchronization status.
  * Monitor failover events and alerts.
* **Tools**:
  * Use pgAdmin, Prometheus with PostgreSQL exporter, or cloud-native monitoring for managed services.
  * Centralize Langflow application logs with ELK Stack or Fluentd for correlation with database issues.

### Maintenance

* **Backups**:
  * Schedule daily logical backups using `pg_dump` or continuous archiving with a write-ahead log (WAL).
  * Test restore procedures quarterly to ensure data recovery.
* **Schema Management**:
  * Langflow manages its schema using migrations, executed with `langflow migration`.
  * Avoid manual schema changes to prevent conflicts with Langflow's migration system.
* **Optimization**:
  * Analyze query patterns, such as frequent reads on flow tables, and create indexes as needed.
  * Tune PostgreSQL parameters, such as `work_mem` and `shared_buffers`, based on workload.

## Security considerations

Securing the database and Langflow's connection to it is critical for enterprise deployments.

* **Secure Credentials**:
  * Store database credentials in a secrets management system like HashiCorp Vault or Kubernetes secrets.
  * Restrict access to the `.env` file or environment variables containing the connection string.
* **SSL Encryption**:
  * Enable SSL for database connections by appending `?sslmode=require` or `?sslmode=verify-full` to the connection string.
  * Ensure PostgreSQL is configured with valid SSL certificates.
* **Access Control**:
  * Grant the Langflow database user minimal permissions, such as CREATE, SELECT, INSERT, UPDATE, DELETE on Langflow tables.
  * Use network security groups or VPCs to restrict database access to Langflow instances.
* **Auditing**:
  * Enable PostgreSQL logging, such as `log_connections` and `log_statements`, to track access and changes.
  * Regularly review logs for suspicious activity.
* **Updates**:
  * Apply security patches to PostgreSQL and Langflow promptly.
  * Monitor for vulnerabilities using tools like Dependabot for Langflow dependencies.