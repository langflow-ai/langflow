---
title: Data source
slug: /components-data
---

import Icon from "@site/src/components/icon";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import PartialParams from '@site/docs/_partial-hidden-params.mdx';
import PartialDevModeWindows from '@site/docs/_partial-dev-mode-windows.mdx';

In Langflow version 1.7.0, the **Data** category was renamed **Data source**.

Data components bring data into your flows from various sources like files, API endpoints, and URLs.
For example:

* **Load files**: Import data from a file or directory with the [**Read File** component](#file) and [**Directory** component](#directory).

* **Search the web**: Fetch data from the web with components like the [**News Search** component](#news-search), [**RSS Reader** component](#rss-reader), [**Web Search** component](#web-search), and [**URL** component](#url).

* **Make API calls**: Use APIs to trigger flows or perform actions with the [**API Request** component](#api-request) and [**Webhook** component](#webhook).

* **Run SQL queries**: Query an SQL database with the [**SQL Database** component](#sql-database).

Each component runs different commands for retrieval, processing, and type checking.
Some components are a minimal wrapper for a command that you provide, and others include built-in scripts to fetch and process data based on variable inputs.
Additionally, some components return raw data, whereas others can convert, restructure, or validate the data before outputting it.
This means that some similar components might produce different results.

:::tip
Data components pair well with [Processing components](/components-processing) that can perform additional parsing, transformation, and validation after retrieving the data.

This can include basic operations, like saving a file in a specific format, or more complex tasks, like using a **Text Splitter** component to break down a large document into smaller chunks before generating embeddings for vector search.
:::

## Use Data components in flows

Data components are used often in flows because they offer a versatile way to perform common functions.

You can use these components to perform their base functions as isolated steps in your flow, or you can connect them to an **Agent** component as tools.

![An agent flow with three Data components connected to the agent as tools](/img/connect-data-components-to-agent.png)

For example flows, see the following:

* [Create a chatbot that can ingest files](/chat-with-files): Learn how to use a **Read File** component to load a file as context for a chatbot.
The file and user input are both passed to the LLM so you can ask questions about the file you uploaded.

* [Create a vector RAG chatbot](/chat-with-rag): Learn how to ingest files for use in Retrieval-Augmented Generation (RAG), and then set up a chatbot that can use the ingested files as context.
The two flows in this tutorial prepare files for RAG, and then let your LLM use vector search to retrieve contextually relevant data during a chat session.

* [Configure tools for agents](/agents-tools): Learn how to use any component as a tool for an agent.
When used as tools, the agent autonomously decides when to call a component based on the user's query.

* [Trigger flows with webhooks](/webhook): Learn how to use the **Webhook** component to trigger a flow run in response to an external event.

## API Request

The **API Request** component constructs and sends HTTP requests using URLs or curl commands:

* **URL mode**: Enter one or more comma-separated URLs, and then select the method for the request to each URL.
* **curl mode**: Enter the curl command to execute.

You can enable additional request options and fields in the component's parameters.

Returns a [`Data` object](/data-types#data) containing the response.

For provider-specific API components, see <Icon name="Blocks" aria-hidden="true" /> [**Bundles**](/components-bundle-components).

### API Request parameters

<PartialParams />

| Name | Display Name | Info |
|------|--------------|------|
| mode | Mode | Input parameter. Set the mode to either **URL** or **curl**. |
| urls | URL | Input parameter. Enter one or more comma-separated URLs for the request. |
| curl | curl | Input parameter. **curl mode** only. Enter a complete curl command. Other component parameters are populated from the command arguments. |
| method | Method | Input parameter. The HTTP method to use. |
| query_params | Query Parameters | Input parameter. The query parameters to append to the URL. |
| body | Body | Input parameter. The body to send with POST, PATCH, and PUT requests as a dictionary. |
| headers | Headers | Input parameter. The headers to send with the request as a dictionary. |
| timeout | Timeout | Input parameter. The timeout to use for the request. |
| follow_redirects | Follow Redirects | Input parameter. Whether to follow HTTP redirects. Starting in Langflow version 1.7, the **Follow Redirects** parameter is disabled (`false`) by default to prevent SSRF bypass attacks where a public URL redirects to internal resources. Only enable redirects if you trust the target server.  For more information, see [SSRF protection environment variables](/api-keys-and-authentication#ssrf-protection). |
| save_to_file | Save to File | Input parameter. Whether to save the API response to a temporary file. Default: Disabled (`false`) |
| include_httpx_metadata | Include HTTPx Metadata | Input parameter. Whether to include properties such as `headers`, `status_code`, `response_headers`, and `redirection_history` in the output. Default: Disabled (`false`) |

## Mock Data

The **Mock Data** component generates sample data for testing and development.
You can select these output types:

* `message_output`: A [Message (text)](/data-types#message) output with Lorem Ipsum sample text.
* `data_output`: A [Data (JSON)](/data-types#data) object containing a JSON structure with one sample record under `records` and a `summary` section.
* `dataframe_output`: A [DataFrame (tabular)](/data-types#dataframe) with 50 mock records, including columns such as `customer_id`, `first_name`, and `last_name`.

## URL

The **URL** component fetches content from one or more URLs, processes the content, and returns it in various formats.
It follows links recursively to a given depth, and it supports output in plain text or raw HTML.

### URL parameters

<PartialParams />

Some of the available parameters include the following:

| Name | Display Name | Info |
|------|--------------|------|
| urls | URLs | Input parameter. One or more URLs to crawl recursively. In the visual editor, click <Icon name="Plus" aria-hidden="true"/> **Add URL** to add multiple URLs. |
| max_depth | Depth | Input parameter. Controls link traversal: how many "clicks" away from the initial page the crawler will go. A depth of 1 limits the crawl to the first page at the given URL only. A depth of 2 means the crawler crawls the first page plus each page directly linked from the first page, then stops. This setting exclusively controls link traversal; it doesn't limit the number of URL path segments or the domain. |
| prevent_outside | Prevent Outside | Input parameter. If enabled, only crawls URLs within the same domain as the root URL. This prevents the crawler from accessing sites outside the given URL's domain, even if they are linked from one of the crawled pages. |
| use_async | Use Async | Input parameter. If enabled, uses asynchronous loading which can be significantly faster but might use more system resources. |
| format | Output Format | Input parameter. Sets the desired output format as **Text** or **HTML**. The default is **Text**. For more information, see [URL output](#url-output).|
| timeout | Timeout | Input parameter. Timeout for the request in seconds. |
| headers | Headers | Input parameter. The headers to send with the request if needed for authentication or otherwise. |

Additional input parameters are available for error handling and encoding.

### URL output

There are two settings that control the output of the **URL** component at different stages:

* **Output Format**: This optional parameter controls the content extracted from the crawled pages:

    * **Text (default)**: The component extracts only the text from the HTML of the crawled pages.
    * **HTML**: The component extracts the entire raw HTML content of the crawled pages.

* **Output data type**: In the component's output field (near the output port) you can select the structure of the outgoing data when it is passed to other components:

    * **Extracted Pages**: Outputs a [`DataFrame`](/data-types#dataframe) that breaks the crawled pages into columns for the entire page content (`text`) and metadata like `url` and `title`.
    * **Raw Content**: Outputs a [`Message`](/data-types#message) containing the entire text or HTML from the crawled pages, including metadata, in a single block of text.

When used as a standard component in a flow, the **URL** component must be connected to a component that accepts the selected output data type (`DataFrame` or `Message`).
You can connect the **URL** component directly to a compatible component, or you can use a [**Type Convert** component](/components-processing#type-convert) to convert the output to another type before passing the data to other components if the data types aren't directly compatible.

Processing components like the **Type Convert** component are useful with the **URL** component because it can extract a large amount of data from the crawled pages.
For example, if you only want to pass specific fields to other components, you can use a [**Parser** component](/components-processing#parser) to extract only that data from the crawled pages before passing the data to other components.

When used in **Tool Mode** with an **Agent** component, the **URL** component can be connected directly to the **Agent** component's **Tools** port without converting the data.
The agent decides whether to use the **URL** component based on the user's query, and it can process the `DataFrame` or `Message` output directly.

## Web Search

The **Web Search** component performs a basic web search using DuckDuckGo's HTML scraping interface.
For other search APIs, see <Icon name="Blocks" aria-hidden="true" /> [**Bundles**](/components-bundle-components).

:::info
The **Web Search** component uses web scraping that can be subject to rate limits.

For production use, consider using another search component with more robust API support, such as provider-specific bundles.
:::

### Use the Web Search component in a flow

The following steps demonstrate one way that you can use a **Web Search** component in a flow:

1. Create a flow based on the **Basic Prompting** template.

2. Add a **Web Search** component, and then enter a search query, such as `environmental news`.

3. Add a [**Type Convert** component](/components-processing#type-convert), set the **Output Type** to **Message**, and then connect the **Web Search** component's output to the **Type Convert** component's input.

    By default, the **Web Search** component outputs a `DataFrame`.
    Because the **Prompt Template** component only accepts `Message` data, this conversion is required so that the flow can pass the search results to the **Prompt Template** component.
    For more information, see [Web Search output](#web-search-output).

5. In the **Prompt Template** component's **Template** field, add a variable like `{searchresults}` or `{context}`.

    This adds a field to the **Prompt Template** component that you can use to pass the converted search results to the prompt.
    For more information, see [Define variables in prompts](/components-prompts#define-variables-in-prompts).

6. Connect the **Type Convert** component's output to the new variable field on the **Prompt Template** component.

    ![Type convert web search output to chat](/img/component-type-convert-and-web-search.png)

7. In the **Language Model** component, add your OpenAI API key, or select a different provider and model.

8. Click **Playground**, and then enter `latest news`.

    The LLM processes the request, including the context passed through the **Prompt Template** component, and then prints the response in the **Playground** chat interface.

    <details>
    <summary>Result</summary>

    The following is an example of a possible response.
    Your response may vary based on the current state of the web, your specific query, the model, and other factors.

    ```text
    Here are some of the latest news articles related to the environment:
    Ozone Pollution and Global Warming: A recent study highlights that ozone pollution is a significant global environmental concern, threatening human health and crop production while exacerbating global warming. Read more
    ...
    ```

    </details>

### Web Search parameters

| Name | Display Name | Info |
|------|--------------|------|
| query | Search Query | Input parameter. Keywords to search for. |
| timeout | Timeout | Input parameter. Timeout for the web search request in seconds. Default: `5`. |
| results | Search Results | Output parameter. Returns a `DataFrame` containing `title`, `links`, and `snippets`. For more information, see [Web Search output](#web-search-output). |

### Web Search output

The **Web Search** component outputs a [`DataFrame`](/data-types#dataframe) containing the key columns `title`, `links`, and `snippets`.

When used as a standard component in a flow, the **Web Search** component must be connected to a component that accepts `DataFrame` input, or you must use a [**Type Convert** component](/components-processing#type-convert) to convert the output to `Data` or `Message` type before passing the data to other components.

When used in **Tool Mode** with an **Agent** component, the **Web Search** component can be connected directly to the **Agent** component's **Tools** port without converting the data.
The agent decides whether to use the **Web Search** component based on the user's query, and it can process the `DataFrame` output directly.

## News Search

The **News Search** component searches Google News through RSS, and then returns clean article data as a [`DataFrame`](/data-types#dataframe) containing article titles, links, publication dates, and summaries.
The component's `clean_html` method parses the HTML content with the BeautifulSoup library, removes HTML markup, and strips whitespace to output clean data.

For other RSS feeds, use the [**RSS Reader** component](#rss-reader), and for other searches use the [**Web Search** component](#web-search) or provider-specific <Icon name="Blocks" aria-hidden="true" /> [**Bundles**](/components-bundle-components).

When used as a standard component in a flow, the **News Search** component must be connected to a component that accepts `DataFrame` input.
You can connect the **News Search** component directly to a compatible component, or you can use a [Processing component](/components-processing) to convert or extract data of a different type between components.

When used in **Tool Mode** with an **Agent** component, the **News Search** component can be connected directly to the **Agent** component's **Tools** port without converting the data.
The agent decides whether to use the **News Search** component based on the user's query, and it can process the `DataFrame` output directly.

### News Search parameters

<PartialParams />

| Name | Display Name | Info |
|------|--------------|------|
| query | Search Query | Input parameter. Search keywords for news articles. |
| hl | Language (hl) | Input parameter. Language code, such as en-US, fr, de. Default: `en-US`. |
| gl | Country (gl) | Input parameter. Country code, such as US, FR, DE. Default: `US`. |
| ceid | Country:Language (ceid) | Input parameter. Language, such as US:en, FR:fr. Default: `US:en`. |
| topic | Topic | Input parameter. One of: `WORLD`, `NATION`, `BUSINESS`, `TECHNOLOGY`, `ENTERTAINMENT`, `SCIENCE`, `SPORTS`, `HEALTH`. |
| location | Location (Geo) | Input parameter. City, state, or country for location-based news. Leave blank for keyword search. |
| timeout | Timeout | Input parameter. Timeout for the request in seconds. |
| articles | News Articles | Output parameter. A `DataFrame` with the key columns `title`, `link`, `published` and `summary`. |

## RSS Reader

The **RSS Reader** component fetches and parses RSS feeds from any valid RSS feed URL, and then returns the feed content as a [`DataFrame`](/data-types#dataframe) containing article titles, links, publication dates, and summaries.

When used as a standard component in a flow, the **RSS Reader** component must be connected to a component that accepts `DataFrame` input.
You can connect the **RSS Reader** component directly to a compatible component, or you can use a [Processing component](/components-processing) to convert or extract data of a different type between components.

When used in **Tool Mode** with an **Agent** component, the **RSS Reader** component can be connected directly to the **Agent** component's **Tools** port without converting the data.
The agent decides whether to use the **RSS Reader** component based on the user's query, and it can process the `DataFrame` output directly.

### RSS Reader parameters

| Name | Display Name | Info |
|------|--------------|------|
| rss_url | RSS Feed URL | Input parameter. URL of the RSS feed to parse, such as `https://rss.nytimes.com/services/xml/rss/nyt/HomePage.xml`. |
| timeout | Timeout | Input parameter. Timeout for the RSS feed request in seconds. Default: `5`. |
| articles | Articles | Output parameter. A `DataFrame` containing the key columns `title`, `link`, `published` and `summary`. |

## Additional Data components

Langflow's core components are meant to be generic and support a range of use cases.
Core components typically aren't limited to a single provider.

If the core components don't meet your needs, you can find provider-specific components in <Icon name="Blocks" aria-hidden="true" /> [**Bundles**](/components-bundle-components).

For example, the [**DataStax** bundle](/bundles-datastax) includes components for CQL queries, and the [**Google** bundle](/bundles-google) includes components for Google Search APIs.

## Legacy Data components

import PartialLegacy from '@site/docs/_partial-legacy.mdx';

<PartialLegacy />

The following Data components are in legacy status:

* **Load CSV**
* **Load JSON**

Replace these components with the **Read File** component, which supports loading CSV and JSON files, as well as many other file types.

## See also

- [**Google** bundle](/bundles-google)
- [**Composio** bundle](/bundles-composio)
- [File management](/concepts-file-management)