---
title: Utilities
slug: /components-helpers
---

import Icon from "@site/src/components/icon";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In Langflow version 1.7.0, the **Helpers** category was renamed **Utilities**.

Utility components provide functions to help manage data and perform simple tasks in your flow.

## Calculator

The **Calculator** component performs basic arithmetic operations on mathematical expressions.
It supports addition, subtraction, multiplication, division, and exponentiation operations.

For an example of using this component in a flow, see the [**Python Interpreter** component](/python-interpreter).

### Calculator parameters

| Name | Type | Description |
|------|------|-------------|
| expression | String | Input parameter. The arithmetic expression to evaluate, such as `4*4*(33/22)+12-20`. |
| result | Data | Output parameter. The calculation result as a [`Data` object](/data-types) containing the evaluated expression. |

## Current Date

The **Current Date** component returns the current date and time in a selected timezone. This component provides a flexible way to obtain timezone-specific date and time information within a Langflow pipeline.

### Current Date parameters

| Name | Type | Description |
|------|------|-------------|
| timezone | String | Input parameter. The timezone for the current date and time. |
| current_date | String | Output parameter. The resulting current date and time in the selected timezone. |

## Message History

The **Message History** component provides combined chat history and message storage functionality.
It can store and retrieve chat messages from either [Langflow storage](/memory) _or_ a dedicated chat memory database like Mem0 or Redis.

:::tip
The **Agent** component has built-in chat memory that is enabled by default and uses Langflow storage.
This built-in chat memory functionality is sufficient for most use cases.

Use the **Message History** component for the following use cases:

* You need to store and retrieve chat memory for a language model component (not an agent).
* You need to retrieve chat memories outside the chat context, such as a sentiment analysis flow that retrieves and analyzes recently stored memories.
* You want to store memories in a specific database that is separate from Langflow storage.

For more information, see [Store chat memory](/memory#store-chat-memory).
:::

### Use the Message History component in a flow

The **Message History** component has two modes, depending on where you want to use it in your flow:

* **Retrieve mode**: The component retrieves chat messages from your Langflow database or external memory.
* **Store mode**: The component stores chat messages in your Langflow database or external memory.

This means that you need multiple **Message History** components in your flow if you want to both store and retrieve chat messages.

<Tabs>
<TabItem value="langflow" label="Use Langflow storage" default>

The following steps explain how to create a chat-based flow that uses **Message History** components to store and retrieve chat memory from your Langflow installation's database:

1. Create or edit a flow where you want to use chat memory.

2. At the beginning of the flow, add a **Message History** component, and then set it to **Retrieve** mode.

3. Optional: In the **Message History** [component's header menu](/concepts-components#component-menus), click <Icon name="SlidersHorizontal" aria-hidden="true"/> **Controls** to enable parameters for memory sorting, filtering, and limits.

3. Add a **Prompt Template** component, add a `{memory}` variable to the **Template** field, and then connect the **Message History** output to the **memory** input.

    The **Prompt Template** component supplies instructions and context to LLMs, separate from chat messages passed through a **Chat Input** component.
    The template can include any text and variables that you want to supply to the LLM, for example:

    ```text
    You are a helpful assistant that answers questions.

    Use markdown to format your answer, properly embedding images and urls.

    History:

    {memory}
    ```

    Variables (`{variable}`) in the template dynamically add fields to the **Prompt Template** component so that your flow can receive definitions for those values from elsewhere, such as other components, Langflow global variables, or runtime input.
    For more information, see [Define variables in prompts](/components-prompts#define-variables-in-prompts).

    In this example, the `{memory}` variable is populated by the retrieved chat memories, which are then passed to a **Language Model** or **Agent** component to provide additional context to the LLM.

4. Connect the **Prompt Template** component's output to a **Language Model** component's **System Message** input.

    This example uses the **Language Model** core component as the central chat driver, but you can also use another language model component or the **Agent** component.

5. Add a **Chat Input** component, and then connect it to the **Language Model** component's **Input** field.

6. Connect the **Language Model** component's output to a **Chat Output** component.

7. At the end of the flow, add another **Message History** component, and then set it to **Store** mode.

    Configure any additional parameters in the second **Message History** component as needed, taking into consideration that this particular component will store chat messages rather than retrieve them.

8. Connect the **Chat Output** component's output to the **Message History** component's **Message** input.

    Each response from the LLM is output from the **Language Model** component to the **Chat Output** component, and then stored in chat memory by the final **Message History** component.

</TabItem>
<TabItem value="external" label="Use external chat memory">

To store and retrieve chat memory from a dedicated, external chat memory database, use the **Message History** component _and_ a provider-specific chat memory component.

The following steps explain how to create a flow that stores and retrieves chat memory from a [**Redis Chat Memory** component](/bundles-redis).
Other options include the [**Mem0 Chat Memory** component](/bundles-mem0) and [**Cassandra Chat Memory** component](/bundles-cassandra#cassandra-chat-memory).

1. Create or edit a flow where you want to use chat memory.

2. At the beginning of the flow, add a **Message History** component and a **Redis Chat Memory** component:

   1. Configure the **Redis Chat Memory** component to connect to your Redis database. For more information, see the [Redis documentation](https://redis.io/docs/latest/).
   2. Set the **Message History** component to **Retrieve** mode.
   3. In the **Message History** [component's header menu](/concepts-components#component-menus), click <Icon name="SlidersHorizontal" aria-hidden="true"/> **Controls**, enable **External Memory**, and then click **Close**.

      In **Controls**, you can also enable parameters for memory sorting, filtering, and limits.

   4. Connect the **Redis Chat Memory** component's output to the **Message History** component's **External Memory** input.

3. Add a **Prompt Template** component, add a `{memory}` variable to the **Template** field, and then connect the **Message History** output to the **memory** input.

    The **Prompt Template** component supplies instructions and context to LLMs, separate from chat messages passed through a **Chat Input** component.
    The template can include any text and variables that you want to supply to the LLM, for example:

    ```text
    You are a helpful assistant that answers questions.

    Use markdown to format your answer, properly embedding images and urls.

    History:

    {memory}
    ```

    Variables (`{variable}`) in the template dynamically add fields to the **Prompt Template** component so that your flow can receive definitions for those values from elsewhere, such as other components, Langflow global variables, or runtime input.
    For more information, see [Define variables in prompts](/components-prompts#define-variables-in-prompts).

    In this example, the `{memory}` variable is populated by the retrieved chat memories, which are then passed to a **Language Model** or **Agent** component to provide additional context to the LLM.

4. Connect the **Prompt Template** component's output to a **Language Model** component's **System Message** input.

    This example uses the **Language Model** core component as the central chat driver, but you can also use another language model component or the **Agent** component.

5. Add a **Chat Input** component, and then connect it to the **Language Model** component's **Input** input.

6. Connect the **Language Model** component's output to a **Chat Output** component.

7. At the end of the flow, add another pair of **Message History** and **Redis Chat Memory** components:

   1. Configure the **Redis Chat Memory** component to connect to your Redis database.
   2. Set the **Message History** component to **Store** mode.
   3. In the **Message History** [component's header menu](/concepts-components#component-menus), click <Icon name="SlidersHorizontal" aria-hidden="true"/> **Controls**, enable **External Memory**, and then click **Close**.

       Configure any additional parameters in this component as needed, taking into consideration that this particular component will store chat messages rather than retrieve them.

   4. Connect the **Redis Chat Memory** component to the **Message History** component's **External Memory** input.

8. Connect the **Chat Output** component's output to the **Message History** component's **Message** input.

    Each response from the LLM is output from the **Language Model** component to the **Chat Output** component, and then stored in chat memory by passing it to the final **Message History** and **Redis Chat Memory** components.

![A flow with Message History and Redis Chat Memory components](/img/component-message-history-external-memory.png)

</TabItem>
</Tabs>

### Message History parameters

import PartialParams from '@site/docs/_partial-hidden-params.mdx';

<PartialParams />

The available parameters depend on whether the component is in **Retrieve** or **Store** mode.

<Tabs>
<TabItem value="retrieve" label="Retrieve mode">

| Name | Type | Description |
|------|------|-------------|
| **Template** (`template`) | String | Input parameter. The template to use for formatting the data. It can contain the keys `{text}`, `{sender}` or any other key in the message data. |
| **External Memory** (`memory`) | External Memory | Input parameter. Retrieve messages from an external memory. If empty, Langflow storage is used. |
| **Number of Messages** (`n_messages`) | Integer | Input parameter. The number of messages to retrieve. Default: 100. |
| **Order** (`order`) | String | Input parameter. The order of the messages. Default: `Ascending`. |
| **Sender Type** (`sender_type`) | String | Input parameter. Filter by sender type, one of `User`, `Machine`, or `Machine and User` (default). |
| **Session ID** (`session_id`) | String | Input parameter. The [session ID](/session-id) of the chat memories to retrieve. If omitted or empty, the current session ID for the flow run is used. |

</TabItem>
<TabItem value="store" label="Store mode">

| Name | Type | Description |
|------|------|-------------|
| **Template** (`template`) | String | Input parameter. The template to use for formatting the data. It can contain the keys `{text}`, `{sender}` or any other key in the message data. |
| **Message** (`message`) | String | Input parameter. The message to store, typically provided by connecting a **Chat Output** component. |
| **External Memory** (`memory`) | External Memory | Input parameter. Store messages in external memory. If empty, Langflow storage is used. |
| **Sender** (`sender`) | String | Input parameter. Choose which messages to store based on sender, one of `User`, `Machine`, or `Machine and User` (default). |
| **Sender Name** (`sender_name`) | String | Input parameter. A backup `sender` label to use if a message doesn't have sender metadata. |
| **Session ID** (`session_id`) | String | Input parameter. The [session ID](/session-id) of the chat memories to store. If omitted or empty, the current session ID for the flow run is used. Use custom session IDs if you need to segregate chat memory for different users or applications that run the same flow. |
| **Sender Type** (`sender_type`) | String | Input parameter. Filter by sender type, one of `User`, `Machine`, or `Machine and User` (default). |

</TabItem>
</Tabs>

### Message History output

Memories can be retrieved in one of two formats:

* **Message**: Retrieve memories as `Message` objects, including `messages_text` containing retrieved chat message text.
This is the typical output format used to pass memories _as chat messages_ to another component.

* **DataFrame**: Returns memories as a `DataFrame` containing the message data.
Useful for cases where you need to retrieve memories in a tabular format rather than as chat messages.

You can set the output type near the component's output port.

## Python Interpreter

This component allows you to execute Python code with imported packages.

The **Python Interpreter** component can only import packages that are already installed in your Langflow environment.
If you encounter an `ImportError` when trying to use a package, you need to install it first.

To install custom packages, see [Install custom dependencies](/install-custom-dependencies).

### Use the Python Interpreter in a flow

1. To use this component in a flow, in the **Global Imports** field, add the packages you want to import as a comma-separated list, such as `math,pandas`.
At least one import is required.
2. In the **Python Code** field, enter the Python code you want to execute. Use `print()` to see the output.
3. Optional: Enable **Tool Mode**, and then connect the **Python Interpreter** component to an **Agent** component as a tool.
For example, connect a **Python Interpreter** component and a [**Calculator** component](/calculator) as tools for an **Agent** component, and then test how it chooses different tools to solve math problems.
![Python Interpreter and Calculator components connected to an Agent component](/img/component-python-interpreter.png)
4. Ask the agent an easier math question.
The **Calculator** tool can add, subtract, multiple, divide, or perform exponentiation.
The agent executes the `evaluate_expression` tool to correctly answer the question.

Result:
```text
Executed evaluate_expression
Input:
{
  "expression": "2+5"
}
Output:
{
  "result": "7"
}
```

5. Give the agent complete Python code.
This example creates a Pandas DataFrame table with the imported `pandas` packages, and returns the square root of the mean squares.

```python
import pandas as pd
import math

# Create a simple DataFrame
df = pd.DataFrame({
    'numbers': [1, 2, 3, 4, 5],
    'squares': [x**2 for x in range(1, 6)]
})

# Calculate the square root of the mean
result = math.sqrt(df['squares'].mean())
print(f"Square root of mean squares: {result}")
```

The agent correctly chooses the `run_python_repl` tool to solve the problem.

Result:
```text
Executed run_python_repl

Input:

{
  "python_code": "import pandas as pd\nimport math\n\n# Create a simple DataFrame\ndf = pd.DataFrame({\n    'numbers': [1, 2, 3, 4, 5],\n    'squares': [x**2 for x in range(1, 6)]\n})\n\n# Calculate the square root of the mean\nresult = math.sqrt(df['squares'].mean())\nprint(f\"Square root of mean squares: {result}\")"
}
Output:

{
  "result": "Square root of mean squares: 3.3166247903554"
}
```

If you don't include the package imports in the chat, the agent can still create the table using `pd.DataFrame`, because the `pandas` package is imported globally by the **Python Interpreter** component in the **Global Imports** field.

### Python Interpreter parameters

| Name | Type | Description |
|------|------|-------------|
| global_imports | String | Input parameter. A comma-separated list of modules to import globally, such as `math,pandas,numpy`. |
| python_code | Code | Input parameter. The Python code to execute. Only modules specified in Global Imports can be used. |
| results | Data | Output parameter. The output of the executed Python code, including any printed results or errors. |

## SQL Database

The **SQL Database** component executes SQL queries on [SQLAlchemy-compatible databases](https://docs.sqlalchemy.org/en/20/).
It supports any SQLAlchemy-compatible database, such as PostgreSQL, MySQL, and SQLite.

For CQL queries, see the [**DataStax** bundle](/bundles-datastax).

### Query an SQL database with natural language prompts

The following example demonstrates how to use the **SQL Database** component in a flow, and then modify the component to support natural language queries through an **Agent** component.

This allows you to use the same **SQL Database** component for any query, rather than limiting it to a single manually entered query or requiring the user, application, or another component to provide valid SQL syntax as input.
Users don't need to master SQL syntax because the **Agent** component translates the users' natural language prompts into SQL queries, passes the query to the **SQL Database** component, and then returns the results to the user.

Additionally, input from applications and other components doesn't have to be extracted and transformed to exact SQL queries.
Instead, you only need to provide enough context for the agent to understand that it should create and run a SQL query according to the incoming data.

1. Use your own sample database or create a test database.

    <details>
    <summary>Create a test SQL database</summary>

    1. Create a database called `test.db`:

        ```shell
        sqlite3 test.db
        ```

    2. Add some values to the database:

        ```shell
        sqlite3 test.db "
        CREATE TABLE users (
            id INTEGER PRIMARY KEY,
            name TEXT,
            email TEXT,
            age INTEGER
        );

        INSERT INTO users (name, email, age) VALUES
            ('John Doe', 'john@example.com', 30),
            ('Jane Smith', 'jane@example.com', 25),
            ('Bob Johnson', 'bob@example.com', 35);
        "
        ```

    3. Verify that the database has been created and contains your data:

        ```shell
        sqlite3 test.db "SELECT * FROM users;"
        ```

        The result should list the text data you entered in the previous step:

        ```shell
        1|John Doe|john@example.com
        2|Jane Smith|jane@example.com
        3|John Doe|john@example.com
        4|Jane Smith|jane@example.com
        ```

    </details>

2. Add an **SQL Database** component to your flow.

3. In the **Database URL** field, add the connection string for your database, such as `sqlite:///test.db`.

    At this point, you can enter an SQL query in the **SQL Query** field or use the [port](/concepts-components#component-ports) to pass a query from another component, such as a **Chat Input** component.
    If you need more space, click <Icon name="Expand" aria-hidden="true"/> **Expand** to open a full-screen text field.

    However, to make this component more dynamic in an agentic context, use an **Agent** component to transform natural language input to SQL queries, as explained in the following steps.

4. Click the **SQL Database** component to expose the [component's header menu](/concepts-components#component-menus), and then enable **Tool Mode**.

    You can now use this component as a tool for an agent.
    In **Tool Mode**, no query is set in the **SQL Database** component because the agent will generate and send one if it determines that the tool is required to complete the user's request.
    For more information, see [Configure tools for agents](/agents-tools).

5. Add an **Agent** component to your flow, and then enter your OpenAI API key.

    The default model is an OpenAI model.
    If you want to use a different model, edit the **Model Provider**, **Model Name**, and **API Key** fields accordingly.

    If you need to execute highly specialized queries, consider selecting a model that is trained for tasks like advanced SQL queries.
    If your preferred model isn't in the **Agent** component's built-in model list, set **Model Provider** to **Connect other models**, and then connect any [language model component](/components-models).

6. Connect the **SQL Database** component's **Toolset** output to the **Agent** component's **Tools** input.

    ![SQL Database component connected to an Agent component](/img/component-sql-database.png)

7. Click **Playground**, and then ask the agent a question about the data in your database, such as `Which users are in my database?`

    The agent determines that it needs to query the database to answer the question, uses the LLM to generate an SQL query, and then uses the **SQL Database** component's `RUN_SQL_QUERY` action to run the query on your database.
    Finally, it returns the results in a conversational format, unless you provide instructions to return raw results or a different format.

    The following example queried a test database with little data, but with a more robust dataset you could ask more detailed or complex questions.

    ```text
    Here are the users in your database:

    1. **John Doe** - Email: john@example.com
    2. **Jane Smith** - Email: jane@example.com
    3. **John Doe** - Email: john@example.com
    4. **Jane Smith** - Email: jane@example.com

    It seems there are duplicate entries for the users.
    ```

### SQL Database parameters

<PartialParams />

| Name | Display Name | Info |
|------|--------------|------|
| database_url | Database URL | Input parameter. The SQLAlchemy-compatible database connection URL. |
| query | SQL Query | Input parameter. The SQL query to execute, which can be entered directly, passed in from another component, or, in **Tool Mode**, automatically provided by an **Agent** component. |
| include_columns | Include Columns | Input parameter. Whether to include column names in the result. The default is enabled (`true`). |
| add_error | Add Error | Input parameter. If enabled, adds any error messages to the result, if any are returned. The default is disabled (`false`). |
| run_sql_query | Result Table | Output parameter. The query results as a [`DataFrame`](/data-types#dataframe). |
