export const newData = {
    // "retrievers": {
    //     "AmazonKendra": {
    //         "template": {
    //             "_type": "CustomComponent",
    //             "attribute_filter": {
    //                 "type": "dict | None",
    //                 "required": false,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "attribute_filter",
    //                 "display_name": "Attribute Filter",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "credentials_profile_name": {
    //                 "type": "str | None",
    //                 "required": false,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "credentials_profile_name",
    //                 "display_name": "Credentials Profile Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "region_name": {
    //                 "type": "str | None",
    //                 "required": false,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "region_name",
    //                 "display_name": "Region Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "user_context": {
    //                 "type": "dict | None",
    //                 "required": false,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "user_context",
    //                 "display_name": "User Context",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import cast\n\nfrom langchain_community.retrievers import AmazonKendraRetriever\n\nfrom langflow.custom import CustomComponent\nfrom langflow.field_typing import Retriever\n\n\nclass AmazonKendraRetrieverComponent(CustomComponent):\n    display_name: str = \"Amazon Kendra Retriever\"\n    description: str = \"Retriever that uses the Amazon Kendra API.\"\n    name = \"AmazonKendra\"\n    icon = \"Amazon\"\n\n    def build_config(self):\n        return {\n            \"index_id\": {\"display_name\": \"Index ID\"},\n            \"region_name\": {\"display_name\": \"Region Name\"},\n            \"credentials_profile_name\": {\"display_name\": \"Credentials Profile Name\"},\n            \"attribute_filter\": {\n                \"display_name\": \"Attribute Filter\",\n                \"field_type\": \"code\",\n            },\n            \"top_k\": {\"display_name\": \"Top K\", \"field_type\": \"int\"},\n            \"user_context\": {\n                \"display_name\": \"User Context\",\n                \"field_type\": \"code\",\n            },\n            \"code\": {\"show\": False},\n        }\n\n    def build(\n        self,\n        index_id: str,\n        top_k: int = 3,\n        region_name: str | None = None,\n        credentials_profile_name: str | None = None,\n        attribute_filter: dict | None = None,\n        user_context: dict | None = None,\n    ) -> Retriever:  # type: ignore[type-var]\n        try:\n            output = AmazonKendraRetriever(\n                index_id=index_id,\n                top_k=top_k,\n                region_name=region_name,\n                credentials_profile_name=credentials_profile_name,\n                attribute_filter=attribute_filter,\n                user_context=user_context,\n            )\n        except Exception as e:\n            msg = \"Could not connect to AmazonKendra API.\"\n            raise ValueError(msg) from e\n        return cast(Retriever, output)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "index_id": {
    //                 "type": "str",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "index_id",
    //                 "display_name": "Index ID",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false,
    //                 "input_types": [
    //                     "Text"
    //                 ]
    //             },
    //             "top_k": {
    //                 "type": "int",
    //                 "required": false,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "value": 3,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "top_k",
    //                 "display_name": "Top K",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             }
    //         },
    //         "description": "Retriever that uses the Amazon Kendra API.",
    //         "icon": "Amazon",
    //         "base_classes": [
    //             "Retriever"
    //         ],
    //         "display_name": "Amazon Kendra Retriever",
    //         "documentation": "",
    //         "custom_fields": {
    //             "index_id": null,
    //             "top_k": null,
    //             "region_name": null,
    //             "credentials_profile_name": null,
    //             "attribute_filter": null,
    //             "user_context": null
    //         },
    //         "output_types": [
    //             "Retriever"
    //         ],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "retriever",
    //                 "hidden": null,
    //                 "display_name": "Retriever",
    //                 "method": null,
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": null
    //             }
    //         ],
    //         "field_order": [],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "VectorStoreRetriever": {
    //         "template": {
    //             "_type": "CustomComponent",
    //             "vectorstore": {
    //                 "type": "VectorStore",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "vectorstore",
    //                 "display_name": "Vector Store",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_core.vectorstores import VectorStoreRetriever\n\nfrom langflow.custom import CustomComponent\nfrom langflow.field_typing import VectorStore\n\n\nclass VectoStoreRetrieverComponent(CustomComponent):\n    display_name = \"VectorStore Retriever\"\n    description = \"A vector store retriever\"\n    name = \"VectorStoreRetriever\"\n\n    def build_config(self):\n        return {\n            \"vectorstore\": {\"display_name\": \"Vector Store\", \"type\": VectorStore},\n        }\n\n    def build(self, vectorstore: VectorStore) -> VectorStoreRetriever:\n        return vectorstore.as_retriever()\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             }
    //         },
    //         "description": "A vector store retriever",
    //         "base_classes": [
    //             "BaseRetriever",
    //             "Generic",
    //             "object",
    //             "Runnable",
    //             "RunnableSerializable",
    //             "RunnableSerializable[str, list[Document]]",
    //             "Serializable",
    //             "VectorStoreRetriever"
    //         ],
    //         "display_name": "VectorStore Retriever",
    //         "documentation": "",
    //         "custom_fields": {
    //             "vectorstore": null
    //         },
    //         "output_types": [
    //             "VectorStoreRetriever"
    //         ],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "VectorStoreRetriever"
    //                 ],
    //                 "selected": "VectorStoreRetriever",
    //                 "name": "vectorstoreretriever",
    //                 "hidden": null,
    //                 "display_name": "VectorStoreRetriever",
    //                 "method": null,
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": null
    //             }
    //         ],
    //         "field_order": [],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "SelfQueryRetriever": {
    //         "template": {
    //             "_type": "Component",
    //             "attribute_infos": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "attribute_infos",
    //                 "value": "",
    //                 "display_name": "Metadata Field Info",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Metadata Field Info to be passed as input.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "llm",
    //                 "value": "",
    //                 "display_name": "LLM",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "LanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "LLM to be passed as input.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "query": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "query",
    //                 "value": "",
    //                 "display_name": "Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message",
    //                     "Text"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Query to be passed as input.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "vectorstore": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "vectorstore",
    //                 "value": "",
    //                 "display_name": "Vector Store",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "VectorStore"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Vector Store to be passed as input.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain.chains.query_constructor.base import AttributeInfo\nfrom langchain.retrievers.self_query.base import SelfQueryRetriever\n\nfrom langflow.custom import Component\nfrom langflow.inputs import HandleInput, MessageTextInput\nfrom langflow.io import Output\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\n\n\nclass SelfQueryRetrieverComponent(Component):\n    display_name = \"Self Query Retriever\"\n    description = \"Retriever that uses a vector store and an LLM to generate the vector store queries.\"\n    name = \"SelfQueryRetriever\"\n    icon = \"LangChain\"\n\n    inputs = [\n        HandleInput(\n            name=\"query\",\n            display_name=\"Query\",\n            info=\"Query to be passed as input.\",\n            input_types=[\"Message\", \"Text\"],\n        ),\n        HandleInput(\n            name=\"vectorstore\",\n            display_name=\"Vector Store\",\n            info=\"Vector Store to be passed as input.\",\n            input_types=[\"VectorStore\"],\n        ),\n        HandleInput(\n            name=\"attribute_infos\",\n            display_name=\"Metadata Field Info\",\n            info=\"Metadata Field Info to be passed as input.\",\n            input_types=[\"Data\"],\n            is_list=True,\n        ),\n        MessageTextInput(\n            name=\"document_content_description\",\n            display_name=\"Document Content Description\",\n            info=\"Document Content Description to be passed as input.\",\n        ),\n        HandleInput(\n            name=\"llm\",\n            display_name=\"LLM\",\n            info=\"LLM to be passed as input.\",\n            input_types=[\"LanguageModel\"],\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Retrieved Documents\", name=\"documents\", method=\"retrieve_documents\"),\n    ]\n\n    def retrieve_documents(self) -> list[Data]:\n        metadata_field_infos = [AttributeInfo(**value.data) for value in self.attribute_infos]\n        self_query_retriever = SelfQueryRetriever.from_llm(\n            llm=self.llm,\n            vectorstore=self.vectorstore,\n            document_contents=self.document_content_description,\n            metadata_field_info=metadata_field_infos,\n            enable_limit=True,\n        )\n\n        if isinstance(self.query, Message):\n            input_text = self.query.text\n        elif isinstance(self.query, str):\n            input_text = self.query\n        else:\n            msg = f\"Query type {type(self.query)} not supported.\"\n            raise TypeError(msg)\n\n        documents = self_query_retriever.invoke(input=input_text, config={\"callbacks\": self.get_langchain_callbacks()})\n        data = [Data.from_document(document) for document in documents]\n        self.status = data\n        return data\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "document_content_description": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "document_content_description",
    //                 "value": "",
    //                 "display_name": "Document Content Description",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Document Content Description to be passed as input.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Retriever that uses a vector store and an LLM to generate the vector store queries.",
    //         "icon": "LangChain",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Self Query Retriever",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "documents",
    //                 "display_name": "Retrieved Documents",
    //                 "method": "retrieve_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "query",
    //             "vectorstore",
    //             "attribute_infos",
    //             "document_content_description",
    //             "llm"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "NvidiaRerankComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "retriever": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "retriever",
    //                 "value": "",
    //                 "display_name": "Retriever",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Retriever"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "base_url": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "base_url",
    //                 "value": "https://integrate.api.nvidia.com/v1",
    //                 "display_name": "Base URL",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The base URL of the NVIDIA API. Defaults to https://integrate.api.nvidia.com/v1.",
    //                 "refresh_button": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any, cast\n\nfrom langchain.retrievers import ContextualCompressionRetriever\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.field_typing import Retriever, VectorStore\nfrom langflow.io import DropdownInput, HandleInput, MultilineInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\nfrom langflow.schema.dotdict import dotdict\nfrom langflow.template.field.base import Output\n\n\nclass NvidiaRerankComponent(LCVectorStoreComponent):\n    display_name = \"NVIDIA Rerank\"\n    description = \"Rerank documents using the NVIDIA API and a retriever.\"\n    icon = \"NVIDIA\"\n\n    inputs = [\n        MultilineInput(\n            name=\"search_query\",\n            display_name=\"Search Query\",\n        ),\n        StrInput(\n            name=\"base_url\",\n            display_name=\"Base URL\",\n            value=\"https://integrate.api.nvidia.com/v1\",\n            refresh_button=True,\n            info=\"The base URL of the NVIDIA API. Defaults to https://integrate.api.nvidia.com/v1.\",\n        ),\n        DropdownInput(\n            name=\"model\", display_name=\"Model\", options=[\"nv-rerank-qa-mistral-4b:1\"], value=\"nv-rerank-qa-mistral-4b:1\"\n        ),\n        SecretStrInput(name=\"api_key\", display_name=\"API Key\"),\n        HandleInput(name=\"retriever\", display_name=\"Retriever\", input_types=[\"Retriever\"]),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Retriever\",\n            name=\"base_retriever\",\n            method=\"build_base_retriever\",\n        ),\n        Output(\n            display_name=\"Search Results\",\n            name=\"search_results\",\n            method=\"search_documents\",\n        ),\n    ]\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"base_url\" and field_value:\n            try:\n                build_model = self.build_model()\n                ids = [model.id for model in build_model.available_models]\n                build_config[\"model\"][\"options\"] = ids\n                build_config[\"model\"][\"value\"] = ids[0]\n            except Exception as e:\n                msg = f\"Error getting model names: {e}\"\n                raise ValueError(msg) from e\n        return build_config\n\n    def build_model(self):\n        try:\n            from langchain_nvidia_ai_endpoints import NVIDIARerank\n        except ImportError as e:\n            msg = \"Please install langchain-nvidia-ai-endpoints to use the NVIDIA model.\"\n            raise ImportError(msg) from e\n        return NVIDIARerank(api_key=self.api_key, model=self.model, base_url=self.base_url)\n\n    def build_base_retriever(self) -> Retriever:  # type: ignore[type-var]\n        nvidia_reranker = self.build_model()\n        retriever = ContextualCompressionRetriever(base_compressor=nvidia_reranker, base_retriever=self.retriever)\n        return cast(Retriever, retriever)\n\n    async def search_documents(self) -> list[Data]:  # type: ignore[override]\n        retriever = self.build_base_retriever()\n        documents = await retriever.ainvoke(self.search_query, config={\"callbacks\": self.get_langchain_callbacks()})\n        data = self.to_data(documents)\n        self.status = data\n        return data\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> VectorStore:\n        msg = \"NVIDIA Rerank does not support vector stores.\"\n        raise NotImplementedError(msg)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "model": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "nv-rerank-qa-mistral-4b:1"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model",
    //                 "value": "nv-rerank-qa-mistral-4b:1",
    //                 "display_name": "Model",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "search_query": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_query",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Rerank documents using the NVIDIA API and a retriever.",
    //         "icon": "NVIDIA",
    //         "base_classes": [
    //             "Data",
    //             "Retriever"
    //         ],
    //         "display_name": "NVIDIA Rerank",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "search_query",
    //             "base_url",
    //             "model",
    //             "api_key",
    //             "retriever"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "VectaraSelfQueryRetriver": {
    //         "template": {
    //             "_type": "CustomComponent",
    //             "llm": {
    //                 "type": "LanguageModel",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "llm",
    //                 "display_name": "LLM",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "For self query retriever",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "vectorstore": {
    //                 "type": "VectorStore",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "vectorstore",
    //                 "display_name": "Vector Store",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Input Vectara Vectore Store",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import json\nfrom typing import cast\n\nfrom langchain.chains.query_constructor.base import AttributeInfo\nfrom langchain.retrievers.self_query.base import SelfQueryRetriever\nfrom langchain_core.vectorstores import VectorStore\n\nfrom langflow.custom import CustomComponent\nfrom langflow.field_typing import Retriever\nfrom langflow.field_typing.constants import LanguageModel\n\n\nclass VectaraSelfQueryRetriverComponent(CustomComponent):\n    \"\"\"A custom component for implementing Vectara Self Query Retriever using a vector store.\"\"\"\n\n    display_name: str = \"Vectara Self Query Retriever for Vectara Vector Store\"\n    description: str = \"Implementation of Vectara Self Query Retriever\"\n    documentation = \"https://python.langchain.com/docs/integrations/retrievers/self_query/vectara_self_query\"\n    name = \"VectaraSelfQueryRetriver\"\n    icon = \"Vectara\"\n\n    field_config = {\n        \"code\": {\"show\": True},\n        \"vectorstore\": {\"display_name\": \"Vector Store\", \"info\": \"Input Vectara Vectore Store\"},\n        \"llm\": {\"display_name\": \"LLM\", \"info\": \"For self query retriever\"},\n        \"document_content_description\": {\n            \"display_name\": \"Document Content Description\",\n            \"info\": \"For self query retriever\",\n        },\n        \"metadata_field_info\": {\n            \"display_name\": \"Metadata Field Info\",\n            \"info\": \"Each metadata field info is a string in the form of key value pair dictionary containing \"\n            \"additional search metadata.\\n\"\n            'Example input: {\"name\":\"speech\",\"description\":\"what name of the speech\",\"type\":'\n            '\"string or list[string]\"}.\\n'\n            \"The keys should remain constant(name, description, type)\",\n        },\n    }\n\n    def build(\n        self,\n        vectorstore: VectorStore,\n        document_content_description: str,\n        llm: LanguageModel,\n        metadata_field_info: list[str],\n    ) -> Retriever:\n        metadata_field_obj = []\n\n        for meta in metadata_field_info:\n            meta_obj = json.loads(meta)\n            if \"name\" not in meta_obj or \"description\" not in meta_obj or \"type\" not in meta_obj:\n                msg = \"Incorrect metadata field info format.\"\n                raise ValueError(msg)\n            attribute_info = AttributeInfo(\n                name=meta_obj[\"name\"],\n                description=meta_obj[\"description\"],\n                type=meta_obj[\"type\"],\n            )\n            metadata_field_obj.append(attribute_info)\n\n        return cast(\n            Retriever,\n            SelfQueryRetriever.from_llm(\n                llm, vectorstore, document_content_description, metadata_field_obj, verbose=True\n            ),\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "document_content_description": {
    //                 "type": "str",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "document_content_description",
    //                 "display_name": "Document Content Description",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "For self query retriever",
    //                 "load_from_db": false,
    //                 "title_case": false,
    //                 "input_types": [
    //                     "Text"
    //                 ]
    //             },
    //             "metadata_field_info": {
    //                 "type": "str",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": true,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "metadata_field_info",
    //                 "display_name": "Metadata Field Info",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Each metadata field info is a string in the form of key value pair dictionary containing additional search metadata.\nExample input: {\"name\":\"speech\",\"description\":\"what name of the speech\",\"type\":\"string or list[string]\"}.\nThe keys should remain constant(name, description, type)",
    //                 "load_from_db": false,
    //                 "title_case": false,
    //                 "input_types": [
    //                     "Text"
    //                 ]
    //             }
    //         },
    //         "description": "Implementation of Vectara Self Query Retriever",
    //         "icon": "Vectara",
    //         "base_classes": [
    //             "Retriever"
    //         ],
    //         "display_name": "Vectara Self Query Retriever for Vectara Vector Store",
    //         "documentation": "https://python.langchain.com/docs/integrations/retrievers/self_query/vectara_self_query",
    //         "custom_fields": {
    //             "vectorstore": null,
    //             "document_content_description": null,
    //             "llm": null,
    //             "metadata_field_info": null
    //         },
    //         "output_types": [
    //             "Retriever"
    //         ],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "retriever",
    //                 "hidden": null,
    //                 "display_name": "Retriever",
    //                 "method": null,
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": null
    //             }
    //         ],
    //         "field_order": [
    //             "code",
    //             "vectorstore",
    //             "llm",
    //             "document_content_description",
    //             "metadata_field_info"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "MetalRetriever": {
    //         "template": {
    //             "_type": "CustomComponent",
    //             "params": {
    //                 "type": "dict | None",
    //                 "required": false,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "params",
    //                 "display_name": "Parameters",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "api_key": {
    //                 "type": "str",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": true,
    //                 "name": "api_key",
    //                 "display_name": "API Key",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false,
    //                 "input_types": [
    //                     "Text"
    //                 ]
    //             },
    //             "client_id": {
    //                 "type": "str",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": true,
    //                 "name": "client_id",
    //                 "display_name": "Client ID",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false,
    //                 "input_types": [
    //                     "Text"
    //                 ]
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import cast\n\nfrom langchain_community.retrievers import MetalRetriever\nfrom metal_sdk.metal import Metal\n\nfrom langflow.custom import CustomComponent\nfrom langflow.field_typing import Retriever\n\n\nclass MetalRetrieverComponent(CustomComponent):\n    display_name: str = \"Metal Retriever\"\n    description: str = \"Retriever that uses the Metal API.\"\n    name = \"MetalRetriever\"\n\n    def build_config(self):\n        return {\n            \"api_key\": {\"display_name\": \"API Key\", \"password\": True},\n            \"client_id\": {\"display_name\": \"Client ID\", \"password\": True},\n            \"index_id\": {\"display_name\": \"Index ID\"},\n            \"params\": {\"display_name\": \"Parameters\"},\n            \"code\": {\"show\": False},\n        }\n\n    def build(self, api_key: str, client_id: str, index_id: str, params: dict | None = None) -> Retriever:  # type: ignore[type-var]\n        try:\n            metal = Metal(api_key=api_key, client_id=client_id, index_id=index_id)\n        except Exception as e:\n            msg = \"Could not connect to Metal API.\"\n            raise ValueError(msg) from e\n        return cast(Retriever, MetalRetriever(client=metal, params=params or {}))\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "index_id": {
    //                 "type": "str",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "index_id",
    //                 "display_name": "Index ID",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false,
    //                 "input_types": [
    //                     "Text"
    //                 ]
    //             }
    //         },
    //         "description": "Retriever that uses the Metal API.",
    //         "base_classes": [
    //             "Retriever"
    //         ],
    //         "display_name": "Metal Retriever",
    //         "documentation": "",
    //         "custom_fields": {
    //             "api_key": null,
    //             "client_id": null,
    //             "index_id": null,
    //             "params": null
    //         },
    //         "output_types": [
    //             "Retriever"
    //         ],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "retriever",
    //                 "hidden": null,
    //                 "display_name": "Retriever",
    //                 "method": null,
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": null
    //             }
    //         ],
    //         "field_order": [],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "MultiQueryRetriever": {
    //         "template": {
    //             "_type": "CustomComponent",
    //             "llm": {
    //                 "type": "LanguageModel",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "llm",
    //                 "display_name": "LLM",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "prompt": {
    //                 "type": "Text | None",
    //                 "required": false,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "prompt",
    //                 "display_name": "Prompt",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "retriever": {
    //                 "type": "BaseRetriever",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "retriever",
    //                 "display_name": "Retriever",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain.retrievers import MultiQueryRetriever\n\nfrom langflow.custom import CustomComponent\nfrom langflow.field_typing import BaseRetriever, LanguageModel, PromptTemplate, Text\n\n\nclass MultiQueryRetrieverComponent(CustomComponent):\n    display_name = \"MultiQueryRetriever\"\n    description = \"Initialize from llm using default template.\"\n    documentation = \"https://python.langchain.com/docs/modules/data_connection/retrievers/how_to/MultiQueryRetriever\"\n    name = \"MultiQueryRetriever\"\n\n    def build_config(self):\n        return {\n            \"llm\": {\"display_name\": \"LLM\"},\n            \"prompt\": {\n                \"display_name\": \"Prompt\",\n                \"default\": {\n                    \"input_variables\": [\"question\"],\n                    \"input_types\": {},\n                    \"output_parser\": None,\n                    \"partial_variables\": {},\n                    \"template\": \"You are an AI language model assistant. Your task is \\n\"\n                    \"to generate 3 different versions of the given user \\n\"\n                    \"question to retrieve relevant documents from a vector database. \\n\"\n                    \"By generating multiple perspectives on the user question, \\n\"\n                    \"your goal is to help the user overcome some of the limitations \\n\"\n                    \"of distance-based similarity search. Provide these alternative \\n\"\n                    \"questions separated by newlines. Original question: {question}\",\n                    \"template_format\": \"f-string\",\n                    \"validate_template\": False,\n                    \"_type\": \"prompt\",\n                },\n            },\n            \"retriever\": {\"display_name\": \"Retriever\"},\n            \"parser_key\": {\"display_name\": \"Parser Key\", \"default\": \"lines\"},\n        }\n\n    def build(\n        self,\n        llm: LanguageModel,\n        retriever: BaseRetriever,\n        prompt: Text | None = None,\n        parser_key: str = \"lines\",\n    ) -> MultiQueryRetriever:\n        if not prompt:\n            return MultiQueryRetriever.from_llm(llm=llm, retriever=retriever, parser_key=parser_key)\n        prompt_template = PromptTemplate.from_template(prompt)\n        return MultiQueryRetriever.from_llm(llm=llm, retriever=retriever, prompt=prompt_template, parser_key=parser_key)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "parser_key": {
    //                 "type": "str",
    //                 "required": false,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "value": "lines",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "parser_key",
    //                 "display_name": "Parser Key",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false,
    //                 "input_types": [
    //                     "Text"
    //                 ]
    //             }
    //         },
    //         "description": "Initialize from llm using default template.",
    //         "base_classes": [
    //             "BaseRetriever",
    //             "Generic",
    //             "MultiQueryRetriever",
    //             "object",
    //             "Runnable",
    //             "RunnableSerializable",
    //             "RunnableSerializable[str, list[Document]]",
    //             "Serializable"
    //         ],
    //         "display_name": "MultiQueryRetriever",
    //         "documentation": "https://python.langchain.com/docs/modules/data_connection/retrievers/how_to/MultiQueryRetriever",
    //         "custom_fields": {
    //             "llm": null,
    //             "retriever": null,
    //             "prompt": null,
    //             "parser_key": null
    //         },
    //         "output_types": [
    //             "MultiQueryRetriever"
    //         ],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "MultiQueryRetriever"
    //                 ],
    //                 "selected": "MultiQueryRetriever",
    //                 "name": "multiqueryretriever",
    //                 "hidden": null,
    //                 "display_name": "MultiQueryRetriever",
    //                 "method": null,
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": null
    //             }
    //         ],
    //         "field_order": [],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "tools": {
    //     "GleanAPI": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import json\nfrom typing import Any\nfrom urllib.parse import urljoin\n\nimport httpx\nfrom langchain.tools import StructuredTool\nfrom langchain_core.pydantic_v1 import BaseModel\nfrom pydantic.v1 import Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import IntInput, MultilineInput, NestedDictInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass GleanSearchAPIComponent(LCToolComponent):\n    display_name = \"Glean Search API\"\n    description = \"Call Glean Search API\"\n    name = \"GleanAPI\"\n\n    inputs = [\n        StrInput(\n            name=\"glean_api_url\",\n            display_name=\"Glean API URL\",\n            required=True,\n        ),\n        SecretStrInput(name=\"glean_access_token\", display_name=\"Glean Access Token\", required=True),\n        MultilineInput(name=\"query\", display_name=\"Query\", required=True),\n        IntInput(name=\"page_size\", display_name=\"Page Size\", value=10),\n        NestedDictInput(name=\"request_options\", display_name=\"Request Options\", required=False),\n    ]\n\n    class GleanAPIWrapper(BaseModel):\n        \"\"\"Wrapper around Glean API.\"\"\"\n\n        glean_api_url: str\n        glean_access_token: str\n        act_as: str = \"langflow-component@datastax.com\"  # TODO: Detect this\n\n        def _prepare_request(\n            self,\n            query: str,\n            page_size: int = 10,\n            request_options: dict[str, Any] | None = None,\n        ) -> dict:\n            # Ensure there's a trailing slash\n            url = self.glean_api_url\n            if not url.endswith(\"/\"):\n                url += \"/\"\n\n            return {\n                \"url\": urljoin(url, \"search\"),\n                \"headers\": {\n                    \"Authorization\": f\"Bearer {self.glean_access_token}\",\n                    \"X-Scio-ActAs\": self.act_as,\n                },\n                \"payload\": {\n                    \"query\": query,\n                    \"pageSize\": page_size,\n                    \"requestOptions\": request_options,\n                },\n            }\n\n        def results(self, query: str, **kwargs: Any) -> list[dict[str, Any]]:\n            results = self._search_api_results(query, **kwargs)\n\n            if len(results) == 0:\n                msg = \"No good Glean Search Result was found\"\n                raise AssertionError(msg)\n\n            return results\n\n        def run(self, query: str, **kwargs: Any) -> list[dict[str, Any]]:\n            results = self.results(query, **kwargs)\n\n            processed_results = []\n            for result in results:\n                if \"title\" in result:\n                    result[\"snippets\"] = result.get(\"snippets\", [{\"snippet\": {\"text\": result[\"title\"]}}])\n                    if \"text\" not in result[\"snippets\"][0]:\n                        result[\"snippets\"][0][\"text\"] = result[\"title\"]\n\n                    processed_results.append(result)\n\n            return processed_results\n\n        def _search_api_results(self, query: str, **kwargs: Any) -> list[dict[str, Any]]:\n            request_details = self._prepare_request(query, **kwargs)\n\n            response = httpx.post(\n                request_details[\"url\"],\n                json=request_details[\"payload\"],\n                headers=request_details[\"headers\"],\n            )\n\n            response.raise_for_status()\n            response_json = response.json()\n\n            return response_json.get(\"results\", [])\n\n        @staticmethod\n        def _result_as_string(result: dict) -> str:\n            return json.dumps(result, indent=4)\n\n    class GleanSearchAPISchema(BaseModel):\n        query: str = Field(..., description=\"The search query\")\n        page_size: int = Field(10, description=\"Maximum number of results to return\")\n        request_options: dict[str, Any] | None = Field(default_factory=dict, description=\"Request Options\")\n\n    def build_tool(self) -> Tool:\n        wrapper = self._build_wrapper(\n            glean_api_url=self.glean_api_url,\n            glean_access_token=self.glean_access_token,\n        )\n\n        tool = StructuredTool.from_function(\n            name=\"glean_search_api\",\n            description=\"Search Glean for relevant results.\",\n            func=wrapper.run,\n            args_schema=self.GleanSearchAPISchema,\n        )\n\n        self.status = \"Glean Search API Tool for Langchain\"\n\n        return tool\n\n    def run_model(self) -> list[Data]:\n        tool = self.build_tool()\n\n        results = tool.run(\n            {\n                \"query\": self.query,\n                \"page_size\": self.page_size,\n                \"request_options\": self.request_options,\n            }\n        )\n\n        # Build the data\n        data = [Data(data=result, text=result[\"snippets\"][0][\"text\"]) for result in results]\n        self.status = data\n\n        return data\n\n    def _build_wrapper(\n        self,\n        glean_api_url: str,\n        glean_access_token: str,\n    ):\n        return self.GleanAPIWrapper(\n            glean_api_url=glean_api_url,\n            glean_access_token=glean_access_token,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "glean_access_token": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "glean_access_token",
    //                 "value": "",
    //                 "display_name": "Glean Access Token",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "glean_api_url": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "glean_api_url",
    //                 "value": "",
    //                 "display_name": "Glean API URL",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "page_size": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "page_size",
    //                 "value": 10,
    //                 "display_name": "Page Size",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "query": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "query",
    //                 "value": "",
    //                 "display_name": "Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "request_options": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "request_options",
    //                 "value": {},
    //                 "display_name": "Request Options",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "NestedDict",
    //                 "_input_type": "NestedDictInput"
    //             }
    //         },
    //         "description": "Call Glean Search API",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "Glean Search API",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "glean_access_token",
    //                     "glean_api_url",
    //                     "page_size",
    //                     "query",
    //                     "request_options"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "glean_access_token",
    //                     "glean_api_url",
    //                     "page_size",
    //                     "query",
    //                     "request_options"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "glean_api_url",
    //             "glean_access_token",
    //             "query",
    //             "page_size",
    //             "request_options"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AstraDBCQLToolComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "api_endpoint": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_endpoint",
    //                 "value": "ASTRA_DB_API_ENDPOINT",
    //                 "display_name": "API Endpoint",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "API endpoint URL for the Astra DB service.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "clustering_keys": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "clustering_keys",
    //                 "value": {},
    //                 "display_name": "Clustering Keys",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Field name and description to the model",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import urllib\nfrom http import HTTPStatus\nfrom typing import Any\n\nimport requests\nfrom langchain.pydantic_v1 import BaseModel, Field, create_model\nfrom langchain_core.tools import StructuredTool\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.io import DictInput, IntInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass AstraDBCQLToolComponent(LCToolComponent):\n    display_name: str = \"Astra DB CQL Tool\"\n    description: str = \"Create a tool to get data from DataStax Astra DB CQL Table\"\n    documentation: str = \"https://astra.datastax.com\"\n    icon: str = \"AstraDB\"\n\n    inputs = [\n        StrInput(name=\"tool_name\", display_name=\"Tool Name\", info=\"The name of the tool.\", required=True),\n        StrInput(\n            name=\"tool_description\",\n            display_name=\"Tool Description\",\n            info=\"The tool description to be passed to the model.\",\n            required=True,\n        ),\n        StrInput(\n            name=\"keyspace\",\n            display_name=\"Keyspace\",\n            value=\"default_keyspace\",\n            info=\"The keyspace name within Astra DB where the data is stored.\",\n            required=True,\n        ),\n        StrInput(\n            name=\"table_name\",\n            display_name=\"Table Name\",\n            info=\"The name of the table within Astra DB where the data is stored.\",\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"token\",\n            display_name=\"Astra DB Application Token\",\n            info=\"Authentication token for accessing Astra DB.\",\n            value=\"ASTRA_DB_APPLICATION_TOKEN\",\n            required=True,\n        ),\n        StrInput(\n            name=\"api_endpoint\",\n            display_name=\"API Endpoint\",\n            info=\"API endpoint URL for the Astra DB service.\",\n            value=\"ASTRA_DB_API_ENDPOINT\",\n            required=True,\n        ),\n        StrInput(\n            name=\"projection_fields\",\n            display_name=\"Projection fields\",\n            info=\"Attributes to return separated by comma.\",\n            required=True,\n            value=\"*\",\n        ),\n        DictInput(\n            name=\"partition_keys\",\n            display_name=\"Partition Keys\",\n            is_list=True,\n            info=\"Field name and description to the model\",\n            required=True,\n        ),\n        DictInput(\n            name=\"clustering_keys\",\n            display_name=\"Clustering Keys\",\n            is_list=True,\n            info=\"Field name and description to the model\",\n        ),\n        DictInput(\n            name=\"static_filters\",\n            display_name=\"Static Filters\",\n            is_list=True,\n            info=\"Field name and value. When filled, it will not be generated by the LLM.\",\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            advanced=True,\n            value=5,\n        ),\n    ]\n\n    def astra_rest(self, args):\n        headers = {\"Accept\": \"application/json\", \"X-Cassandra-Token\": f\"{self.token}\"}\n        astra_url = f\"{self.api_endpoint}/api/rest/v2/keyspaces/{self.keyspace}/{self.table_name}/\"\n        key = []\n        # Partition keys are mandatory\n        for k in self.partition_keys:\n            if k in args:\n                key.append(args[k])\n            elif self.static_filters[k] is not None:\n                key.append(self.static_filters[k])\n            else:\n                # TO-DO: Raise error - Missing information\n                key.append(\"none\")\n\n        # Clustering keys are optional\n        for k in self.clustering_keys:\n            if k in args:\n                key.append(args[k])\n            elif self.static_filters[k] is not None:\n                key.append(self.static_filters[k])\n\n        url = f'{astra_url}{\"/\".join(key)}?page-size={self.number_of_results}'\n\n        if self.projection_fields != \"*\":\n            url += f'&fields={urllib.parse.quote(self.projection_fields.replace(\" \", \"\"))}'\n\n        res = requests.request(\"GET\", url=url, headers=headers, timeout=10)\n\n        if int(res.status_code) >= HTTPStatus.BAD_REQUEST:\n            return res.text\n\n        try:\n            res_data = res.json()\n            return res_data[\"data\"]\n        except ValueError:\n            return res.status_code\n\n    def create_args_schema(self) -> dict[str, BaseModel]:\n        args: dict[str, tuple[Any, Field]] = {}\n\n        for key in self.partition_keys:\n            # Partition keys are mandatory is it doesn't have a static filter\n            if key not in self.static_filters:\n                args[key] = (str, Field(description=self.partition_keys[key]))\n\n        for key in self.clustering_keys:\n            # Partition keys are mandatory if has the exclamation mark and doesn't have a static filter\n            if key not in self.static_filters:\n                if key.startswith(\"!\"):  # Mandatory\n                    args[key[1:]] = (str, Field(description=self.clustering_keys[key]))\n                else:  # Optional\n                    args[key] = (str | None, Field(description=self.clustering_keys[key], default=None))\n\n        model = create_model(\"ToolInput\", **args, __base__=BaseModel)\n        return {\"ToolInput\": model}\n\n    def build_tool(self) -> StructuredTool:\n        \"\"\"Builds a Astra DB CQL Table tool.\n\n        Args:\n            name (str, optional): The name of the tool.\n\n        Returns:\n            Tool: The built AstraDB tool.\n        \"\"\"\n        schema_dict = self.create_args_schema()\n        return StructuredTool.from_function(\n            name=self.tool_name,\n            args_schema=schema_dict[\"ToolInput\"],\n            description=self.tool_description,\n            func=self.run_model,\n            return_direct=False,\n        )\n\n    def projection_args(self, input_str: str) -> dict:\n        elements = input_str.split(\",\")\n        result = {}\n\n        for element in elements:\n            if element.startswith(\"!\"):\n                result[element[1:]] = False\n            else:\n                result[element] = True\n\n        return result\n\n    def run_model(self, **args) -> Data | list[Data]:\n        results = self.astra_rest(args)\n        data: list[Data] = [Data(data=doc) for doc in results]\n        self.status = data\n        return results\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "keyspace": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "keyspace",
    //                 "value": "default_keyspace",
    //                 "display_name": "Keyspace",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The keyspace name within Astra DB where the data is stored.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 5,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "partition_keys": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "partition_keys",
    //                 "value": {},
    //                 "display_name": "Partition Keys",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Field name and description to the model",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "projection_fields": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "projection_fields",
    //                 "value": "*",
    //                 "display_name": "Projection fields",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Attributes to return separated by comma.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "static_filters": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "static_filters",
    //                 "value": {},
    //                 "display_name": "Static Filters",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Field name and value. When filled, it will not be generated by the LLM.",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "table_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "table_name",
    //                 "value": "",
    //                 "display_name": "Table Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The name of the table within Astra DB where the data is stored.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "token": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "token",
    //                 "value": "ASTRA_DB_APPLICATION_TOKEN",
    //                 "display_name": "Astra DB Application Token",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Authentication token for accessing Astra DB.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "tool_description": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tool_description",
    //                 "value": "",
    //                 "display_name": "Tool Description",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The tool description to be passed to the model.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "tool_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tool_name",
    //                 "value": "",
    //                 "display_name": "Tool Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The name of the tool.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Create a tool to get data from DataStax Astra DB CQL Table",
    //         "icon": "AstraDB",
    //         "base_classes": [
    //             "Data",
    //             "StructuredTool"
    //         ],
    //         "display_name": "Astra DB CQL Tool",
    //         "documentation": "https://astra.datastax.com",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_endpoint",
    //                     "clustering_keys",
    //                     "keyspace",
    //                     "number_of_results",
    //                     "partition_keys",
    //                     "projection_fields",
    //                     "static_filters",
    //                     "table_name",
    //                     "token",
    //                     "tool_description",
    //                     "tool_name"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "StructuredTool"
    //                 ],
    //                 "selected": "StructuredTool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_endpoint",
    //                     "clustering_keys",
    //                     "keyspace",
    //                     "number_of_results",
    //                     "partition_keys",
    //                     "projection_fields",
    //                     "static_filters",
    //                     "table_name",
    //                     "token",
    //                     "tool_description",
    //                     "tool_name"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "tool_name",
    //             "tool_description",
    //             "keyspace",
    //             "table_name",
    //             "token",
    //             "api_endpoint",
    //             "projection_fields",
    //             "partition_keys",
    //             "clustering_keys",
    //             "static_filters",
    //             "number_of_results"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "BingSearchAPI": {
    //         "template": {
    //             "_type": "Component",
    //             "bing_search_url": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "bing_search_url",
    //                 "value": "",
    //                 "display_name": "Bing Search URL",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "bing_subscription_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "bing_subscription_key",
    //                 "value": "",
    //                 "display_name": "Bing Subscription Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import cast\n\nfrom langchain_community.tools.bing_search import BingSearchResults\nfrom langchain_community.utilities import BingSearchAPIWrapper\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import IntInput, MessageTextInput, MultilineInput, SecretStrInput\nfrom langflow.schema import Data\n\n\nclass BingSearchAPIComponent(LCToolComponent):\n    display_name = \"Bing Search API\"\n    description = \"Call the Bing Search API.\"\n    name = \"BingSearchAPI\"\n\n    inputs = [\n        SecretStrInput(name=\"bing_subscription_key\", display_name=\"Bing Subscription Key\"),\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n        ),\n        MessageTextInput(name=\"bing_search_url\", display_name=\"Bing Search URL\", advanced=True),\n        IntInput(name=\"k\", display_name=\"Number of results\", value=4, required=True),\n    ]\n\n    def run_model(self) -> list[Data]:\n        if self.bing_search_url:\n            wrapper = BingSearchAPIWrapper(\n                bing_search_url=self.bing_search_url, bing_subscription_key=self.bing_subscription_key\n            )\n        else:\n            wrapper = BingSearchAPIWrapper(bing_subscription_key=self.bing_subscription_key)\n        results = wrapper.results(query=self.input_value, num_results=self.k)\n        data = [Data(data=result, text=result[\"snippet\"]) for result in results]\n        self.status = data\n        return data\n\n    def build_tool(self) -> Tool:\n        if self.bing_search_url:\n            wrapper = BingSearchAPIWrapper(\n                bing_search_url=self.bing_search_url, bing_subscription_key=self.bing_subscription_key\n            )\n        else:\n            wrapper = BingSearchAPIWrapper(bing_subscription_key=self.bing_subscription_key)\n        return cast(Tool, BingSearchResults(api_wrapper=wrapper, num_results=self.k))\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "k": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "k",
    //                 "value": 4,
    //                 "display_name": "Number of results",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             }
    //         },
    //         "description": "Call the Bing Search API.",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "Bing Search API",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "bing_search_url",
    //                     "bing_subscription_key",
    //                     "input_value",
    //                     "k"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "bing_search_url",
    //                     "bing_subscription_key",
    //                     "input_value",
    //                     "k"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "bing_subscription_key",
    //             "input_value",
    //             "bing_search_url",
    //             "k"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "GoogleSearchAPI": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_core.tools import Tool\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.inputs import IntInput, MultilineInput, SecretStrInput\nfrom langflow.schema import Data\n\n\nclass GoogleSearchAPIComponent(LCToolComponent):\n    display_name = \"Google Search API\"\n    description = \"Call Google Search API.\"\n    name = \"GoogleSearchAPI\"\n\n    inputs = [\n        SecretStrInput(name=\"google_api_key\", display_name=\"Google API Key\", required=True),\n        SecretStrInput(name=\"google_cse_id\", display_name=\"Google CSE ID\", required=True),\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n        ),\n        IntInput(name=\"k\", display_name=\"Number of results\", value=4, required=True),\n    ]\n\n    def run_model(self) -> Data | list[Data]:\n        wrapper = self._build_wrapper()\n        results = wrapper.results(query=self.input_value, num_results=self.k)\n        data = [Data(data=result, text=result[\"snippet\"]) for result in results]\n        self.status = data\n        return data\n\n    def build_tool(self) -> Tool:\n        wrapper = self._build_wrapper()\n        return Tool(\n            name=\"google_search\",\n            description=\"Search Google for recent results.\",\n            func=wrapper.run,\n        )\n\n    def _build_wrapper(self):\n        try:\n            from langchain_google_community import GoogleSearchAPIWrapper\n        except ImportError as e:\n            msg = \"Please install langchain-google-community to use GoogleSearchAPIWrapper.\"\n            raise ImportError(msg) from e\n        return GoogleSearchAPIWrapper(google_api_key=self.google_api_key, google_cse_id=self.google_cse_id, k=self.k)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "google_api_key": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "google_api_key",
    //                 "value": "",
    //                 "display_name": "Google API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "google_cse_id": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "google_cse_id",
    //                 "value": "",
    //                 "display_name": "Google CSE ID",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "k": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "k",
    //                 "value": 4,
    //                 "display_name": "Number of results",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             }
    //         },
    //         "description": "Call Google Search API.",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "Google Search API",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "google_api_key",
    //                     "google_cse_id",
    //                     "input_value",
    //                     "k"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "google_api_key",
    //                     "google_cse_id",
    //                     "input_value",
    //                     "k"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "google_api_key",
    //             "google_cse_id",
    //             "input_value",
    //             "k"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "GoogleSerperAPI": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_community.utilities.google_serper import GoogleSerperAPIWrapper\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import IntInput, MultilineInput, SecretStrInput\nfrom langflow.schema import Data\n\n\nclass GoogleSerperAPIComponent(LCToolComponent):\n    display_name = \"Google Serper API\"\n    description = \"Call the Serper.dev Google Search API.\"\n    name = \"GoogleSerperAPI\"\n\n    inputs = [\n        SecretStrInput(name=\"serper_api_key\", display_name=\"Serper API Key\", required=True),\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n        ),\n        IntInput(name=\"k\", display_name=\"Number of results\", value=4, required=True),\n    ]\n\n    def run_model(self) -> Data | list[Data]:\n        wrapper = self._build_wrapper()\n        results = wrapper.results(query=self.input_value)\n        list_results = results.get(\"organic\", [])\n        data = [Data(data=result, text=result[\"snippet\"]) for result in list_results]\n        self.status = data\n        return data\n\n    def build_tool(self) -> Tool:\n        wrapper = self._build_wrapper()\n        return Tool(\n            name=\"google_search\",\n            description=\"Search Google for recent results.\",\n            func=wrapper.run,\n        )\n\n    def _build_wrapper(self):\n        return GoogleSerperAPIWrapper(serper_api_key=self.serper_api_key, k=self.k)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "k": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "k",
    //                 "value": 4,
    //                 "display_name": "Number of results",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "serper_api_key": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "serper_api_key",
    //                 "value": "",
    //                 "display_name": "Serper API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             }
    //         },
    //         "description": "Call the Serper.dev Google Search API.",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "Google Serper API",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "k",
    //                     "serper_api_key"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "k",
    //                     "serper_api_key"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "serper_api_key",
    //             "input_value",
    //             "k"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "PythonCodeStructuredTool": {
    //         "template": {
    //             "_type": "Component",
    //             "_classes": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "_classes",
    //                 "value": "",
    //                 "display_name": "Classes",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "_functions": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "_functions",
    //                 "value": "",
    //                 "display_name": "Functions",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import ast\nimport json\nfrom typing import Any\n\nfrom langchain.agents import Tool\nfrom langchain_core.tools import StructuredTool\nfrom loguru import logger\nfrom pydantic.v1 import Field, create_model\nfrom pydantic.v1.fields import Undefined\nfrom typing_extensions import override\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.inputs.inputs import BoolInput, DropdownInput, FieldTypes, HandleInput, MessageTextInput, MultilineInput\nfrom langflow.io import Output\nfrom langflow.schema import Data\nfrom langflow.schema.dotdict import dotdict\n\n\nclass PythonCodeStructuredTool(LCToolComponent):\n    DEFAULT_KEYS = [\n        \"code\",\n        \"_type\",\n        \"text_key\",\n        \"tool_code\",\n        \"tool_name\",\n        \"tool_description\",\n        \"return_direct\",\n        \"tool_function\",\n        \"global_variables\",\n        \"_classes\",\n        \"_functions\",\n    ]\n    display_name = \"Python Code Structured Tool\"\n    description = \"structuredtool dataclass code to tool\"\n    documentation = \"https://python.langchain.com/docs/modules/tools/custom_tools/#structuredtool-dataclass\"\n    name = \"PythonCodeStructuredTool\"\n    icon = \"\"\n    field_order = [\"name\", \"description\", \"tool_code\", \"return_direct\", \"tool_function\"]\n\n    inputs = [\n        MultilineInput(\n            name=\"tool_code\",\n            display_name=\"Tool Code\",\n            info=\"Enter the dataclass code.\",\n            placeholder=\"def my_function(args):\\n    pass\",\n            required=True,\n            real_time_refresh=True,\n            refresh_button=True,\n        ),\n        MessageTextInput(name=\"tool_name\", display_name=\"Tool Name\", info=\"Enter the name of the tool.\", required=True),\n        MessageTextInput(\n            name=\"tool_description\",\n            display_name=\"Description\",\n            info=\"Enter the description of the tool.\",\n            required=True,\n        ),\n        BoolInput(\n            name=\"return_direct\",\n            display_name=\"Return Directly\",\n            info=\"Should the tool return the function output directly?\",\n        ),\n        DropdownInput(\n            name=\"tool_function\",\n            display_name=\"Tool Function\",\n            info=\"Select the function for additional expressions.\",\n            options=[],\n            required=True,\n            real_time_refresh=True,\n            refresh_button=True,\n        ),\n        HandleInput(\n            name=\"global_variables\",\n            display_name=\"Global Variables\",\n            info=\"Enter the global variables or Create Data Component.\",\n            input_types=[\"Data\"],\n            field_type=FieldTypes.DICT,\n            is_list=True,\n        ),\n        MessageTextInput(name=\"_classes\", display_name=\"Classes\", advanced=True),\n        MessageTextInput(name=\"_functions\", display_name=\"Functions\", advanced=True),\n    ]\n\n    outputs = [\n        Output(display_name=\"Tool\", name=\"result_tool\", method=\"build_tool\"),\n    ]\n\n    @override\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None) -> dotdict:\n        if field_name is None:\n            return build_config\n\n        if field_name not in {\"tool_code\", \"tool_function\"}:\n            return build_config\n\n        try:\n            named_functions = {}\n            [classes, functions] = self._parse_code(build_config[\"tool_code\"][\"value\"])\n            existing_fields = {}\n            if len(build_config) > len(self.DEFAULT_KEYS):\n                for key in build_config.copy():\n                    if key not in self.DEFAULT_KEYS:\n                        existing_fields[key] = build_config.pop(key)\n\n            names = []\n            for func in functions:\n                named_functions[func[\"name\"]] = func\n                names.append(func[\"name\"])\n\n                for arg in func[\"args\"]:\n                    field_name = f\"{func['name']}|{arg['name']}\"\n                    if field_name in existing_fields:\n                        build_config[field_name] = existing_fields[field_name]\n                        continue\n\n                    field = MessageTextInput(\n                        display_name=f\"{arg['name']}: Description\",\n                        name=field_name,\n                        info=f\"Enter the description for {arg['name']}\",\n                        required=True,\n                    )\n                    build_config[field_name] = field.to_dict()\n            build_config[\"_functions\"][\"value\"] = json.dumps(named_functions)\n            build_config[\"_classes\"][\"value\"] = json.dumps(classes)\n            build_config[\"tool_function\"][\"options\"] = names\n        except Exception as e:  # noqa: BLE001\n            self.status = f\"Failed to extract names: {e}\"\n            logger.opt(exception=True).debug(self.status)\n            build_config[\"tool_function\"][\"options\"] = [\"Failed to parse\", str(e)]\n        return build_config\n\n    async def build_tool(self) -> Tool:\n        _local_namespace = {}  # type: ignore[var-annotated]\n        modules = self._find_imports(self.tool_code)\n        import_code = \"\"\n        for module in modules[\"imports\"]:\n            import_code += f\"global {module}\\nimport {module}\\n\"\n        for from_module in modules[\"from_imports\"]:\n            for alias in from_module.names:\n                import_code += f\"global {alias.name}\\n\"\n            import_code += (\n                f\"from {from_module.module} import {', '.join([alias.name for alias in from_module.names])}\\n\"\n            )\n        exec(import_code, globals())\n        exec(self.tool_code, globals(), _local_namespace)\n\n        class PythonCodeToolFunc:\n            params: dict = {}\n\n            def run(**kwargs):\n                for key, arg in kwargs.items():\n                    if key not in PythonCodeToolFunc.params:\n                        PythonCodeToolFunc.params[key] = arg\n                return _local_namespace[self.tool_function](**PythonCodeToolFunc.params)\n\n        _globals = globals()\n        _local = {}\n        _local[self.tool_function] = PythonCodeToolFunc\n        _globals.update(_local)\n\n        if isinstance(self.global_variables, list):\n            for data in self.global_variables:\n                if isinstance(data, Data):\n                    _globals.update(data.data)\n        elif isinstance(self.global_variables, dict):\n            _globals.update(self.global_variables)\n\n        classes = json.loads(self._attributes[\"_classes\"])\n        for class_dict in classes:\n            exec(\"\\n\".join(class_dict[\"code\"]), _globals)\n\n        named_functions = json.loads(self._attributes[\"_functions\"])\n        schema_fields = {}\n\n        for attr in self._attributes:\n            if attr in self.DEFAULT_KEYS:\n                continue\n\n            func_name = attr.split(\"|\")[0]\n            field_name = attr.split(\"|\")[1]\n            func_arg = self._find_arg(named_functions, func_name, field_name)\n            if func_arg is None:\n                msg = f\"Failed to find arg: {field_name}\"\n                raise ValueError(msg)\n\n            field_annotation = func_arg[\"annotation\"]\n            field_description = self._get_value(self._attributes[attr], str)\n\n            if field_annotation:\n                exec(f\"temp_annotation_type = {field_annotation}\", _globals)\n                schema_annotation = _globals[\"temp_annotation_type\"]\n            else:\n                schema_annotation = Any\n            schema_fields[field_name] = (\n                schema_annotation,\n                Field(default=func_arg.get(\"default\", Undefined), description=field_description),\n            )\n\n        if \"temp_annotation_type\" in _globals:\n            _globals.pop(\"temp_annotation_type\")\n\n        python_code_tool_schema = None\n        if schema_fields:\n            python_code_tool_schema = create_model(\"PythonCodeToolSchema\", **schema_fields)\n\n        return StructuredTool.from_function(\n            func=_local[self.tool_function].run,\n            args_schema=python_code_tool_schema,\n            name=self.tool_name,\n            description=self.tool_description,\n            return_direct=self.return_direct,\n        )\n\n    def post_code_processing(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = super().post_code_processing(new_frontend_node, current_frontend_node)\n        frontend_node[\"template\"] = self.update_build_config(\n            frontend_node[\"template\"], frontend_node[\"template\"][\"tool_code\"][\"value\"], \"tool_code\"\n        )\n        frontend_node = super().post_code_processing(new_frontend_node, current_frontend_node)\n        for key in frontend_node[\"template\"]:\n            if key in self.DEFAULT_KEYS:\n                continue\n            frontend_node[\"template\"] = self.update_build_config(\n                frontend_node[\"template\"], frontend_node[\"template\"][key][\"value\"], key\n            )\n            frontend_node = super().post_code_processing(new_frontend_node, current_frontend_node)\n        return frontend_node\n\n    def _parse_code(self, code: str) -> tuple[list[dict], list[dict]]:\n        parsed_code = ast.parse(code)\n        lines = code.split(\"\\n\")\n        classes = []\n        functions = []\n        for node in parsed_code.body:\n            if isinstance(node, ast.ClassDef):\n                class_lines = lines[node.lineno - 1 : node.end_lineno]\n                class_lines[-1] = class_lines[-1][: node.end_col_offset]\n                class_lines[0] = class_lines[0][node.col_offset :]\n                classes.append(\n                    {\n                        \"name\": node.name,\n                        \"code\": class_lines,\n                    }\n                )\n                continue\n\n            if not isinstance(node, ast.FunctionDef):\n                continue\n\n            func = {\"name\": node.name, \"args\": []}\n            for arg in node.args.args:\n                if arg.lineno != arg.end_lineno:\n                    msg = \"Multiline arguments are not supported\"\n                    raise ValueError(msg)\n\n                func_arg = {\n                    \"name\": arg.arg,\n                    \"annotation\": None,\n                }\n\n                for default in node.args.defaults:\n                    if (\n                        arg.lineno > default.lineno\n                        or arg.col_offset > default.col_offset\n                        or (\n                            arg.end_lineno is not None\n                            and default.end_lineno is not None\n                            and arg.end_lineno < default.end_lineno\n                        )\n                        or (\n                            arg.end_col_offset is not None\n                            and default.end_col_offset is not None\n                            and arg.end_col_offset < default.end_col_offset\n                        )\n                    ):\n                        continue\n\n                    if isinstance(default, ast.Name):\n                        func_arg[\"default\"] = default.id\n                    elif isinstance(default, ast.Constant):\n                        func_arg[\"default\"] = default.value\n\n                if arg.annotation:\n                    annotation_line = lines[arg.annotation.lineno - 1]\n                    annotation_line = annotation_line[: arg.annotation.end_col_offset]\n                    annotation_line = annotation_line[arg.annotation.col_offset :]\n                    func_arg[\"annotation\"] = annotation_line\n                    if isinstance(func_arg[\"annotation\"], str) and func_arg[\"annotation\"].count(\"=\") > 0:\n                        func_arg[\"annotation\"] = \"=\".join(func_arg[\"annotation\"].split(\"=\")[:-1]).strip()\n                if isinstance(func[\"args\"], list):\n                    func[\"args\"].append(func_arg)\n            functions.append(func)\n\n        return classes, functions\n\n    def _find_imports(self, code: str) -> dotdict:\n        imports: list[str] = []\n        from_imports = []\n        parsed_code = ast.parse(code)\n        for node in parsed_code.body:\n            if isinstance(node, ast.Import):\n                imports.extend(alias.name for alias in node.names)\n            elif isinstance(node, ast.ImportFrom):\n                from_imports.append(node)\n        return dotdict({\"imports\": imports, \"from_imports\": from_imports})\n\n    def _get_value(self, value: Any, annotation: Any) -> Any:\n        return value if isinstance(value, annotation) else value[\"value\"]\n\n    def _find_arg(self, named_functions: dict, func_name: str, arg_name: str) -> dict | None:\n        for arg in named_functions[func_name][\"args\"]:\n            if arg[\"name\"] == arg_name:\n                return arg\n        return None\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "global_variables": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "global_variables",
    //                 "value": "",
    //                 "display_name": "Global Variables",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Enter the global variables or Create Data Component.",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "HandleInput"
    //             },
    //             "return_direct": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "return_direct",
    //                 "value": false,
    //                 "display_name": "Return Directly",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Should the tool return the function output directly?",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "tool_code": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "def my_function(args):\n    pass",
    //                 "show": true,
    //                 "name": "tool_code",
    //                 "value": "",
    //                 "display_name": "Tool Code",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Enter the dataclass code.",
    //                 "real_time_refresh": true,
    //                 "refresh_button": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "tool_description": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tool_description",
    //                 "value": "",
    //                 "display_name": "Description",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Enter the description of the tool.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "tool_function": {
    //                 "trace_as_metadata": true,
    //                 "options": [],
    //                 "combobox": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tool_function",
    //                 "value": "",
    //                 "display_name": "Tool Function",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Select the function for additional expressions.",
    //                 "real_time_refresh": true,
    //                 "refresh_button": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "tool_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tool_name",
    //                 "value": "",
    //                 "display_name": "Tool Name",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Enter the name of the tool.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "structuredtool dataclass code to tool",
    //         "icon": "",
    //         "base_classes": [
    //             "Tool"
    //         ],
    //         "display_name": "Python Code Structured Tool",
    //         "documentation": "https://python.langchain.com/docs/modules/tools/custom_tools/#structuredtool-dataclass",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "result_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "tool_code",
    //             "tool_name",
    //             "tool_description",
    //             "return_direct",
    //             "tool_function",
    //             "global_variables",
    //             "_classes",
    //             "_functions"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "WikipediaAPI": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import cast\n\nfrom langchain_community.tools import WikipediaQueryRun\nfrom langchain_community.utilities.wikipedia import WikipediaAPIWrapper\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import BoolInput, IntInput, MessageTextInput, MultilineInput\nfrom langflow.schema import Data\n\n\nclass WikipediaAPIComponent(LCToolComponent):\n    display_name = \"Wikipedia API\"\n    description = \"Call Wikipedia API.\"\n    name = \"WikipediaAPI\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n        ),\n        MessageTextInput(name=\"lang\", display_name=\"Language\", value=\"en\"),\n        IntInput(name=\"k\", display_name=\"Number of results\", value=4, required=True),\n        BoolInput(name=\"load_all_available_meta\", display_name=\"Load all available meta\", value=False, advanced=True),\n        IntInput(\n            name=\"doc_content_chars_max\", display_name=\"Document content characters max\", value=4000, advanced=True\n        ),\n    ]\n\n    def run_model(self) -> list[Data]:\n        wrapper = self._build_wrapper()\n        docs = wrapper.load(self.input_value)\n        data = [Data.from_document(doc) for doc in docs]\n        self.status = data\n        return data\n\n    def build_tool(self) -> Tool:\n        wrapper = self._build_wrapper()\n        return cast(Tool, WikipediaQueryRun(api_wrapper=wrapper))\n\n    def _build_wrapper(self) -> WikipediaAPIWrapper:\n        return WikipediaAPIWrapper(\n            top_k_results=self.k,\n            lang=self.lang,\n            load_all_available_meta=self.load_all_available_meta,\n            doc_content_chars_max=self.doc_content_chars_max,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "doc_content_chars_max": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "doc_content_chars_max",
    //                 "value": 4000,
    //                 "display_name": "Document content characters max",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "k": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "k",
    //                 "value": 4,
    //                 "display_name": "Number of results",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "lang": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "lang",
    //                 "value": "en",
    //                 "display_name": "Language",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "load_all_available_meta": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "load_all_available_meta",
    //                 "value": false,
    //                 "display_name": "Load all available meta",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Call Wikipedia API.",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "Wikipedia API",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "doc_content_chars_max",
    //                     "input_value",
    //                     "k",
    //                     "lang",
    //                     "load_all_available_meta"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "doc_content_chars_max",
    //                     "input_value",
    //                     "k",
    //                     "lang",
    //                     "load_all_available_meta"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "lang",
    //             "k",
    //             "load_all_available_meta",
    //             "doc_content_chars_max"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AstraDBToolComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "api_endpoint": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_endpoint",
    //                 "value": "ASTRA_DB_API_ENDPOINT",
    //                 "display_name": "API Endpoint",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "API endpoint URL for the Astra DB service.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom astrapy import Collection, DataAPIClient, Database\nfrom langchain.pydantic_v1 import BaseModel, Field, create_model\nfrom langchain_core.tools import StructuredTool\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.io import DictInput, IntInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass AstraDBToolComponent(LCToolComponent):\n    display_name: str = \"Astra DB Tool\"\n    description: str = \"Create a tool to get data from DataStax Astra DB Collection\"\n    documentation: str = \"https://astra.datastax.com\"\n    icon: str = \"AstraDB\"\n\n    inputs = [\n        StrInput(\n            name=\"tool_name\",\n            display_name=\"Tool Name\",\n            info=\"The name of the tool.\",\n            required=True,\n        ),\n        StrInput(\n            name=\"tool_description\",\n            display_name=\"Tool Description\",\n            info=\"The description of the tool.\",\n            required=True,\n        ),\n        StrInput(\n            name=\"namespace\",\n            display_name=\"Namespace Name\",\n            info=\"The name of the namespace within Astra where the collection is be stored.\",\n            value=\"default_keyspace\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"collection_name\",\n            display_name=\"Collection Name\",\n            info=\"The name of the collection within Astra DB where the vectors will be stored.\",\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"token\",\n            display_name=\"Astra DB Application Token\",\n            info=\"Authentication token for accessing Astra DB.\",\n            value=\"ASTRA_DB_APPLICATION_TOKEN\",\n            required=True,\n        ),\n        StrInput(\n            name=\"api_endpoint\",\n            display_name=\"API Endpoint\",\n            info=\"API endpoint URL for the Astra DB service.\",\n            value=\"ASTRA_DB_API_ENDPOINT\",\n            required=True,\n        ),\n        StrInput(\n            name=\"projection_attributes\",\n            display_name=\"Projection Attributes\",\n            info=\"Attributes to return separated by comma.\",\n            required=True,\n            value=\"*\",\n            advanced=True,\n        ),\n        DictInput(\n            name=\"tool_params\",\n            info=\"Attributes to filter and description to the model. Add ! for mandatory (e.g: !customerId)\",\n            display_name=\"Tool params\",\n            is_list=True,\n        ),\n        DictInput(\n            name=\"static_filters\",\n            info=\"Attributes to filter and correspoding value\",\n            display_name=\"Static filters\",\n            is_list=True,\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            advanced=True,\n            value=5,\n        ),\n    ]\n\n    _cached_client: DataAPIClient | None = None\n    _cached_db: Database | None = None\n    _cached_collection: Collection | None = None\n\n    def _build_collection(self):\n        if self._cached_collection:\n            return self._cached_collection\n\n        _cached_client = DataAPIClient(self.token)\n        _cached_db = _cached_client.get_database(self.api_endpoint, namespace=self.namespace)\n        self._cached_collection = _cached_db.get_collection(self.collection_name)\n        return self._cached_collection\n\n    def create_args_schema(self) -> dict[str, BaseModel]:\n        args: dict[str, tuple[Any, Field] | list[str]] = {}\n\n        for key in self.tool_params:\n            if key.startswith(\"!\"):  # Mandatory\n                args[key[1:]] = (str, Field(description=self.tool_params[key]))\n            else:  # Optional\n                args[key] = (str | None, Field(description=self.tool_params[key], default=None))\n\n        model = create_model(\"ToolInput\", **args, __base__=BaseModel)\n        return {\"ToolInput\": model}\n\n    def build_tool(self) -> StructuredTool:\n        \"\"\"Builds an Astra DB Collection tool.\n\n        Returns:\n            Tool: The built Astra DB tool.\n        \"\"\"\n        schema_dict = self.create_args_schema()\n\n        tool = StructuredTool.from_function(\n            name=self.tool_name,\n            args_schema=schema_dict[\"ToolInput\"],\n            description=self.tool_description,\n            func=self.run_model,\n            return_direct=False,\n        )\n        self.status = \"Astra DB Tool created\"\n\n        return tool\n\n    def projection_args(self, input_str: str) -> dict:\n        elements = input_str.split(\",\")\n        result = {}\n\n        for element in elements:\n            if element.startswith(\"!\"):\n                result[element[1:]] = False\n            else:\n                result[element] = True\n\n        return result\n\n    def run_model(self, **args) -> Data | list[Data]:\n        collection = self._build_collection()\n        results = collection.find(\n            ({**args, **self.static_filters}),\n            projection=self.projection_args(self.projection_attributes),\n            limit=self.number_of_results,\n        )\n\n        data: list[Data] = [Data(data=doc) for doc in results]\n        self.status = data\n        return data\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "collection_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "collection_name",
    //                 "value": "",
    //                 "display_name": "Collection Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The name of the collection within Astra DB where the vectors will be stored.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "namespace": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "namespace",
    //                 "value": "default_keyspace",
    //                 "display_name": "Namespace Name",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The name of the namespace within Astra where the collection is be stored.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 5,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "projection_attributes": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "projection_attributes",
    //                 "value": "*",
    //                 "display_name": "Projection Attributes",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Attributes to return separated by comma.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "static_filters": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "static_filters",
    //                 "value": {},
    //                 "display_name": "Static filters",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Attributes to filter and correspoding value",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "token": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "token",
    //                 "value": "ASTRA_DB_APPLICATION_TOKEN",
    //                 "display_name": "Astra DB Application Token",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Authentication token for accessing Astra DB.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "tool_description": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tool_description",
    //                 "value": "",
    //                 "display_name": "Tool Description",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The description of the tool.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "tool_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tool_name",
    //                 "value": "",
    //                 "display_name": "Tool Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The name of the tool.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "tool_params": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tool_params",
    //                 "value": {},
    //                 "display_name": "Tool params",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Attributes to filter and description to the model. Add ! for mandatory (e.g: !customerId)",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             }
    //         },
    //         "description": "Create a tool to get data from DataStax Astra DB Collection",
    //         "icon": "AstraDB",
    //         "base_classes": [
    //             "Data",
    //             "StructuredTool"
    //         ],
    //         "display_name": "Astra DB Tool",
    //         "documentation": "https://astra.datastax.com",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_endpoint",
    //                     "collection_name",
    //                     "namespace",
    //                     "number_of_results",
    //                     "projection_attributes",
    //                     "static_filters",
    //                     "token",
    //                     "tool_description",
    //                     "tool_name",
    //                     "tool_params"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "StructuredTool"
    //                 ],
    //                 "selected": "StructuredTool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_endpoint",
    //                     "collection_name",
    //                     "namespace",
    //                     "number_of_results",
    //                     "projection_attributes",
    //                     "static_filters",
    //                     "token",
    //                     "tool_description",
    //                     "tool_name",
    //                     "tool_params"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "tool_name",
    //             "tool_description",
    //             "namespace",
    //             "collection_name",
    //             "token",
    //             "api_endpoint",
    //             "projection_attributes",
    //             "tool_params",
    //             "static_filters",
    //             "number_of_results"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "RetrieverTool": {
    //         "template": {
    //             "_type": "CustomComponent",
    //             "retriever": {
    //                 "type": "BaseRetriever",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "retriever",
    //                 "display_name": "Retriever",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Retriever"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Retriever to interact with",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_core.tools import create_retriever_tool\n\nfrom langflow.custom import CustomComponent\nfrom langflow.field_typing import BaseRetriever, Tool\n\n\nclass RetrieverToolComponent(CustomComponent):\n    display_name = \"RetrieverTool\"\n    description = \"Tool for interacting with retriever\"\n    name = \"RetrieverTool\"\n\n    def build_config(self):\n        return {\n            \"retriever\": {\n                \"display_name\": \"Retriever\",\n                \"info\": \"Retriever to interact with\",\n                \"type\": BaseRetriever,\n                \"input_types\": [\"Retriever\"],\n            },\n            \"name\": {\"display_name\": \"Name\", \"info\": \"Name of the tool\"},\n            \"description\": {\"display_name\": \"Description\", \"info\": \"Description of the tool\"},\n        }\n\n    def build(\n        self,\n        retriever: BaseRetriever,\n        name: str,\n        description: str,\n    ) -> Tool:\n        return create_retriever_tool(\n            retriever=retriever,\n            name=name,\n            description=description,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "description": {
    //                 "type": "str",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "description",
    //                 "display_name": "Description",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Description of the tool",
    //                 "load_from_db": false,
    //                 "title_case": false,
    //                 "input_types": [
    //                     "Text"
    //                 ]
    //             },
    //             "name": {
    //                 "type": "str",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "name",
    //                 "display_name": "Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Name of the tool",
    //                 "load_from_db": false,
    //                 "title_case": false,
    //                 "input_types": [
    //                     "Text"
    //                 ]
    //             }
    //         },
    //         "description": "Tool for interacting with retriever",
    //         "base_classes": [
    //             "BaseTool",
    //             "Generic",
    //             "object",
    //             "Runnable",
    //             "RunnableSerializable",
    //             "RunnableSerializable[Union[str, dict, ToolCall], Any]",
    //             "Serializable",
    //             "Tool"
    //         ],
    //         "display_name": "RetrieverTool",
    //         "documentation": "",
    //         "custom_fields": {
    //             "retriever": null,
    //             "name": null,
    //             "description": null
    //         },
    //         "output_types": [
    //             "Tool"
    //         ],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "tool",
    //                 "hidden": null,
    //                 "display_name": "Tool",
    //                 "method": null,
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": null
    //             }
    //         ],
    //         "field_order": [],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "SearXNGTool": {
    //         "template": {
    //             "_type": "Component",
    //             "categories": {
    //                 "trace_as_metadata": true,
    //                 "options": [],
    //                 "combobox": false,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "categories",
    //                 "value": [],
    //                 "display_name": "Categories",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultiselectInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import json\nfrom collections.abc import Sequence\nfrom typing import Any\n\nimport requests\nfrom langchain.agents import Tool\nfrom langchain_core.tools import StructuredTool\nfrom loguru import logger\nfrom pydantic.v1 import Field, create_model\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.inputs import DropdownInput, IntInput, MessageTextInput, MultiselectInput\nfrom langflow.io import Output\nfrom langflow.schema.dotdict import dotdict\n\n\nclass SearXNGToolComponent(LCToolComponent):\n    search_headers: dict = {}\n    display_name = \"SearXNG Search Tool\"\n    description = \"A component that searches for tools using SearXNG.\"\n    name = \"SearXNGTool\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"url\",\n            display_name=\"URL\",\n            value=\"http://localhost\",\n            required=True,\n            refresh_button=True,\n        ),\n        IntInput(\n            name=\"max_results\",\n            display_name=\"Max Results\",\n            value=10,\n            required=True,\n        ),\n        MultiselectInput(\n            name=\"categories\",\n            display_name=\"Categories\",\n            options=[],\n            value=[],\n        ),\n        DropdownInput(\n            name=\"language\",\n            display_name=\"Language\",\n            options=[],\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Tool\", name=\"result_tool\", method=\"build_tool\"),\n    ]\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None) -> dotdict:\n        if field_name is None:\n            return build_config\n\n        if field_name != \"url\":\n            return build_config\n\n        try:\n            url = f\"{field_value}/config\"\n\n            response = requests.get(url=url, headers=self.search_headers.copy(), timeout=10)\n            data = None\n            if response.headers.get(\"Content-Encoding\") == \"zstd\":\n                data = json.loads(response.content)\n            else:\n                data = response.json()\n            build_config[\"categories\"][\"options\"] = data[\"categories\"].copy()\n            for selected_category in build_config[\"categories\"][\"value\"]:\n                if selected_category not in build_config[\"categories\"][\"options\"]:\n                    build_config[\"categories\"][\"value\"].remove(selected_category)\n            languages = list(data[\"locales\"])\n            build_config[\"language\"][\"options\"] = languages.copy()\n        except Exception as e:  # noqa: BLE001\n            self.status = f\"Failed to extract names: {e}\"\n            logger.opt(exception=True).debug(self.status)\n            build_config[\"categories\"][\"options\"] = [\"Failed to parse\", str(e)]\n        return build_config\n\n    def build_tool(self) -> Tool:\n        class SearxSearch:\n            _url: str = \"\"\n            _categories: list[str] = []\n            _language: str = \"\"\n            _headers: dict = {}\n            _max_results: int = 10\n\n            @staticmethod\n            def search(query: str, categories: Sequence[str] = ()) -> list:\n                if not SearxSearch._categories and not categories:\n                    msg = \"No categories provided.\"\n                    raise ValueError(msg)\n                all_categories = SearxSearch._categories + list(set(categories) - set(SearxSearch._categories))\n                try:\n                    url = f\"{SearxSearch._url}/\"\n                    headers = SearxSearch._headers.copy()\n                    response = requests.get(\n                        url=url,\n                        headers=headers,\n                        params={\n                            \"q\": query,\n                            \"categories\": \",\".join(all_categories),\n                            \"language\": SearxSearch._language,\n                            \"format\": \"json\",\n                        },\n                        timeout=10,\n                    ).json()\n\n                    num_results = min(SearxSearch._max_results, len(response[\"results\"]))\n                    return [response[\"results\"][i] for i in range(num_results)]\n                except Exception as e:  # noqa: BLE001\n                    logger.opt(exception=True).debug(\"Error running SearXNG Search\")\n                    return [f\"Failed to search: {e}\"]\n\n        SearxSearch._url = self.url\n        SearxSearch._categories = self.categories.copy()\n        SearxSearch._language = self.language\n        SearxSearch._headers = self.search_headers.copy()\n        SearxSearch._max_results = self.max_results\n\n        _globals = globals()\n        _local = {}\n        _local[\"SearxSearch\"] = SearxSearch\n        _globals.update(_local)\n\n        schema_fields = {\n            \"query\": (str, Field(..., description=\"The query to search for.\")),\n            \"categories\": (list[str], Field(default=[], description=\"The categories to search in.\")),\n        }\n\n        searx_search_schema = create_model(\"SearxSearchSchema\", **schema_fields)\n\n        return StructuredTool.from_function(\n            func=_local[\"SearxSearch\"].search,\n            args_schema=searx_search_schema,\n            name=\"searxng_search_tool\",\n            description=\"A tool that searches for tools using SearXNG.\\nThe available categories are: \"\n            + \", \".join(self.categories),\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "language": {
    //                 "trace_as_metadata": true,
    //                 "options": [],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "language",
    //                 "value": "",
    //                 "display_name": "Language",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "max_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_results",
    //                 "value": 10,
    //                 "display_name": "Max Results",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "url": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "url",
    //                 "value": "http://localhost",
    //                 "display_name": "URL",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "refresh_button": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "A component that searches for tools using SearXNG.",
    //         "base_classes": [
    //             "Tool"
    //         ],
    //         "display_name": "SearXNG Search Tool",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "result_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "url",
    //             "max_results",
    //             "categories",
    //             "language"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "WolframAlphaAPI": {
    //         "template": {
    //             "_type": "Component",
    //             "app_id": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "app_id",
    //                 "value": "",
    //                 "display_name": "App ID",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_community.utilities.wolfram_alpha import WolframAlphaAPIWrapper\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import MultilineInput, SecretStrInput\nfrom langflow.schema import Data\n\n\nclass WolframAlphaAPIComponent(LCToolComponent):\n    display_name = \"WolframAlphaAPI\"\n    description = \"Call Wolfram Alpha API.\"\n    name = \"WolframAlphaAPI\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n        ),\n        SecretStrInput(name=\"app_id\", display_name=\"App ID\", required=True),\n    ]\n\n    def run_model(self) -> list[Data]:\n        wrapper = self._build_wrapper()\n        result_str = wrapper.run(self.input_value)\n        data = [Data(text=result_str)]\n        self.status = data\n        return data\n\n    def build_tool(self) -> Tool:\n        wrapper = self._build_wrapper()\n        return Tool(name=\"wolfram_alpha_api\", description=\"Answers mathematical questions.\", func=wrapper.run)\n\n    def _build_wrapper(self) -> WolframAlphaAPIWrapper:\n        return WolframAlphaAPIWrapper(wolfram_alpha_appid=self.app_id)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Call Wolfram Alpha API.",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "WolframAlphaAPI",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "app_id",
    //                     "input_value"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "app_id",
    //                     "input_value"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "app_id"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "TavilyAISearch": {
    //         "template": {
    //             "_type": "Component",
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "Tavily API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Your Tavily API Key.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nimport httpx\nfrom langchain.tools import StructuredTool\nfrom loguru import logger\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import BoolInput, DropdownInput, IntInput, MessageTextInput, SecretStrInput\nfrom langflow.schema import Data\n\n\nclass TavilySearchToolComponent(LCToolComponent):\n    display_name = \"Tavily AI Search\"\n    description = \"\"\"**Tavily AI** is a search engine optimized for LLMs and RAG, \\\n        aimed at efficient, quick, and persistent search results. It can be used independently or as an agent tool.\n\nNote: Check 'Advanced' for all options.\n\"\"\"\n    icon = \"TavilyIcon\"\n    name = \"TavilyAISearch\"\n    documentation = \"https://docs.tavily.com/\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Tavily API Key\",\n            required=True,\n            info=\"Your Tavily API Key.\",\n        ),\n        MessageTextInput(\n            name=\"query\",\n            display_name=\"Search Query\",\n            info=\"The search query you want to execute with Tavily.\",\n        ),\n        DropdownInput(\n            name=\"search_depth\",\n            display_name=\"Search Depth\",\n            info=\"The depth of the search.\",\n            options=[\"basic\", \"advanced\"],\n            value=\"advanced\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"topic\",\n            display_name=\"Search Topic\",\n            info=\"The category of the search.\",\n            options=[\"general\", \"news\"],\n            value=\"general\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"max_results\",\n            display_name=\"Max Results\",\n            info=\"The maximum number of search results to return.\",\n            value=5,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"include_images\",\n            display_name=\"Include Images\",\n            info=\"Include a list of query-related images in the response.\",\n            value=True,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"include_answer\",\n            display_name=\"Include Answer\",\n            info=\"Include a short answer to original query.\",\n            value=True,\n            advanced=True,\n        ),\n    ]\n\n    class TavilySearchSchema(BaseModel):\n        query: str = Field(..., description=\"The search query you want to execute with Tavily.\")\n        search_depth: str = Field(\"basic\", description=\"The depth of the search.\")\n        topic: str = Field(\"general\", description=\"The category of the search.\")\n        max_results: int = Field(5, description=\"The maximum number of search results to return.\")\n        include_images: bool = Field(\n            default=False, description=\"Include a list of query-related images in the response.\"\n        )\n        include_answer: bool = Field(default=False, description=\"Include a short answer to original query.\")\n\n    def run_model(self) -> list[Data]:\n        return self._tavily_search(\n            self.query,\n            search_depth=self.search_depth,\n            topic=self.topic,\n            max_results=self.max_results,\n            include_images=self.include_images,\n            include_answer=self.include_answer,\n        )\n\n    def build_tool(self) -> Tool:\n        return StructuredTool.from_function(\n            name=\"tavily_search\",\n            description=\"Perform a web search using the Tavily API.\",\n            func=self._tavily_search,\n            args_schema=self.TavilySearchSchema,\n        )\n\n    def _tavily_search(\n        self,\n        query: str,\n        *,\n        search_depth: str = \"basic\",\n        topic: str = \"general\",\n        max_results: int = 5,\n        include_images: bool = False,\n        include_answer: bool = False,\n    ) -> list[Data]:\n        try:\n            url = \"https://api.tavily.com/search\"\n            headers = {\n                \"content-type\": \"application/json\",\n                \"accept\": \"application/json\",\n            }\n            payload = {\n                \"api_key\": self.api_key,\n                \"query\": query,\n                \"search_depth\": search_depth,\n                \"topic\": topic,\n                \"max_results\": max_results,\n                \"include_images\": include_images,\n                \"include_answer\": include_answer,\n            }\n\n            with httpx.Client() as client:\n                response = client.post(url, json=payload, headers=headers)\n\n            response.raise_for_status()\n            search_results = response.json()\n\n            data_results = [\n                Data(\n                    data={\n                        \"title\": result.get(\"title\"),\n                        \"url\": result.get(\"url\"),\n                        \"content\": result.get(\"content\"),\n                        \"score\": result.get(\"score\"),\n                    }\n                )\n                for result in search_results.get(\"results\", [])\n            ]\n\n            if include_answer and search_results.get(\"answer\"):\n                data_results.insert(0, Data(data={\"answer\": search_results[\"answer\"]}))\n\n            if include_images and search_results.get(\"images\"):\n                data_results.append(Data(data={\"images\": search_results[\"images\"]}))\n\n        except httpx.HTTPStatusError as e:\n            error_message = f\"HTTP error: {e.response.status_code} - {e.response.text}\"\n            self.status = error_message\n            return [Data(data={\"error\": error_message})]\n        except Exception as e:  # noqa: BLE001\n            logger.opt(exception=True).debug(\"Error running Tavily Search\")\n            error_message = f\"Unexpected error: {e}\"\n            self.status = error_message\n            return [Data(data={\"error\": error_message})]\n\n        self.status: Any = data_results\n        return data_results\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "include_answer": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "include_answer",
    //                 "value": true,
    //                 "display_name": "Include Answer",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Include a short answer to original query.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "include_images": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "include_images",
    //                 "value": true,
    //                 "display_name": "Include Images",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Include a list of query-related images in the response.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "max_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_results",
    //                 "value": 5,
    //                 "display_name": "Max Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The maximum number of search results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "query": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "query",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The search query you want to execute with Tavily.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "search_depth": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "basic",
    //                     "advanced"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_depth",
    //                 "value": "advanced",
    //                 "display_name": "Search Depth",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The depth of the search.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "topic": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "general",
    //                     "news"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "topic",
    //                 "value": "general",
    //                 "display_name": "Search Topic",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The category of the search.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             }
    //         },
    //         "description": "**Tavily AI** is a search engine optimized for LLMs and RAG,         aimed at efficient, quick, and persistent search results. It can be used independently or as an agent tool.\n\nNote: Check 'Advanced' for all options.\n",
    //         "icon": "TavilyIcon",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "Tavily AI Search",
    //         "documentation": "https://docs.tavily.com/",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_key",
    //                     "include_answer",
    //                     "include_images",
    //                     "max_results",
    //                     "query",
    //                     "search_depth",
    //                     "topic"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_key",
    //                     "include_answer",
    //                     "include_images",
    //                     "max_results",
    //                     "query",
    //                     "search_depth",
    //                     "topic"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "api_key",
    //             "query",
    //             "search_depth",
    //             "topic",
    //             "max_results",
    //             "include_images",
    //             "include_answer"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "CalculatorTool": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import ast\nimport operator\n\nfrom langchain.tools import StructuredTool\nfrom loguru import logger\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import MessageTextInput\nfrom langflow.schema import Data\n\n\nclass CalculatorToolComponent(LCToolComponent):\n    display_name = \"Calculator\"\n    description = \"Perform basic arithmetic operations on a given expression.\"\n    icon = \"calculator\"\n    name = \"CalculatorTool\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"expression\",\n            display_name=\"Expression\",\n            info=\"The arithmetic expression to evaluate (e.g., '4*4*(33/22)+12-20').\",\n        ),\n    ]\n\n    class CalculatorToolSchema(BaseModel):\n        expression: str = Field(..., description=\"The arithmetic expression to evaluate.\")\n\n    def run_model(self) -> list[Data]:\n        return self._evaluate_expression(self.expression)\n\n    def build_tool(self) -> Tool:\n        return StructuredTool.from_function(\n            name=\"calculator\",\n            description=\"Evaluate basic arithmetic expressions. Input should be a string containing the expression.\",\n            func=self._evaluate_expression,\n            args_schema=self.CalculatorToolSchema,\n        )\n\n    def _eval_expr(self, node):\n        # Define the allowed operators\n        operators = {\n            ast.Add: operator.add,\n            ast.Sub: operator.sub,\n            ast.Mult: operator.mul,\n            ast.Div: operator.truediv,\n            ast.Pow: operator.pow,\n        }\n        if isinstance(node, ast.Num):\n            return node.n\n        if isinstance(node, ast.BinOp):\n            return operators[type(node.op)](self._eval_expr(node.left), self._eval_expr(node.right))\n        if isinstance(node, ast.UnaryOp):\n            return operators[type(node.op)](self._eval_expr(node.operand))\n        raise TypeError(node)\n\n    def _evaluate_expression(self, expression: str) -> list[Data]:\n        try:\n            # Parse the expression and evaluate it\n            tree = ast.parse(expression, mode=\"eval\")\n            result = self._eval_expr(tree.body)\n\n            # Format the result to a reasonable number of decimal places\n            formatted_result = f\"{result:.6f}\".rstrip(\"0\").rstrip(\".\")\n\n            self.status = formatted_result\n            return [Data(data={\"result\": formatted_result})]\n\n        except (SyntaxError, TypeError, KeyError) as e:\n            error_message = f\"Invalid expression: {e}\"\n            self.status = error_message\n            return [Data(data={\"error\": error_message})]\n        except ZeroDivisionError:\n            error_message = \"Error: Division by zero\"\n            self.status = error_message\n            return [Data(data={\"error\": error_message})]\n        except Exception as e:  # noqa: BLE001\n            logger.opt(exception=True).debug(\"Error evaluating expression\")\n            error_message = f\"Error: {e}\"\n            self.status = error_message\n            return [Data(data={\"error\": error_message})]\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "expression": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "expression",
    //                 "value": "",
    //                 "display_name": "Expression",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The arithmetic expression to evaluate (e.g., '4*4*(33/22)+12-20').",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Perform basic arithmetic operations on a given expression.",
    //         "icon": "calculator",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "Calculator",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "expression"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "expression"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "expression"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "PythonREPLTool": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import importlib\n\nfrom langchain.tools import StructuredTool\nfrom langchain_experimental.utilities import PythonREPL\nfrom loguru import logger\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import StrInput\nfrom langflow.schema import Data\n\n\nclass PythonREPLToolComponent(LCToolComponent):\n    display_name = \"Python REPL Tool\"\n    description = \"A tool for running Python code in a REPL environment.\"\n    name = \"PythonREPLTool\"\n\n    inputs = [\n        StrInput(\n            name=\"name\",\n            display_name=\"Tool Name\",\n            info=\"The name of the tool.\",\n            value=\"python_repl\",\n        ),\n        StrInput(\n            name=\"description\",\n            display_name=\"Tool Description\",\n            info=\"A description of the tool.\",\n            value=\"A Python shell. Use this to execute python commands. \"\n            \"Input should be a valid python command. \"\n            \"If you want to see the output of a value, you should print it out with `print(...)`.\",\n        ),\n        StrInput(\n            name=\"global_imports\",\n            display_name=\"Global Imports\",\n            info=\"A comma-separated list of modules to import globally, e.g. 'math,numpy'.\",\n            value=\"math\",\n        ),\n        StrInput(\n            name=\"code\",\n            display_name=\"Python Code\",\n            info=\"The Python code to execute.\",\n            value=\"print('Hello, World!')\",\n        ),\n    ]\n\n    class PythonREPLSchema(BaseModel):\n        code: str = Field(..., description=\"The Python code to execute.\")\n\n    def get_globals(self, global_imports: str | list[str]) -> dict:\n        global_dict = {}\n        if isinstance(global_imports, str):\n            modules = [module.strip() for module in global_imports.split(\",\")]\n        elif isinstance(global_imports, list):\n            modules = global_imports\n        else:\n            msg = \"global_imports must be either a string or a list\"\n            raise TypeError(msg)\n\n        for module in modules:\n            try:\n                imported_module = importlib.import_module(module)\n                global_dict[imported_module.__name__] = imported_module\n            except ImportError as e:\n                msg = f\"Could not import module {module}\"\n                raise ImportError(msg) from e\n        return global_dict\n\n    def build_tool(self) -> Tool:\n        _globals = self.get_globals(self.global_imports)\n        python_repl = PythonREPL(_globals=_globals)\n\n        def run_python_code(code: str) -> str:\n            try:\n                return python_repl.run(code)\n            except Exception as e:  # noqa: BLE001\n                logger.opt(exception=True).debug(\"Error running Python code\")\n                return f\"Error: {e}\"\n\n        tool = StructuredTool.from_function(\n            name=self.name,\n            description=self.description,\n            func=run_python_code,\n            args_schema=self.PythonREPLSchema,\n        )\n\n        self.status = f\"Python REPL Tool created with global imports: {self.global_imports}\"\n        return tool\n\n    def run_model(self) -> list[Data]:\n        tool = self.build_tool()\n        result = tool.run(self.code)\n        return [Data(data={\"result\": result})]\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "description": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "description",
    //                 "value": "A Python shell. Use this to execute python commands. Input should be a valid python command. If you want to see the output of a value, you should print it out with `print(...)`.",
    //                 "display_name": "Tool Description",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "A description of the tool.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "global_imports": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "global_imports",
    //                 "value": "math",
    //                 "display_name": "Global Imports",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "A comma-separated list of modules to import globally, e.g. 'math,numpy'.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "name",
    //                 "value": "python_repl",
    //                 "display_name": "Tool Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The name of the tool.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "A tool for running Python code in a REPL environment.",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "Python REPL Tool",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "code",
    //                     "description",
    //                     "global_imports",
    //                     "name"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "code",
    //                     "description",
    //                     "global_imports",
    //                     "name"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "name",
    //             "description",
    //             "global_imports",
    //             "code"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "YahooFinanceTool": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import ast\nimport pprint\n\nimport yfinance as yf\nfrom langchain.tools import StructuredTool\nfrom loguru import logger\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import DropdownInput, IntInput, MessageTextInput\nfrom langflow.schema import Data\n\n\nclass YfinanceToolComponent(LCToolComponent):\n    display_name = \"Yahoo Finance Tool\"\n    description = \"Access financial data and market information using Yahoo Finance.\"\n    icon = \"trending-up\"\n    name = \"YahooFinanceTool\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"symbol\",\n            display_name=\"Stock Symbol\",\n            info=\"The stock symbol to retrieve data for (e.g., AAPL, GOOG).\",\n            required=True,\n        ),\n        DropdownInput(\n            name=\"method\",\n            display_name=\"Data Method\",\n            info=\"The type of data to retrieve.\",\n            options=[\n                \"get_actions\",\n                \"get_analysis\",\n                \"get_balance_sheet\",\n                \"get_calendar\",\n                \"get_cashflow\",\n                \"get_info\",\n                \"get_institutional_holders\",\n                \"get_news\",\n                \"get_recommendations\",\n                \"get_sustainability\",\n            ],\n            value=\"get_news\",\n        ),\n        IntInput(\n            name=\"num_news\",\n            display_name=\"Number of News\",\n            info=\"The number of news articles to retrieve (only applicable for get_news).\",\n            value=5,\n        ),\n    ]\n\n    class YahooFinanceSchema(BaseModel):\n        symbol: str = Field(..., description=\"The stock symbol to retrieve data for.\")\n        method: str = Field(\"get_info\", description=\"The type of data to retrieve.\")\n        num_news: int | None = Field(5, description=\"The number of news articles to retrieve.\")\n\n    def run_model(self) -> list[Data]:\n        return self._yahoo_finance_tool(\n            self.symbol,\n            self.method,\n            self.num_news,\n        )\n\n    def build_tool(self) -> Tool:\n        return StructuredTool.from_function(\n            name=\"yahoo_finance\",\n            description=\"Access financial data and market information from Yahoo Finance.\",\n            func=self._yahoo_finance_tool,\n            args_schema=self.YahooFinanceSchema,\n        )\n\n    def _yahoo_finance_tool(\n        self,\n        symbol: str,\n        method: str,\n        num_news: int | None = 5,\n    ) -> list[Data]:\n        ticker = yf.Ticker(symbol)\n\n        try:\n            if method == \"get_info\":\n                result = ticker.info\n            elif method == \"get_news\":\n                result = ticker.news[:num_news]\n            else:\n                result = getattr(ticker, method)()\n\n            result = pprint.pformat(result)\n\n            if method == \"get_news\":\n                data_list = [Data(data=article) for article in ast.literal_eval(result)]\n            else:\n                data_list = [Data(data={\"result\": result})]\n\n        except Exception as e:  # noqa: BLE001\n            error_message = f\"Error retrieving data: {e}\"\n            logger.opt(exception=True).debug(error_message)\n            self.status = error_message\n            return [Data(data={\"error\": error_message})]\n\n        return data_list\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "method": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "get_actions",
    //                     "get_analysis",
    //                     "get_balance_sheet",
    //                     "get_calendar",
    //                     "get_cashflow",
    //                     "get_info",
    //                     "get_institutional_holders",
    //                     "get_news",
    //                     "get_recommendations",
    //                     "get_sustainability"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "method",
    //                 "value": "get_news",
    //                 "display_name": "Data Method",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The type of data to retrieve.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "num_news": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "num_news",
    //                 "value": 5,
    //                 "display_name": "Number of News",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The number of news articles to retrieve (only applicable for get_news).",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "symbol": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "symbol",
    //                 "value": "",
    //                 "display_name": "Stock Symbol",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The stock symbol to retrieve data for (e.g., AAPL, GOOG).",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Access financial data and market information using Yahoo Finance.",
    //         "icon": "trending-up",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "Yahoo Finance Tool",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "method",
    //                     "num_news",
    //                     "symbol"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "method",
    //                     "num_news",
    //                     "symbol"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "symbol",
    //             "method",
    //             "num_news"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "SearchAPI": {
    //         "template": {
    //             "_type": "Component",
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "SearchAPI API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom langchain.tools import StructuredTool\nfrom langchain_community.utilities.searchapi import SearchApiAPIWrapper\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import DictInput, IntInput, MessageTextInput, MultilineInput, SecretStrInput\nfrom langflow.schema import Data\n\n\nclass SearchAPIComponent(LCToolComponent):\n    display_name: str = \"Search API\"\n    description: str = \"Call the searchapi.io API with result limiting\"\n    name = \"SearchAPI\"\n    documentation: str = \"https://www.searchapi.io/docs/google\"\n\n    inputs = [\n        MessageTextInput(name=\"engine\", display_name=\"Engine\", value=\"google\"),\n        SecretStrInput(name=\"api_key\", display_name=\"SearchAPI API Key\", required=True),\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n        ),\n        DictInput(name=\"search_params\", display_name=\"Search parameters\", advanced=True, is_list=True),\n        IntInput(name=\"max_results\", display_name=\"Max Results\", value=5, advanced=True),\n        IntInput(name=\"max_snippet_length\", display_name=\"Max Snippet Length\", value=100, advanced=True),\n    ]\n\n    class SearchAPISchema(BaseModel):\n        query: str = Field(..., description=\"The search query\")\n        params: dict[str, Any] | None = Field(default_factory=dict, description=\"Additional search parameters\")\n        max_results: int = Field(5, description=\"Maximum number of results to return\")\n        max_snippet_length: int = Field(100, description=\"Maximum length of each result snippet\")\n\n    def _build_wrapper(self):\n        return SearchApiAPIWrapper(engine=self.engine, searchapi_api_key=self.api_key)\n\n    def build_tool(self) -> Tool:\n        wrapper = self._build_wrapper()\n\n        def search_func(\n            query: str, params: dict[str, Any] | None = None, max_results: int = 5, max_snippet_length: int = 100\n        ) -> list[dict[str, Any]]:\n            params = params or {}\n            full_results = wrapper.results(query=query, **params)\n            organic_results = full_results.get(\"organic_results\", [])[:max_results]\n\n            limited_results = []\n            for result in organic_results:\n                limited_result = {\n                    \"title\": result.get(\"title\", \"\")[:max_snippet_length],\n                    \"link\": result.get(\"link\", \"\"),\n                    \"snippet\": result.get(\"snippet\", \"\")[:max_snippet_length],\n                }\n                limited_results.append(limited_result)\n\n            return limited_results\n\n        tool = StructuredTool.from_function(\n            name=\"search_api\",\n            description=\"Search for recent results using searchapi.io with result limiting\",\n            func=search_func,\n            args_schema=self.SearchAPISchema,\n        )\n\n        self.status = f\"Search API Tool created with engine: {self.engine}\"\n        return tool\n\n    def run_model(self) -> list[Data]:\n        tool = self.build_tool()\n        results = tool.run(\n            {\n                \"query\": self.input_value,\n                \"params\": self.search_params or {},\n                \"max_results\": self.max_results,\n                \"max_snippet_length\": self.max_snippet_length,\n            }\n        )\n\n        data_list = [Data(data=result, text=result.get(\"snippet\", \"\")) for result in results]\n\n        self.status = data_list\n        return data_list\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "engine": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "engine",
    //                 "value": "google",
    //                 "display_name": "Engine",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "max_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_results",
    //                 "value": 5,
    //                 "display_name": "Max Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "max_snippet_length": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_snippet_length",
    //                 "value": 100,
    //                 "display_name": "Max Snippet Length",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "search_params": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_params",
    //                 "value": {},
    //                 "display_name": "Search parameters",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             }
    //         },
    //         "description": "Call the searchapi.io API with result limiting",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "Search API",
    //         "documentation": "https://www.searchapi.io/docs/google",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_key",
    //                     "engine",
    //                     "input_value",
    //                     "max_results",
    //                     "max_snippet_length",
    //                     "search_params"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_key",
    //                     "engine",
    //                     "input_value",
    //                     "max_results",
    //                     "max_snippet_length",
    //                     "search_params"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "engine",
    //             "api_key",
    //             "input_value",
    //             "search_params",
    //             "max_results",
    //             "max_snippet_length"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "DuckDuckGoSearch": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom langchain.tools import StructuredTool\nfrom langchain_community.tools import DuckDuckGoSearchRun\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import IntInput, MessageTextInput\nfrom langflow.schema import Data\n\n\nclass DuckDuckGoSearchComponent(LCToolComponent):\n    display_name: str = \"DuckDuckGo Search\"\n    description: str = \"Perform web searches using the DuckDuckGo search engine with result limiting\"\n    name = \"DuckDuckGoSearch\"\n    documentation: str = \"https://python.langchain.com/docs/integrations/tools/ddg\"\n    icon: str = \"DuckDuckGo\"\n    inputs = [\n        MessageTextInput(\n            name=\"input_value\",\n            display_name=\"Search Query\",\n            required=True,\n        ),\n        IntInput(name=\"max_results\", display_name=\"Max Results\", value=5, advanced=True),\n        IntInput(name=\"max_snippet_length\", display_name=\"Max Snippet Length\", value=100, advanced=True),\n    ]\n\n    class DuckDuckGoSearchSchema(BaseModel):\n        query: str = Field(..., description=\"The search query\")\n        max_results: int = Field(5, description=\"Maximum number of results to return\")\n        max_snippet_length: int = Field(100, description=\"Maximum length of each result snippet\")\n\n    def _build_wrapper(self):\n        return DuckDuckGoSearchRun()\n\n    def build_tool(self) -> Tool:\n        wrapper = self._build_wrapper()\n\n        def search_func(query: str, max_results: int = 5, max_snippet_length: int = 100) -> list[dict[str, Any]]:\n            full_results = wrapper.run(f\"{query} (site:*)\")\n            result_list = full_results.split(\"\\n\")[:max_results]\n            limited_results = []\n            for result in result_list:\n                limited_result = {\n                    \"snippet\": result[:max_snippet_length],\n                }\n                limited_results.append(limited_result)\n            return limited_results\n\n        tool = StructuredTool.from_function(\n            name=\"duckduckgo_search\",\n            description=\"Search for recent results using DuckDuckGo with result limiting\",\n            func=search_func,\n            args_schema=self.DuckDuckGoSearchSchema,\n        )\n        self.status = \"DuckDuckGo Search Tool created\"\n        return tool\n\n    def run_model(self) -> list[Data]:\n        tool = self.build_tool()\n        results = tool.run(\n            {\n                \"query\": self.input_value,\n                \"max_results\": self.max_results,\n                \"max_snippet_length\": self.max_snippet_length,\n            }\n        )\n        data_list = [Data(data=result, text=result.get(\"snippet\", \"\")) for result in results]\n        self.status = data_list\n        return data_list\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "max_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_results",
    //                 "value": 5,
    //                 "display_name": "Max Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "max_snippet_length": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_snippet_length",
    //                 "value": 100,
    //                 "display_name": "Max Snippet Length",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             }
    //         },
    //         "description": "Perform web searches using the DuckDuckGo search engine with result limiting",
    //         "icon": "DuckDuckGo",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "DuckDuckGo Search",
    //         "documentation": "https://python.langchain.com/docs/integrations/tools/ddg",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "max_results",
    //                     "max_snippet_length"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "max_results",
    //                     "max_snippet_length"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "max_results",
    //             "max_snippet_length"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "SerpAPI": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom langchain.tools import StructuredTool\nfrom langchain_community.utilities.serpapi import SerpAPIWrapper\nfrom loguru import logger\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import DictInput, IntInput, MultilineInput, SecretStrInput\nfrom langflow.schema import Data\n\n\nclass SerpAPIComponent(LCToolComponent):\n    display_name = \"Serp Search API\"\n    description = \"Call Serp Search API with result limiting\"\n    name = \"SerpAPI\"\n\n    inputs = [\n        SecretStrInput(name=\"serpapi_api_key\", display_name=\"SerpAPI API Key\", required=True),\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n        ),\n        DictInput(name=\"search_params\", display_name=\"Parameters\", advanced=True, is_list=True),\n        IntInput(name=\"max_results\", display_name=\"Max Results\", value=5, advanced=True),\n        IntInput(name=\"max_snippet_length\", display_name=\"Max Snippet Length\", value=100, advanced=True),\n    ]\n\n    class SerpAPISchema(BaseModel):\n        query: str = Field(..., description=\"The search query\")\n        params: dict[str, Any] | None = Field(default_factory=dict, description=\"Additional search parameters\")\n        max_results: int = Field(5, description=\"Maximum number of results to return\")\n        max_snippet_length: int = Field(100, description=\"Maximum length of each result snippet\")\n\n    def _build_wrapper(self) -> SerpAPIWrapper:\n        if self.search_params:\n            return SerpAPIWrapper(\n                serpapi_api_key=self.serpapi_api_key,\n                params=self.search_params,\n            )\n        return SerpAPIWrapper(serpapi_api_key=self.serpapi_api_key)\n\n    def build_tool(self) -> Tool:\n        wrapper = self._build_wrapper()\n\n        def search_func(\n            query: str, params: dict[str, Any] | None = None, max_results: int = 5, max_snippet_length: int = 100\n        ) -> list[dict[str, Any]]:\n            params = params or {}\n            full_results = wrapper.results(query, **params)\n            organic_results = full_results.get(\"organic_results\", [])[:max_results]\n\n            limited_results = []\n            for result in organic_results:\n                limited_result = {\n                    \"title\": result.get(\"title\", \"\")[:max_snippet_length],\n                    \"link\": result.get(\"link\", \"\"),\n                    \"snippet\": result.get(\"snippet\", \"\")[:max_snippet_length],\n                }\n                limited_results.append(limited_result)\n\n            return limited_results\n\n        tool = StructuredTool.from_function(\n            name=\"serp_search_api\",\n            description=\"Search for recent results using SerpAPI with result limiting\",\n            func=search_func,\n            args_schema=self.SerpAPISchema,\n        )\n\n        self.status = \"SerpAPI Tool created\"\n        return tool\n\n    def run_model(self) -> list[Data]:\n        tool = self.build_tool()\n        try:\n            results = tool.run(\n                {\n                    \"query\": self.input_value,\n                    \"params\": self.search_params or {},\n                    \"max_results\": self.max_results,\n                    \"max_snippet_length\": self.max_snippet_length,\n                }\n            )\n\n            data_list = [Data(data=result, text=result.get(\"snippet\", \"\")) for result in results]\n\n        except Exception as e:  # noqa: BLE001\n            logger.opt(exception=True).debug(\"Error running SerpAPI\")\n            self.status = f\"Error: {e}\"\n            return [Data(data={\"error\": str(e)}, text=str(e))]\n\n        self.status = data_list\n        return data_list\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "max_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_results",
    //                 "value": 5,
    //                 "display_name": "Max Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "max_snippet_length": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_snippet_length",
    //                 "value": 100,
    //                 "display_name": "Max Snippet Length",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "search_params": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_params",
    //                 "value": {},
    //                 "display_name": "Parameters",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "serpapi_api_key": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "serpapi_api_key",
    //                 "value": "",
    //                 "display_name": "SerpAPI API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             }
    //         },
    //         "description": "Call Serp Search API with result limiting",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "Serp Search API",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "max_results",
    //                     "max_snippet_length",
    //                     "search_params",
    //                     "serpapi_api_key"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "max_results",
    //                     "max_snippet_length",
    //                     "search_params",
    //                     "serpapi_api_key"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "serpapi_api_key",
    //             "input_value",
    //             "search_params",
    //             "max_results",
    //             "max_snippet_length"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "embeddings": {
    //     "VertexAIEmbeddings": {
    //         "template": {
    //             "_type": "Component",
    //             "credentials": {
    //                 "trace_as_metadata": true,
    //                 "file_path": "",
    //                 "fileTypes": [
    //                     "json"
    //                 ],
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "credentials",
    //                 "value": "",
    //                 "display_name": "Credentials",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "JSON credentials file. Leave empty to fallback to environment variables",
    //                 "title_case": false,
    //                 "type": "file",
    //                 "_input_type": "FileInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import Embeddings\nfrom langflow.io import BoolInput, FileInput, FloatInput, IntInput, MessageTextInput, Output\n\n\nclass VertexAIEmbeddingsComponent(LCModelComponent):\n    display_name = \"VertexAI Embeddings\"\n    description = \"Generate embeddings using Google Cloud VertexAI models.\"\n    icon = \"VertexAI\"\n    name = \"VertexAIEmbeddings\"\n\n    inputs = [\n        FileInput(\n            name=\"credentials\",\n            display_name=\"Credentials\",\n            info=\"JSON credentials file. Leave empty to fallback to environment variables\",\n            value=\"\",\n            file_types=[\"json\"],\n        ),\n        MessageTextInput(name=\"location\", display_name=\"Location\", value=\"us-central1\", advanced=True),\n        MessageTextInput(name=\"project\", display_name=\"Project\", info=\"The project ID.\", advanced=True),\n        IntInput(name=\"max_output_tokens\", display_name=\"Max Output Tokens\", advanced=True),\n        IntInput(name=\"max_retries\", display_name=\"Max Retries\", value=1, advanced=True),\n        MessageTextInput(name=\"model_name\", display_name=\"Model Name\", value=\"textembedding-gecko\"),\n        IntInput(name=\"n\", display_name=\"N\", value=1, advanced=True),\n        IntInput(name=\"request_parallelism\", value=5, display_name=\"Request Parallelism\", advanced=True),\n        MessageTextInput(name=\"stop_sequences\", display_name=\"Stop\", advanced=True, is_list=True),\n        BoolInput(name=\"streaming\", display_name=\"Streaming\", value=False, advanced=True),\n        FloatInput(name=\"temperature\", value=0.0, display_name=\"Temperature\"),\n        IntInput(name=\"top_k\", display_name=\"Top K\", advanced=True),\n        FloatInput(name=\"top_p\", display_name=\"Top P\", value=0.95, advanced=True),\n    ]\n\n    outputs = [\n        Output(display_name=\"Embeddings\", name=\"embeddings\", method=\"build_embeddings\"),\n    ]\n\n    def build_embeddings(self) -> Embeddings:\n        try:\n            from langchain_google_vertexai import VertexAIEmbeddings\n        except ImportError as e:\n            msg = \"Please install the langchain-google-vertexai package to use the VertexAIEmbeddings component.\"\n            raise ImportError(msg) from e\n\n        from google.oauth2 import service_account\n\n        if self.credentials:\n            gcloud_credentials = service_account.Credentials.from_service_account_file(self.credentials)\n        else:\n            # will fallback to environment variable or inferred from gcloud CLI\n            gcloud_credentials = None\n        return VertexAIEmbeddings(\n            credentials=gcloud_credentials,\n            location=self.location,\n            max_output_tokens=self.max_output_tokens or None,\n            max_retries=self.max_retries,\n            model_name=self.model_name,\n            n=self.n,\n            project=self.project,\n            request_parallelism=self.request_parallelism,\n            stop=self.stop_sequences or None,\n            streaming=self.streaming,\n            temperature=self.temperature,\n            top_k=self.top_k or None,\n            top_p=self.top_p,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "location": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "location",
    //                 "value": "us-central1",
    //                 "display_name": "Location",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "max_output_tokens": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_output_tokens",
    //                 "value": "",
    //                 "display_name": "Max Output Tokens",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "max_retries": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_retries",
    //                 "value": 1,
    //                 "display_name": "Max Retries",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "model_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_name",
    //                 "value": "textembedding-gecko",
    //                 "display_name": "Model Name",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "n": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "n",
    //                 "value": 1,
    //                 "display_name": "N",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "project": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "project",
    //                 "value": "",
    //                 "display_name": "Project",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The project ID.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "request_parallelism": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "request_parallelism",
    //                 "value": 5,
    //                 "display_name": "Request Parallelism",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "stop_sequences": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "stop_sequences",
    //                 "value": "",
    //                 "display_name": "Stop",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "streaming": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "streaming",
    //                 "value": false,
    //                 "display_name": "Streaming",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "temperature": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "temperature",
    //                 "value": 0.0,
    //                 "display_name": "Temperature",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "top_k": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "top_k",
    //                 "value": "",
    //                 "display_name": "Top K",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "top_p": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "top_p",
    //                 "value": 0.95,
    //                 "display_name": "Top P",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             }
    //         },
    //         "description": "Generate embeddings using Google Cloud VertexAI models.",
    //         "icon": "VertexAI",
    //         "base_classes": [
    //             "Embeddings"
    //         ],
    //         "display_name": "VertexAI Embeddings",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Embeddings"
    //                 ],
    //                 "selected": "Embeddings",
    //                 "name": "embeddings",
    //                 "display_name": "Embeddings",
    //                 "method": "build_embeddings",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "credentials",
    //             "location",
    //             "project",
    //             "max_output_tokens",
    //             "max_retries",
    //             "model_name",
    //             "n",
    //             "request_parallelism",
    //             "stop_sequences",
    //             "streaming",
    //             "temperature",
    //             "top_k",
    //             "top_p"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "HuggingFaceInferenceAPIEmbeddings": {
    //         "template": {
    //             "_type": "Component",
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "API Key",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Required for non-local inference endpoints. Local inference does not require an API Key.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from urllib.parse import urlparse\n\nimport requests\nfrom langchain_community.embeddings.huggingface import HuggingFaceInferenceAPIEmbeddings\nfrom pydantic.v1.types import SecretStr\nfrom tenacity import retry, stop_after_attempt, wait_fixed\n\nfrom langflow.base.embeddings.model import LCEmbeddingsModel\nfrom langflow.field_typing import Embeddings\nfrom langflow.io import MessageTextInput, Output, SecretStrInput\n\n\nclass HuggingFaceInferenceAPIEmbeddingsComponent(LCEmbeddingsModel):\n    display_name = \"HuggingFace Embeddings Inference\"\n    description = \"Generate embeddings using HuggingFace Text Embeddings Inference (TEI)\"\n    documentation = \"https://huggingface.co/docs/text-embeddings-inference/index\"\n    icon = \"HuggingFace\"\n    name = \"HuggingFaceInferenceAPIEmbeddings\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"API Key\",\n            advanced=True,\n            info=\"Required for non-local inference endpoints. Local inference does not require an API Key.\",\n        ),\n        MessageTextInput(\n            name=\"inference_endpoint\",\n            display_name=\"Inference Endpoint\",\n            required=True,\n            value=\"https://api-inference.huggingface.co/models/\",\n            info=\"Custom inference endpoint URL.\",\n        ),\n        MessageTextInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            value=\"BAAI/bge-large-en-v1.5\",\n            info=\"The name of the model to use for text embeddings.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Embeddings\", name=\"embeddings\", method=\"build_embeddings\"),\n    ]\n\n    def validate_inference_endpoint(self, inference_endpoint: str) -> bool:\n        parsed_url = urlparse(inference_endpoint)\n        if not all([parsed_url.scheme, parsed_url.netloc]):\n            msg = (\n                f\"Invalid inference endpoint format: '{self.inference_endpoint}'. \"\n                \"Please ensure the URL includes both a scheme (e.g., 'http://' or 'https://') and a domain name. \"\n                \"Example: 'http://localhost:8080' or 'https://api.example.com'\"\n            )\n            raise ValueError(msg)\n\n        try:\n            response = requests.get(f\"{inference_endpoint}/health\", timeout=5)\n        except requests.RequestException as e:\n            msg = (\n                f\"Inference endpoint '{inference_endpoint}' is not responding. \"\n                \"Please ensure the URL is correct and the service is running.\"\n            )\n            raise ValueError(msg) from e\n\n        if response.status_code != requests.codes.ok:\n            msg = f\"HuggingFace health check failed: {response.status_code}\"\n            raise ValueError(msg)\n        # returning True to solve linting error\n        return True\n\n    def get_api_url(self) -> str:\n        if \"huggingface\" in self.inference_endpoint.lower():\n            return f\"{self.inference_endpoint}{self.model_name}\"\n        return self.inference_endpoint\n\n    @retry(stop=stop_after_attempt(3), wait=wait_fixed(2))\n    def create_huggingface_embeddings(\n        self, api_key: SecretStr, api_url: str, model_name: str\n    ) -> HuggingFaceInferenceAPIEmbeddings:\n        return HuggingFaceInferenceAPIEmbeddings(api_key=api_key, api_url=api_url, model_name=model_name)\n\n    def build_embeddings(self) -> Embeddings:\n        api_url = self.get_api_url()\n\n        is_local_url = api_url.startswith((\"http://localhost\", \"http://127.0.0.1\"))\n\n        if not self.api_key and is_local_url:\n            self.validate_inference_endpoint(api_url)\n            api_key = SecretStr(\"DummyAPIKeyForLocalDeployment\")\n        elif not self.api_key:\n            msg = \"API Key is required for non-local inference endpoints\"\n            raise ValueError(msg)\n        else:\n            api_key = SecretStr(self.api_key).get_secret_value()\n\n        try:\n            return self.create_huggingface_embeddings(api_key, api_url, self.model_name)\n        except Exception as e:\n            msg = \"Could not connect to HuggingFace Inference API.\"\n            raise ValueError(msg) from e\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "inference_endpoint": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "inference_endpoint",
    //                 "value": "https://api-inference.huggingface.co/models/",
    //                 "display_name": "Inference Endpoint",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Custom inference endpoint URL.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "model_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_name",
    //                 "value": "BAAI/bge-large-en-v1.5",
    //                 "display_name": "Model Name",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The name of the model to use for text embeddings.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Generate embeddings using HuggingFace Text Embeddings Inference (TEI)",
    //         "icon": "HuggingFace",
    //         "base_classes": [
    //             "Embeddings"
    //         ],
    //         "display_name": "HuggingFace Embeddings Inference",
    //         "documentation": "https://huggingface.co/docs/text-embeddings-inference/index",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Embeddings"
    //                 ],
    //                 "selected": "Embeddings",
    //                 "name": "embeddings",
    //                 "display_name": "Embeddings",
    //                 "method": "build_embeddings",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "api_key",
    //             "inference_endpoint",
    //             "model_name"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "NVIDIAEmbeddingsComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "base_url": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "base_url",
    //                 "value": "https://integrate.api.nvidia.com/v1",
    //                 "display_name": "NVIDIA Base URL",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "refresh_button": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom langflow.base.embeddings.model import LCEmbeddingsModel\nfrom langflow.field_typing import Embeddings\nfrom langflow.inputs.inputs import DropdownInput, SecretStrInput\nfrom langflow.io import FloatInput, MessageTextInput\nfrom langflow.schema.dotdict import dotdict\n\n\nclass NVIDIAEmbeddingsComponent(LCEmbeddingsModel):\n    display_name: str = \"NVIDIA Embeddings\"\n    description: str = \"Generate embeddings using NVIDIA models.\"\n    icon = \"NVIDIA\"\n\n    inputs = [\n        DropdownInput(\n            name=\"model\",\n            display_name=\"Model\",\n            options=[\n                \"nvidia/nv-embed-v1\",\n                \"snowflake/arctic-embed-I\",\n            ],\n            value=\"nvidia/nv-embed-v1\",\n        ),\n        MessageTextInput(\n            name=\"base_url\",\n            display_name=\"NVIDIA Base URL\",\n            refresh_button=True,\n            value=\"https://integrate.api.nvidia.com/v1\",\n        ),\n        SecretStrInput(\n            name=\"nvidia_api_key\",\n            display_name=\"NVIDIA API Key\",\n            info=\"The NVIDIA API Key.\",\n            advanced=False,\n            value=\"NVIDIA_API_KEY\",\n        ),\n        FloatInput(\n            name=\"temperature\",\n            display_name=\"Model Temperature\",\n            value=0.1,\n            advanced=True,\n        ),\n    ]\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"base_url\" and field_value:\n            try:\n                build_model = self.build_embeddings()\n                ids = [model.id for model in build_model.available_models]\n                build_config[\"model\"][\"options\"] = ids\n                build_config[\"model\"][\"value\"] = ids[0]\n            except Exception as e:\n                msg = f\"Error getting model names: {e}\"\n                raise ValueError(msg) from e\n        return build_config\n\n    def build_embeddings(self) -> Embeddings:\n        try:\n            from langchain_nvidia_ai_endpoints import NVIDIAEmbeddings\n        except ImportError as e:\n            msg = \"Please install langchain-nvidia-ai-endpoints to use the Nvidia model.\"\n            raise ImportError(msg) from e\n        try:\n            output = NVIDIAEmbeddings(\n                model=self.model,\n                base_url=self.base_url,\n                temperature=self.temperature,\n                nvidia_api_key=self.nvidia_api_key,\n            )\n        except Exception as e:\n            msg = f\"Could not connect to NVIDIA API. Error: {e}\"\n            raise ValueError(msg) from e\n        return output\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "model": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "nvidia/nv-embed-v1",
    //                     "snowflake/arctic-embed-I"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model",
    //                 "value": "nvidia/nv-embed-v1",
    //                 "display_name": "Model",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "nvidia_api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "nvidia_api_key",
    //                 "value": "NVIDIA_API_KEY",
    //                 "display_name": "NVIDIA API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The NVIDIA API Key.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "temperature": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "temperature",
    //                 "value": 0.1,
    //                 "display_name": "Model Temperature",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             }
    //         },
    //         "description": "Generate embeddings using NVIDIA models.",
    //         "icon": "NVIDIA",
    //         "base_classes": [
    //             "Embeddings"
    //         ],
    //         "display_name": "NVIDIA Embeddings",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Embeddings"
    //                 ],
    //                 "selected": "Embeddings",
    //                 "name": "embeddings",
    //                 "display_name": "Embeddings",
    //                 "method": "build_embeddings",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "base_url",
    //                     "model",
    //                     "nvidia_api_key",
    //                     "temperature"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "model",
    //             "base_url",
    //             "nvidia_api_key",
    //             "temperature"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AmazonBedrockEmbeddings": {
    //         "template": {
    //             "_type": "Component",
    //             "aws_access_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "aws_access_key",
    //                 "value": "",
    //                 "display_name": "Access Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "aws_secret_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "aws_secret_key",
    //                 "value": "",
    //                 "display_name": "Secret Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_community.embeddings import BedrockEmbeddings\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import Embeddings\nfrom langflow.inputs import SecretStrInput\nfrom langflow.io import DropdownInput, MessageTextInput, Output\n\n\nclass AmazonBedrockEmbeddingsComponent(LCModelComponent):\n    display_name: str = \"Amazon Bedrock Embeddings\"\n    description: str = \"Generate embeddings using Amazon Bedrock models.\"\n    documentation = \"https://python.langchain.com/docs/modules/data_connection/text_embedding/integrations/bedrock\"\n    icon = \"Amazon\"\n    name = \"AmazonBedrockEmbeddings\"\n\n    inputs = [\n        DropdownInput(\n            name=\"model_id\",\n            display_name=\"Model Id\",\n            options=[\"amazon.titan-embed-text-v1\"],\n            value=\"amazon.titan-embed-text-v1\",\n        ),\n        SecretStrInput(name=\"aws_access_key\", display_name=\"Access Key\"),\n        SecretStrInput(name=\"aws_secret_key\", display_name=\"Secret Key\"),\n        MessageTextInput(\n            name=\"credentials_profile_name\",\n            display_name=\"Credentials Profile Name\",\n            advanced=True,\n        ),\n        MessageTextInput(name=\"region_name\", display_name=\"Region Name\", value=\"us-east-1\"),\n        MessageTextInput(name=\"endpoint_url\", display_name=\" Endpoint URL\", advanced=True),\n    ]\n\n    outputs = [\n        Output(display_name=\"Embeddings\", name=\"embeddings\", method=\"build_embeddings\"),\n    ]\n\n    def build_embeddings(self) -> Embeddings:\n        if self.aws_access_key:\n            import boto3\n\n            session = boto3.Session(\n                aws_access_key_id=self.aws_access_key,\n                aws_secret_access_key=self.aws_secret_key,\n            )\n        elif self.credentials_profile_name:\n            import boto3\n\n            session = boto3.Session(profile_name=self.credentials_profile_name)\n        else:\n            import boto3\n\n            session = boto3.Session()\n\n        client_params = {}\n        if self.endpoint_url:\n            client_params[\"endpoint_url\"] = self.endpoint_url\n        if self.region_name:\n            client_params[\"region_name\"] = self.region_name\n\n        boto3_client = session.client(\"bedrock-runtime\", **client_params)\n        return BedrockEmbeddings(\n            credentials_profile_name=self.credentials_profile_name,\n            client=boto3_client,\n            model_id=self.model_id,\n            endpoint_url=self.endpoint_url,\n            region_name=self.region_name,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "credentials_profile_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "credentials_profile_name",
    //                 "value": "",
    //                 "display_name": "Credentials Profile Name",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "endpoint_url": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "endpoint_url",
    //                 "value": "",
    //                 "display_name": " Endpoint URL",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "model_id": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "amazon.titan-embed-text-v1"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_id",
    //                 "value": "amazon.titan-embed-text-v1",
    //                 "display_name": "Model Id",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "region_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "region_name",
    //                 "value": "us-east-1",
    //                 "display_name": "Region Name",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Generate embeddings using Amazon Bedrock models.",
    //         "icon": "Amazon",
    //         "base_classes": [
    //             "Embeddings"
    //         ],
    //         "display_name": "Amazon Bedrock Embeddings",
    //         "documentation": "https://python.langchain.com/docs/modules/data_connection/text_embedding/integrations/bedrock",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Embeddings"
    //                 ],
    //                 "selected": "Embeddings",
    //                 "name": "embeddings",
    //                 "display_name": "Embeddings",
    //                 "method": "build_embeddings",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "model_id",
    //             "aws_access_key",
    //             "aws_secret_key",
    //             "credentials_profile_name",
    //             "region_name",
    //             "endpoint_url"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "MistalAIEmbeddings": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_mistralai.embeddings import MistralAIEmbeddings\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import Embeddings\nfrom langflow.io import DropdownInput, IntInput, MessageTextInput, Output, SecretStrInput\n\n\nclass MistralAIEmbeddingsComponent(LCModelComponent):\n    display_name = \"MistralAI Embeddings\"\n    description = \"Generate embeddings using MistralAI models.\"\n    icon = \"MistralAI\"\n    name = \"MistalAIEmbeddings\"\n\n    inputs = [\n        DropdownInput(\n            name=\"model\",\n            display_name=\"Model\",\n            advanced=False,\n            options=[\"mistral-embed\"],\n            value=\"mistral-embed\",\n        ),\n        SecretStrInput(name=\"mistral_api_key\", display_name=\"Mistral API Key\"),\n        IntInput(\n            name=\"max_concurrent_requests\",\n            display_name=\"Max Concurrent Requests\",\n            advanced=True,\n            value=64,\n        ),\n        IntInput(name=\"max_retries\", display_name=\"Max Retries\", advanced=True, value=5),\n        IntInput(name=\"timeout\", display_name=\"Request Timeout\", advanced=True, value=120),\n        MessageTextInput(\n            name=\"endpoint\",\n            display_name=\"API Endpoint\",\n            advanced=True,\n            value=\"https://api.mistral.ai/v1/\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Embeddings\", name=\"embeddings\", method=\"build_embeddings\"),\n    ]\n\n    def build_embeddings(self) -> Embeddings:\n        if not self.mistral_api_key:\n            msg = \"Mistral API Key is required\"\n            raise ValueError(msg)\n\n        api_key = SecretStr(self.mistral_api_key).get_secret_value()\n\n        return MistralAIEmbeddings(\n            api_key=api_key,\n            model=self.model,\n            endpoint=self.endpoint,\n            max_concurrent_requests=self.max_concurrent_requests,\n            max_retries=self.max_retries,\n            timeout=self.timeout,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "endpoint": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "endpoint",
    //                 "value": "https://api.mistral.ai/v1/",
    //                 "display_name": "API Endpoint",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "max_concurrent_requests": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_concurrent_requests",
    //                 "value": 64,
    //                 "display_name": "Max Concurrent Requests",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "max_retries": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_retries",
    //                 "value": 5,
    //                 "display_name": "Max Retries",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "mistral_api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "mistral_api_key",
    //                 "value": "",
    //                 "display_name": "Mistral API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "model": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "mistral-embed"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model",
    //                 "value": "mistral-embed",
    //                 "display_name": "Model",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "timeout": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "timeout",
    //                 "value": 120,
    //                 "display_name": "Request Timeout",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             }
    //         },
    //         "description": "Generate embeddings using MistralAI models.",
    //         "icon": "MistralAI",
    //         "base_classes": [
    //             "Embeddings"
    //         ],
    //         "display_name": "MistralAI Embeddings",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Embeddings"
    //                 ],
    //                 "selected": "Embeddings",
    //                 "name": "embeddings",
    //                 "display_name": "Embeddings",
    //                 "method": "build_embeddings",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "model",
    //             "mistral_api_key",
    //             "max_concurrent_requests",
    //             "max_retries",
    //             "timeout",
    //             "endpoint"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "EmbeddingSimilarityComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding_vectors": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding_vectors",
    //                 "value": "",
    //                 "display_name": "Embedding Vectors",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "A list containing exactly two data objects with embedding vectors to compare.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import numpy as np\n\nfrom langflow.custom import Component\nfrom langflow.io import DataInput, DropdownInput, Output\nfrom langflow.schema import Data\n\n\nclass EmbeddingSimilarityComponent(Component):\n    display_name: str = \"Embedding Similarity\"\n    description: str = \"Compute selected form of similarity between two embedding vectors.\"\n    icon = \"equal\"\n\n    inputs = [\n        DataInput(\n            name=\"embedding_vectors\",\n            display_name=\"Embedding Vectors\",\n            info=\"A list containing exactly two data objects with embedding vectors to compare.\",\n            is_list=True,\n        ),\n        DropdownInput(\n            name=\"similarity_metric\",\n            display_name=\"Similarity Metric\",\n            info=\"Select the similarity metric to use.\",\n            options=[\"Cosine Similarity\", \"Euclidean Distance\", \"Manhattan Distance\"],\n            value=\"Cosine Similarity\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Similarity Data\", name=\"similarity_data\", method=\"compute_similarity\"),\n    ]\n\n    def compute_similarity(self) -> Data:\n        embedding_vectors: list[Data] = self.embedding_vectors\n\n        # Assert that the list contains exactly two Data objects\n        if len(embedding_vectors) != 2:  # noqa: PLR2004\n            msg = \"Exactly two embedding vectors are required.\"\n            raise ValueError(msg)\n\n        embedding_1 = np.array(embedding_vectors[0].data[\"embeddings\"])\n        embedding_2 = np.array(embedding_vectors[1].data[\"embeddings\"])\n\n        if embedding_1.shape != embedding_2.shape:\n            similarity_score = {\"error\": \"Embeddings must have the same dimensions.\"}\n        else:\n            similarity_metric = self.similarity_metric\n\n            if similarity_metric == \"Cosine Similarity\":\n                score = np.dot(embedding_1, embedding_2) / (np.linalg.norm(embedding_1) * np.linalg.norm(embedding_2))\n                similarity_score = {\"cosine_similarity\": score}\n\n            elif similarity_metric == \"Euclidean Distance\":\n                score = np.linalg.norm(embedding_1 - embedding_2)\n                similarity_score = {\"euclidean_distance\": score}\n\n            elif similarity_metric == \"Manhattan Distance\":\n                score = np.sum(np.abs(embedding_1 - embedding_2))\n                similarity_score = {\"manhattan_distance\": score}\n\n        # Create a Data object to encapsulate the similarity score and additional information\n        similarity_data = Data(\n            data={\n                \"embedding_1\": embedding_vectors[0].data[\"embeddings\"],\n                \"embedding_2\": embedding_vectors[1].data[\"embeddings\"],\n                \"similarity_score\": similarity_score,\n            },\n            text_key=\"similarity_score\",\n        )\n\n        self.status = similarity_data\n        return similarity_data\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "similarity_metric": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Cosine Similarity",
    //                     "Euclidean Distance",
    //                     "Manhattan Distance"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "similarity_metric",
    //                 "value": "Cosine Similarity",
    //                 "display_name": "Similarity Metric",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Select the similarity metric to use.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             }
    //         },
    //         "description": "Compute selected form of similarity between two embedding vectors.",
    //         "icon": "equal",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Embedding Similarity",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "similarity_data",
    //                 "display_name": "Similarity Data",
    //                 "method": "compute_similarity",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "embedding_vectors",
    //             "similarity_metric"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AIMLEmbeddings": {
    //         "template": {
    //             "_type": "Component",
    //             "aiml_api_key": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "aiml_api_key",
    //                 "value": "AIML_API_KEY",
    //                 "display_name": "AI/ML API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.base.embeddings.model import LCEmbeddingsModel\nfrom langflow.base.models.aiml_constants import AIML_EMBEDDING_MODELS\nfrom langflow.components.embeddings.util import AIMLEmbeddingsImpl\nfrom langflow.field_typing import Embeddings\nfrom langflow.inputs.inputs import DropdownInput\nfrom langflow.io import SecretStrInput\n\n\nclass AIMLEmbeddingsComponent(LCEmbeddingsModel):\n    display_name = \"AI/ML Embeddings\"\n    description = \"Generate embeddings using the AI/ML API.\"\n    icon = \"AI/ML\"\n    name = \"AIMLEmbeddings\"\n\n    inputs = [\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            options=AIML_EMBEDDING_MODELS,\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"aiml_api_key\",\n            display_name=\"AI/ML API Key\",\n            value=\"AIML_API_KEY\",\n            required=True,\n        ),\n    ]\n\n    def build_embeddings(self) -> Embeddings:\n        return AIMLEmbeddingsImpl(\n            api_key=self.aiml_api_key,\n            model=self.model_name,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "model_name": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "text-embedding-3-large",
    //                     "text-embedding-3-small",
    //                     "text-embedding-ada-002",
    //                     "text-multilingual-embedding-002",
    //                     "textembedding-gecko-multilingual@001",
    //                     "textembedding-gecko@001",
    //                     "textembedding-gecko@003"
    //                 ],
    //                 "combobox": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_name",
    //                 "value": "",
    //                 "display_name": "Model Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             }
    //         },
    //         "description": "Generate embeddings using the AI/ML API.",
    //         "icon": "AI/ML",
    //         "base_classes": [
    //             "Embeddings"
    //         ],
    //         "display_name": "AI/ML Embeddings",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [
    //             "aiml"
    //         ],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Embeddings"
    //                 ],
    //                 "selected": "Embeddings",
    //                 "name": "embeddings",
    //                 "display_name": "Embeddings",
    //                 "method": "build_embeddings",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "aiml_api_key",
    //                     "model_name"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "model_name",
    //             "aiml_api_key"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AstraVectorize": {
    //         "template": {
    //             "_type": "Component",
    //             "api_key_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key_name",
    //                 "value": "",
    //                 "display_name": "API Key name",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The name of the embeddings provider API key stored on Astra. If set, it will override the 'ProviderKey' in the authentication parameters.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "authentication": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "authentication",
    //                 "value": {},
    //                 "display_name": "Authentication Parameters",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DictInput, DropdownInput, MessageTextInput, SecretStrInput\nfrom langflow.template.field.base import Output\n\n\nclass AstraVectorizeComponent(Component):\n    display_name: str = \"Astra Vectorize [DEPRECATED]\"\n    description: str = (\n        \"Configuration options for Astra Vectorize server-side embeddings. \"\n        \"This component is deprecated. Please use the Astra DB Component directly.\"\n    )\n    documentation: str = \"https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html\"\n    icon = \"AstraDB\"\n    name = \"AstraVectorize\"\n\n    VECTORIZE_PROVIDERS_MAPPING = {\n        \"Azure OpenAI\": [\"azureOpenAI\", [\"text-embedding-3-small\", \"text-embedding-3-large\", \"text-embedding-ada-002\"]],\n        \"Hugging Face - Dedicated\": [\"huggingfaceDedicated\", [\"endpoint-defined-model\"]],\n        \"Hugging Face - Serverless\": [\n            \"huggingface\",\n            [\n                \"sentence-transformers/all-MiniLM-L6-v2\",\n                \"intfloat/multilingual-e5-large\",\n                \"intfloat/multilingual-e5-large-instruct\",\n                \"BAAI/bge-small-en-v1.5\",\n                \"BAAI/bge-base-en-v1.5\",\n                \"BAAI/bge-large-en-v1.5\",\n            ],\n        ],\n        \"Jina AI\": [\n            \"jinaAI\",\n            [\n                \"jina-embeddings-v2-base-en\",\n                \"jina-embeddings-v2-base-de\",\n                \"jina-embeddings-v2-base-es\",\n                \"jina-embeddings-v2-base-code\",\n                \"jina-embeddings-v2-base-zh\",\n            ],\n        ],\n        \"Mistral AI\": [\"mistral\", [\"mistral-embed\"]],\n        \"NVIDIA\": [\"nvidia\", [\"NV-Embed-QA\"]],\n        \"OpenAI\": [\"openai\", [\"text-embedding-3-small\", \"text-embedding-3-large\", \"text-embedding-ada-002\"]],\n        \"Upstage\": [\"upstageAI\", [\"solar-embedding-1-large\"]],\n        \"Voyage AI\": [\n            \"voyageAI\",\n            [\"voyage-large-2-instruct\", \"voyage-law-2\", \"voyage-code-2\", \"voyage-large-2\", \"voyage-2\"],\n        ],\n    }\n    VECTORIZE_MODELS_STR = \"\\n\\n\".join(\n        [provider + \": \" + (\", \".join(models[1])) for provider, models in VECTORIZE_PROVIDERS_MAPPING.items()]\n    )\n\n    inputs = [\n        DropdownInput(\n            name=\"provider\",\n            display_name=\"Provider\",\n            options=VECTORIZE_PROVIDERS_MAPPING.keys(),\n            value=\"\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            info=\"The embedding model to use for the selected provider. Each provider has a different set of models \"\n            f\"available (full list at https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html):\\n\\n{VECTORIZE_MODELS_STR}\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"api_key_name\",\n            display_name=\"API Key name\",\n            info=\"The name of the embeddings provider API key stored on Astra. \"\n            \"If set, it will override the 'ProviderKey' in the authentication parameters.\",\n        ),\n        DictInput(\n            name=\"authentication\",\n            display_name=\"Authentication parameters\",\n            is_list=True,\n            advanced=True,\n        ),\n        SecretStrInput(\n            name=\"provider_api_key\",\n            display_name=\"Provider API Key\",\n            info=\"An alternative to the Astra Authentication that passes an API key for the provider with each request \"\n            \"to Astra DB. \"\n            \"This may be used when Vectorize is configured for the collection, \"\n            \"but no corresponding provider secret is stored within Astra's key management system.\",\n            advanced=True,\n        ),\n        DictInput(\n            name=\"authentication\",\n            display_name=\"Authentication Parameters\",\n            is_list=True,\n            advanced=True,\n        ),\n        DictInput(\n            name=\"model_parameters\",\n            display_name=\"Model Parameters\",\n            advanced=True,\n            is_list=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Vectorize\", name=\"config\", method=\"build_options\", types=[\"dict\"]),\n    ]\n\n    def build_options(self) -> dict[str, Any]:\n        provider_value = self.VECTORIZE_PROVIDERS_MAPPING[self.provider][0]\n        authentication = {**(self.authentication or {})}\n        api_key_name = self.api_key_name\n        if api_key_name:\n            authentication[\"providerKey\"] = api_key_name\n        return {\n            # must match astrapy.info.CollectionVectorServiceOptions\n            \"collection_vector_service_options\": {\n                \"provider\": provider_value,\n                \"modelName\": self.model_name,\n                \"authentication\": authentication,\n                \"parameters\": self.model_parameters or {},\n            },\n            \"collection_embedding_api_key\": self.provider_api_key,\n        }\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "model_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_name",
    //                 "value": "",
    //                 "display_name": "Model Name",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The embedding model to use for the selected provider. Each provider has a different set of models available (full list at https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html):\n\nAzure OpenAI: text-embedding-3-small, text-embedding-3-large, text-embedding-ada-002\n\nHugging Face - Dedicated: endpoint-defined-model\n\nHugging Face - Serverless: sentence-transformers/all-MiniLM-L6-v2, intfloat/multilingual-e5-large, intfloat/multilingual-e5-large-instruct, BAAI/bge-small-en-v1.5, BAAI/bge-base-en-v1.5, BAAI/bge-large-en-v1.5\n\nJina AI: jina-embeddings-v2-base-en, jina-embeddings-v2-base-de, jina-embeddings-v2-base-es, jina-embeddings-v2-base-code, jina-embeddings-v2-base-zh\n\nMistral AI: mistral-embed\n\nNVIDIA: NV-Embed-QA\n\nOpenAI: text-embedding-3-small, text-embedding-3-large, text-embedding-ada-002\n\nUpstage: solar-embedding-1-large\n\nVoyage AI: voyage-large-2-instruct, voyage-law-2, voyage-code-2, voyage-large-2, voyage-2",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "model_parameters": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_parameters",
    //                 "value": {},
    //                 "display_name": "Model Parameters",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "provider": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Azure OpenAI",
    //                     "Hugging Face - Dedicated",
    //                     "Hugging Face - Serverless",
    //                     "Jina AI",
    //                     "Mistral AI",
    //                     "NVIDIA",
    //                     "OpenAI",
    //                     "Upstage",
    //                     "Voyage AI"
    //                 ],
    //                 "combobox": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "provider",
    //                 "value": "",
    //                 "display_name": "Provider",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "provider_api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "provider_api_key",
    //                 "value": "",
    //                 "display_name": "Provider API Key",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "An alternative to the Astra Authentication that passes an API key for the provider with each request to Astra DB. This may be used when Vectorize is configured for the collection, but no corresponding provider secret is stored within Astra's key management system.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             }
    //         },
    //         "description": "Configuration options for Astra Vectorize server-side embeddings. This component is deprecated. Please use the Astra DB Component directly.",
    //         "icon": "AstraDB",
    //         "base_classes": [
    //             "dict"
    //         ],
    //         "display_name": "Astra Vectorize [DEPRECATED]",
    //         "documentation": "https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "dict"
    //                 ],
    //                 "selected": "dict",
    //                 "name": "config",
    //                 "display_name": "Vectorize",
    //                 "method": "build_options",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "provider",
    //             "model_name",
    //             "api_key_name",
    //             "authentication",
    //             "provider_api_key",
    //             "authentication",
    //             "model_parameters"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "Google Generative AI Embeddings": {
    //         "template": {
    //             "_type": "Component",
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "# from langflow.field_typing import Data\nimport numpy as np\n\n# TODO: remove ignore once the google package is published with types\nfrom google.ai.generativelanguage_v1beta.types import BatchEmbedContentsRequest\nfrom langchain_core.embeddings import Embeddings\nfrom langchain_google_genai import GoogleGenerativeAIEmbeddings\nfrom langchain_google_genai._common import GoogleGenerativeAIError\n\nfrom langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output, SecretStrInput\n\n\nclass GoogleGenerativeAIEmbeddingsComponent(Component):\n    display_name = \"Google Generative AI Embeddings\"\n    description = (\n        \"Connect to Google's generative AI embeddings service using the GoogleGenerativeAIEmbeddings class, \"\n        \"found in the langchain-google-genai package.\"\n    )\n    documentation: str = \"https://python.langchain.com/v0.2/docs/integrations/text_embedding/google_generative_ai/\"\n    icon = \"Google\"\n    name = \"Google Generative AI Embeddings\"\n\n    inputs = [\n        SecretStrInput(name=\"api_key\", display_name=\"API Key\"),\n        MessageTextInput(name=\"model_name\", display_name=\"Model Name\", value=\"models/text-embedding-004\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Embeddings\", name=\"embeddings\", method=\"build_embeddings\"),\n    ]\n\n    def build_embeddings(self) -> Embeddings:\n        if not self.api_key:\n            msg = \"API Key is required\"\n            raise ValueError(msg)\n\n        class HotaGoogleGenerativeAIEmbeddings(GoogleGenerativeAIEmbeddings):\n            def __init__(self, *args, **kwargs) -> None:\n                super(GoogleGenerativeAIEmbeddings, self).__init__(*args, **kwargs)\n\n            def embed_documents(\n                self,\n                texts: list[str],\n                *,\n                batch_size: int = 100,\n                task_type: str | None = None,\n                titles: list[str] | None = None,\n                output_dimensionality: int | None = 1536,\n            ) -> list[list[float]]:\n                \"\"\"Embed a list of strings.\n\n                Google Generative AI currently sets a max batch size of 100 strings.\n\n                Args:\n                    texts: List[str] The list of strings to embed.\n                    batch_size: [int] The batch size of embeddings to send to the model\n                    task_type: task_type (https://ai.google.dev/api/rest/v1/TaskType)\n                    titles: An optional list of titles for texts provided.\n                    Only applicable when TaskType is RETRIEVAL_DOCUMENT.\n                    output_dimensionality: Optional reduced dimension for the output embedding.\n                    https://ai.google.dev/api/rest/v1/models/batchEmbedContents#EmbedContentRequest\n                Returns:\n                    List of embeddings, one for each text.\n                \"\"\"\n                embeddings: list[list[float]] = []\n                batch_start_index = 0\n                for batch in GoogleGenerativeAIEmbeddings._prepare_batches(texts, batch_size):\n                    if titles:\n                        titles_batch = titles[batch_start_index : batch_start_index + len(batch)]\n                        batch_start_index += len(batch)\n                    else:\n                        titles_batch = [None] * len(batch)  # type: ignore[list-item]\n\n                    requests = [\n                        self._prepare_request(\n                            text=text,\n                            task_type=task_type,\n                            title=title,\n                            output_dimensionality=output_dimensionality,\n                        )\n                        for text, title in zip(batch, titles_batch, strict=True)\n                    ]\n\n                    try:\n                        result = self.client.batch_embed_contents(\n                            BatchEmbedContentsRequest(requests=requests, model=self.model)\n                        )\n                    except Exception as e:\n                        msg = f\"Error embedding content: {e}\"\n                        raise GoogleGenerativeAIError(msg) from e\n                    embeddings.extend([list(np.pad(e.values, (0, 768), \"constant\")) for e in result.embeddings])\n                return embeddings\n\n            def embed_query(\n                self,\n                text: str,\n                task_type: str | None = None,\n                title: str | None = None,\n                output_dimensionality: int | None = 1536,\n            ) -> list[float]:\n                \"\"\"Embed a text.\n\n                Args:\n                    text: The text to embed.\n                    task_type: task_type (https://ai.google.dev/api/rest/v1/TaskType)\n                    title: An optional title for the text.\n                    Only applicable when TaskType is RETRIEVAL_DOCUMENT.\n                    output_dimensionality: Optional reduced dimension for the output embedding.\n                    https://ai.google.dev/api/rest/v1/models/batchEmbedContents#EmbedContentRequest\n\n                Returns:\n                    Embedding for the text.\n                \"\"\"\n                task_type = task_type or \"RETRIEVAL_QUERY\"\n                return self.embed_documents(\n                    [text],\n                    task_type=task_type,\n                    titles=[title] if title else None,\n                    output_dimensionality=output_dimensionality,\n                )[0]\n\n        return HotaGoogleGenerativeAIEmbeddings(model=self.model_name, google_api_key=self.api_key)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "model_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_name",
    //                 "value": "models/text-embedding-004",
    //                 "display_name": "Model Name",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Connect to Google's generative AI embeddings service using the GoogleGenerativeAIEmbeddings class, found in the langchain-google-genai package.",
    //         "icon": "Google",
    //         "base_classes": [
    //             "Embeddings"
    //         ],
    //         "display_name": "Google Generative AI Embeddings",
    //         "documentation": "https://python.langchain.com/v0.2/docs/integrations/text_embedding/google_generative_ai/",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Embeddings"
    //                 ],
    //                 "selected": "Embeddings",
    //                 "name": "embeddings",
    //                 "display_name": "Embeddings",
    //                 "method": "build_embeddings",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "api_key",
    //             "model_name"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "OpenAIEmbeddings": {
    //         "template": {
    //             "_type": "Component",
    //             "chunk_size": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chunk_size",
    //                 "value": 1000,
    //                 "display_name": "Chunk Size",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "client": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "client",
    //                 "value": "",
    //                 "display_name": "Client",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_openai.embeddings.base import OpenAIEmbeddings\n\nfrom langflow.base.embeddings.model import LCEmbeddingsModel\nfrom langflow.base.models.openai_constants import OPENAI_EMBEDDING_MODEL_NAMES\nfrom langflow.field_typing import Embeddings\nfrom langflow.io import BoolInput, DictInput, DropdownInput, FloatInput, IntInput, MessageTextInput, SecretStrInput\n\n\nclass OpenAIEmbeddingsComponent(LCEmbeddingsModel):\n    display_name = \"OpenAI Embeddings\"\n    description = \"Generate embeddings using OpenAI models.\"\n    icon = \"OpenAI\"\n    name = \"OpenAIEmbeddings\"\n\n    inputs = [\n        DictInput(\n            name=\"default_headers\",\n            display_name=\"Default Headers\",\n            advanced=True,\n            info=\"Default headers to use for the API request.\",\n        ),\n        DictInput(\n            name=\"default_query\",\n            display_name=\"Default Query\",\n            advanced=True,\n            info=\"Default query parameters to use for the API request.\",\n        ),\n        IntInput(name=\"chunk_size\", display_name=\"Chunk Size\", advanced=True, value=1000),\n        MessageTextInput(name=\"client\", display_name=\"Client\", advanced=True),\n        MessageTextInput(name=\"deployment\", display_name=\"Deployment\", advanced=True),\n        IntInput(name=\"embedding_ctx_length\", display_name=\"Embedding Context Length\", advanced=True, value=1536),\n        IntInput(name=\"max_retries\", display_name=\"Max Retries\", value=3, advanced=True),\n        DropdownInput(\n            name=\"model\",\n            display_name=\"Model\",\n            advanced=False,\n            options=OPENAI_EMBEDDING_MODEL_NAMES,\n            value=\"text-embedding-3-small\",\n        ),\n        DictInput(name=\"model_kwargs\", display_name=\"Model Kwargs\", advanced=True),\n        SecretStrInput(name=\"openai_api_base\", display_name=\"OpenAI API Base\", advanced=True),\n        SecretStrInput(name=\"openai_api_key\", display_name=\"OpenAI API Key\", value=\"OPENAI_API_KEY\"),\n        SecretStrInput(name=\"openai_api_type\", display_name=\"OpenAI API Type\", advanced=True),\n        MessageTextInput(name=\"openai_api_version\", display_name=\"OpenAI API Version\", advanced=True),\n        MessageTextInput(\n            name=\"openai_organization\",\n            display_name=\"OpenAI Organization\",\n            advanced=True,\n        ),\n        MessageTextInput(name=\"openai_proxy\", display_name=\"OpenAI Proxy\", advanced=True),\n        FloatInput(name=\"request_timeout\", display_name=\"Request Timeout\", advanced=True),\n        BoolInput(name=\"show_progress_bar\", display_name=\"Show Progress Bar\", advanced=True),\n        BoolInput(name=\"skip_empty\", display_name=\"Skip Empty\", advanced=True),\n        MessageTextInput(\n            name=\"tiktoken_model_name\",\n            display_name=\"TikToken Model Name\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"tiktoken_enable\",\n            display_name=\"TikToken Enable\",\n            advanced=True,\n            value=True,\n            info=\"If False, you must have transformers installed.\",\n        ),\n        IntInput(\n            name=\"dimensions\",\n            display_name=\"Dimensions\",\n            info=\"The number of dimensions the resulting output embeddings should have. \"\n            \"Only supported by certain models.\",\n            advanced=True,\n        ),\n    ]\n\n    def build_embeddings(self) -> Embeddings:\n        return OpenAIEmbeddings(\n            tiktoken_enabled=self.tiktoken_enable,\n            default_headers=self.default_headers,\n            default_query=self.default_query,\n            allowed_special=\"all\",\n            disallowed_special=\"all\",\n            chunk_size=self.chunk_size,\n            deployment=self.deployment,\n            embedding_ctx_length=self.embedding_ctx_length,\n            max_retries=self.max_retries,\n            model=self.model,\n            model_kwargs=self.model_kwargs,\n            base_url=self.openai_api_base,\n            api_key=self.openai_api_key,\n            openai_api_type=self.openai_api_type,\n            api_version=self.openai_api_version,\n            organization=self.openai_organization,\n            openai_proxy=self.openai_proxy,\n            timeout=self.request_timeout or None,\n            show_progress_bar=self.show_progress_bar,\n            skip_empty=self.skip_empty,\n            tiktoken_model_name=self.tiktoken_model_name,\n            dimensions=self.dimensions or None,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "default_headers": {
    //                 "trace_as_input": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "default_headers",
    //                 "value": {},
    //                 "display_name": "Default Headers",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Default headers to use for the API request.",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "default_query": {
    //                 "trace_as_input": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "default_query",
    //                 "value": {},
    //                 "display_name": "Default Query",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Default query parameters to use for the API request.",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "deployment": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "deployment",
    //                 "value": "",
    //                 "display_name": "Deployment",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "dimensions": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "dimensions",
    //                 "value": "",
    //                 "display_name": "Dimensions",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The number of dimensions the resulting output embeddings should have. Only supported by certain models.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "embedding_ctx_length": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding_ctx_length",
    //                 "value": 1536,
    //                 "display_name": "Embedding Context Length",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "max_retries": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_retries",
    //                 "value": 3,
    //                 "display_name": "Max Retries",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "model": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "text-embedding-3-small",
    //                     "text-embedding-3-large",
    //                     "text-embedding-ada-002"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model",
    //                 "value": "text-embedding-3-small",
    //                 "display_name": "Model",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "model_kwargs": {
    //                 "trace_as_input": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_kwargs",
    //                 "value": {},
    //                 "display_name": "Model Kwargs",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "openai_api_base": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "openai_api_base",
    //                 "value": "",
    //                 "display_name": "OpenAI API Base",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "openai_api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "openai_api_key",
    //                 "value": "OPENAI_API_KEY",
    //                 "display_name": "OpenAI API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "openai_api_type": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "openai_api_type",
    //                 "value": "",
    //                 "display_name": "OpenAI API Type",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "openai_api_version": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "openai_api_version",
    //                 "value": "",
    //                 "display_name": "OpenAI API Version",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "openai_organization": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "openai_organization",
    //                 "value": "",
    //                 "display_name": "OpenAI Organization",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "openai_proxy": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "openai_proxy",
    //                 "value": "",
    //                 "display_name": "OpenAI Proxy",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "request_timeout": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "request_timeout",
    //                 "value": "",
    //                 "display_name": "Request Timeout",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "show_progress_bar": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "show_progress_bar",
    //                 "value": false,
    //                 "display_name": "Show Progress Bar",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "skip_empty": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "skip_empty",
    //                 "value": false,
    //                 "display_name": "Skip Empty",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "tiktoken_enable": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tiktoken_enable",
    //                 "value": true,
    //                 "display_name": "TikToken Enable",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "If False, you must have transformers installed.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "tiktoken_model_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tiktoken_model_name",
    //                 "value": "",
    //                 "display_name": "TikToken Model Name",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Generate embeddings using OpenAI models.",
    //         "icon": "OpenAI",
    //         "base_classes": [
    //             "Embeddings"
    //         ],
    //         "display_name": "OpenAI Embeddings",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Embeddings"
    //                 ],
    //                 "selected": "Embeddings",
    //                 "name": "embeddings",
    //                 "display_name": "Embeddings",
    //                 "method": "build_embeddings",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "chunk_size",
    //                     "default_headers",
    //                     "default_query",
    //                     "deployment",
    //                     "dimensions",
    //                     "embedding_ctx_length",
    //                     "max_retries",
    //                     "model",
    //                     "model_kwargs",
    //                     "openai_api_base",
    //                     "openai_api_key",
    //                     "openai_api_type",
    //                     "openai_api_version",
    //                     "openai_organization",
    //                     "openai_proxy",
    //                     "request_timeout",
    //                     "show_progress_bar",
    //                     "skip_empty",
    //                     "tiktoken_enable",
    //                     "tiktoken_model_name"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "default_headers",
    //             "default_query",
    //             "chunk_size",
    //             "client",
    //             "deployment",
    //             "embedding_ctx_length",
    //             "max_retries",
    //             "model",
    //             "model_kwargs",
    //             "openai_api_base",
    //             "openai_api_key",
    //             "openai_api_type",
    //             "openai_api_version",
    //             "openai_organization",
    //             "openai_proxy",
    //             "request_timeout",
    //             "show_progress_bar",
    //             "skip_empty",
    //             "tiktoken_model_name",
    //             "tiktoken_enable",
    //             "dimensions"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "LMStudioEmbeddingsComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "LMSTUDIO_API_KEY",
    //                 "display_name": "LM Studio API Key",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "base_url": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "base_url",
    //                 "value": "http://localhost:1234/v1",
    //                 "display_name": "LM Studio Base URL",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "refresh_button": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\nfrom urllib.parse import urljoin\n\nimport httpx\nfrom typing_extensions import override\n\nfrom langflow.base.embeddings.model import LCEmbeddingsModel\nfrom langflow.field_typing import Embeddings\nfrom langflow.inputs.inputs import DropdownInput, SecretStrInput\nfrom langflow.io import FloatInput, MessageTextInput\n\n\nclass LMStudioEmbeddingsComponent(LCEmbeddingsModel):\n    display_name: str = \"LM Studio Embeddings\"\n    description: str = \"Generate embeddings using LM Studio.\"\n    icon = \"LMStudio\"\n\n    @override\n    def update_build_config(self, build_config: dict, field_value: Any, field_name: str | None = None):\n        if field_name == \"model\":\n            base_url_dict = build_config.get(\"base_url\", {})\n            base_url_load_from_db = base_url_dict.get(\"load_from_db\", False)\n            base_url_value = base_url_dict.get(\"value\")\n            if base_url_load_from_db:\n                base_url_value = self.variables(base_url_value)\n            elif not base_url_value:\n                base_url_value = \"http://localhost:1234/v1\"\n            build_config[\"model\"][\"options\"] = self.get_model(base_url_value)\n\n        return build_config\n\n    def get_model(self, base_url_value: str) -> list[str]:\n        try:\n            url = urljoin(base_url_value, \"/v1/models\")\n            with httpx.Client() as client:\n                response = client.get(url)\n                response.raise_for_status()\n                data = response.json()\n\n                return [model[\"id\"] for model in data.get(\"data\", [])]\n        except Exception as e:\n            msg = \"Could not retrieve models. Please, make sure the LM Studio server is running.\"\n            raise ValueError(msg) from e\n\n    inputs = [\n        DropdownInput(\n            name=\"model\",\n            display_name=\"Model\",\n            advanced=False,\n            refresh_button=True,\n        ),\n        MessageTextInput(\n            name=\"base_url\",\n            display_name=\"LM Studio Base URL\",\n            refresh_button=True,\n            value=\"http://localhost:1234/v1\",\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"LM Studio API Key\",\n            advanced=True,\n            value=\"LMSTUDIO_API_KEY\",\n        ),\n        FloatInput(\n            name=\"temperature\",\n            display_name=\"Model Temperature\",\n            value=0.1,\n            advanced=True,\n        ),\n    ]\n\n    def build_embeddings(self) -> Embeddings:\n        try:\n            from langchain_nvidia_ai_endpoints import NVIDIAEmbeddings\n        except ImportError as e:\n            msg = \"Please install langchain-nvidia-ai-endpoints to use LM Studio Embeddings.\"\n            raise ImportError(msg) from e\n        try:\n            output = NVIDIAEmbeddings(\n                model=self.model,\n                base_url=self.base_url,\n                temperature=self.temperature,\n                nvidia_api_key=self.api_key,\n            )\n        except Exception as e:\n            msg = f\"Could not connect to LM Studio API. Error: {e}\"\n            raise ValueError(msg) from e\n        return output\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "model": {
    //                 "trace_as_metadata": true,
    //                 "options": [],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model",
    //                 "value": "",
    //                 "display_name": "Model",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "refresh_button": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "temperature": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "temperature",
    //                 "value": 0.1,
    //                 "display_name": "Model Temperature",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             }
    //         },
    //         "description": "Generate embeddings using LM Studio.",
    //         "icon": "LMStudio",
    //         "base_classes": [
    //             "Embeddings"
    //         ],
    //         "display_name": "LM Studio Embeddings",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Embeddings"
    //                 ],
    //                 "selected": "Embeddings",
    //                 "name": "embeddings",
    //                 "display_name": "Embeddings",
    //                 "method": "build_embeddings",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_key",
    //                     "base_url",
    //                     "model",
    //                     "temperature"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "model",
    //             "base_url",
    //             "api_key",
    //             "temperature"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AzureOpenAIEmbeddings": {
    //         "template": {
    //             "_type": "Component",
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "api_version": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "2022-12-01",
    //                     "2023-03-15-preview",
    //                     "2023-05-15",
    //                     "2023-06-01-preview",
    //                     "2023-07-01-preview",
    //                     "2023-08-01-preview"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_version",
    //                 "value": "2023-08-01-preview",
    //                 "display_name": "API Version",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "azure_deployment": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "azure_deployment",
    //                 "value": "",
    //                 "display_name": "Deployment Name",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "azure_endpoint": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "azure_endpoint",
    //                 "value": "",
    //                 "display_name": "Azure Endpoint",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Your Azure endpoint, including the resource. Example: `https://example-resource.azure.openai.com/`",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_openai import AzureOpenAIEmbeddings\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.base.models.openai_constants import OPENAI_EMBEDDING_MODEL_NAMES\nfrom langflow.field_typing import Embeddings\nfrom langflow.io import DropdownInput, IntInput, MessageTextInput, Output, SecretStrInput\n\n\nclass AzureOpenAIEmbeddingsComponent(LCModelComponent):\n    display_name: str = \"Azure OpenAI Embeddings\"\n    description: str = \"Generate embeddings using Azure OpenAI models.\"\n    documentation: str = \"https://python.langchain.com/docs/integrations/text_embedding/azureopenai\"\n    icon = \"Azure\"\n    name = \"AzureOpenAIEmbeddings\"\n\n    API_VERSION_OPTIONS = [\n        \"2022-12-01\",\n        \"2023-03-15-preview\",\n        \"2023-05-15\",\n        \"2023-06-01-preview\",\n        \"2023-07-01-preview\",\n        \"2023-08-01-preview\",\n    ]\n\n    inputs = [\n        DropdownInput(\n            name=\"model\",\n            display_name=\"Model\",\n            advanced=False,\n            options=OPENAI_EMBEDDING_MODEL_NAMES,\n            value=OPENAI_EMBEDDING_MODEL_NAMES[0],\n        ),\n        MessageTextInput(\n            name=\"azure_endpoint\",\n            display_name=\"Azure Endpoint\",\n            required=True,\n            info=\"Your Azure endpoint, including the resource. Example: `https://example-resource.azure.openai.com/`\",\n        ),\n        MessageTextInput(\n            name=\"azure_deployment\",\n            display_name=\"Deployment Name\",\n            required=True,\n        ),\n        DropdownInput(\n            name=\"api_version\",\n            display_name=\"API Version\",\n            options=API_VERSION_OPTIONS,\n            value=API_VERSION_OPTIONS[-1],\n            advanced=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"API Key\",\n            required=True,\n        ),\n        IntInput(\n            name=\"dimensions\",\n            display_name=\"Dimensions\",\n            info=\"The number of dimensions the resulting output embeddings should have. \"\n            \"Only supported by certain models.\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Embeddings\", name=\"embeddings\", method=\"build_embeddings\"),\n    ]\n\n    def build_embeddings(self) -> Embeddings:\n        try:\n            embeddings = AzureOpenAIEmbeddings(\n                model=self.model,\n                azure_endpoint=self.azure_endpoint,\n                azure_deployment=self.azure_deployment,\n                api_version=self.api_version,\n                api_key=self.api_key,\n                dimensions=self.dimensions or None,\n            )\n        except Exception as e:\n            msg = f\"Could not connect to AzureOpenAIEmbeddings API: {e}\"\n            raise ValueError(msg) from e\n\n        return embeddings\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "dimensions": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "dimensions",
    //                 "value": "",
    //                 "display_name": "Dimensions",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The number of dimensions the resulting output embeddings should have. Only supported by certain models.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "model": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "text-embedding-3-small",
    //                     "text-embedding-3-large",
    //                     "text-embedding-ada-002"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model",
    //                 "value": "text-embedding-3-small",
    //                 "display_name": "Model",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             }
    //         },
    //         "description": "Generate embeddings using Azure OpenAI models.",
    //         "icon": "Azure",
    //         "base_classes": [
    //             "Embeddings"
    //         ],
    //         "display_name": "Azure OpenAI Embeddings",
    //         "documentation": "https://python.langchain.com/docs/integrations/text_embedding/azureopenai",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Embeddings"
    //                 ],
    //                 "selected": "Embeddings",
    //                 "name": "embeddings",
    //                 "display_name": "Embeddings",
    //                 "method": "build_embeddings",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "model",
    //             "azure_endpoint",
    //             "azure_deployment",
    //             "api_version",
    //             "api_key",
    //             "dimensions"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "TextEmbedderComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding_model": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding_model",
    //                 "value": "",
    //                 "display_name": "Embedding Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The embedding model to use for generating embeddings.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import logging\nfrom typing import TYPE_CHECKING\n\nfrom langflow.custom import Component\nfrom langflow.io import HandleInput, MessageInput, Output\nfrom langflow.schema import Data\n\nif TYPE_CHECKING:\n    from langflow.field_typing import Embeddings\n    from langflow.schema.message import Message\n\n\nclass TextEmbedderComponent(Component):\n    display_name: str = \"Text Embedder\"\n    description: str = \"Generate embeddings for a given message using the specified embedding model.\"\n    icon = \"binary\"\n    inputs = [\n        HandleInput(\n            name=\"embedding_model\",\n            display_name=\"Embedding Model\",\n            info=\"The embedding model to use for generating embeddings.\",\n            input_types=[\"Embeddings\"],\n        ),\n        MessageInput(\n            name=\"message\",\n            display_name=\"Message\",\n            info=\"The message to generate embeddings for.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Embedding Data\", name=\"embeddings\", method=\"generate_embeddings\"),\n    ]\n\n    def generate_embeddings(self) -> Data:\n        try:\n            embedding_model: Embeddings = self.embedding_model\n            message: Message = self.message\n\n            # Validate embedding model\n            if not embedding_model:\n                msg = \"Embedding model not provided\"\n                raise ValueError(msg)\n\n            # Extract the text content from the message\n            text_content = message.text if message and message.text else \"\"\n            if not text_content:\n                msg = \"No text content found in message\"\n                raise ValueError(msg)\n\n            # Check if the embedding model has the required attributes\n            if not hasattr(embedding_model, \"client\") or not embedding_model.client:\n                msg = \"Embedding model client not properly initialized\"\n                raise ValueError(msg)\n\n            # Ensure the base URL has proper protocol\n            if hasattr(embedding_model.client, \"base_url\"):\n                base_url = embedding_model.client.base_url\n                if not base_url.startswith((\"http://\", \"https://\")):\n                    embedding_model.client.base_url = f\"https://{base_url}\"\n\n            # Generate embeddings using the provided embedding model\n            embeddings = embedding_model.embed_documents([text_content])\n\n            # Validate embeddings output\n            if not embeddings or not isinstance(embeddings, list):\n                msg = \"Invalid embeddings generated\"\n                raise ValueError(msg)\n\n            embedding_vector = embeddings[0]\n\n        except Exception as e:\n            logging.exception(\"Error generating embeddings\")\n            # Return empty data with error status\n            error_data = Data(data={\"text\": \"\", \"embeddings\": [], \"error\": str(e)})\n            self.status = {\"error\": str(e)}\n            return error_data\n\n        # Create a Data object to encapsulate the results\n        result_data = Data(data={\"text\": text_content, \"embeddings\": embedding_vector})\n        self.status = {\"text\": text_content, \"embeddings\": embedding_vector}\n        return result_data\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "message",
    //                 "value": "",
    //                 "display_name": "Message",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The message to generate embeddings for.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             }
    //         },
    //         "description": "Generate embeddings for a given message using the specified embedding model.",
    //         "icon": "binary",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Text Embedder",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "embeddings",
    //                 "display_name": "Embedding Data",
    //                 "method": "generate_embeddings",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "embedding_model",
    //             "message"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "CohereEmbeddings": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_community.embeddings.cohere import CohereEmbeddings\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import Embeddings\nfrom langflow.io import DropdownInput, FloatInput, IntInput, MessageTextInput, Output, SecretStrInput\n\n\nclass CohereEmbeddingsComponent(LCModelComponent):\n    display_name = \"Cohere Embeddings\"\n    description = \"Generate embeddings using Cohere models.\"\n    icon = \"Cohere\"\n    name = \"CohereEmbeddings\"\n\n    inputs = [\n        SecretStrInput(name=\"cohere_api_key\", display_name=\"Cohere API Key\"),\n        DropdownInput(\n            name=\"model\",\n            display_name=\"Model\",\n            advanced=True,\n            options=[\n                \"embed-english-v2.0\",\n                \"embed-multilingual-v2.0\",\n                \"embed-english-light-v2.0\",\n                \"embed-multilingual-light-v2.0\",\n            ],\n            value=\"embed-english-v2.0\",\n        ),\n        MessageTextInput(name=\"truncate\", display_name=\"Truncate\", advanced=True),\n        IntInput(name=\"max_retries\", display_name=\"Max Retries\", value=3, advanced=True),\n        MessageTextInput(name=\"user_agent\", display_name=\"User Agent\", advanced=True, value=\"langchain\"),\n        FloatInput(name=\"request_timeout\", display_name=\"Request Timeout\", advanced=True),\n    ]\n\n    outputs = [\n        Output(display_name=\"Embeddings\", name=\"embeddings\", method=\"build_embeddings\"),\n    ]\n\n    def build_embeddings(self) -> Embeddings:\n        return CohereEmbeddings(\n            cohere_api_key=self.cohere_api_key,\n            model=self.model,\n            truncate=self.truncate,\n            max_retries=self.max_retries,\n            user_agent=self.user_agent,\n            request_timeout=self.request_timeout or None,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "cohere_api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "cohere_api_key",
    //                 "value": "",
    //                 "display_name": "Cohere API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "max_retries": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_retries",
    //                 "value": 3,
    //                 "display_name": "Max Retries",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "model": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "embed-english-v2.0",
    //                     "embed-multilingual-v2.0",
    //                     "embed-english-light-v2.0",
    //                     "embed-multilingual-light-v2.0"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model",
    //                 "value": "embed-english-v2.0",
    //                 "display_name": "Model",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "request_timeout": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "request_timeout",
    //                 "value": "",
    //                 "display_name": "Request Timeout",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "truncate": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "truncate",
    //                 "value": "",
    //                 "display_name": "Truncate",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "user_agent": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "user_agent",
    //                 "value": "langchain",
    //                 "display_name": "User Agent",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Generate embeddings using Cohere models.",
    //         "icon": "Cohere",
    //         "base_classes": [
    //             "Embeddings"
    //         ],
    //         "display_name": "Cohere Embeddings",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Embeddings"
    //                 ],
    //                 "selected": "Embeddings",
    //                 "name": "embeddings",
    //                 "display_name": "Embeddings",
    //                 "method": "build_embeddings",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "cohere_api_key",
    //             "model",
    //             "truncate",
    //             "max_retries",
    //             "user_agent",
    //             "request_timeout"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "OllamaEmbeddings": {
    //         "template": {
    //             "_type": "Component",
    //             "base_url": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "base_url",
    //                 "value": "http://localhost:11434",
    //                 "display_name": "Ollama Base URL",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_community.embeddings import OllamaEmbeddings\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import Embeddings\nfrom langflow.io import FloatInput, MessageTextInput, Output\n\n\nclass OllamaEmbeddingsComponent(LCModelComponent):\n    display_name: str = \"Ollama Embeddings\"\n    description: str = \"Generate embeddings using Ollama models.\"\n    documentation = \"https://python.langchain.com/docs/integrations/text_embedding/ollama\"\n    icon = \"Ollama\"\n    name = \"OllamaEmbeddings\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"model\",\n            display_name=\"Ollama Model\",\n            value=\"llama3.1\",\n        ),\n        MessageTextInput(\n            name=\"base_url\",\n            display_name=\"Ollama Base URL\",\n            value=\"http://localhost:11434\",\n        ),\n        FloatInput(\n            name=\"temperature\",\n            display_name=\"Model Temperature\",\n            value=0.1,\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Embeddings\", name=\"embeddings\", method=\"build_embeddings\"),\n    ]\n\n    def build_embeddings(self) -> Embeddings:\n        try:\n            output = OllamaEmbeddings(\n                model=self.model,\n                base_url=self.base_url,\n                temperature=self.temperature,\n            )\n        except Exception as e:\n            msg = \"Could not connect to Ollama API.\"\n            raise ValueError(msg) from e\n        return output\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "model": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model",
    //                 "value": "llama3.1",
    //                 "display_name": "Ollama Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "temperature": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "temperature",
    //                 "value": 0.1,
    //                 "display_name": "Model Temperature",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             }
    //         },
    //         "description": "Generate embeddings using Ollama models.",
    //         "icon": "Ollama",
    //         "base_classes": [
    //             "Embeddings"
    //         ],
    //         "display_name": "Ollama Embeddings",
    //         "documentation": "https://python.langchain.com/docs/integrations/text_embedding/ollama",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Embeddings"
    //                 ],
    //                 "selected": "Embeddings",
    //                 "name": "embeddings",
    //                 "display_name": "Embeddings",
    //                 "method": "build_embeddings",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "model",
    //             "base_url",
    //             "temperature"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "langchain_utilities": {
    //     "FirecrawlCrawlApi": {
    //         "template": {
    //             "_type": "CustomComponent",
    //             "crawlerOptions": {
    //                 "type": "Data | None",
    //                 "required": false,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "crawlerOptions",
    //                 "display_name": "Crawler Options",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Options for the crawler behavior.",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "idempotency_key": {
    //                 "type": "str | None",
    //                 "required": false,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "idempotency_key",
    //                 "display_name": "Idempotency Key",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Optional idempotency key to ensure unique requests.",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "pageOptions": {
    //                 "type": "Data | None",
    //                 "required": false,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "pageOptions",
    //                 "display_name": "Page Options",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The page options to send with the request.",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "api_key": {
    //                 "type": "str",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": true,
    //                 "name": "api_key",
    //                 "display_name": "API Key",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The API key to use Firecrawl API.",
    //                 "load_from_db": false,
    //                 "title_case": false,
    //                 "input_types": [
    //                     "Text"
    //                 ]
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import uuid\n\nfrom langflow.custom import CustomComponent\nfrom langflow.schema import Data\n\n\nclass FirecrawlCrawlApi(CustomComponent):\n    display_name: str = \"FirecrawlCrawlApi\"\n    description: str = \"Firecrawl Crawl API.\"\n    name = \"FirecrawlCrawlApi\"\n\n    output_types: list[str] = [\"Document\"]\n    documentation: str = \"https://docs.firecrawl.dev/api-reference/endpoint/crawl\"\n    field_config = {\n        \"api_key\": {\n            \"display_name\": \"API Key\",\n            \"field_type\": \"str\",\n            \"required\": True,\n            \"password\": True,\n            \"info\": \"The API key to use Firecrawl API.\",\n        },\n        \"url\": {\n            \"display_name\": \"URL\",\n            \"field_type\": \"str\",\n            \"required\": True,\n            \"info\": \"The base URL to start crawling from.\",\n        },\n        \"timeout\": {\n            \"display_name\": \"Timeout\",\n            \"field_type\": \"int\",\n            \"info\": \"The timeout in milliseconds.\",\n        },\n        \"crawlerOptions\": {\n            \"display_name\": \"Crawler Options\",\n            \"info\": \"Options for the crawler behavior.\",\n        },\n        \"pageOptions\": {\n            \"display_name\": \"Page Options\",\n            \"info\": \"The page options to send with the request.\",\n        },\n        \"idempotency_key\": {\n            \"display_name\": \"Idempotency Key\",\n            \"field_type\": \"str\",\n            \"info\": \"Optional idempotency key to ensure unique requests.\",\n        },\n    }\n\n    def build(\n        self,\n        api_key: str,\n        url: str,\n        timeout: int = 30000,\n        crawlerOptions: Data | None = None,  # noqa: N803\n        pageOptions: Data | None = None,  # noqa: N803\n        idempotency_key: str | None = None,\n    ) -> Data:\n        try:\n            from firecrawl.firecrawl import FirecrawlApp\n        except ImportError as e:\n            msg = \"Could not import firecrawl integration package. Please install it with `pip install firecrawl-py`.\"\n            raise ImportError(msg) from e\n        crawler_options_dict = crawlerOptions.__dict__[\"data\"][\"text\"] if crawlerOptions else {}\n\n        page_options_dict = pageOptions.__dict__[\"data\"][\"text\"] if pageOptions else {}\n\n        if not idempotency_key:\n            idempotency_key = str(uuid.uuid4())\n\n        app = FirecrawlApp(api_key=api_key)\n        crawl_result = app.crawl_url(\n            url,\n            params={\n                \"crawlerOptions\": crawler_options_dict,\n                \"pageOptions\": page_options_dict,\n            },\n            wait_until_done=True,\n            poll_interval=int(timeout / 1000),\n            idempotency_key=idempotency_key,\n        )\n\n        return Data(data={\"results\": crawl_result})\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "timeout": {
    //                 "type": "int",
    //                 "required": false,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "value": 30000,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "timeout",
    //                 "display_name": "Timeout",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The timeout in milliseconds.",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "url": {
    //                 "type": "str",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "url",
    //                 "display_name": "URL",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The base URL to start crawling from.",
    //                 "load_from_db": false,
    //                 "title_case": false,
    //                 "input_types": [
    //                     "Text"
    //                 ]
    //             }
    //         },
    //         "description": "Firecrawl Crawl API.",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "FirecrawlCrawlApi",
    //         "documentation": "https://docs.firecrawl.dev/api-reference/endpoint/crawl",
    //         "custom_fields": {
    //             "api_key": null,
    //             "url": null,
    //             "timeout": null,
    //             "crawlerOptions": null,
    //             "pageOptions": null,
    //             "idempotency_key": null
    //         },
    //         "output_types": [
    //             "Data"
    //         ],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "hidden": null,
    //                 "display_name": "Data",
    //                 "method": null,
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": null
    //             }
    //         ],
    //         "field_order": [
    //             "api_key",
    //             "url",
    //             "timeout",
    //             "crawlerOptions",
    //             "pageOptions",
    //             "idempotency_key"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "SQLDatabase": {
    //         "template": {
    //             "_type": "CustomComponent",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_community.utilities.sql_database import SQLDatabase\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.pool import StaticPool\n\nfrom langflow.custom import CustomComponent\n\n\nclass SQLDatabaseComponent(CustomComponent):\n    display_name = \"SQLDatabase\"\n    description = \"SQL Database\"\n    name = \"SQLDatabase\"\n\n    def build_config(self):\n        return {\n            \"uri\": {\"display_name\": \"URI\", \"info\": \"URI to the database.\"},\n        }\n\n    def clean_up_uri(self, uri: str) -> str:\n        if uri.startswith(\"postgres://\"):\n            uri = uri.replace(\"postgres://\", \"postgresql://\")\n        return uri.strip()\n\n    def build(self, uri: str) -> SQLDatabase:\n        uri = self.clean_up_uri(uri)\n        # Create an engine using SQLAlchemy with StaticPool\n        engine = create_engine(uri, poolclass=StaticPool)\n        return SQLDatabase(engine)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "uri": {
    //                 "type": "str",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "uri",
    //                 "display_name": "URI",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "URI to the database.",
    //                 "load_from_db": false,
    //                 "title_case": false,
    //                 "input_types": [
    //                     "Text"
    //                 ]
    //             }
    //         },
    //         "description": "SQL Database",
    //         "base_classes": [
    //             "object",
    //             "SQLDatabase"
    //         ],
    //         "display_name": "SQLDatabase",
    //         "documentation": "",
    //         "custom_fields": {
    //             "uri": null
    //         },
    //         "output_types": [
    //             "SQLDatabase"
    //         ],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "SQLDatabase"
    //                 ],
    //                 "selected": "SQLDatabase",
    //                 "name": "sqldatabase",
    //                 "hidden": null,
    //                 "display_name": "SQLDatabase",
    //                 "method": null,
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": null
    //             }
    //         ],
    //         "field_order": [],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "FirecrawlScrapeApi": {
    //         "template": {
    //             "_type": "CustomComponent",
    //             "extractorOptions": {
    //                 "type": "Data | None",
    //                 "required": false,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "extractorOptions",
    //                 "display_name": "Extractor Options",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The extractor options to send with the request.",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "pageOptions": {
    //                 "type": "Data | None",
    //                 "required": false,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "pageOptions",
    //                 "display_name": "Page Options",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The page options to send with the request.",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "api_key": {
    //                 "type": "str",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": true,
    //                 "name": "api_key",
    //                 "display_name": "API Key",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The API key to use Firecrawl API.",
    //                 "load_from_db": false,
    //                 "title_case": false,
    //                 "input_types": [
    //                     "Text"
    //                 ]
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.custom import CustomComponent\nfrom langflow.schema import Data\n\n\nclass FirecrawlScrapeApi(CustomComponent):\n    display_name: str = \"FirecrawlScrapeApi\"\n    description: str = \"Firecrawl Scrape API.\"\n    name = \"FirecrawlScrapeApi\"\n\n    output_types: list[str] = [\"Document\"]\n    documentation: str = \"https://docs.firecrawl.dev/api-reference/endpoint/scrape\"\n    field_config = {\n        \"api_key\": {\n            \"display_name\": \"API Key\",\n            \"field_type\": \"str\",\n            \"required\": True,\n            \"password\": True,\n            \"info\": \"The API key to use Firecrawl API.\",\n        },\n        \"url\": {\n            \"display_name\": \"URL\",\n            \"field_type\": \"str\",\n            \"required\": True,\n            \"info\": \"The URL to scrape.\",\n        },\n        \"timeout\": {\n            \"display_name\": \"Timeout\",\n            \"info\": \"Timeout in milliseconds for the request.\",\n            \"field_type\": \"int\",\n            \"default_value\": 10000,\n        },\n        \"pageOptions\": {\n            \"display_name\": \"Page Options\",\n            \"info\": \"The page options to send with the request.\",\n        },\n        \"extractorOptions\": {\n            \"display_name\": \"Extractor Options\",\n            \"info\": \"The extractor options to send with the request.\",\n        },\n    }\n\n    def build(\n        self,\n        api_key: str,\n        url: str,\n        timeout: int = 10000,\n        pageOptions: Data | None = None,  # noqa: N803\n        extractorOptions: Data | None = None,  # noqa: N803\n    ) -> Data:\n        try:\n            from firecrawl.firecrawl import FirecrawlApp\n        except ImportError as e:\n            msg = \"Could not import firecrawl integration package. Please install it with `pip install firecrawl-py`.\"\n            raise ImportError(msg) from e\n        extractor_options_dict = extractorOptions.__dict__[\"data\"][\"text\"] if extractorOptions else {}\n\n        page_options_dict = pageOptions.__dict__[\"data\"][\"text\"] if pageOptions else {}\n\n        app = FirecrawlApp(api_key=api_key)\n        results = app.scrape_url(\n            url,\n            {\n                \"timeout\": str(timeout),\n                \"extractorOptions\": extractor_options_dict,\n                \"pageOptions\": page_options_dict,\n            },\n        )\n\n        return Data(data=results)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "timeout": {
    //                 "type": "int",
    //                 "required": false,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "value": 10000,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "timeout",
    //                 "display_name": "Timeout",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Timeout in milliseconds for the request.",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "url": {
    //                 "type": "str",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "url",
    //                 "display_name": "URL",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The URL to scrape.",
    //                 "load_from_db": false,
    //                 "title_case": false,
    //                 "input_types": [
    //                     "Text"
    //                 ]
    //             }
    //         },
    //         "description": "Firecrawl Scrape API.",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "FirecrawlScrapeApi",
    //         "documentation": "https://docs.firecrawl.dev/api-reference/endpoint/scrape",
    //         "custom_fields": {
    //             "api_key": null,
    //             "url": null,
    //             "timeout": null,
    //             "pageOptions": null,
    //             "extractorOptions": null
    //         },
    //         "output_types": [
    //             "Data"
    //         ],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "hidden": null,
    //                 "display_name": "Data",
    //                 "method": null,
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": null
    //             }
    //         ],
    //         "field_order": [
    //             "api_key",
    //             "url",
    //             "timeout",
    //             "pageOptions",
    //             "extractorOptions"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "SpiderTool": {
    //         "template": {
    //             "_type": "Component",
    //             "blacklist": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "blacklist",
    //                 "value": "",
    //                 "display_name": "Blacklist",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Blacklist paths that you do not want to crawl. Use Regex patterns.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from spider.spider import Spider\n\nfrom langflow.base.langchain_utilities.spider_constants import MODES\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    DictInput,\n    DropdownInput,\n    IntInput,\n    Output,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\n\n\nclass SpiderTool(Component):\n    display_name: str = \"Spider Web Crawler & Scraper\"\n    description: str = \"Spider API for web crawling and scraping.\"\n    output_types: list[str] = [\"Document\"]\n    documentation: str = \"https://spider.cloud/docs/api\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"spider_api_key\",\n            display_name=\"Spider API Key\",\n            required=True,\n            password=True,\n            info=\"The Spider API Key, get it from https://spider.cloud\",\n        ),\n        StrInput(\n            name=\"url\",\n            display_name=\"URL\",\n            required=True,\n            info=\"The URL to scrape or crawl\",\n        ),\n        DropdownInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            required=True,\n            options=MODES,\n            value=MODES[0],\n            info=\"The mode of operation: scrape or crawl\",\n        ),\n        IntInput(\n            name=\"limit\",\n            display_name=\"Limit\",\n            info=\"The maximum amount of pages allowed to crawl per website. Set to 0 to crawl all pages.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"depth\",\n            display_name=\"Depth\",\n            info=\"The crawl limit for maximum depth. If 0, no limit will be applied.\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"blacklist\",\n            display_name=\"Blacklist\",\n            info=\"Blacklist paths that you do not want to crawl. Use Regex patterns.\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"whitelist\",\n            display_name=\"Whitelist\",\n            info=\"Whitelist paths that you want to crawl, ignoring all other routes. Use Regex patterns.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"readability\",\n            display_name=\"Use Readability\",\n            info=\"Use readability to pre-process the content for reading.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"request_timeout\",\n            display_name=\"Request Timeout\",\n            info=\"Timeout for the request in seconds.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"metadata\",\n            display_name=\"Metadata\",\n            info=\"Include metadata in the response.\",\n            advanced=True,\n        ),\n        DictInput(\n            name=\"params\",\n            display_name=\"Additional Parameters\",\n            info=\"Additional parameters to pass to the API. If provided, other inputs will be ignored.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Markdown\", name=\"content\", method=\"crawl\"),\n    ]\n\n    def crawl(self) -> list[Data]:\n        if self.params:\n            parameters = self.params[\"data\"]\n        else:\n            parameters = {\n                \"limit\": self.limit or None,\n                \"depth\": self.depth or None,\n                \"blacklist\": self.blacklist or None,\n                \"whitelist\": self.whitelist or None,\n                \"readability\": self.readability,\n                \"request_timeout\": self.request_timeout or None,\n                \"metadata\": self.metadata,\n                \"return_format\": \"markdown\",\n            }\n\n        app = Spider(api_key=self.spider_api_key)\n        if self.mode == \"scrape\":\n            parameters[\"limit\"] = 1\n            result = app.scrape_url(self.url, parameters)\n        elif self.mode == \"crawl\":\n            result = app.crawl_url(self.url, parameters)\n        else:\n            msg = f\"Invalid mode: {self.mode}. Must be 'scrape' or 'crawl'.\"\n            raise ValueError(msg)\n\n        records = []\n\n        for record in result:\n            if self.metadata:\n                records.append(\n                    Data(\n                        data={\n                            \"content\": record[\"content\"],\n                            \"url\": record[\"url\"],\n                            \"metadata\": record[\"metadata\"],\n                        }\n                    )\n                )\n            else:\n                records.append(Data(data={\"content\": record[\"content\"], \"url\": record[\"url\"]}))\n        return records\n\n\nclass SpiderToolError(Exception):\n    \"\"\"SpiderTool error.\"\"\"\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "depth": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "depth",
    //                 "value": "",
    //                 "display_name": "Depth",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The crawl limit for maximum depth. If 0, no limit will be applied.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "limit": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "limit",
    //                 "value": "",
    //                 "display_name": "Limit",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The maximum amount of pages allowed to crawl per website. Set to 0 to crawl all pages.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "metadata": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "metadata",
    //                 "value": false,
    //                 "display_name": "Metadata",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Include metadata in the response.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "mode": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "scrape",
    //                     "crawl"
    //                 ],
    //                 "combobox": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "mode",
    //                 "value": "scrape",
    //                 "display_name": "Mode",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The mode of operation: scrape or crawl",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "params": {
    //                 "trace_as_input": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "params",
    //                 "value": {},
    //                 "display_name": "Additional Parameters",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Additional parameters to pass to the API. If provided, other inputs will be ignored.",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "readability": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "readability",
    //                 "value": false,
    //                 "display_name": "Use Readability",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Use readability to pre-process the content for reading.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "request_timeout": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "request_timeout",
    //                 "value": "",
    //                 "display_name": "Request Timeout",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Timeout for the request in seconds.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "spider_api_key": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "spider_api_key",
    //                 "value": "",
    //                 "display_name": "Spider API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The Spider API Key, get it from https://spider.cloud",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "url": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "url",
    //                 "value": "",
    //                 "display_name": "URL",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The URL to scrape or crawl",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "whitelist": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "whitelist",
    //                 "value": "",
    //                 "display_name": "Whitelist",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Whitelist paths that you want to crawl, ignoring all other routes. Use Regex patterns.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Spider API for web crawling and scraping.",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Spider Web Crawler & Scraper",
    //         "documentation": "https://spider.cloud/docs/api",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "content",
    //                 "display_name": "Markdown",
    //                 "method": "crawl",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "spider_api_key",
    //             "url",
    //             "mode",
    //             "limit",
    //             "depth",
    //             "blacklist",
    //             "whitelist",
    //             "readability",
    //             "request_timeout",
    //             "metadata",
    //             "params"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "JSONDocumentBuilder": {
    //         "template": {
    //             "_type": "CustomComponent",
    //             "document": {
    //                 "type": "Document",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "document",
    //                 "display_name": "Document",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "# JSON Document Builder\n\n# Build a Document containing a JSON object using a key and another Document page content.\n\n# **Params**\n\n# - **Key:** The key to use for the JSON object.\n# - **Document:** The Document page to use for the JSON object.\n\n# **Output**\n\n# - **Document:** The Document containing the JSON object.\n\nfrom langchain_core.documents import Document\n\nfrom langflow.custom import CustomComponent\nfrom langflow.services.database.models.base import orjson_dumps\n\n\nclass JSONDocumentBuilder(CustomComponent):\n    display_name: str = \"JSON Document Builder\"\n    description: str = \"Build a Document containing a JSON object using a key and another Document page content.\"\n    name = \"JSONDocumentBuilder\"\n\n    output_types: list[str] = [\"Document\"]\n    documentation: str = \"https://docs.langflow.org/components/utilities#json-document-builder\"\n\n    field_config = {\n        \"key\": {\"display_name\": \"Key\"},\n        \"document\": {\"display_name\": \"Document\"},\n    }\n\n    def build(\n        self,\n        key: str,\n        document: Document,\n    ) -> Document:\n        documents = None\n        if isinstance(document, list):\n            documents = [\n                Document(page_content=orjson_dumps({key: doc.page_content}, indent_2=False)) for doc in document\n            ]\n        elif isinstance(document, Document):\n            documents = Document(page_content=orjson_dumps({key: document.page_content}, indent_2=False))\n        else:\n            msg = f\"Expected Document or list of Documents, got {type(document)}\"\n            raise TypeError(msg)\n        self.repr_value = documents\n        return documents\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "key": {
    //                 "type": "str",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "key",
    //                 "display_name": "Key",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false,
    //                 "input_types": [
    //                     "Text"
    //                 ]
    //             }
    //         },
    //         "description": "Build a Document containing a JSON object using a key and another Document page content.",
    //         "base_classes": [
    //             "BaseMedia",
    //             "Document",
    //             "Serializable"
    //         ],
    //         "display_name": "JSON Document Builder",
    //         "documentation": "https://docs.langflow.org/components/utilities#json-document-builder",
    //         "custom_fields": {
    //             "key": null,
    //             "document": null
    //         },
    //         "output_types": [
    //             "Document"
    //         ],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Document"
    //                 ],
    //                 "selected": "Document",
    //                 "name": "document",
    //                 "hidden": null,
    //                 "display_name": "Document",
    //                 "method": null,
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": null
    //             }
    //         ],
    //         "field_order": [
    //             "key",
    //             "document"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "documentloaders": {
    //     "GitLoader": {
    //         "template": {
    //             "_type": "Component",
    //             "branch": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "branch",
    //                 "value": "main",
    //                 "display_name": "Branch",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The branch to load files from. Defaults to 'main'.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "clone_url": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "clone_url",
    //                 "value": "",
    //                 "display_name": "Clone URL",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The URL to clone the Git repository from.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import re\nfrom pathlib import Path\n\nfrom langchain_community.document_loaders.git import GitLoader\n\nfrom langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema import Data\n\n\nclass GitLoaderComponent(Component):\n    display_name = \"GitLoader\"\n    description = \"Load files from a Git repository\"\n    documentation = \"https://python.langchain.com/v0.2/docs/integrations/document_loaders/git/\"\n    trace_type = \"tool\"\n    icon = \"GitLoader\"\n    name = \"GitLoader\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"repo_path\",\n            display_name=\"Repository Path\",\n            required=True,\n            info=\"The local path to the Git repository.\",\n        ),\n        MessageTextInput(\n            name=\"clone_url\",\n            display_name=\"Clone URL\",\n            required=False,\n            info=\"The URL to clone the Git repository from.\",\n        ),\n        MessageTextInput(\n            name=\"branch\",\n            display_name=\"Branch\",\n            required=False,\n            value=\"main\",\n            info=\"The branch to load files from. Defaults to 'main'.\",\n        ),\n        MessageTextInput(\n            name=\"file_filter\",\n            display_name=\"File Filter\",\n            required=False,\n            advanced=True,\n            info=\"A list of patterns to filter files. Example to include only .py files: '*.py'. \"\n            \"Example to exclude .py files: '!*.py'. Multiple patterns can be separated by commas.\",\n        ),\n        MessageTextInput(\n            name=\"content_filter\",\n            display_name=\"Content Filter\",\n            required=False,\n            advanced=True,\n            info=\"A regex pattern to filter files based on their content.\",\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"data\", display_name=\"Data\", method=\"load_documents\"),\n    ]\n\n    @staticmethod\n    def is_binary(file_path: str) -> bool:\n        \"\"\"Check if a file is binary by looking for null bytes.\n\n        This is necessary because when searches are performed using\n        the content_filter, binary files need to be ignored.\n        \"\"\"\n        with Path(file_path).open(\"rb\") as file:\n            return b\"\\x00\" in file.read(1024)\n\n    def build_gitloader(self) -> GitLoader:\n        file_filter_patterns = getattr(self, \"file_filter\", None)\n        content_filter_pattern = getattr(self, \"content_filter\", None)\n\n        file_filters = []\n        if file_filter_patterns:\n            patterns = [pattern.strip() for pattern in file_filter_patterns.split(\",\")]\n\n            def file_filter(file_path: Path) -> bool:\n                if len(patterns) == 1 and patterns[0].startswith(\"!\"):\n                    return not file_path.match(patterns[0][1:])\n                included = any(file_path.match(pattern) for pattern in patterns if not pattern.startswith(\"!\"))\n                excluded = any(file_path.match(pattern[1:]) for pattern in patterns if pattern.startswith(\"!\"))\n                return included and not excluded\n\n            file_filters.append(file_filter)\n\n        if content_filter_pattern:\n            content_regex = re.compile(content_filter_pattern)\n\n            def content_filter(file_path: Path) -> bool:\n                content = file_path.read_text(encoding=\"utf-8\", errors=\"ignore\")\n                return bool(content_regex.search(content))\n\n            file_filters.append(content_filter)\n\n        def combined_filter(file_path: str) -> bool:\n            path = Path(file_path)\n            if self.is_binary(file_path):\n                return False\n            return all(f(path) for f in file_filters)\n\n        return GitLoader(\n            repo_path=self.repo_path,\n            clone_url=self.clone_url,\n            branch=self.branch,\n            file_filter=combined_filter,\n        )\n\n    def load_documents(self) -> list[Data]:\n        gitloader = self.build_gitloader()\n        documents = list(gitloader.lazy_load())\n        data = [Data.from_document(doc) for doc in documents]\n        self.status = data\n        return data\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "content_filter": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "content_filter",
    //                 "value": "",
    //                 "display_name": "Content Filter",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "A regex pattern to filter files based on their content.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "file_filter": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "file_filter",
    //                 "value": "",
    //                 "display_name": "File Filter",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "A list of patterns to filter files. Example to include only .py files: '*.py'. Example to exclude .py files: '!*.py'. Multiple patterns can be separated by commas.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "repo_path": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "repo_path",
    //                 "value": "",
    //                 "display_name": "Repository Path",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The local path to the Git repository.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Load files from a Git repository",
    //         "icon": "GitLoader",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "GitLoader",
    //         "documentation": "https://python.langchain.com/v0.2/docs/integrations/document_loaders/git/",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "display_name": "Data",
    //                 "method": "load_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "repo_path",
    //             "clone_url",
    //             "branch",
    //             "file_filter",
    //             "content_filter"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "Confluence": {
    //         "template": {
    //             "_type": "Component",
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Atlassian Key. Create at: https://id.atlassian.com/manage-profile/security/api-tokens",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "cloud": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "cloud",
    //                 "value": true,
    //                 "display_name": "Use Cloud?",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_community.document_loaders import ConfluenceLoader\nfrom langchain_community.document_loaders.confluence import ContentFormat\n\nfrom langflow.custom import Component\nfrom langflow.io import BoolInput, DropdownInput, IntInput, Output, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass ConfluenceComponent(Component):\n    display_name = \"Confluence\"\n    description = \"Confluence wiki collaboration platform\"\n    documentation = \"https://python.langchain.com/v0.2/docs/integrations/document_loaders/confluence/\"\n    trace_type = \"tool\"\n    icon = \"Confluence\"\n    name = \"Confluence\"\n\n    inputs = [\n        StrInput(\n            name=\"url\",\n            display_name=\"Site URL\",\n            required=True,\n            info=\"The base URL of the Confluence Space. Example: https://<company>.atlassian.net/wiki.\",\n        ),\n        StrInput(\n            name=\"username\",\n            display_name=\"Username\",\n            required=True,\n            info=\"Atlassian User E-mail. Example: email@example.com\",\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"API Key\",\n            required=True,\n            info=\"Atlassian Key. Create at: https://id.atlassian.com/manage-profile/security/api-tokens\",\n        ),\n        StrInput(name=\"space_key\", display_name=\"Space Key\", required=True),\n        BoolInput(name=\"cloud\", display_name=\"Use Cloud?\", required=True, value=True, advanced=True),\n        DropdownInput(\n            name=\"content_format\",\n            display_name=\"Content Format\",\n            options=[\n                ContentFormat.EDITOR.value,\n                ContentFormat.EXPORT_VIEW.value,\n                ContentFormat.ANONYMOUS_EXPORT_VIEW.value,\n                ContentFormat.STORAGE.value,\n                ContentFormat.VIEW.value,\n            ],\n            value=ContentFormat.STORAGE.value,\n            required=True,\n            advanced=True,\n            info=\"Specify content format, defaults to ContentFormat.STORAGE\",\n        ),\n        IntInput(\n            name=\"max_pages\",\n            display_name=\"Max Pages\",\n            required=False,\n            value=1000,\n            advanced=True,\n            info=\"Maximum number of pages to retrieve in total, defaults 1000\",\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"data\", display_name=\"Data\", method=\"load_documents\"),\n    ]\n\n    def build_confluence(self) -> ConfluenceLoader:\n        content_format = ContentFormat(self.content_format)\n        return ConfluenceLoader(\n            url=self.url,\n            username=self.username,\n            api_key=self.api_key,\n            cloud=self.cloud,\n            space_key=self.space_key,\n            content_format=content_format,\n            max_pages=self.max_pages,\n        )\n\n    def load_documents(self) -> list[Data]:\n        confluence = self.build_confluence()\n        documents = confluence.load()\n        data = [Data.from_document(doc) for doc in documents]  # Using the from_document method of Data\n        self.status = data\n        return data\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "content_format": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "body.editor",
    //                     "body.export_view",
    //                     "body.anonymous_export_view",
    //                     "body.storage",
    //                     "body.view"
    //                 ],
    //                 "combobox": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "content_format",
    //                 "value": "body.storage",
    //                 "display_name": "Content Format",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Specify content format, defaults to ContentFormat.STORAGE",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "max_pages": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_pages",
    //                 "value": 1000,
    //                 "display_name": "Max Pages",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Maximum number of pages to retrieve in total, defaults 1000",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "space_key": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "space_key",
    //                 "value": "",
    //                 "display_name": "Space Key",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "url": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "url",
    //                 "value": "",
    //                 "display_name": "Site URL",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The base URL of the Confluence Space. Example: https://<company>.atlassian.net/wiki.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "username": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "username",
    //                 "value": "",
    //                 "display_name": "Username",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Atlassian User E-mail. Example: email@example.com",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Confluence wiki collaboration platform",
    //         "icon": "Confluence",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Confluence",
    //         "documentation": "https://python.langchain.com/v0.2/docs/integrations/document_loaders/confluence/",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "display_name": "Data",
    //                 "method": "load_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "url",
    //             "username",
    //             "api_key",
    //             "space_key",
    //             "cloud",
    //             "content_format",
    //             "max_pages"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "Unstructured": {
    //         "template": {
    //             "_type": "Component",
    //             "file": {
    //                 "trace_as_metadata": true,
    //                 "file_path": "",
    //                 "fileTypes": [
    //                     "pdf",
    //                     "docx",
    //                     "txt"
    //                 ],
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "file",
    //                 "value": "",
    //                 "display_name": "File",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The path to the file with which you want to use Unstructured to parse. Supports: PDF, DOCX, TXT",
    //                 "title_case": false,
    //                 "type": "file",
    //                 "_input_type": "FileInput"
    //             },
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "Unstructured.io Serverless API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Unstructured API Key. Create at: https://app.unstructured.io/",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_unstructured import UnstructuredLoader\n\nfrom langflow.custom import Component\nfrom langflow.inputs import FileInput, SecretStrInput\nfrom langflow.schema import Data\nfrom langflow.template import Output\n\n\nclass UnstructuredComponent(Component):\n    display_name = \"Unstructured\"\n    description = \"Uses Unstructured.io to extract clean text from raw source documents. Supports: PDF, DOCX, TXT\"\n    documentation = \"https://python.langchain.com/v0.2/docs/integrations/providers/unstructured/\"\n    trace_type = \"tool\"\n    icon = \"Unstructured\"\n    name = \"Unstructured\"\n\n    inputs = [\n        FileInput(\n            name=\"file\",\n            display_name=\"File\",\n            required=True,\n            info=\"The path to the file with which you want to use Unstructured to parse. Supports: PDF, DOCX, TXT\",\n            file_types=[\"pdf\", \"docx\", \"txt\"],  # TODO: Support all unstructured file types\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Unstructured.io Serverless API Key\",\n            required=True,\n            info=\"Unstructured API Key. Create at: https://app.unstructured.io/\",\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"data\", display_name=\"Data\", method=\"load_documents\"),\n    ]\n\n    def build_unstructured(self) -> UnstructuredLoader:\n        file_paths = [self.file]\n\n        return UnstructuredLoader(\n            file_paths,\n            api_key=self.api_key,\n            partition_via_api=True,\n        )\n\n    def load_documents(self) -> list[Data]:\n        unstructured = self.build_unstructured()\n\n        documents = unstructured.load()\n        data = [Data.from_document(doc) for doc in documents]  # Using the from_document method of Data\n\n        self.status = data\n\n        return data\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             }
    //         },
    //         "description": "Uses Unstructured.io to extract clean text from raw source documents. Supports: PDF, DOCX, TXT",
    //         "icon": "Unstructured",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Unstructured",
    //         "documentation": "https://python.langchain.com/v0.2/docs/integrations/providers/unstructured/",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "display_name": "Data",
    //                 "method": "load_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "file",
    //             "api_key"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "agents": {
    //     "SequentialTaskAgentComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "llm",
    //                 "value": "",
    //                 "display_name": "Language Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "LanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Language model that will run the agent.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "previous_task": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "previous_task",
    //                 "value": "",
    //                 "display_name": "Previous Task",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "SequentialTask"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The previous task in the sequence (for chaining).",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "tools": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tools",
    //                 "value": [],
    //                 "display_name": "Tools",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Tool"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Tools at agent's disposal",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "agent_kwargs": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "agent_kwargs",
    //                 "value": {},
    //                 "display_name": "Agent kwargs",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Additional kwargs for the agent.",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "allow_code_execution": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "allow_code_execution",
    //                 "value": false,
    //                 "display_name": "Allow Code Execution",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Whether the agent is allowed to execute code.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "allow_delegation": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "allow_delegation",
    //                 "value": false,
    //                 "display_name": "Allow Delegation",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Whether the agent is allowed to delegate tasks to other agents.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "async_execution": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "async_execution",
    //                 "value": false,
    //                 "display_name": "Async Execution",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Boolean flag indicating asynchronous task execution.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "backstory": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "backstory",
    //                 "value": "",
    //                 "display_name": "Backstory",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The backstory of the agent.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from crewai import Agent, Task\n\nfrom langflow.base.agents.crewai.tasks import SequentialTask\nfrom langflow.custom import Component\nfrom langflow.io import BoolInput, DictInput, HandleInput, MultilineInput, Output\n\n\nclass SequentialTaskAgentComponent(Component):\n    display_name = \"Sequential Task Agent\"\n    description = \"Creates a CrewAI Task and its associated Agent.\"\n    documentation = \"https://docs.crewai.com/how-to/LLM-Connections/\"\n    icon = \"CrewAI\"\n\n    inputs = [\n        # Agent inputs\n        MultilineInput(name=\"role\", display_name=\"Role\", info=\"The role of the agent.\"),\n        MultilineInput(name=\"goal\", display_name=\"Goal\", info=\"The objective of the agent.\"),\n        MultilineInput(\n            name=\"backstory\",\n            display_name=\"Backstory\",\n            info=\"The backstory of the agent.\",\n        ),\n        HandleInput(\n            name=\"tools\",\n            display_name=\"Tools\",\n            input_types=[\"Tool\"],\n            is_list=True,\n            info=\"Tools at agent's disposal\",\n            value=[],\n        ),\n        HandleInput(\n            name=\"llm\",\n            display_name=\"Language Model\",\n            info=\"Language model that will run the agent.\",\n            input_types=[\"LanguageModel\"],\n        ),\n        BoolInput(\n            name=\"memory\",\n            display_name=\"Memory\",\n            info=\"Whether the agent should have memory or not\",\n            advanced=True,\n            value=True,\n        ),\n        BoolInput(\n            name=\"verbose\",\n            display_name=\"Verbose\",\n            advanced=True,\n            value=True,\n        ),\n        BoolInput(\n            name=\"allow_delegation\",\n            display_name=\"Allow Delegation\",\n            info=\"Whether the agent is allowed to delegate tasks to other agents.\",\n            value=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"allow_code_execution\",\n            display_name=\"Allow Code Execution\",\n            info=\"Whether the agent is allowed to execute code.\",\n            value=False,\n            advanced=True,\n        ),\n        DictInput(\n            name=\"agent_kwargs\",\n            display_name=\"Agent kwargs\",\n            info=\"Additional kwargs for the agent.\",\n            is_list=True,\n            advanced=True,\n        ),\n        # Task inputs\n        MultilineInput(\n            name=\"task_description\",\n            display_name=\"Task Description\",\n            info=\"Descriptive text detailing task's purpose and execution.\",\n        ),\n        MultilineInput(\n            name=\"expected_output\",\n            display_name=\"Expected Task Output\",\n            info=\"Clear definition of expected task outcome.\",\n        ),\n        BoolInput(\n            name=\"async_execution\",\n            display_name=\"Async Execution\",\n            value=False,\n            advanced=True,\n            info=\"Boolean flag indicating asynchronous task execution.\",\n        ),\n        # Chaining input\n        HandleInput(\n            name=\"previous_task\",\n            display_name=\"Previous Task\",\n            input_types=[\"SequentialTask\"],\n            info=\"The previous task in the sequence (for chaining).\",\n            required=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Sequential Task\",\n            name=\"task_output\",\n            method=\"build_agent_and_task\",\n        ),\n    ]\n\n    def build_agent_and_task(self) -> list[SequentialTask]:\n        # Build the agent\n        agent_kwargs = self.agent_kwargs or {}\n        agent = Agent(\n            role=self.role,\n            goal=self.goal,\n            backstory=self.backstory,\n            llm=self.llm,\n            verbose=self.verbose,\n            memory=self.memory,\n            tools=self.tools or [],\n            allow_delegation=self.allow_delegation,\n            allow_code_execution=self.allow_code_execution,\n            **agent_kwargs,\n        )\n\n        # Build the task\n        task = Task(\n            description=self.task_description,\n            expected_output=self.expected_output,\n            agent=agent,\n            async_execution=self.async_execution,\n        )\n\n        # If there's a previous task, create a list of tasks\n        if self.previous_task:\n            tasks = [*self.previous_task, task] if isinstance(self.previous_task, list) else [self.previous_task, task]\n        else:\n            tasks = [task]\n\n        self.status = f\"Agent: {agent!r}\\nTask: {task!r}\"\n        return tasks\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "expected_output": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "expected_output",
    //                 "value": "",
    //                 "display_name": "Expected Task Output",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Clear definition of expected task outcome.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "goal": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "goal",
    //                 "value": "",
    //                 "display_name": "Goal",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The objective of the agent.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "memory": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "memory",
    //                 "value": true,
    //                 "display_name": "Memory",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Whether the agent should have memory or not",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "role": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "role",
    //                 "value": "",
    //                 "display_name": "Role",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The role of the agent.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "task_description": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "task_description",
    //                 "value": "",
    //                 "display_name": "Task Description",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Descriptive text detailing task's purpose and execution.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "verbose": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "verbose",
    //                 "value": true,
    //                 "display_name": "Verbose",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Creates a CrewAI Task and its associated Agent.",
    //         "icon": "CrewAI",
    //         "base_classes": [
    //             "SequentialTask"
    //         ],
    //         "display_name": "Sequential Task Agent",
    //         "documentation": "https://docs.crewai.com/how-to/LLM-Connections/",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "SequentialTask"
    //                 ],
    //                 "selected": "SequentialTask",
    //                 "name": "task_output",
    //                 "display_name": "Sequential Task",
    //                 "method": "build_agent_and_task",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "role",
    //             "goal",
    //             "backstory",
    //             "tools",
    //             "llm",
    //             "memory",
    //             "verbose",
    //             "allow_delegation",
    //             "allow_code_execution",
    //             "agent_kwargs",
    //             "task_description",
    //             "expected_output",
    //             "async_execution",
    //             "previous_task"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "VectorStoreAgent": {
    //         "template": {
    //             "_type": "Component",
    //             "llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "llm",
    //                 "value": "",
    //                 "display_name": "Language Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "LanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "vectorstore": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "vectorstore",
    //                 "value": "",
    //                 "display_name": "Vector Store",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "VectorStoreInfo"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain.agents import AgentExecutor, create_vectorstore_agent\nfrom langchain.agents.agent_toolkits.vectorstore.toolkit import VectorStoreToolkit\n\nfrom langflow.base.agents.agent import LCAgentComponent\nfrom langflow.inputs import HandleInput\n\n\nclass VectorStoreAgentComponent(LCAgentComponent):\n    display_name = \"VectorStoreAgent\"\n    description = \"Construct an agent from a Vector Store.\"\n    name = \"VectorStoreAgent\"\n\n    inputs = [\n        *LCAgentComponent._base_inputs,\n        HandleInput(name=\"llm\", display_name=\"Language Model\", input_types=[\"LanguageModel\"], required=True),\n        HandleInput(name=\"vectorstore\", display_name=\"Vector Store\", input_types=[\"VectorStoreInfo\"], required=True),\n    ]\n\n    def build_agent(self) -> AgentExecutor:\n        toolkit = VectorStoreToolkit(vectorstore_info=self.vectorstore, llm=self.llm)\n        return create_vectorstore_agent(llm=self.llm, toolkit=toolkit, **self.get_agent_kwargs())\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "handle_parsing_errors": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "handle_parsing_errors",
    //                 "value": true,
    //                 "display_name": "Handle Parse Errors",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "max_iterations": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_iterations",
    //                 "value": 15,
    //                 "display_name": "Max Iterations",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "verbose": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "verbose",
    //                 "value": true,
    //                 "display_name": "Verbose",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Construct an agent from a Vector Store.",
    //         "base_classes": [
    //             "AgentExecutor",
    //             "Message"
    //         ],
    //         "display_name": "VectorStoreAgent",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "AgentExecutor"
    //                 ],
    //                 "selected": "AgentExecutor",
    //                 "name": "agent",
    //                 "display_name": "Agent",
    //                 "method": "build_agent",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "llm",
    //                     "vectorstore"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "response",
    //                 "display_name": "Response",
    //                 "method": "message_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "handle_parsing_errors",
    //             "verbose",
    //             "max_iterations",
    //             "llm",
    //             "vectorstore"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "OpenAPIAgent": {
    //         "template": {
    //             "_type": "Component",
    //             "llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "llm",
    //                 "value": "",
    //                 "display_name": "Language Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "LanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "path": {
    //                 "trace_as_metadata": true,
    //                 "file_path": "",
    //                 "fileTypes": [
    //                     "json",
    //                     "yaml",
    //                     "yml"
    //                 ],
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "path",
    //                 "value": "",
    //                 "display_name": "File Path",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "file",
    //                 "_input_type": "FileInput"
    //             },
    //             "allow_dangerous_requests": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "allow_dangerous_requests",
    //                 "value": false,
    //                 "display_name": "Allow Dangerous Requests",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from pathlib import Path\n\nimport yaml\nfrom langchain.agents import AgentExecutor\nfrom langchain_community.agent_toolkits import create_openapi_agent\nfrom langchain_community.agent_toolkits.openapi.toolkit import OpenAPIToolkit\nfrom langchain_community.tools.json.tool import JsonSpec\nfrom langchain_community.utilities.requests import TextRequestsWrapper\n\nfrom langflow.base.agents.agent import LCAgentComponent\nfrom langflow.inputs import BoolInput, FileInput, HandleInput\n\n\nclass OpenAPIAgentComponent(LCAgentComponent):\n    display_name = \"OpenAPI Agent\"\n    description = \"Agent to interact with OpenAPI API.\"\n    name = \"OpenAPIAgent\"\n\n    inputs = [\n        *LCAgentComponent._base_inputs,\n        HandleInput(name=\"llm\", display_name=\"Language Model\", input_types=[\"LanguageModel\"], required=True),\n        FileInput(name=\"path\", display_name=\"File Path\", file_types=[\"json\", \"yaml\", \"yml\"], required=True),\n        BoolInput(name=\"allow_dangerous_requests\", display_name=\"Allow Dangerous Requests\", value=False, required=True),\n    ]\n\n    def build_agent(self) -> AgentExecutor:\n        path = Path(self.path)\n        if path.suffix in (\"yaml\", \"yml\"):\n            with path.open(encoding=\"utf-8\") as file:\n                yaml_dict = yaml.safe_load(file)\n            spec = JsonSpec(dict_=yaml_dict)\n        else:\n            spec = JsonSpec.from_file(path)\n        requests_wrapper = TextRequestsWrapper()\n        toolkit = OpenAPIToolkit.from_llm(\n            llm=self.llm,\n            json_spec=spec,\n            requests_wrapper=requests_wrapper,\n            allow_dangerous_requests=self.allow_dangerous_requests,\n        )\n\n        agent_args = self.get_agent_kwargs()\n\n        # This is bit weird - generally other create_*_agent functions have max_iterations in the\n        # `agent_executor_kwargs`, but openai has this parameter passed directly.\n        agent_args[\"max_iterations\"] = agent_args[\"agent_executor_kwargs\"][\"max_iterations\"]\n        del agent_args[\"agent_executor_kwargs\"][\"max_iterations\"]\n        return create_openapi_agent(llm=self.llm, toolkit=toolkit, **agent_args)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "handle_parsing_errors": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "handle_parsing_errors",
    //                 "value": true,
    //                 "display_name": "Handle Parse Errors",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "max_iterations": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_iterations",
    //                 "value": 15,
    //                 "display_name": "Max Iterations",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "verbose": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "verbose",
    //                 "value": true,
    //                 "display_name": "Verbose",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Agent to interact with OpenAPI API.",
    //         "base_classes": [
    //             "AgentExecutor",
    //             "Message"
    //         ],
    //         "display_name": "OpenAPI Agent",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "AgentExecutor"
    //                 ],
    //                 "selected": "AgentExecutor",
    //                 "name": "agent",
    //                 "display_name": "Agent",
    //                 "method": "build_agent",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "allow_dangerous_requests",
    //                     "llm",
    //                     "path"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "response",
    //                 "display_name": "Response",
    //                 "method": "message_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "handle_parsing_errors",
    //             "verbose",
    //             "max_iterations",
    //             "llm",
    //             "path",
    //             "allow_dangerous_requests"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "CrewAIAgentComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "llm",
    //                 "value": "",
    //                 "display_name": "Language Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "LanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Language model that will run the agent.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "tools": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tools",
    //                 "value": [],
    //                 "display_name": "Tools",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Tool"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Tools at agents disposal",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "allow_code_execution": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "allow_code_execution",
    //                 "value": false,
    //                 "display_name": "Allow Code Execution",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Whether the agent is allowed to execute code.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "allow_delegation": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "allow_delegation",
    //                 "value": true,
    //                 "display_name": "Allow Delegation",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Whether the agent is allowed to delegate tasks to other agents.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "backstory": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "backstory",
    //                 "value": "",
    //                 "display_name": "Backstory",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The backstory of the agent.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from crewai import Agent\n\nfrom langflow.custom import Component\nfrom langflow.io import BoolInput, DictInput, HandleInput, MultilineInput, Output\n\n\nclass CrewAIAgentComponent(Component):\n    display_name = \"CrewAI Agent\"\n    description = \"Represents an agent of CrewAI.\"\n    documentation: str = \"https://docs.crewai.com/how-to/LLM-Connections/\"\n    icon = \"CrewAI\"\n\n    inputs = [\n        MultilineInput(name=\"role\", display_name=\"Role\", info=\"The role of the agent.\"),\n        MultilineInput(name=\"goal\", display_name=\"Goal\", info=\"The objective of the agent.\"),\n        MultilineInput(name=\"backstory\", display_name=\"Backstory\", info=\"The backstory of the agent.\"),\n        HandleInput(\n            name=\"tools\",\n            display_name=\"Tools\",\n            input_types=[\"Tool\"],\n            is_list=True,\n            info=\"Tools at agents disposal\",\n            value=[],\n        ),\n        HandleInput(\n            name=\"llm\",\n            display_name=\"Language Model\",\n            info=\"Language model that will run the agent.\",\n            input_types=[\"LanguageModel\"],\n        ),\n        BoolInput(\n            name=\"memory\",\n            display_name=\"Memory\",\n            info=\"Whether the agent should have memory or not\",\n            advanced=True,\n            value=True,\n        ),\n        BoolInput(\n            name=\"verbose\",\n            display_name=\"Verbose\",\n            advanced=True,\n            value=False,\n        ),\n        BoolInput(\n            name=\"allow_delegation\",\n            display_name=\"Allow Delegation\",\n            info=\"Whether the agent is allowed to delegate tasks to other agents.\",\n            value=True,\n        ),\n        BoolInput(\n            name=\"allow_code_execution\",\n            display_name=\"Allow Code Execution\",\n            info=\"Whether the agent is allowed to execute code.\",\n            value=False,\n            advanced=True,\n        ),\n        DictInput(\n            name=\"kwargs\",\n            display_name=\"kwargs\",\n            info=\"kwargs of agent.\",\n            is_list=True,\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Agent\", name=\"output\", method=\"build_output\"),\n    ]\n\n    def build_output(self) -> Agent:\n        kwargs = self.kwargs or {}\n        agent = Agent(\n            role=self.role,\n            goal=self.goal,\n            backstory=self.backstory,\n            llm=self.llm,\n            verbose=self.verbose,\n            memory=self.memory,\n            tools=self.tools or [],\n            allow_delegation=self.allow_delegation,\n            allow_code_execution=self.allow_code_execution,\n            **kwargs,\n        )\n        self.status = repr(agent)\n        return agent\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "goal": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "goal",
    //                 "value": "",
    //                 "display_name": "Goal",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The objective of the agent.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "kwargs": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "kwargs",
    //                 "value": {},
    //                 "display_name": "kwargs",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "kwargs of agent.",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "memory": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "memory",
    //                 "value": true,
    //                 "display_name": "Memory",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Whether the agent should have memory or not",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "role": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "role",
    //                 "value": "",
    //                 "display_name": "Role",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The role of the agent.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "verbose": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "verbose",
    //                 "value": false,
    //                 "display_name": "Verbose",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Represents an agent of CrewAI.",
    //         "icon": "CrewAI",
    //         "base_classes": [
    //             "Agent"
    //         ],
    //         "display_name": "CrewAI Agent",
    //         "documentation": "https://docs.crewai.com/how-to/LLM-Connections/",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Agent"
    //                 ],
    //                 "selected": "Agent",
    //                 "name": "output",
    //                 "display_name": "Agent",
    //                 "method": "build_output",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "role",
    //             "goal",
    //             "backstory",
    //             "tools",
    //             "llm",
    //             "memory",
    //             "verbose",
    //             "allow_delegation",
    //             "allow_code_execution",
    //             "kwargs"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "OpenAIToolsAgent": {
    //         "template": {
    //             "_type": "Component",
    //             "chat_history": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chat_history",
    //                 "value": "",
    //                 "display_name": "Chat History",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "llm",
    //                 "value": "",
    //                 "display_name": "Language Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "LanguageModel",
    //                     "ToolEnabledLanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "tools": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tools",
    //                 "value": "",
    //                 "display_name": "Tools",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Tool",
    //                     "BaseTool",
    //                     "StructuredTool"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain.agents import create_openai_tools_agent\nfrom langchain_core.prompts import ChatPromptTemplate, HumanMessagePromptTemplate, PromptTemplate\n\nfrom langflow.base.agents.agent import LCToolsAgentComponent\nfrom langflow.inputs import MultilineInput\nfrom langflow.inputs.inputs import DataInput, HandleInput\nfrom langflow.schema import Data\n\n\nclass OpenAIToolsAgentComponent(LCToolsAgentComponent):\n    display_name: str = \"OpenAI Tools Agent\"\n    description: str = \"Agent that uses tools via openai-tools.\"\n    icon = \"LangChain\"\n    beta = True\n    name = \"OpenAIToolsAgent\"\n\n    inputs = [\n        *LCToolsAgentComponent._base_inputs,\n        HandleInput(\n            name=\"llm\",\n            display_name=\"Language Model\",\n            input_types=[\"LanguageModel\", \"ToolEnabledLanguageModel\"],\n            required=True,\n        ),\n        MultilineInput(\n            name=\"system_prompt\",\n            display_name=\"System Prompt\",\n            info=\"System prompt for the agent.\",\n            value=\"You are a helpful assistant\",\n        ),\n        MultilineInput(\n            name=\"user_prompt\", display_name=\"Prompt\", info=\"This prompt must contain 'input' key.\", value=\"{input}\"\n        ),\n        DataInput(name=\"chat_history\", display_name=\"Chat History\", is_list=True, advanced=True),\n    ]\n\n    def get_chat_history_data(self) -> list[Data] | None:\n        return self.chat_history\n\n    def create_agent_runnable(self):\n        if \"input\" not in self.user_prompt:\n            msg = \"Prompt must contain 'input' key.\"\n            raise ValueError(msg)\n        messages = [\n            (\"system\", self.system_prompt),\n            (\"placeholder\", \"{chat_history}\"),\n            HumanMessagePromptTemplate(prompt=PromptTemplate(input_variables=[\"input\"], template=self.user_prompt)),\n            (\"placeholder\", \"{agent_scratchpad}\"),\n        ]\n        prompt = ChatPromptTemplate.from_messages(messages)\n        return create_openai_tools_agent(self.llm, self.tools, prompt)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "handle_parsing_errors": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "handle_parsing_errors",
    //                 "value": true,
    //                 "display_name": "Handle Parse Errors",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "max_iterations": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_iterations",
    //                 "value": 15,
    //                 "display_name": "Max Iterations",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "system_prompt": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "system_prompt",
    //                 "value": "You are a helpful assistant",
    //                 "display_name": "System Prompt",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "System prompt for the agent.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "user_prompt": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "user_prompt",
    //                 "value": "{input}",
    //                 "display_name": "Prompt",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "This prompt must contain 'input' key.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "verbose": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "verbose",
    //                 "value": true,
    //                 "display_name": "Verbose",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Agent that uses tools via openai-tools.",
    //         "icon": "LangChain",
    //         "base_classes": [
    //             "AgentExecutor",
    //             "Message"
    //         ],
    //         "display_name": "OpenAI Tools Agent",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "AgentExecutor"
    //                 ],
    //                 "selected": "AgentExecutor",
    //                 "name": "agent",
    //                 "display_name": "Agent",
    //                 "method": "build_agent",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "tools"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "response",
    //                 "display_name": "Response",
    //                 "method": "message_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "handle_parsing_errors",
    //             "verbose",
    //             "max_iterations",
    //             "tools",
    //             "llm",
    //             "system_prompt",
    //             "user_prompt",
    //             "chat_history"
    //         ],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "XMLAgent": {
    //         "template": {
    //             "_type": "Component",
    //             "chat_history": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chat_history",
    //                 "value": "",
    //                 "display_name": "Chat History",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "llm",
    //                 "value": "",
    //                 "display_name": "Language Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "LanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "tools": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tools",
    //                 "value": "",
    //                 "display_name": "Tools",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Tool",
    //                     "BaseTool",
    //                     "StructuredTool"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain.agents import create_xml_agent\nfrom langchain_core.prompts import ChatPromptTemplate, HumanMessagePromptTemplate, PromptTemplate\n\nfrom langflow.base.agents.agent import LCToolsAgentComponent\nfrom langflow.inputs import MultilineInput\nfrom langflow.inputs.inputs import DataInput, HandleInput\nfrom langflow.schema import Data\n\n\nclass XMLAgentComponent(LCToolsAgentComponent):\n    display_name: str = \"XML Agent\"\n    description: str = \"Agent that uses tools formatting instructions as xml to the Language Model.\"\n    icon = \"LangChain\"\n    beta = True\n    name = \"XMLAgent\"\n    inputs = [\n        *LCToolsAgentComponent._base_inputs,\n        HandleInput(name=\"llm\", display_name=\"Language Model\", input_types=[\"LanguageModel\"], required=True),\n        DataInput(name=\"chat_history\", display_name=\"Chat History\", is_list=True, advanced=True),\n        MultilineInput(\n            name=\"system_prompt\",\n            display_name=\"System Prompt\",\n            info=\"System prompt for the agent.\",\n            value=\"\"\"You are a helpful assistant. Help the user answer any questions.\n\nYou have access to the following tools:\n\n{tools}\n\nIn order to use a tool, you can use <tool></tool> and <tool_input></tool_input> tags. You will then get back a response in the form <observation></observation>\n\nFor example, if you have a tool called 'search' that could run a google search, in order to search for the weather in SF you would respond:\n\n<tool>search</tool><tool_input>weather in SF</tool_input>\n\n<observation>64 degrees</observation>\n\nWhen you are done, respond with a final answer between <final_answer></final_answer>. For example:\n\n<final_answer>The weather in SF is 64 degrees</final_answer>\n\nBegin!\n\nQuestion: {input}\n\n{agent_scratchpad}\n            \"\"\",  # noqa: E501\n        ),\n        MultilineInput(\n            name=\"user_prompt\", display_name=\"Prompt\", info=\"This prompt must contain 'input' key.\", value=\"{input}\"\n        ),\n    ]\n\n    def get_chat_history_data(self) -> list[Data] | None:\n        return self.chat_history\n\n    def create_agent_runnable(self):\n        if \"input\" not in self.user_prompt:\n            msg = \"Prompt must contain 'input' key.\"\n            raise ValueError(msg)\n        messages = [\n            (\"system\", self.system_prompt),\n            (\"placeholder\", \"{chat_history}\"),\n            HumanMessagePromptTemplate(prompt=PromptTemplate(input_variables=[\"input\"], template=self.user_prompt)),\n            (\"ai\", \"{agent_scratchpad}\"),\n        ]\n        prompt = ChatPromptTemplate.from_messages(messages)\n        return create_xml_agent(self.llm, self.tools, prompt)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "handle_parsing_errors": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "handle_parsing_errors",
    //                 "value": true,
    //                 "display_name": "Handle Parse Errors",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "max_iterations": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_iterations",
    //                 "value": 15,
    //                 "display_name": "Max Iterations",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "system_prompt": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "system_prompt",
    //                 "value": "You are a helpful assistant. Help the user answer any questions.\n\nYou have access to the following tools:\n\n{tools}\n\nIn order to use a tool, you can use <tool></tool> and <tool_input></tool_input> tags. You will then get back a response in the form <observation></observation>\n\nFor example, if you have a tool called 'search' that could run a google search, in order to search for the weather in SF you would respond:\n\n<tool>search</tool><tool_input>weather in SF</tool_input>\n\n<observation>64 degrees</observation>\n\nWhen you are done, respond with a final answer between <final_answer></final_answer>. For example:\n\n<final_answer>The weather in SF is 64 degrees</final_answer>\n\nBegin!\n\nQuestion: {input}\n\n{agent_scratchpad}\n            ",
    //                 "display_name": "System Prompt",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "System prompt for the agent.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "user_prompt": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "user_prompt",
    //                 "value": "{input}",
    //                 "display_name": "Prompt",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "This prompt must contain 'input' key.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "verbose": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "verbose",
    //                 "value": true,
    //                 "display_name": "Verbose",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Agent that uses tools formatting instructions as xml to the Language Model.",
    //         "icon": "LangChain",
    //         "base_classes": [
    //             "AgentExecutor",
    //             "Message"
    //         ],
    //         "display_name": "XML Agent",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "AgentExecutor"
    //                 ],
    //                 "selected": "AgentExecutor",
    //                 "name": "agent",
    //                 "display_name": "Agent",
    //                 "method": "build_agent",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "tools"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "response",
    //                 "display_name": "Response",
    //                 "method": "message_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "handle_parsing_errors",
    //             "verbose",
    //             "max_iterations",
    //             "tools",
    //             "llm",
    //             "chat_history",
    //             "system_prompt",
    //             "user_prompt"
    //         ],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "HierarchicalCrewComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "agents": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "agents",
    //                 "value": "",
    //                 "display_name": "Agents",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Agent"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "function_calling_llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "function_calling_llm",
    //                 "value": "",
    //                 "display_name": "Function Calling LLM",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "LanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Turns the ReAct CrewAI agent into a function-calling agent",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "manager_agent": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "manager_agent",
    //                 "value": "",
    //                 "display_name": "Manager Agent",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Agent"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "manager_llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "manager_llm",
    //                 "value": "",
    //                 "display_name": "Manager LLM",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "LanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "tasks": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tasks",
    //                 "value": "",
    //                 "display_name": "Tasks",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "HierarchicalTask"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from crewai import Crew, Process\n\nfrom langflow.base.agents.crewai.crew import BaseCrewComponent\nfrom langflow.io import HandleInput\n\n\nclass HierarchicalCrewComponent(BaseCrewComponent):\n    display_name: str = \"Hierarchical Crew\"\n    description: str = (\n        \"Represents a group of agents, defining how they should collaborate and the tasks they should perform.\"\n    )\n    documentation: str = \"https://docs.crewai.com/how-to/Hierarchical/\"\n    icon = \"CrewAI\"\n\n    inputs = [\n        *BaseCrewComponent._base_inputs,\n        HandleInput(name=\"agents\", display_name=\"Agents\", input_types=[\"Agent\"], is_list=True),\n        HandleInput(name=\"tasks\", display_name=\"Tasks\", input_types=[\"HierarchicalTask\"], is_list=True),\n        HandleInput(name=\"manager_llm\", display_name=\"Manager LLM\", input_types=[\"LanguageModel\"], required=False),\n        HandleInput(name=\"manager_agent\", display_name=\"Manager Agent\", input_types=[\"Agent\"], required=False),\n    ]\n\n    def build_crew(self) -> Crew:\n        tasks, agents = self.get_tasks_and_agents()\n        return Crew(\n            agents=agents,\n            tasks=tasks,\n            process=Process.hierarchical,\n            verbose=self.verbose,\n            memory=self.memory,\n            cache=self.use_cache,\n            max_rpm=self.max_rpm,\n            share_crew=self.share_crew,\n            function_calling_llm=self.function_calling_llm,\n            manager_agent=self.manager_agent,\n            manager_llm=self.manager_llm,\n            step_callback=self.get_step_callback(),\n            task_callback=self.get_task_callback(),\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "max_rpm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_rpm",
    //                 "value": 100,
    //                 "display_name": "Max RPM",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "memory": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "memory",
    //                 "value": false,
    //                 "display_name": "Memory",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "share_crew": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "share_crew",
    //                 "value": false,
    //                 "display_name": "Share Crew",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "use_cache": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "use_cache",
    //                 "value": true,
    //                 "display_name": "Cache",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "verbose": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "verbose",
    //                 "value": 0,
    //                 "display_name": "Verbose",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             }
    //         },
    //         "description": "Represents a group of agents, defining how they should collaborate and the tasks they should perform.",
    //         "icon": "CrewAI",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Hierarchical Crew",
    //         "documentation": "https://docs.crewai.com/how-to/Hierarchical/",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "output",
    //                 "display_name": "Output",
    //                 "method": "build_output",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "verbose",
    //             "memory",
    //             "use_cache",
    //             "max_rpm",
    //             "share_crew",
    //             "function_calling_llm",
    //             "agents",
    //             "tasks",
    //             "manager_llm",
    //             "manager_agent"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "VectorStoreRouterAgent": {
    //         "template": {
    //             "_type": "Component",
    //             "llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "llm",
    //                 "value": "",
    //                 "display_name": "Language Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "LanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "vectorstores": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "vectorstores",
    //                 "value": "",
    //                 "display_name": "Vector Stores",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "VectorStoreInfo"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain.agents import AgentExecutor, create_vectorstore_router_agent\nfrom langchain.agents.agent_toolkits.vectorstore.toolkit import VectorStoreRouterToolkit\n\nfrom langflow.base.agents.agent import LCAgentComponent\nfrom langflow.inputs import HandleInput\n\n\nclass VectorStoreRouterAgentComponent(LCAgentComponent):\n    display_name = \"VectorStoreRouterAgent\"\n    description = \"Construct an agent from a Vector Store Router.\"\n    name = \"VectorStoreRouterAgent\"\n\n    inputs = [\n        *LCAgentComponent._base_inputs,\n        HandleInput(name=\"llm\", display_name=\"Language Model\", input_types=[\"LanguageModel\"], required=True),\n        HandleInput(\n            name=\"vectorstores\",\n            display_name=\"Vector Stores\",\n            input_types=[\"VectorStoreInfo\"],\n            is_list=True,\n            required=True,\n        ),\n    ]\n\n    def build_agent(self) -> AgentExecutor:\n        toolkit = VectorStoreRouterToolkit(vectorstores=self.vectorstores, llm=self.llm)\n        return create_vectorstore_router_agent(llm=self.llm, toolkit=toolkit, **self.get_agent_kwargs())\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "handle_parsing_errors": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "handle_parsing_errors",
    //                 "value": true,
    //                 "display_name": "Handle Parse Errors",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "max_iterations": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_iterations",
    //                 "value": 15,
    //                 "display_name": "Max Iterations",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "verbose": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "verbose",
    //                 "value": true,
    //                 "display_name": "Verbose",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Construct an agent from a Vector Store Router.",
    //         "base_classes": [
    //             "AgentExecutor",
    //             "Message"
    //         ],
    //         "display_name": "VectorStoreRouterAgent",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "AgentExecutor"
    //                 ],
    //                 "selected": "AgentExecutor",
    //                 "name": "agent",
    //                 "display_name": "Agent",
    //                 "method": "build_agent",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "llm",
    //                     "vectorstores"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "response",
    //                 "display_name": "Response",
    //                 "method": "message_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "handle_parsing_errors",
    //             "verbose",
    //             "max_iterations",
    //             "llm",
    //             "vectorstores"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "CSVAgent": {
    //         "template": {
    //             "_type": "Component",
    //             "llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "llm",
    //                 "value": "",
    //                 "display_name": "Language Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "LanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "An LLM Model Object (It can be found in any LLM Component).",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "path": {
    //                 "trace_as_metadata": true,
    //                 "file_path": "",
    //                 "fileTypes": [
    //                     "csv"
    //                 ],
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "path",
    //                 "value": "",
    //                 "display_name": "File Path",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "str",
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "A CSV File or File Path.",
    //                 "title_case": false,
    //                 "type": "file",
    //                 "_input_type": "FileInput"
    //             },
    //             "agent_type": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "zero-shot-react-description",
    //                     "openai-functions",
    //                     "openai-tools"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "agent_type",
    //                 "value": "openai-tools",
    //                 "display_name": "Agent Type",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_experimental.agents.agent_toolkits.csv.base import create_csv_agent\n\nfrom langflow.base.agents.agent import LCAgentComponent\nfrom langflow.field_typing import AgentExecutor\nfrom langflow.inputs import DropdownInput, FileInput, HandleInput\nfrom langflow.inputs.inputs import MessageTextInput\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass CSVAgentComponent(LCAgentComponent):\n    display_name = \"CSVAgent\"\n    description = \"Construct a CSV agent from a CSV and tools.\"\n    documentation = \"https://python.langchain.com/docs/modules/agents/toolkits/csv\"\n    name = \"CSVAgent\"\n\n    inputs = [\n        *LCAgentComponent._base_inputs,\n        HandleInput(\n            name=\"llm\",\n            display_name=\"Language Model\",\n            input_types=[\"LanguageModel\"],\n            required=True,\n            info=\"An LLM Model Object (It can be found in any LLM Component).\",\n        ),\n        FileInput(\n            name=\"path\",\n            display_name=\"File Path\",\n            file_types=[\"csv\"],\n            input_types=[\"str\", \"Message\"],\n            required=True,\n            info=\"A CSV File or File Path.\",\n        ),\n        DropdownInput(\n            name=\"agent_type\",\n            display_name=\"Agent Type\",\n            advanced=True,\n            options=[\"zero-shot-react-description\", \"openai-functions\", \"openai-tools\"],\n            value=\"openai-tools\",\n        ),\n        MessageTextInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as input and extract info from the CSV File.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Response\", name=\"response\", method=\"build_agent_response\"),\n        Output(display_name=\"Agent\", name=\"agent\", method=\"build_agent\"),\n    ]\n\n    def build_agent_response(self) -> Message:\n        agent_kwargs = {\n            \"verbose\": self.verbose,\n            \"allow_dangerous_code\": True,\n        }\n\n        agent_csv = create_csv_agent(\n            llm=self.llm,\n            path=self.path,\n            agent_type=self.agent_type,\n            handle_parsing_errors=self.handle_parsing_errors,\n            **agent_kwargs,\n        )\n\n        result = agent_csv.invoke({\"input\": self.input_value})\n        return Message(text=str(result[\"output\"]))\n\n    def build_agent(self) -> AgentExecutor:\n        agent_kwargs = {\n            \"verbose\": self.verbose,\n            \"allow_dangerous_code\": True,\n        }\n\n        agent_csv = create_csv_agent(\n            llm=self.llm,\n            path=self.path,\n            agent_type=self.agent_type,\n            handle_parsing_errors=self.handle_parsing_errors,\n            **agent_kwargs,\n        )\n\n        self.status = Message(text=str(agent_csv))\n\n        return agent_csv\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "handle_parsing_errors": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "handle_parsing_errors",
    //                 "value": true,
    //                 "display_name": "Handle Parse Errors",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Text",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Text to be passed as input and extract info from the CSV File.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "max_iterations": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_iterations",
    //                 "value": 15,
    //                 "display_name": "Max Iterations",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "verbose": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "verbose",
    //                 "value": true,
    //                 "display_name": "Verbose",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Construct a CSV agent from a CSV and tools.",
    //         "base_classes": [
    //             "AgentExecutor",
    //             "Message"
    //         ],
    //         "display_name": "CSVAgent",
    //         "documentation": "https://python.langchain.com/docs/modules/agents/toolkits/csv",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "response",
    //                 "display_name": "Response",
    //                 "method": "build_agent_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             },
    //             {
    //                 "types": [
    //                     "AgentExecutor"
    //                 ],
    //                 "selected": "AgentExecutor",
    //                 "name": "agent",
    //                 "display_name": "Agent",
    //                 "method": "build_agent",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "handle_parsing_errors",
    //             "verbose",
    //             "max_iterations",
    //             "llm",
    //             "path",
    //             "agent_type",
    //             "input_value"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "SequentialCrewComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "function_calling_llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "function_calling_llm",
    //                 "value": "",
    //                 "display_name": "Function Calling LLM",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "LanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Turns the ReAct CrewAI agent into a function-calling agent",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "tasks": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tasks",
    //                 "value": "",
    //                 "display_name": "Tasks",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "SequentialTask"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from crewai import Agent, Crew, Process, Task\n\nfrom langflow.base.agents.crewai.crew import BaseCrewComponent\nfrom langflow.io import HandleInput\nfrom langflow.schema.message import Message\n\n\nclass SequentialCrewComponent(BaseCrewComponent):\n    display_name: str = \"Sequential Crew\"\n    description: str = \"Represents a group of agents with tasks that are executed sequentially.\"\n    documentation: str = \"https://docs.crewai.com/how-to/Sequential/\"\n    icon = \"CrewAI\"\n\n    inputs = [\n        *BaseCrewComponent._base_inputs,\n        HandleInput(name=\"tasks\", display_name=\"Tasks\", input_types=[\"SequentialTask\"], is_list=True),\n    ]\n\n    def get_tasks_and_agents(self) -> tuple[list[Task], list[Agent]]:\n        return self.tasks, [task.agent for task in self.tasks]\n\n    def build_crew(self) -> Message:\n        tasks, agents = self.get_tasks_and_agents()\n        return Crew(\n            agents=agents,\n            tasks=tasks,\n            process=Process.sequential,\n            verbose=self.verbose,\n            memory=self.memory,\n            cache=self.use_cache,\n            max_rpm=self.max_rpm,\n            share_crew=self.share_crew,\n            function_calling_llm=self.function_calling_llm,\n            step_callback=self.get_step_callback(),\n            task_callback=self.get_task_callback(),\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "max_rpm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_rpm",
    //                 "value": 100,
    //                 "display_name": "Max RPM",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "memory": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "memory",
    //                 "value": false,
    //                 "display_name": "Memory",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "share_crew": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "share_crew",
    //                 "value": false,
    //                 "display_name": "Share Crew",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "use_cache": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "use_cache",
    //                 "value": true,
    //                 "display_name": "Cache",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "verbose": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "verbose",
    //                 "value": 0,
    //                 "display_name": "Verbose",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             }
    //         },
    //         "description": "Represents a group of agents with tasks that are executed sequentially.",
    //         "icon": "CrewAI",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Sequential Crew",
    //         "documentation": "https://docs.crewai.com/how-to/Sequential/",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "output",
    //                 "display_name": "Output",
    //                 "method": "build_output",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "verbose",
    //             "memory",
    //             "use_cache",
    //             "max_rpm",
    //             "share_crew",
    //             "function_calling_llm",
    //             "tasks"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "SQLAgent": {
    //         "template": {
    //             "_type": "Component",
    //             "extra_tools": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "extra_tools",
    //                 "value": "",
    //                 "display_name": "Extra Tools",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Tool",
    //                     "BaseTool"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "llm",
    //                 "value": "",
    //                 "display_name": "Language Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "LanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain.agents import AgentExecutor\nfrom langchain_community.agent_toolkits import SQLDatabaseToolkit\nfrom langchain_community.agent_toolkits.sql.base import create_sql_agent\nfrom langchain_community.utilities import SQLDatabase\n\nfrom langflow.base.agents.agent import LCAgentComponent\nfrom langflow.inputs import HandleInput, MessageTextInput\n\n\nclass SQLAgentComponent(LCAgentComponent):\n    display_name = \"SQLAgent\"\n    description = \"Construct an SQL agent from an LLM and tools.\"\n    name = \"SQLAgent\"\n\n    inputs = [\n        *LCAgentComponent._base_inputs,\n        HandleInput(name=\"llm\", display_name=\"Language Model\", input_types=[\"LanguageModel\"], required=True),\n        MessageTextInput(name=\"database_uri\", display_name=\"Database URI\", required=True),\n        HandleInput(\n            name=\"extra_tools\",\n            display_name=\"Extra Tools\",\n            input_types=[\"Tool\", \"BaseTool\"],\n            is_list=True,\n            advanced=True,\n        ),\n    ]\n\n    def build_agent(self) -> AgentExecutor:\n        db = SQLDatabase.from_uri(self.database_uri)\n        toolkit = SQLDatabaseToolkit(db=db, llm=self.llm)\n        agent_args = self.get_agent_kwargs()\n        agent_args[\"max_iterations\"] = agent_args[\"agent_executor_kwargs\"][\"max_iterations\"]\n        del agent_args[\"agent_executor_kwargs\"][\"max_iterations\"]\n        return create_sql_agent(llm=self.llm, toolkit=toolkit, extra_tools=self.extra_tools or [], **agent_args)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "database_uri": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "database_uri",
    //                 "value": "",
    //                 "display_name": "Database URI",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "handle_parsing_errors": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "handle_parsing_errors",
    //                 "value": true,
    //                 "display_name": "Handle Parse Errors",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "max_iterations": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_iterations",
    //                 "value": 15,
    //                 "display_name": "Max Iterations",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "verbose": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "verbose",
    //                 "value": true,
    //                 "display_name": "Verbose",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Construct an SQL agent from an LLM and tools.",
    //         "base_classes": [
    //             "AgentExecutor",
    //             "Message"
    //         ],
    //         "display_name": "SQLAgent",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "AgentExecutor"
    //                 ],
    //                 "selected": "AgentExecutor",
    //                 "name": "agent",
    //                 "display_name": "Agent",
    //                 "method": "build_agent",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "database_uri",
    //                     "extra_tools",
    //                     "llm"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "response",
    //                 "display_name": "Response",
    //                 "method": "message_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "handle_parsing_errors",
    //             "verbose",
    //             "max_iterations",
    //             "llm",
    //             "database_uri",
    //             "extra_tools"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "JsonAgent": {
    //         "template": {
    //             "_type": "Component",
    //             "llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "llm",
    //                 "value": "",
    //                 "display_name": "Language Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "LanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "path": {
    //                 "trace_as_metadata": true,
    //                 "file_path": "",
    //                 "fileTypes": [
    //                     "json",
    //                     "yaml",
    //                     "yml"
    //                 ],
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "path",
    //                 "value": "",
    //                 "display_name": "File Path",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "file",
    //                 "_input_type": "FileInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from pathlib import Path\n\nimport yaml\nfrom langchain.agents import AgentExecutor\nfrom langchain_community.agent_toolkits import create_json_agent\nfrom langchain_community.agent_toolkits.json.toolkit import JsonToolkit\nfrom langchain_community.tools.json.tool import JsonSpec\n\nfrom langflow.base.agents.agent import LCAgentComponent\nfrom langflow.inputs import FileInput, HandleInput\n\n\nclass JsonAgentComponent(LCAgentComponent):\n    display_name = \"JsonAgent\"\n    description = \"Construct a json agent from an LLM and tools.\"\n    name = \"JsonAgent\"\n\n    inputs = [\n        *LCAgentComponent._base_inputs,\n        HandleInput(name=\"llm\", display_name=\"Language Model\", input_types=[\"LanguageModel\"], required=True),\n        FileInput(name=\"path\", display_name=\"File Path\", file_types=[\"json\", \"yaml\", \"yml\"], required=True),\n    ]\n\n    def build_agent(self) -> AgentExecutor:\n        path = Path(self.path)\n        if path.suffix in (\"yaml\", \"yml\"):\n            with path.open(encoding=\"utf-8\") as file:\n                yaml_dict = yaml.safe_load(file)\n            spec = JsonSpec(dict_=yaml_dict)\n        else:\n            spec = JsonSpec.from_file(path)\n        toolkit = JsonToolkit(spec=spec)\n\n        return create_json_agent(llm=self.llm, toolkit=toolkit, **self.get_agent_kwargs())\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "handle_parsing_errors": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "handle_parsing_errors",
    //                 "value": true,
    //                 "display_name": "Handle Parse Errors",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "max_iterations": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_iterations",
    //                 "value": 15,
    //                 "display_name": "Max Iterations",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "verbose": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "verbose",
    //                 "value": true,
    //                 "display_name": "Verbose",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Construct a json agent from an LLM and tools.",
    //         "base_classes": [
    //             "AgentExecutor",
    //             "Message"
    //         ],
    //         "display_name": "JsonAgent",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "AgentExecutor"
    //                 ],
    //                 "selected": "AgentExecutor",
    //                 "name": "agent",
    //                 "display_name": "Agent",
    //                 "method": "build_agent",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "llm",
    //                     "path"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "response",
    //                 "display_name": "Response",
    //                 "method": "message_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "handle_parsing_errors",
    //             "verbose",
    //             "max_iterations",
    //             "llm",
    //             "path"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "ToolCallingAgent": {
    //         "template": {
    //             "_type": "Component",
    //             "chat_history": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chat_history",
    //                 "value": "",
    //                 "display_name": "Chat History",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "llm",
    //                 "value": "",
    //                 "display_name": "Language Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "LanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "tools": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tools",
    //                 "value": "",
    //                 "display_name": "Tools",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Tool",
    //                     "BaseTool",
    //                     "StructuredTool"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain.agents import create_tool_calling_agent\nfrom langchain_core.prompts import ChatPromptTemplate, HumanMessagePromptTemplate, PromptTemplate\n\nfrom langflow.base.agents.agent import LCToolsAgentComponent\nfrom langflow.inputs import MultilineInput\nfrom langflow.inputs.inputs import DataInput, HandleInput\nfrom langflow.schema import Data\n\n\nclass ToolCallingAgentComponent(LCToolsAgentComponent):\n    display_name: str = \"Tool Calling Agent\"\n    description: str = \"Agent that uses tools\"\n    icon = \"LangChain\"\n    beta = True\n    name = \"ToolCallingAgent\"\n\n    inputs = [\n        *LCToolsAgentComponent._base_inputs,\n        HandleInput(name=\"llm\", display_name=\"Language Model\", input_types=[\"LanguageModel\"], required=True),\n        MultilineInput(\n            name=\"system_prompt\",\n            display_name=\"System Prompt\",\n            info=\"System prompt for the agent.\",\n            value=\"You are a helpful assistant\",\n        ),\n        MultilineInput(\n            name=\"user_prompt\", display_name=\"Prompt\", info=\"This prompt must contain 'input' key.\", value=\"{input}\"\n        ),\n        DataInput(name=\"chat_history\", display_name=\"Chat History\", is_list=True, advanced=True),\n    ]\n\n    def get_chat_history_data(self) -> list[Data] | None:\n        return self.chat_history\n\n    def create_agent_runnable(self):\n        if \"input\" not in self.user_prompt:\n            msg = \"Prompt must contain 'input' key.\"\n            raise ValueError(msg)\n        messages = [\n            (\"system\", self.system_prompt),\n            (\"placeholder\", \"{chat_history}\"),\n            HumanMessagePromptTemplate(prompt=PromptTemplate(input_variables=[\"input\"], template=self.user_prompt)),\n            (\"placeholder\", \"{agent_scratchpad}\"),\n        ]\n        prompt = ChatPromptTemplate.from_messages(messages)\n        try:\n            return create_tool_calling_agent(self.llm, self.tools, prompt)\n        except NotImplementedError as e:\n            message = f\"{self.display_name} does not support tool calling.\" \"Please try using a compatible model.\"\n            raise NotImplementedError(message) from e\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "handle_parsing_errors": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "handle_parsing_errors",
    //                 "value": true,
    //                 "display_name": "Handle Parse Errors",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "max_iterations": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_iterations",
    //                 "value": 15,
    //                 "display_name": "Max Iterations",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "system_prompt": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "system_prompt",
    //                 "value": "You are a helpful assistant",
    //                 "display_name": "System Prompt",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "System prompt for the agent.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "user_prompt": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "user_prompt",
    //                 "value": "{input}",
    //                 "display_name": "Prompt",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "This prompt must contain 'input' key.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "verbose": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "verbose",
    //                 "value": true,
    //                 "display_name": "Verbose",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Agent that uses tools",
    //         "icon": "LangChain",
    //         "base_classes": [
    //             "AgentExecutor",
    //             "Message"
    //         ],
    //         "display_name": "Tool Calling Agent",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "AgentExecutor"
    //                 ],
    //                 "selected": "AgentExecutor",
    //                 "name": "agent",
    //                 "display_name": "Agent",
    //                 "method": "build_agent",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "tools"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "response",
    //                 "display_name": "Response",
    //                 "method": "message_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "handle_parsing_errors",
    //             "verbose",
    //             "max_iterations",
    //             "tools",
    //             "llm",
    //             "system_prompt",
    //             "user_prompt",
    //             "chat_history"
    //         ],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "toolkits": {
    //     "ComposioAPI": {
    //         "template": {
    //             "_type": "Component",
    //             "action_names": {
    //                 "trace_as_metadata": true,
    //                 "options": [],
    //                 "combobox": false,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "action_names",
    //                 "value": [],
    //                 "display_name": "Actions to use",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The actions to pass to agent to execute",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultiselectInput"
    //             },
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "Composio API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Refer to https://docs.composio.dev/introduction/foundations/howtos/get_api_key",
    //                 "refresh_button": true,
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "app_names": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "APALEO",
    //                     "APIFY",
    //                     "ASANA",
    //                     "ATTIO",
    //                     "BITBUCKET",
    //                     "BREVO",
    //                     "BROWSERBASE_TOOL",
    //                     "BROWSER_TOOL",
    //                     "CLICKUP",
    //                     "CODEINTERPRETER",
    //                     "CODE_FORMAT_TOOL",
    //                     "CODE_GREP_TOOL",
    //                     "CODE_INDEX_TOOL",
    //                     "CODE_MAP_TOOL",
    //                     "COMPOSIO",
    //                     "DISCORD",
    //                     "DROPBOX",
    //                     "ELEVENLABS",
    //                     "EMBED_TOOL",
    //                     "EXA",
    //                     "FIGMA",
    //                     "FILETOOL",
    //                     "FIRECRAWL",
    //                     "GIT",
    //                     "GITHUB",
    //                     "GITLAB",
    //                     "GMAIL",
    //                     "GOOGLECALENDAR",
    //                     "GOOGLEDOCS",
    //                     "GOOGLEDRIVE",
    //                     "GOOGLEMEET",
    //                     "GOOGLESHEETS",
    //                     "GOOGLETASKS",
    //                     "GREPTILE",
    //                     "HACKERNEWS",
    //                     "HEROKU",
    //                     "HISTORY_FETCHER",
    //                     "HUBSPOT",
    //                     "IMAGE_ANALYSER",
    //                     "INDUCED_AI",
    //                     "JIRA",
    //                     "KLAVIYO",
    //                     "LINEAR",
    //                     "LISTENNOTES",
    //                     "MATHEMATICAL",
    //                     "MULTIONAI",
    //                     "NASA",
    //                     "NOTION",
    //                     "OKTA",
    //                     "PAGERDUTY",
    //                     "PERPLEXITYAI",
    //                     "PIPEDRIVE",
    //                     "POSTHOG",
    //                     "RAGTOOL",
    //                     "SCHEDULER",
    //                     "SERPAPI",
    //                     "SHELLTOOL",
    //                     "SLACK",
    //                     "SLACKBOT",
    //                     "SNOWFLAKE",
    //                     "SOUNDCLOUD",
    //                     "SPIDERTOOL",
    //                     "SPLITWISE",
    //                     "SPOTIFY",
    //                     "SQLTOOL",
    //                     "STRAVA",
    //                     "TASKADE",
    //                     "TAVILY",
    //                     "TRELLO",
    //                     "TWILIO",
    //                     "TWITTER",
    //                     "TYPEFORM",
    //                     "WEATHERMAP",
    //                     "WEBTOOL",
    //                     "WHATSAPP",
    //                     "WORKABLE",
    //                     "WORKSPACE_TOOL",
    //                     "YOUSEARCH",
    //                     "YOUTUBE",
    //                     "ZENDESK",
    //                     "ZEPTOOL",
    //                     "ZOOM"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "app_names",
    //                 "value": "",
    //                 "display_name": "App Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The app name to use. Please refresh after selecting app name",
    //                 "refresh_button": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "auth_status_config": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "auth_status_config",
    //                 "value": "",
    //                 "display_name": "Auth status",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Open link or enter api key. Then refresh button",
    //                 "refresh_button": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from collections.abc import Sequence\nfrom typing import Any\n\nfrom composio_langchain import Action, App, ComposioToolSet\nfrom langchain_core.tools import Tool\nfrom loguru import logger\nfrom typing_extensions import override\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.inputs import DropdownInput, MessageTextInput, MultiselectInput, SecretStrInput, StrInput\n\n\nclass ComposioAPIComponent(LCToolComponent):\n    display_name: str = \"Composio Tools\"\n    description: str = \"Use Composio toolset to run actions with your agent\"\n    name = \"ComposioAPI\"\n    icon = \"Composio\"\n    documentation: str = \"https://docs.composio.dev\"\n\n    inputs = [\n        MessageTextInput(name=\"entity_id\", display_name=\"Entity ID\", value=\"default\", advanced=True),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Composio API Key\",\n            required=True,\n            refresh_button=True,\n            info=\"Refer to https://docs.composio.dev/introduction/foundations/howtos/get_api_key\",\n        ),\n        DropdownInput(\n            name=\"app_names\",\n            display_name=\"App Name\",\n            options=list(App.__annotations__),\n            value=\"\",\n            info=\"The app name to use. Please refresh after selecting app name\",\n            refresh_button=True,\n        ),\n        MultiselectInput(\n            name=\"action_names\",\n            display_name=\"Actions to use\",\n            required=False,\n            options=[],\n            value=[],\n            info=\"The actions to pass to agent to execute\",\n        ),\n        StrInput(\n            name=\"auth_status_config\",\n            display_name=\"Auth status\",\n            value=\"\",\n            refresh_button=True,\n            info=\"Open link or enter api key. Then refresh button\",\n        ),\n    ]\n\n    def _check_for_authorization(self, app: str) -> str:\n        \"\"\"Checks if the app is authorized.\n\n        Args:\n            app (str): The app name to check authorization for.\n\n        Returns:\n            str: The authorization status.\n        \"\"\"\n        toolset = self._build_wrapper()\n        entity = toolset.client.get_entity(id=self.entity_id)\n        try:\n            entity.get_connection(app=app)\n        except Exception:  # noqa: BLE001\n            logger.opt(exception=True).debug(\"Authorization error\")\n            return self._handle_authorization_failure(toolset, entity, app)\n\n        return f\"{app} CONNECTED\"\n\n    def _handle_authorization_failure(self, toolset: ComposioToolSet, entity: Any, app: str) -> str:\n        \"\"\"Handles the authorization failure by attempting to process API key auth or initiate default connection.\n\n        Args:\n            toolset (ComposioToolSet): The toolset instance.\n            entity (Any): The entity instance.\n            app (str): The app name.\n\n        Returns:\n            str: The result of the authorization failure message.\n        \"\"\"\n        try:\n            auth_schemes = toolset.client.apps.get(app).auth_schemes\n            if auth_schemes[0].auth_mode == \"API_KEY\":\n                return self._process_api_key_auth(entity, app)\n            return self._initiate_default_connection(entity, app)\n        except Exception:  # noqa: BLE001\n            logger.exception(\"Authorization error\")\n            return \"Error\"\n\n    def _process_api_key_auth(self, entity: Any, app: str) -> str:\n        \"\"\"Processes the API key authentication.\n\n        Args:\n            entity (Any): The entity instance.\n            app (str): The app name.\n\n        Returns:\n            str: The status of the API key authentication.\n        \"\"\"\n        auth_status_config = self.auth_status_config\n        is_url = \"http\" in auth_status_config or \"https\" in auth_status_config\n        is_different_app = \"CONNECTED\" in auth_status_config and app not in auth_status_config\n        is_default_api_key_message = \"API Key\" in auth_status_config\n\n        if is_different_app or is_url or is_default_api_key_message:\n            return \"Enter API Key\"\n        if not is_default_api_key_message:\n            entity.initiate_connection(\n                app_name=app,\n                auth_mode=\"API_KEY\",\n                auth_config={\"api_key\": self.auth_status_config},\n                use_composio_auth=False,\n                force_new_integration=True,\n            )\n            return f\"{app} CONNECTED\"\n        return \"Enter API Key\"\n\n    def _initiate_default_connection(self, entity: Any, app: str) -> str:\n        connection = entity.initiate_connection(app_name=app, use_composio_auth=True, force_new_integration=True)\n        return connection.redirectUrl\n\n    def _get_connected_app_names_for_entity(self) -> list[str]:\n        toolset = self._build_wrapper()\n        connections = toolset.client.get_entity(id=self.entity_id).get_connections()\n        return list({connection.appUniqueId for connection in connections})\n\n    def _update_app_names_with_connected_status(self, build_config: dict) -> dict:\n        connected_app_names = self._get_connected_app_names_for_entity()\n\n        app_names = [\n            f\"{app_name}_CONNECTED\" for app_name in App.__annotations__ if app_name.lower() in connected_app_names\n        ]\n        non_connected_app_names = [\n            app_name for app_name in App.__annotations__ if app_name.lower() not in connected_app_names\n        ]\n        build_config[\"app_names\"][\"options\"] = app_names + non_connected_app_names\n        build_config[\"app_names\"][\"value\"] = app_names[0] if app_names else \"\"\n        return build_config\n\n    def _get_normalized_app_name(self) -> str:\n        return self.app_names.replace(\"_CONNECTED\", \"\").replace(\"_connected\", \"\")\n\n    @override\n    def update_build_config(self, build_config: dict, field_value: Any, field_name: str | None = None) -> dict:\n        if field_name == \"api_key\":\n            if hasattr(self, \"api_key\") and self.api_key != \"\":\n                build_config = self._update_app_names_with_connected_status(build_config)\n            return build_config\n\n        if field_name in {\"app_names\", \"auth_status_config\"}:\n            if hasattr(self, \"api_key\") and self.api_key != \"\":\n                build_config[\"auth_status_config\"][\"value\"] = self._check_for_authorization(\n                    self._get_normalized_app_name()\n                )\n            all_action_names = list(Action.__annotations__)\n            app_action_names = [\n                action_name\n                for action_name in all_action_names\n                if action_name.lower().startswith(self._get_normalized_app_name().lower() + \"_\")\n            ]\n            build_config[\"action_names\"][\"options\"] = app_action_names\n            build_config[\"action_names\"][\"value\"] = [app_action_names[0]] if app_action_names else [\"\"]\n        return build_config\n\n    def build_tool(self) -> Sequence[Tool]:\n        composio_toolset = self._build_wrapper()\n        return composio_toolset.get_tools(actions=self.action_names)\n\n    def _build_wrapper(self) -> ComposioToolSet:\n        return ComposioToolSet(api_key=self.api_key)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "entity_id": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "entity_id",
    //                 "value": "default",
    //                 "display_name": "Entity ID",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Use Composio toolset to run actions with your agent",
    //         "icon": "Composio",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "Composio Tools",
    //         "documentation": "https://docs.composio.dev",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "action_names",
    //                     "api_key",
    //                     "app_names",
    //                     "auth_status_config",
    //                     "entity_id"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "entity_id",
    //             "api_key",
    //             "app_names",
    //             "action_names",
    //             "auth_status_config"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "VectorStoreInfo": {
    //         "template": {
    //             "_type": "Component",
    //             "input_vectorstore": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_vectorstore",
    //                 "value": "",
    //                 "display_name": "Vector Store",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "VectorStore"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain.agents.agent_toolkits.vectorstore.toolkit import VectorStoreInfo\n\nfrom langflow.custom import Component\nfrom langflow.inputs import HandleInput, MessageTextInput, MultilineInput\nfrom langflow.template import Output\n\n\nclass VectorStoreInfoComponent(Component):\n    display_name = \"VectorStoreInfo\"\n    description = \"Information about a VectorStore\"\n    name = \"VectorStoreInfo\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"vectorstore_name\",\n            display_name=\"Name\",\n            info=\"Name of the VectorStore\",\n            required=True,\n        ),\n        MultilineInput(\n            name=\"vectorstore_description\",\n            display_name=\"Description\",\n            info=\"Description of the VectorStore\",\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_vectorstore\",\n            display_name=\"Vector Store\",\n            input_types=[\"VectorStore\"],\n            required=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Vector Store Info\", name=\"info\", method=\"build_info\"),\n    ]\n\n    def build_info(self) -> VectorStoreInfo:\n        self.status = {\n            \"name\": self.vectorstore_name,\n            \"description\": self.vectorstore_description,\n        }\n        return VectorStoreInfo(\n            vectorstore=self.input_vectorstore, description=self.vectorstore_description, name=self.vectorstore_name\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "vectorstore_description": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "vectorstore_description",
    //                 "value": "",
    //                 "display_name": "Description",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Description of the VectorStore",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "vectorstore_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "vectorstore_name",
    //                 "value": "",
    //                 "display_name": "Name",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Name of the VectorStore",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Information about a VectorStore",
    //         "base_classes": [
    //             "VectorStoreInfo"
    //         ],
    //         "display_name": "VectorStoreInfo",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "VectorStoreInfo"
    //                 ],
    //                 "selected": "VectorStoreInfo",
    //                 "name": "info",
    //                 "display_name": "Vector Store Info",
    //                 "method": "build_info",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "vectorstore_name",
    //             "vectorstore_description",
    //             "input_vectorstore"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "MetaphorToolkit": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_core.tools import tool\nfrom metaphor_python import Metaphor\n\nfrom langflow.custom import Component\nfrom langflow.field_typing import Tool\nfrom langflow.io import BoolInput, IntInput, Output, SecretStrInput\n\n\nclass MetaphorToolkit(Component):\n    display_name = \"Metaphor\"\n    description = \"Metaphor Toolkit for search and content retrieval\"\n    documentation = \"https://python.langchain.com/docs/integrations/tools/metaphor_search\"\n    beta = True\n\n    inputs = [\n        SecretStrInput(\n            name=\"metaphor_api_key\",\n            display_name=\"Metaphor API Key\",\n            password=True,\n        ),\n        BoolInput(\n            name=\"use_autoprompt\",\n            display_name=\"Use Autoprompt\",\n            value=True,\n        ),\n        IntInput(\n            name=\"search_num_results\",\n            display_name=\"Search Number of Results\",\n            value=5,\n        ),\n        IntInput(\n            name=\"similar_num_results\",\n            display_name=\"Similar Number of Results\",\n            value=5,\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"tools\", display_name=\"Tools\", method=\"build_toolkit\"),\n    ]\n\n    def build_toolkit(self) -> Tool:\n        client = Metaphor(api_key=self.metaphor_api_key)\n\n        @tool\n        def search(query: str):\n            \"\"\"Call search engine with a query.\"\"\"\n            return client.search(query, use_autoprompt=self.use_autoprompt, num_results=self.search_num_results)\n\n        @tool\n        def get_contents(ids: list[str]):\n            \"\"\"Get contents of a webpage.\n\n            The ids passed in should be a list of ids as fetched from `search`.\n            \"\"\"\n            return client.get_contents(ids)\n\n        @tool\n        def find_similar(url: str):\n            \"\"\"Get search results similar to a given URL.\n\n            The url passed in should be a URL returned from `search`\n            \"\"\"\n            return client.find_similar(url, num_results=self.similar_num_results)\n\n        return [search, get_contents, find_similar]\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "metaphor_api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "metaphor_api_key",
    //                 "value": "",
    //                 "display_name": "Metaphor API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "search_num_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_num_results",
    //                 "value": 5,
    //                 "display_name": "Search Number of Results",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "similar_num_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "similar_num_results",
    //                 "value": 5,
    //                 "display_name": "Similar Number of Results",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "use_autoprompt": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "use_autoprompt",
    //                 "value": true,
    //                 "display_name": "Use Autoprompt",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Metaphor Toolkit for search and content retrieval",
    //         "base_classes": [
    //             "Tool"
    //         ],
    //         "display_name": "Metaphor",
    //         "documentation": "https://python.langchain.com/docs/integrations/tools/metaphor_search",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "tools",
    //                 "display_name": "Tools",
    //                 "method": "build_toolkit",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "metaphor_api_key",
    //             "use_autoprompt",
    //             "search_num_results",
    //             "similar_num_results"
    //         ],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "models": {
    //     "VertexAiModel": {
    //         "template": {
    //             "_type": "Component",
    //             "credentials": {
    //                 "trace_as_metadata": true,
    //                 "file_path": "",
    //                 "fileTypes": [
    //                     "json"
    //                 ],
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "credentials",
    //                 "value": "",
    //                 "display_name": "Credentials",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "JSON credentials file. Leave empty to fallback to environment variables",
    //                 "title_case": false,
    //                 "type": "file",
    //                 "_input_type": "FileInput"
    //             },
    //             "output_parser": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "output_parser",
    //                 "value": "",
    //                 "display_name": "Output Parser",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "OutputParser"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The parser to use to parse the output of the model",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import cast\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.inputs import MessageTextInput\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import BoolInput, FileInput, FloatInput, IntInput, StrInput\n\n\nclass ChatVertexAIComponent(LCModelComponent):\n    display_name = \"Vertex AI\"\n    description = \"Generate text using Vertex AI LLMs.\"\n    icon = \"VertexAI\"\n    name = \"VertexAiModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        FileInput(\n            name=\"credentials\",\n            display_name=\"Credentials\",\n            info=\"JSON credentials file. Leave empty to fallback to environment variables\",\n            file_types=[\"json\"],\n        ),\n        MessageTextInput(name=\"model_name\", display_name=\"Model Name\", value=\"gemini-1.5-pro\"),\n        StrInput(name=\"project\", display_name=\"Project\", info=\"The project ID.\", advanced=True),\n        StrInput(name=\"location\", display_name=\"Location\", value=\"us-central1\", advanced=True),\n        IntInput(name=\"max_output_tokens\", display_name=\"Max Output Tokens\", advanced=True),\n        IntInput(name=\"max_retries\", display_name=\"Max Retries\", value=1, advanced=True),\n        FloatInput(name=\"temperature\", value=0.0, display_name=\"Temperature\"),\n        IntInput(name=\"top_k\", display_name=\"Top K\", advanced=True),\n        FloatInput(name=\"top_p\", display_name=\"Top P\", value=0.95, advanced=True),\n        BoolInput(name=\"verbose\", display_name=\"Verbose\", value=False, advanced=True),\n        HandleInput(\n            name=\"output_parser\",\n            display_name=\"Output Parser\",\n            info=\"The parser to use to parse the output of the model\",\n            advanced=True,\n            input_types=[\"OutputParser\"],\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:\n        try:\n            from langchain_google_vertexai import ChatVertexAI\n        except ImportError as e:\n            msg = \"Please install the langchain-google-vertexai package to use the VertexAIEmbeddings component.\"\n            raise ImportError(msg) from e\n        location = self.location or None\n        if self.credentials:\n            from google.cloud import aiplatform\n            from google.oauth2 import service_account\n\n            credentials = service_account.Credentials.from_service_account_file(self.credentials)\n            project = self.project or credentials.project_id\n            # ChatVertexAI sometimes skip manual credentials initialization\n            aiplatform.init(\n                project=project,\n                location=location,\n                credentials=credentials,\n            )\n        else:\n            project = self.project or None\n            credentials = None\n\n        return cast(\n            LanguageModel,\n            ChatVertexAI(\n                credentials=credentials,\n                location=location,\n                project=project,\n                max_output_tokens=self.max_output_tokens or None,\n                max_retries=self.max_retries,\n                model_name=self.model_name,\n                temperature=self.temperature,\n                top_k=self.top_k or None,\n                top_p=self.top_p,\n                verbose=self.verbose,\n            ),\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "location": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "location",
    //                 "value": "us-central1",
    //                 "display_name": "Location",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "max_output_tokens": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_output_tokens",
    //                 "value": "",
    //                 "display_name": "Max Output Tokens",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "max_retries": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_retries",
    //                 "value": 1,
    //                 "display_name": "Max Retries",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "model_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_name",
    //                 "value": "gemini-1.5-pro",
    //                 "display_name": "Model Name",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "project": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "project",
    //                 "value": "",
    //                 "display_name": "Project",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The project ID.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "stream": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "stream",
    //                 "value": false,
    //                 "display_name": "Stream",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Stream the response from the model. Streaming works only in Chat.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "system_message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "system_message",
    //                 "value": "",
    //                 "display_name": "System Message",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "System message to pass to the model.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "temperature": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "temperature",
    //                 "value": 0.0,
    //                 "display_name": "Temperature",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "top_k": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "top_k",
    //                 "value": "",
    //                 "display_name": "Top K",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "top_p": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "top_p",
    //                 "value": 0.95,
    //                 "display_name": "Top P",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "verbose": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "verbose",
    //                 "value": false,
    //                 "display_name": "Verbose",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Generate text using Vertex AI LLMs.",
    //         "icon": "VertexAI",
    //         "base_classes": [
    //             "LanguageModel",
    //             "Message"
    //         ],
    //         "display_name": "Vertex AI",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text_output",
    //                 "display_name": "Text",
    //                 "method": "text_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "stream",
    //                     "system_message"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "LanguageModel"
    //                 ],
    //                 "selected": "LanguageModel",
    //                 "name": "model_output",
    //                 "display_name": "Language Model",
    //                 "method": "build_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "credentials",
    //                     "location",
    //                     "max_output_tokens",
    //                     "max_retries",
    //                     "model_name",
    //                     "project",
    //                     "temperature",
    //                     "top_k",
    //                     "top_p",
    //                     "verbose"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "system_message",
    //             "stream",
    //             "credentials",
    //             "model_name",
    //             "project",
    //             "location",
    //             "max_output_tokens",
    //             "max_retries",
    //             "temperature",
    //             "top_k",
    //             "top_p",
    //             "verbose",
    //             "output_parser"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "BaiduQianfanChatModel": {
    //         "template": {
    //             "_type": "Component",
    //             "output_parser": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "output_parser",
    //                 "value": "",
    //                 "display_name": "Output Parser",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "OutputParser"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The parser to use to parse the output of the model",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_community.chat_models.baidu_qianfan_endpoint import QianfanChatEndpoint\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing.constants import LanguageModel\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import DropdownInput, FloatInput, MessageTextInput, SecretStrInput\n\n\nclass QianfanChatEndpointComponent(LCModelComponent):\n    display_name: str = \"Qianfan\"\n    description: str = \"Generate text using Baidu Qianfan LLMs.\"\n    documentation: str = \"https://python.langchain.com/docs/integrations/chat/baidu_qianfan_endpoint\"\n    icon = \"BaiduQianfan\"\n    name = \"BaiduQianfanChatModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        DropdownInput(\n            name=\"model\",\n            display_name=\"Model Name\",\n            options=[\n                \"ERNIE-Bot\",\n                \"ERNIE-Bot-turbo\",\n                \"BLOOMZ-7B\",\n                \"Llama-2-7b-chat\",\n                \"Llama-2-13b-chat\",\n                \"Llama-2-70b-chat\",\n                \"Qianfan-BLOOMZ-7B-compressed\",\n                \"Qianfan-Chinese-Llama-2-7B\",\n                \"ChatGLM2-6B-32K\",\n                \"AquilaChat-7B\",\n            ],\n            info=\"https://python.langchain.com/docs/integrations/chat/baidu_qianfan_endpoint\",\n            value=\"ERNIE-Bot-turbo\",\n        ),\n        SecretStrInput(\n            name=\"qianfan_ak\",\n            display_name=\"Qianfan Ak\",\n            info=\"which you could get from  https://cloud.baidu.com/product/wenxinworkshop\",\n        ),\n        SecretStrInput(\n            name=\"qianfan_sk\",\n            display_name=\"Qianfan Sk\",\n            info=\"which you could get from  https://cloud.baidu.com/product/wenxinworkshop\",\n        ),\n        FloatInput(\n            name=\"top_p\",\n            display_name=\"Top p\",\n            info=\"Model params, only supported in ERNIE-Bot and ERNIE-Bot-turbo\",\n            value=0.8,\n            advanced=True,\n        ),\n        FloatInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            info=\"Model params, only supported in ERNIE-Bot and ERNIE-Bot-turbo\",\n            value=0.95,\n        ),\n        FloatInput(\n            name=\"penalty_score\",\n            display_name=\"Penalty Score\",\n            info=\"Model params, only supported in ERNIE-Bot and ERNIE-Bot-turbo\",\n            value=1.0,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"endpoint\", display_name=\"Endpoint\", info=\"Endpoint of the Qianfan LLM, required if custom model used.\"\n        ),\n        HandleInput(\n            name=\"output_parser\",\n            display_name=\"Output Parser\",\n            info=\"The parser to use to parse the output of the model\",\n            advanced=True,\n            input_types=[\"OutputParser\"],\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        model = self.model\n        qianfan_ak = self.qianfan_ak\n        qianfan_sk = self.qianfan_sk\n        top_p = self.top_p\n        temperature = self.temperature\n        penalty_score = self.penalty_score\n        endpoint = self.endpoint\n\n        try:\n            output = QianfanChatEndpoint(\n                model=model,\n                qianfan_ak=SecretStr(qianfan_ak).get_secret_value() if qianfan_ak else None,\n                qianfan_sk=SecretStr(qianfan_sk).get_secret_value() if qianfan_sk else None,\n                top_p=top_p,\n                temperature=temperature,\n                penalty_score=penalty_score,\n                endpoint=endpoint,\n            )\n        except Exception as e:\n            msg = \"Could not connect to Baidu Qianfan API.\"\n            raise ValueError(msg) from e\n\n        return output\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "endpoint": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "endpoint",
    //                 "value": "",
    //                 "display_name": "Endpoint",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Endpoint of the Qianfan LLM, required if custom model used.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "model": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "ERNIE-Bot",
    //                     "ERNIE-Bot-turbo",
    //                     "BLOOMZ-7B",
    //                     "Llama-2-7b-chat",
    //                     "Llama-2-13b-chat",
    //                     "Llama-2-70b-chat",
    //                     "Qianfan-BLOOMZ-7B-compressed",
    //                     "Qianfan-Chinese-Llama-2-7B",
    //                     "ChatGLM2-6B-32K",
    //                     "AquilaChat-7B"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model",
    //                 "value": "ERNIE-Bot-turbo",
    //                 "display_name": "Model Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "https://python.langchain.com/docs/integrations/chat/baidu_qianfan_endpoint",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "penalty_score": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "penalty_score",
    //                 "value": 1.0,
    //                 "display_name": "Penalty Score",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Model params, only supported in ERNIE-Bot and ERNIE-Bot-turbo",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "qianfan_ak": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "qianfan_ak",
    //                 "value": "",
    //                 "display_name": "Qianfan Ak",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "which you could get from  https://cloud.baidu.com/product/wenxinworkshop",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "qianfan_sk": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "qianfan_sk",
    //                 "value": "",
    //                 "display_name": "Qianfan Sk",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "which you could get from  https://cloud.baidu.com/product/wenxinworkshop",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "stream": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "stream",
    //                 "value": false,
    //                 "display_name": "Stream",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Stream the response from the model. Streaming works only in Chat.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "system_message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "system_message",
    //                 "value": "",
    //                 "display_name": "System Message",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "System message to pass to the model.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "temperature": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "temperature",
    //                 "value": 0.95,
    //                 "display_name": "Temperature",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Model params, only supported in ERNIE-Bot and ERNIE-Bot-turbo",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "top_p": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "top_p",
    //                 "value": 0.8,
    //                 "display_name": "Top p",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Model params, only supported in ERNIE-Bot and ERNIE-Bot-turbo",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             }
    //         },
    //         "description": "Generate text using Baidu Qianfan LLMs.",
    //         "icon": "BaiduQianfan",
    //         "base_classes": [
    //             "LanguageModel",
    //             "Message"
    //         ],
    //         "display_name": "Qianfan",
    //         "documentation": "https://python.langchain.com/docs/integrations/chat/baidu_qianfan_endpoint",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text_output",
    //                 "display_name": "Text",
    //                 "method": "text_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "stream",
    //                     "system_message"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "LanguageModel"
    //                 ],
    //                 "selected": "LanguageModel",
    //                 "name": "model_output",
    //                 "display_name": "Language Model",
    //                 "method": "build_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "endpoint",
    //                     "model",
    //                     "penalty_score",
    //                     "qianfan_ak",
    //                     "qianfan_sk",
    //                     "temperature",
    //                     "top_p"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "system_message",
    //             "stream",
    //             "model",
    //             "qianfan_ak",
    //             "qianfan_sk",
    //             "top_p",
    //             "temperature",
    //             "penalty_score",
    //             "endpoint",
    //             "output_parser"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "Maritalk": {
    //         "template": {
    //             "_type": "Component",
    //             "output_parser": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "output_parser",
    //                 "value": "",
    //                 "display_name": "Output Parser",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "OutputParser"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The parser to use to parse the output of the model",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "Maritalk API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The Maritalk API Key to use for the OpenAI model.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_community.chat_models import ChatMaritalk\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import DropdownInput, FloatInput, IntInput, SecretStrInput\nfrom langflow.inputs.inputs import HandleInput\n\n\nclass MaritalkModelComponent(LCModelComponent):\n    display_name = \"Maritalk\"\n    description = \"Generates text using Maritalk LLMs.\"\n    icon = \"Maritalk\"\n    name = \"Maritalk\"\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            value=512,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            advanced=False,\n            options=[\"sabia-2-small\", \"sabia-2-medium\"],\n            value=[\"sabia-2-small\"],\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Maritalk API Key\",\n            info=\"The Maritalk API Key to use for the OpenAI model.\",\n            advanced=False,\n        ),\n        FloatInput(name=\"temperature\", display_name=\"Temperature\", value=0.1, range_spec=RangeSpec(min=0, max=1)),\n        HandleInput(\n            name=\"output_parser\",\n            display_name=\"Output Parser\",\n            info=\"The parser to use to parse the output of the model\",\n            advanced=True,\n            input_types=[\"OutputParser\"],\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        # self.output_schea is a list of dictionarie s\n        # let's convert it to a dictionary\n        api_key = self.api_key\n        temperature = self.temperature\n        model_name: str = self.model_name\n        max_tokens = self.max_tokens\n\n        return ChatMaritalk(\n            max_tokens=max_tokens,\n            model=model_name,\n            api_key=api_key,\n            temperature=temperature or 0.1,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "max_tokens": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_tokens",
    //                 "value": 512,
    //                 "display_name": "Max Tokens",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "model_name": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "sabia-2-small",
    //                     "sabia-2-medium"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_name",
    //                 "value": [
    //                     "sabia-2-small"
    //                 ],
    //                 "display_name": "Model Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "stream": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "stream",
    //                 "value": false,
    //                 "display_name": "Stream",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Stream the response from the model. Streaming works only in Chat.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "system_message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "system_message",
    //                 "value": "",
    //                 "display_name": "System Message",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "System message to pass to the model.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "temperature": {
    //                 "trace_as_metadata": true,
    //                 "range_spec": {
    //                     "step_type": "float",
    //                     "min": 0.0,
    //                     "max": 1.0,
    //                     "step": 0.1
    //                 },
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "temperature",
    //                 "value": 0.1,
    //                 "display_name": "Temperature",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             }
    //         },
    //         "description": "Generates text using Maritalk LLMs.",
    //         "icon": "Maritalk",
    //         "base_classes": [
    //             "LanguageModel",
    //             "Message"
    //         ],
    //         "display_name": "Maritalk",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text_output",
    //                 "display_name": "Text",
    //                 "method": "text_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "stream",
    //                     "system_message"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "LanguageModel"
    //                 ],
    //                 "selected": "LanguageModel",
    //                 "name": "model_output",
    //                 "display_name": "Language Model",
    //                 "method": "build_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_key",
    //                     "max_tokens",
    //                     "model_name",
    //                     "temperature"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "system_message",
    //             "stream",
    //             "max_tokens",
    //             "model_name",
    //             "api_key",
    //             "temperature",
    //             "output_parser"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "NVIDIAModelComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "output_parser": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "output_parser",
    //                 "value": "",
    //                 "display_name": "Output Parser",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "OutputParser"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The parser to use to parse the output of the model",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "base_url": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "base_url",
    //                 "value": "https://integrate.api.nvidia.com/v1",
    //                 "display_name": "NVIDIA Base URL",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The base URL of the NVIDIA API. Defaults to https://integrate.api.nvidia.com/v1.",
    //                 "refresh_button": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.inputs import DropdownInput, FloatInput, IntInput, SecretStrInput, StrInput\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.schema.dotdict import dotdict\n\n\nclass NVIDIAModelComponent(LCModelComponent):\n    display_name = \"NVIDIA\"\n    description = \"Generates text using NVIDIA LLMs.\"\n    icon = \"NVIDIA\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            advanced=False,\n            options=[\"mistralai/mixtral-8x7b-instruct-v0.1\"],\n            value=\"mistralai/mixtral-8x7b-instruct-v0.1\",\n        ),\n        StrInput(\n            name=\"base_url\",\n            display_name=\"NVIDIA Base URL\",\n            value=\"https://integrate.api.nvidia.com/v1\",\n            refresh_button=True,\n            info=\"The base URL of the NVIDIA API. Defaults to https://integrate.api.nvidia.com/v1.\",\n        ),\n        SecretStrInput(\n            name=\"nvidia_api_key\",\n            display_name=\"NVIDIA API Key\",\n            info=\"The NVIDIA API Key.\",\n            advanced=False,\n            value=\"NVIDIA_API_KEY\",\n        ),\n        FloatInput(name=\"temperature\", display_name=\"Temperature\", value=0.1),\n        IntInput(\n            name=\"seed\",\n            display_name=\"Seed\",\n            info=\"The seed controls the reproducibility of the job.\",\n            advanced=True,\n            value=1,\n        ),\n        HandleInput(\n            name=\"output_parser\",\n            display_name=\"Output Parser\",\n            info=\"The parser to use to parse the output of the model\",\n            advanced=True,\n            input_types=[\"OutputParser\"],\n        ),\n    ]\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"base_url\" and field_value:\n            try:\n                build_model = self.build_model()\n                ids = [model.id for model in build_model.available_models]\n                build_config[\"model_name\"][\"options\"] = ids\n                build_config[\"model_name\"][\"value\"] = ids[0]\n            except Exception as e:\n                msg = f\"Error getting model names: {e}\"\n                raise ValueError(msg) from e\n        return build_config\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        try:\n            from langchain_nvidia_ai_endpoints import ChatNVIDIA\n        except ImportError as e:\n            msg = \"Please install langchain-nvidia-ai-endpoints to use the NVIDIA model.\"\n            raise ImportError(msg) from e\n        nvidia_api_key = self.nvidia_api_key\n        temperature = self.temperature\n        model_name: str = self.model_name\n        max_tokens = self.max_tokens\n        seed = self.seed\n        return ChatNVIDIA(\n            max_tokens=max_tokens or None,\n            model=model_name,\n            base_url=self.base_url,\n            api_key=nvidia_api_key,\n            temperature=temperature or 0.1,\n            seed=seed,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "max_tokens": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_tokens",
    //                 "value": "",
    //                 "display_name": "Max Tokens",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "model_name": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "mistralai/mixtral-8x7b-instruct-v0.1"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_name",
    //                 "value": "mistralai/mixtral-8x7b-instruct-v0.1",
    //                 "display_name": "Model Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "nvidia_api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "nvidia_api_key",
    //                 "value": "NVIDIA_API_KEY",
    //                 "display_name": "NVIDIA API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The NVIDIA API Key.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "seed": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "seed",
    //                 "value": 1,
    //                 "display_name": "Seed",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The seed controls the reproducibility of the job.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "stream": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "stream",
    //                 "value": false,
    //                 "display_name": "Stream",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Stream the response from the model. Streaming works only in Chat.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "system_message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "system_message",
    //                 "value": "",
    //                 "display_name": "System Message",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "System message to pass to the model.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "temperature": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "temperature",
    //                 "value": 0.1,
    //                 "display_name": "Temperature",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             }
    //         },
    //         "description": "Generates text using NVIDIA LLMs.",
    //         "icon": "NVIDIA",
    //         "base_classes": [
    //             "LanguageModel",
    //             "Message"
    //         ],
    //         "display_name": "NVIDIA",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text_output",
    //                 "display_name": "Text",
    //                 "method": "text_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "stream",
    //                     "system_message"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "LanguageModel"
    //                 ],
    //                 "selected": "LanguageModel",
    //                 "name": "model_output",
    //                 "display_name": "Language Model",
    //                 "method": "build_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "base_url",
    //                     "max_tokens",
    //                     "model_name",
    //                     "nvidia_api_key",
    //                     "seed",
    //                     "temperature"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "system_message",
    //             "stream",
    //             "max_tokens",
    //             "model_name",
    //             "base_url",
    //             "nvidia_api_key",
    //             "temperature",
    //             "seed",
    //             "output_parser"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AmazonBedrockModel": {
    //         "template": {
    //             "_type": "Component",
    //             "output_parser": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "output_parser",
    //                 "value": "",
    //                 "display_name": "Output Parser",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "OutputParser"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The parser to use to parse the output of the model",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "aws_access_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "aws_access_key",
    //                 "value": "",
    //                 "display_name": "Access Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "aws_secret_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "aws_secret_key",
    //                 "value": "",
    //                 "display_name": "Secret Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.inputs import MessageTextInput, SecretStrInput\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import DictInput, DropdownInput\n\n\nclass AmazonBedrockComponent(LCModelComponent):\n    display_name: str = \"Amazon Bedrock\"\n    description: str = \"Generate text using Amazon Bedrock LLMs.\"\n    icon = \"Amazon\"\n    name = \"AmazonBedrockModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        DropdownInput(\n            name=\"model_id\",\n            display_name=\"Model ID\",\n            options=[\n                \"amazon.titan-text-express-v1\",\n                \"amazon.titan-text-lite-v1\",\n                \"amazon.titan-text-premier-v1:0\",\n                \"amazon.titan-embed-text-v1\",\n                \"amazon.titan-embed-text-v2:0\",\n                \"amazon.titan-embed-image-v1\",\n                \"amazon.titan-image-generator-v1\",\n                \"anthropic.claude-v2\",\n                \"anthropic.claude-v2:1\",\n                \"anthropic.claude-3-sonnet-20240229-v1:0\",\n                \"anthropic.claude-3-haiku-20240307-v1:0\",\n                \"anthropic.claude-3-opus-20240229-v1:0\",\n                \"anthropic.claude-instant-v1\",\n                \"ai21.j2-mid-v1\",\n                \"ai21.j2-ultra-v1\",\n                \"cohere.command-text-v14\",\n                \"cohere.command-light-text-v14\",\n                \"cohere.command-r-v1:0\",\n                \"cohere.command-r-plus-v1:0\",\n                \"cohere.embed-english-v3\",\n                \"cohere.embed-multilingual-v3\",\n                \"meta.llama2-13b-chat-v1\",\n                \"meta.llama2-70b-chat-v1\",\n                \"meta.llama3-8b-instruct-v1:0\",\n                \"meta.llama3-70b-instruct-v1:0\",\n                \"mistral.mistral-7b-instruct-v0:2\",\n                \"mistral.mixtral-8x7b-instruct-v0:1\",\n                \"mistral.mistral-large-2402-v1:0\",\n                \"mistral.mistral-small-2402-v1:0\",\n                \"stability.stable-diffusion-xl-v0\",\n                \"stability.stable-diffusion-xl-v1\",\n            ],\n            value=\"anthropic.claude-3-haiku-20240307-v1:0\",\n        ),\n        SecretStrInput(name=\"aws_access_key\", display_name=\"Access Key\"),\n        SecretStrInput(name=\"aws_secret_key\", display_name=\"Secret Key\"),\n        MessageTextInput(name=\"credentials_profile_name\", display_name=\"Credentials Profile Name\", advanced=True),\n        MessageTextInput(name=\"region_name\", display_name=\"Region Name\", value=\"us-east-1\"),\n        DictInput(name=\"model_kwargs\", display_name=\"Model Kwargs\", advanced=True, is_list=True),\n        MessageTextInput(name=\"endpoint_url\", display_name=\"Endpoint URL\", advanced=True),\n        HandleInput(\n            name=\"output_parser\",\n            display_name=\"Output Parser\",\n            info=\"The parser to use to parse the output of the model\",\n            advanced=True,\n            input_types=[\"OutputParser\"],\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        try:\n            from langchain_aws import ChatBedrock\n        except ImportError as e:\n            msg = \"langchain_aws is not installed. Please install it with `pip install langchain_aws`.\"\n            raise ImportError(msg) from e\n        if self.aws_access_key:\n            import boto3\n\n            session = boto3.Session(\n                aws_access_key_id=self.aws_access_key,\n                aws_secret_access_key=self.aws_secret_key,\n            )\n        elif self.credentials_profile_name:\n            import boto3\n\n            session = boto3.Session(profile_name=self.credentials_profile_name)\n        else:\n            import boto3\n\n            session = boto3.Session()\n\n        client_params = {}\n        if self.endpoint_url:\n            client_params[\"endpoint_url\"] = self.endpoint_url\n        if self.region_name:\n            client_params[\"region_name\"] = self.region_name\n\n        boto3_client = session.client(\"bedrock-runtime\", **client_params)\n        try:\n            output = ChatBedrock(\n                client=boto3_client,\n                model_id=self.model_id,\n                region_name=self.region_name,\n                model_kwargs=self.model_kwargs,\n                endpoint_url=self.endpoint_url,\n                streaming=self.stream,\n            )\n        except Exception as e:\n            msg = \"Could not connect to AmazonBedrock API.\"\n            raise ValueError(msg) from e\n        return output\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "credentials_profile_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "credentials_profile_name",
    //                 "value": "",
    //                 "display_name": "Credentials Profile Name",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "endpoint_url": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "endpoint_url",
    //                 "value": "",
    //                 "display_name": "Endpoint URL",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "model_id": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "amazon.titan-text-express-v1",
    //                     "amazon.titan-text-lite-v1",
    //                     "amazon.titan-text-premier-v1:0",
    //                     "amazon.titan-embed-text-v1",
    //                     "amazon.titan-embed-text-v2:0",
    //                     "amazon.titan-embed-image-v1",
    //                     "amazon.titan-image-generator-v1",
    //                     "anthropic.claude-v2",
    //                     "anthropic.claude-v2:1",
    //                     "anthropic.claude-3-sonnet-20240229-v1:0",
    //                     "anthropic.claude-3-haiku-20240307-v1:0",
    //                     "anthropic.claude-3-opus-20240229-v1:0",
    //                     "anthropic.claude-instant-v1",
    //                     "ai21.j2-mid-v1",
    //                     "ai21.j2-ultra-v1",
    //                     "cohere.command-text-v14",
    //                     "cohere.command-light-text-v14",
    //                     "cohere.command-r-v1:0",
    //                     "cohere.command-r-plus-v1:0",
    //                     "cohere.embed-english-v3",
    //                     "cohere.embed-multilingual-v3",
    //                     "meta.llama2-13b-chat-v1",
    //                     "meta.llama2-70b-chat-v1",
    //                     "meta.llama3-8b-instruct-v1:0",
    //                     "meta.llama3-70b-instruct-v1:0",
    //                     "mistral.mistral-7b-instruct-v0:2",
    //                     "mistral.mixtral-8x7b-instruct-v0:1",
    //                     "mistral.mistral-large-2402-v1:0",
    //                     "mistral.mistral-small-2402-v1:0",
    //                     "stability.stable-diffusion-xl-v0",
    //                     "stability.stable-diffusion-xl-v1"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_id",
    //                 "value": "anthropic.claude-3-haiku-20240307-v1:0",
    //                 "display_name": "Model ID",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "model_kwargs": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_kwargs",
    //                 "value": {},
    //                 "display_name": "Model Kwargs",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "region_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "region_name",
    //                 "value": "us-east-1",
    //                 "display_name": "Region Name",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "stream": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "stream",
    //                 "value": false,
    //                 "display_name": "Stream",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Stream the response from the model. Streaming works only in Chat.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "system_message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "system_message",
    //                 "value": "",
    //                 "display_name": "System Message",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "System message to pass to the model.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Generate text using Amazon Bedrock LLMs.",
    //         "icon": "Amazon",
    //         "base_classes": [
    //             "LanguageModel",
    //             "Message"
    //         ],
    //         "display_name": "Amazon Bedrock",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text_output",
    //                 "display_name": "Text",
    //                 "method": "text_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "stream",
    //                     "system_message"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "LanguageModel"
    //                 ],
    //                 "selected": "LanguageModel",
    //                 "name": "model_output",
    //                 "display_name": "Language Model",
    //                 "method": "build_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "aws_access_key",
    //                     "aws_secret_key",
    //                     "credentials_profile_name",
    //                     "endpoint_url",
    //                     "model_id",
    //                     "model_kwargs",
    //                     "region_name",
    //                     "stream"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "system_message",
    //             "stream",
    //             "model_id",
    //             "aws_access_key",
    //             "aws_secret_key",
    //             "credentials_profile_name",
    //             "region_name",
    //             "model_kwargs",
    //             "endpoint_url",
    //             "output_parser"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "MistralModel": {
    //         "template": {
    //             "_type": "Component",
    //             "output_parser": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "output_parser",
    //                 "value": "",
    //                 "display_name": "Output Parser",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "OutputParser"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The parser to use to parse the output of the model",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "Mistral API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The Mistral API Key to use for the Mistral model.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_mistralai import ChatMistralAI\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import BoolInput, DropdownInput, FloatInput, IntInput, SecretStrInput, StrInput\n\n\nclass MistralAIModelComponent(LCModelComponent):\n    display_name = \"MistralAI\"\n    description = \"Generates text using MistralAI LLMs.\"\n    icon = \"MistralAI\"\n    name = \"MistralModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            advanced=False,\n            options=[\n                \"open-mixtral-8x7b\",\n                \"open-mixtral-8x22b\",\n                \"mistral-small-latest\",\n                \"mistral-medium-latest\",\n                \"mistral-large-latest\",\n                \"codestral-latest\",\n            ],\n            value=\"codestral-latest\",\n        ),\n        StrInput(\n            name=\"mistral_api_base\",\n            display_name=\"Mistral API Base\",\n            advanced=True,\n            info=\"The base URL of the Mistral API. Defaults to https://api.mistral.ai/v1. \"\n            \"You can change this to use other APIs like JinaChat, LocalAI and Prem.\",\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Mistral API Key\",\n            info=\"The Mistral API Key to use for the Mistral model.\",\n            advanced=False,\n        ),\n        FloatInput(name=\"temperature\", display_name=\"Temperature\", advanced=False, value=0.5),\n        IntInput(name=\"max_retries\", display_name=\"Max Retries\", advanced=True, value=5),\n        IntInput(name=\"timeout\", display_name=\"Timeout\", advanced=True, value=60),\n        IntInput(name=\"max_concurrent_requests\", display_name=\"Max Concurrent Requests\", advanced=True, value=3),\n        FloatInput(name=\"top_p\", display_name=\"Top P\", advanced=True, value=1),\n        IntInput(name=\"random_seed\", display_name=\"Random Seed\", value=1, advanced=True),\n        BoolInput(name=\"safe_mode\", display_name=\"Safe Mode\", advanced=True),\n        HandleInput(\n            name=\"output_parser\",\n            display_name=\"Output Parser\",\n            info=\"The parser to use to parse the output of the model\",\n            advanced=True,\n            input_types=[\"OutputParser\"],\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        mistral_api_key = self.api_key\n        temperature = self.temperature\n        model_name = self.model_name\n        max_tokens = self.max_tokens\n        mistral_api_base = self.mistral_api_base or \"https://api.mistral.ai/v1\"\n        max_retries = self.max_retries\n        timeout = self.timeout\n        max_concurrent_requests = self.max_concurrent_requests\n        top_p = self.top_p\n        random_seed = self.random_seed\n        safe_mode = self.safe_mode\n\n        api_key = SecretStr(mistral_api_key).get_secret_value() if mistral_api_key else None\n\n        return ChatMistralAI(\n            max_tokens=max_tokens or None,\n            model_name=model_name,\n            endpoint=mistral_api_base,\n            api_key=api_key,\n            temperature=temperature,\n            max_retries=max_retries,\n            timeout=timeout,\n            max_concurrent_requests=max_concurrent_requests,\n            top_p=top_p,\n            random_seed=random_seed,\n            safe_mode=safe_mode,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "max_concurrent_requests": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_concurrent_requests",
    //                 "value": 3,
    //                 "display_name": "Max Concurrent Requests",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "max_retries": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_retries",
    //                 "value": 5,
    //                 "display_name": "Max Retries",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "max_tokens": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_tokens",
    //                 "value": "",
    //                 "display_name": "Max Tokens",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "mistral_api_base": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "mistral_api_base",
    //                 "value": "",
    //                 "display_name": "Mistral API Base",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The base URL of the Mistral API. Defaults to https://api.mistral.ai/v1. You can change this to use other APIs like JinaChat, LocalAI and Prem.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "model_name": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "open-mixtral-8x7b",
    //                     "open-mixtral-8x22b",
    //                     "mistral-small-latest",
    //                     "mistral-medium-latest",
    //                     "mistral-large-latest",
    //                     "codestral-latest"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_name",
    //                 "value": "codestral-latest",
    //                 "display_name": "Model Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "random_seed": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "random_seed",
    //                 "value": 1,
    //                 "display_name": "Random Seed",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "safe_mode": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "safe_mode",
    //                 "value": false,
    //                 "display_name": "Safe Mode",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "stream": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "stream",
    //                 "value": false,
    //                 "display_name": "Stream",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Stream the response from the model. Streaming works only in Chat.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "system_message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "system_message",
    //                 "value": "",
    //                 "display_name": "System Message",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "System message to pass to the model.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "temperature": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "temperature",
    //                 "value": 0.5,
    //                 "display_name": "Temperature",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "timeout": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "timeout",
    //                 "value": 60,
    //                 "display_name": "Timeout",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "top_p": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "top_p",
    //                 "value": 1.0,
    //                 "display_name": "Top P",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             }
    //         },
    //         "description": "Generates text using MistralAI LLMs.",
    //         "icon": "MistralAI",
    //         "base_classes": [
    //             "LanguageModel",
    //             "Message"
    //         ],
    //         "display_name": "MistralAI",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text_output",
    //                 "display_name": "Text",
    //                 "method": "text_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "stream",
    //                     "system_message"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "LanguageModel"
    //                 ],
    //                 "selected": "LanguageModel",
    //                 "name": "model_output",
    //                 "display_name": "Language Model",
    //                 "method": "build_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_key",
    //                     "max_concurrent_requests",
    //                     "max_retries",
    //                     "max_tokens",
    //                     "mistral_api_base",
    //                     "model_name",
    //                     "random_seed",
    //                     "safe_mode",
    //                     "temperature",
    //                     "timeout",
    //                     "top_p"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "system_message",
    //             "stream",
    //             "max_tokens",
    //             "model_name",
    //             "mistral_api_base",
    //             "api_key",
    //             "temperature",
    //             "max_retries",
    //             "timeout",
    //             "max_concurrent_requests",
    //             "top_p",
    //             "random_seed",
    //             "safe_mode",
    //             "output_parser"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AIMLModel": {
    //         "template": {
    //             "_type": "Component",
    //             "output_parser": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "output_parser",
    //                 "value": "",
    //                 "display_name": "Output Parser",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "OutputParser"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The parser to use to parse the output of the model",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "aiml_api_base": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "aiml_api_base",
    //                 "value": "",
    //                 "display_name": "AIML API Base",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The base URL of the OpenAI API. Defaults to https://api.aimlapi.com . You can change this to use other APIs like JinaChat, LocalAI and Prem.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "AIML_API_KEY",
    //                 "display_name": "AIML API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The AIML API Key to use for the OpenAI model.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_openai import ChatOpenAI\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.aiml_constants import AIML_CHAT_MODELS\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import (\n    DictInput,\n    DropdownInput,\n    FloatInput,\n    IntInput,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.inputs.inputs import HandleInput\n\n\nclass AIMLModelComponent(LCModelComponent):\n    display_name = \"AIML\"\n    description = \"Generates text using AIML LLMs.\"\n    icon = \"AIML\"\n    name = \"AIMLModel\"\n    documentation = \"https://docs.aimlapi.com/api-reference\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n            range_spec=RangeSpec(min=0, max=128000),\n        ),\n        DictInput(name=\"model_kwargs\", display_name=\"Model Kwargs\", advanced=True),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            advanced=False,\n            options=AIML_CHAT_MODELS,\n            value=AIML_CHAT_MODELS[0],\n        ),\n        StrInput(\n            name=\"aiml_api_base\",\n            display_name=\"AIML API Base\",\n            advanced=True,\n            info=\"The base URL of the OpenAI API. Defaults to https://api.aimlapi.com . \"\n            \"You can change this to use other APIs like JinaChat, LocalAI and Prem.\",\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"AIML API Key\",\n            info=\"The AIML API Key to use for the OpenAI model.\",\n            advanced=False,\n            value=\"AIML_API_KEY\",\n        ),\n        FloatInput(name=\"temperature\", display_name=\"Temperature\", value=0.1),\n        IntInput(\n            name=\"seed\",\n            display_name=\"Seed\",\n            info=\"The seed controls the reproducibility of the job.\",\n            advanced=True,\n            value=1,\n        ),\n        HandleInput(\n            name=\"output_parser\",\n            display_name=\"Output Parser\",\n            info=\"The parser to use to parse the output of the model\",\n            advanced=True,\n            input_types=[\"OutputParser\"],\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        aiml_api_key = self.api_key\n        temperature = self.temperature\n        model_name: str = self.model_name\n        max_tokens = self.max_tokens\n        model_kwargs = self.model_kwargs or {}\n        aiml_api_base = self.aiml_api_base or \"https://api.aimlapi.com\"\n        seed = self.seed\n\n        openai_api_key = aiml_api_key.get_secret_value() if isinstance(aiml_api_key, SecretStr) else aiml_api_key\n\n        return ChatOpenAI(\n            model=model_name,\n            temperature=temperature,\n            api_key=openai_api_key,\n            base_url=aiml_api_base,\n            max_tokens=max_tokens or None,\n            seed=seed,\n            **model_kwargs,\n        )\n\n    def _get_exception_message(self, e: Exception):\n        \"\"\"Get a message from an OpenAI exception.\n\n        Args:\n            e (Exception): The exception to get the message from.\n\n        Returns:\n            str: The message from the exception.\n        \"\"\"\n        try:\n            from openai.error import BadRequestError\n        except ImportError:\n            return None\n        if isinstance(e, BadRequestError):\n            message = e.json_body.get(\"error\", {}).get(\"message\", \"\")\n            if message:\n                return message\n        return None\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "max_tokens": {
    //                 "trace_as_metadata": true,
    //                 "range_spec": {
    //                     "step_type": "float",
    //                     "min": 0.0,
    //                     "max": 128000.0,
    //                     "step": 0.1
    //                 },
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_tokens",
    //                 "value": "",
    //                 "display_name": "Max Tokens",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "model_kwargs": {
    //                 "trace_as_input": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_kwargs",
    //                 "value": {},
    //                 "display_name": "Model Kwargs",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "model_name": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "#g1_aura-angus-en",
    //                     "#g1_aura-arcas-en",
    //                     "#g1_aura-asteria-en",
    //                     "#g1_aura-athena-en",
    //                     "#g1_aura-helios-en",
    //                     "#g1_aura-hera-en",
    //                     "#g1_aura-luna-en",
    //                     "#g1_aura-orion-en",
    //                     "#g1_aura-orpheus-en",
    //                     "#g1_aura-perseus-en",
    //                     "#g1_aura-stella-en",
    //                     "#g1_aura-zeus-en",
    //                     "#g1_nova-2-automotive",
    //                     "#g1_nova-2-conversationalai",
    //                     "#g1_nova-2-drivethru",
    //                     "#g1_nova-2-finance",
    //                     "#g1_nova-2-general",
    //                     "#g1_nova-2-medical",
    //                     "#g1_nova-2-meeting",
    //                     "#g1_nova-2-phonecall",
    //                     "#g1_nova-2-video",
    //                     "#g1_nova-2-voicemail",
    //                     "#g1_redaction",
    //                     "#g1_whisper-base",
    //                     "#g1_whisper-large",
    //                     "#g1_whisper-medium",
    //                     "#g1_whisper-small",
    //                     "#g1_whisper-tiny",
    //                     "Austism/chronos-hermes-13b",
    //                     "BAAI/bge-base-en-v1.5",
    //                     "BAAI/bge-large-en-v1.5",
    //                     "EleutherAI/llemma_7b",
    //                     "Gryphe/MythoMax-L2-13b",
    //                     "HuggingFaceH4/zephyr-7b-beta",
    //                     "Meta-Llama/Llama-Guard-7b",
    //                     "Nexusflow/NexusRaven-V2-13B",
    //                     "NousResearch/Hermes-2-Theta-Llama-3-70B",
    //                     "NousResearch/Nous-Capybara-7B-V1p9",
    //                     "NousResearch/Nous-Hermes-13b",
    //                     "NousResearch/Nous-Hermes-2-Mistral-7B-DPO",
    //                     "NousResearch/Nous-Hermes-2-Mixtral-8x7B-DPO",
    //                     "NousResearch/Nous-Hermes-2-Mixtral-8x7B-SFT",
    //                     "NousResearch/Nous-Hermes-2-Yi-34B",
    //                     "NousResearch/Nous-Hermes-Llama2-13b",
    //                     "NousResearch/Nous-Hermes-Llama2-70b",
    //                     "NousResearch/Nous-Hermes-llama-2-7b",
    //                     "NumbersStation/nsql-llama-2-7B",
    //                     "Open-Orca/Mistral-7B-OpenOrca",
    //                     "Phind/Phind-CodeLlama-34B-Python-v1",
    //                     "Phind/Phind-CodeLlama-34B-v2",
    //                     "Qwen/Qwen1.5-0.5B",
    //                     "Qwen/Qwen1.5-0.5B-Chat",
    //                     "Qwen/Qwen1.5-1.8B",
    //                     "Qwen/Qwen1.5-1.8B-Chat",
    //                     "Qwen/Qwen1.5-110B-Chat",
    //                     "Qwen/Qwen1.5-14B",
    //                     "Qwen/Qwen1.5-14B-Chat",
    //                     "Qwen/Qwen1.5-32B",
    //                     "Qwen/Qwen1.5-32B-Chat",
    //                     "Qwen/Qwen1.5-4B",
    //                     "Qwen/Qwen1.5-4B-Chat",
    //                     "Qwen/Qwen1.5-72B",
    //                     "Qwen/Qwen1.5-72B-Chat",
    //                     "Qwen/Qwen1.5-7B",
    //                     "Qwen/Qwen1.5-7B-Chat",
    //                     "Qwen/Qwen2-1.5B",
    //                     "Qwen/Qwen2-1.5B-Instruct",
    //                     "Qwen/Qwen2-72B",
    //                     "Qwen/Qwen2-72B-Instruct",
    //                     "Qwen/Qwen2-7B",
    //                     "Qwen/Qwen2-7B-Instruct",
    //                     "SG161222/Realistic_Vision_V3.0_VAE",
    //                     "Snowflake/snowflake-arctic-instruct",
    //                     "Undi95/ReMM-SLERP-L2-13B",
    //                     "Undi95/Toppy-M-7B",
    //                     "WhereIsAI/UAE-Large-V1",
    //                     "WizardLM/WizardCoder-Python-34B-V1.0",
    //                     "WizardLM/WizardLM-13B-V1.2",
    //                     "WizardLM/WizardLM-70B-V1.0",
    //                     "allenai/OLMo-7B",
    //                     "allenai/OLMo-7B-Instruct",
    //                     "allenai/OLMo-7B-Twin-2T",
    //                     "bert-base-uncased",
    //                     "carson/ml318br",
    //                     "chatgpt-4o-latest",
    //                     "claude-3-5-sonnet-20240620",
    //                     "claude-3-haiku-20240307",
    //                     "claude-3-opus-20240229",
    //                     "claude-3-sonnet-20240229",
    //                     "codellama/CodeLlama-13b-Instruct-hf",
    //                     "codellama/CodeLlama-13b-Python-hf",
    //                     "codellama/CodeLlama-13b-hf",
    //                     "codellama/CodeLlama-34b-Instruct-hf",
    //                     "codellama/CodeLlama-34b-Python-hf",
    //                     "codellama/CodeLlama-34b-hf",
    //                     "codellama/CodeLlama-70b-Instruct-hf",
    //                     "codellama/CodeLlama-70b-Python-hf",
    //                     "codellama/CodeLlama-70b-hf",
    //                     "codellama/CodeLlama-7b-Instruct-hf",
    //                     "codellama/CodeLlama-7b-Python-hf",
    //                     "codellama/CodeLlama-7b-hf",
    //                     "cognitivecomputations/dolphin-2.5-mixtral-8x7b",
    //                     "dall-e-2",
    //                     "dall-e-3",
    //                     "databricks/dbrx-instruct",
    //                     "deepseek-ai/deepseek-coder-33b-instruct",
    //                     "deepseek-ai/deepseek-llm-67b-chat",
    //                     "flux-pro",
    //                     "flux-realism",
    //                     "flux/dev",
    //                     "flux/dev/image-to-image",
    //                     "flux/schnell",
    //                     "garage-bAInd/Platypus2-70B-instruct",
    //                     "gemini-1.5-flash",
    //                     "gemini-1.5-pro",
    //                     "gemini-pro",
    //                     "google/gemma-2-27b-it",
    //                     "google/gemma-2-9b-it",
    //                     "google/gemma-2b",
    //                     "google/gemma-2b-it",
    //                     "google/gemma-7b",
    //                     "google/gemma-7b-it",
    //                     "gpt-3.5-turbo-0125",
    //                     "gpt-3.5-turbo-0301",
    //                     "gpt-3.5-turbo-0613",
    //                     "gpt-3.5-turbo-1106",
    //                     "gpt-3.5-turbo-16k-0613",
    //                     "gpt-3.5-turbo-instruct",
    //                     "gpt-4",
    //                     "gpt-4-0125-preview",
    //                     "gpt-4-1106-preview",
    //                     "gpt-4-32k",
    //                     "gpt-4-turbo",
    //                     "gpt-4-turbo-2024-04-09",
    //                     "gpt-4-vision-preview",
    //                     "gpt-4o",
    //                     "gpt-4o-2024-05-13",
    //                     "gpt-4o-2024-08-06",
    //                     "gpt-4o-mini",
    //                     "gpt-4o-mini-2024-07-18",
    //                     "gradientai/Llama-3-70B-Instruct-Gradient-1048k",
    //                     "huggyllama/llama-13b",
    //                     "huggyllama/llama-30b",
    //                     "huggyllama/llama-65b",
    //                     "huggyllama/llama-7b",
    //                     "lmsys/vicuna-13b-v1.3",
    //                     "lmsys/vicuna-13b-v1.5",
    //                     "lmsys/vicuna-13b-v1.5-16k",
    //                     "lmsys/vicuna-7b-v1.3",
    //                     "lmsys/vicuna-7b-v1.5",
    //                     "meta-llama/Llama-2-13b-chat-hf",
    //                     "meta-llama/Llama-2-13b-hf",
    //                     "meta-llama/Llama-2-70b-chat-hf",
    //                     "meta-llama/Llama-2-70b-hf",
    //                     "meta-llama/Llama-2-7b-chat-hf",
    //                     "meta-llama/Llama-2-7b-hf",
    //                     "meta-llama/Llama-3-70b-chat-hf",
    //                     "meta-llama/Llama-3-70b-hf",
    //                     "meta-llama/Llama-3-8b-chat-hf",
    //                     "meta-llama/Llama-3-8b-hf",
    //                     "meta-llama/LlamaGuard-2-8b",
    //                     "meta-llama/Meta-Llama-3-70B",
    //                     "meta-llama/Meta-Llama-3-70B-Instruct",
    //                     "meta-llama/Meta-Llama-3-70B-Instruct-Lite",
    //                     "meta-llama/Meta-Llama-3-70B-Instruct-Turbo",
    //                     "meta-llama/Meta-Llama-3-8B",
    //                     "meta-llama/Meta-Llama-3-8B-Instruct",
    //                     "meta-llama/Meta-Llama-3-8B-Instruct-Lite",
    //                     "meta-llama/Meta-Llama-3-8B-Instruct-Turbo",
    //                     "meta-llama/Meta-Llama-3.1-405B-Instruct-Turbo",
    //                     "meta-llama/Meta-Llama-3.1-70B-Instruct-Reference",
    //                     "meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo",
    //                     "meta-llama/Meta-Llama-3.1-70B-Reference",
    //                     "meta-llama/Meta-Llama-3.1-8B-Instruct-Turbo",
    //                     "meta-llama/Meta-Llama-3.1-8B-Reference",
    //                     "meta-llama/Meta-Llama-Guard-3-8B",
    //                     "microsoft/WizardLM-2-8x22B",
    //                     "microsoft/phi-2",
    //                     "mistralai/Mistral-7B-Instruct-v0.1",
    //                     "mistralai/Mistral-7B-Instruct-v0.2",
    //                     "mistralai/Mistral-7B-Instruct-v0.3",
    //                     "mistralai/Mistral-7B-v0.1",
    //                     "mistralai/Mixtral-8x22B",
    //                     "mistralai/Mixtral-8x22B-Instruct-v0.1",
    //                     "mistralai/Mixtral-8x7B-Instruct-v0.1",
    //                     "mistralai/Mixtral-8x7B-v0.1",
    //                     "openchat/openchat-3.5-1210",
    //                     "prompthero/openjourney",
    //                     "runwayml/stable-diffusion-v1-5",
    //                     "sentence-transformers/msmarco-bert-base-dot-v5",
    //                     "snorkelai/Snorkel-Mistral-PairRM-DPO",
    //                     "stabilityai/stable-diffusion-2-1",
    //                     "stabilityai/stable-diffusion-xl-base-1.0",
    //                     "stable-diffusion-v3-medium",
    //                     "teknium/OpenHermes-2-Mistral-7B",
    //                     "teknium/OpenHermes-2p5-Mistral-7B",
    //                     "togethercomputer/CodeLlama-13b-Instruct",
    //                     "togethercomputer/CodeLlama-13b-Python",
    //                     "togethercomputer/CodeLlama-34b",
    //                     "togethercomputer/CodeLlama-34b-Instruct",
    //                     "togethercomputer/CodeLlama-34b-Python",
    //                     "togethercomputer/CodeLlama-7b-Instruct",
    //                     "togethercomputer/CodeLlama-7b-Python",
    //                     "togethercomputer/Koala-13B",
    //                     "togethercomputer/Koala-7B",
    //                     "togethercomputer/LLaMA-2-7B-32K",
    //                     "togethercomputer/Llama-2-7B-32K-Instruct",
    //                     "togethercomputer/Llama-3-8b-chat-hf-int4",
    //                     "togethercomputer/Llama-3-8b-chat-hf-int8",
    //                     "togethercomputer/SOLAR-10.7B-Instruct-v1.0-int4",
    //                     "togethercomputer/StripedHyena-Hessian-7B",
    //                     "togethercomputer/StripedHyena-Nous-7B",
    //                     "togethercomputer/alpaca-7b",
    //                     "togethercomputer/evo-1-131k-base",
    //                     "togethercomputer/evo-1-8k-base",
    //                     "togethercomputer/guanaco-13b",
    //                     "togethercomputer/guanaco-33b",
    //                     "togethercomputer/guanaco-65b",
    //                     "togethercomputer/guanaco-7b",
    //                     "togethercomputer/llama-2-13b",
    //                     "togethercomputer/llama-2-13b-chat",
    //                     "togethercomputer/llama-2-70b",
    //                     "togethercomputer/llama-2-70b-chat",
    //                     "togethercomputer/llama-2-7b",
    //                     "togethercomputer/llama-2-7b-chat",
    //                     "togethercomputer/m2-bert-80M-2k-retrieval",
    //                     "togethercomputer/m2-bert-80M-32k-retrieval",
    //                     "togethercomputer/m2-bert-80M-8k-retrieval",
    //                     "upstage/SOLAR-10.7B-Instruct-v1.0",
    //                     "voyage-2",
    //                     "voyage-code-2",
    //                     "voyage-finance-2",
    //                     "voyage-large-2",
    //                     "voyage-large-2-instruct",
    //                     "voyage-law-2",
    //                     "voyage-multilingual-2",
    //                     "wavymulder/Analog-Diffusion",
    //                     "zero-one-ai/Yi-34B",
    //                     "zero-one-ai/Yi-34B-Chat",
    //                     "zero-one-ai/Yi-6B"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_name",
    //                 "value": "#g1_aura-angus-en",
    //                 "display_name": "Model Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "seed": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "seed",
    //                 "value": 1,
    //                 "display_name": "Seed",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The seed controls the reproducibility of the job.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "stream": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "stream",
    //                 "value": false,
    //                 "display_name": "Stream",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Stream the response from the model. Streaming works only in Chat.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "system_message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "system_message",
    //                 "value": "",
    //                 "display_name": "System Message",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "System message to pass to the model.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "temperature": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "temperature",
    //                 "value": 0.1,
    //                 "display_name": "Temperature",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             }
    //         },
    //         "description": "Generates text using AIML LLMs.",
    //         "icon": "AIML",
    //         "base_classes": [
    //             "LanguageModel",
    //             "Message"
    //         ],
    //         "display_name": "AIML",
    //         "documentation": "https://docs.aimlapi.com/api-reference",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text_output",
    //                 "display_name": "Text",
    //                 "method": "text_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "stream",
    //                     "system_message"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "LanguageModel"
    //                 ],
    //                 "selected": "LanguageModel",
    //                 "name": "model_output",
    //                 "display_name": "Language Model",
    //                 "method": "build_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "aiml_api_base",
    //                     "api_key",
    //                     "max_tokens",
    //                     "model_kwargs",
    //                     "model_name",
    //                     "seed",
    //                     "temperature"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "system_message",
    //             "stream",
    //             "max_tokens",
    //             "model_kwargs",
    //             "model_name",
    //             "aiml_api_base",
    //             "api_key",
    //             "temperature",
    //             "seed",
    //             "output_parser"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "PerplexityModel": {
    //         "template": {
    //             "_type": "Component",
    //             "output_parser": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "output_parser",
    //                 "value": "",
    //                 "display_name": "Output Parser",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "OutputParser"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The parser to use to parse the output of the model",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "Perplexity API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The Perplexity API Key to use for the Perplexity model.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_community.chat_models import ChatPerplexity\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import DropdownInput, FloatInput, IntInput, SecretStrInput\n\n\nclass PerplexityComponent(LCModelComponent):\n    display_name = \"Perplexity\"\n    description = \"Generate text using Perplexity LLMs.\"\n    documentation = \"https://python.langchain.com/v0.2/docs/integrations/chat/perplexity/\"\n    icon = \"Perplexity\"\n    name = \"PerplexityModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            advanced=False,\n            options=[\n                \"llama-3.1-sonar-small-128k-online\",\n                \"llama-3.1-sonar-large-128k-online\",\n                \"llama-3.1-sonar-huge-128k-online\",\n                \"llama-3.1-sonar-small-128k-chat\",\n                \"llama-3.1-sonar-large-128k-chat\",\n                \"llama-3.1-8b-instruct\",\n                \"llama-3.1-70b-instruct\",\n            ],\n            value=\"llama-3.1-sonar-small-128k-online\",\n        ),\n        IntInput(\n            name=\"max_output_tokens\", display_name=\"Max Output Tokens\", info=\"The maximum number of tokens to generate.\"\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Perplexity API Key\",\n            info=\"The Perplexity API Key to use for the Perplexity model.\",\n            advanced=False,\n        ),\n        FloatInput(name=\"temperature\", display_name=\"Temperature\", value=0.75),\n        FloatInput(\n            name=\"top_p\",\n            display_name=\"Top P\",\n            info=\"The maximum cumulative probability of tokens to consider when sampling.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"n\",\n            display_name=\"N\",\n            info=\"Number of chat completions to generate for each prompt. \"\n            \"Note that the API may not return the full n completions if duplicates are generated.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"top_k\",\n            display_name=\"Top K\",\n            info=\"Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.\",\n            advanced=True,\n        ),\n        HandleInput(\n            name=\"output_parser\",\n            display_name=\"Output Parser\",\n            info=\"The parser to use to parse the output of the model\",\n            advanced=True,\n            input_types=[\"OutputParser\"],\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        api_key = SecretStr(self.api_key).get_secret_value()\n        temperature = self.temperature\n        model = self.model_name\n        max_output_tokens = self.max_output_tokens\n        top_k = self.top_k\n        top_p = self.top_p\n        n = self.n\n\n        return ChatPerplexity(\n            model=model,\n            temperature=temperature or 0.75,\n            pplx_api_key=api_key,\n            top_k=top_k or None,\n            top_p=top_p or None,\n            n=n or 1,\n            max_output_tokens=max_output_tokens,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "max_output_tokens": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_output_tokens",
    //                 "value": "",
    //                 "display_name": "Max Output Tokens",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The maximum number of tokens to generate.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "model_name": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "llama-3.1-sonar-small-128k-online",
    //                     "llama-3.1-sonar-large-128k-online",
    //                     "llama-3.1-sonar-huge-128k-online",
    //                     "llama-3.1-sonar-small-128k-chat",
    //                     "llama-3.1-sonar-large-128k-chat",
    //                     "llama-3.1-8b-instruct",
    //                     "llama-3.1-70b-instruct"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_name",
    //                 "value": "llama-3.1-sonar-small-128k-online",
    //                 "display_name": "Model Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "n": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "n",
    //                 "value": "",
    //                 "display_name": "N",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of chat completions to generate for each prompt. Note that the API may not return the full n completions if duplicates are generated.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "stream": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "stream",
    //                 "value": false,
    //                 "display_name": "Stream",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Stream the response from the model. Streaming works only in Chat.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "system_message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "system_message",
    //                 "value": "",
    //                 "display_name": "System Message",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "System message to pass to the model.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "temperature": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "temperature",
    //                 "value": 0.75,
    //                 "display_name": "Temperature",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "top_k": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "top_k",
    //                 "value": "",
    //                 "display_name": "Top K",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "top_p": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "top_p",
    //                 "value": "",
    //                 "display_name": "Top P",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The maximum cumulative probability of tokens to consider when sampling.",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             }
    //         },
    //         "description": "Generate text using Perplexity LLMs.",
    //         "icon": "Perplexity",
    //         "base_classes": [
    //             "LanguageModel",
    //             "Message"
    //         ],
    //         "display_name": "Perplexity",
    //         "documentation": "https://python.langchain.com/v0.2/docs/integrations/chat/perplexity/",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text_output",
    //                 "display_name": "Text",
    //                 "method": "text_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "stream",
    //                     "system_message"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "LanguageModel"
    //                 ],
    //                 "selected": "LanguageModel",
    //                 "name": "model_output",
    //                 "display_name": "Language Model",
    //                 "method": "build_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_key",
    //                     "max_output_tokens",
    //                     "model_name",
    //                     "n",
    //                     "temperature",
    //                     "top_k",
    //                     "top_p"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "system_message",
    //             "stream",
    //             "model_name",
    //             "max_output_tokens",
    //             "api_key",
    //             "temperature",
    //             "top_p",
    //             "n",
    //             "top_k",
    //             "output_parser"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "GoogleGenerativeAIModel": {
    //         "template": {
    //             "_type": "Component",
    //             "output_parser": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "output_parser",
    //                 "value": "",
    //                 "display_name": "Output Parser",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "OutputParser"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The parser to use to parse the output of the model",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from pydantic.v1 import SecretStr\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.inputs import DropdownInput, FloatInput, IntInput, SecretStrInput\nfrom langflow.inputs.inputs import HandleInput\n\n\nclass GoogleGenerativeAIComponent(LCModelComponent):\n    display_name = \"Google Generative AI\"\n    description = \"Generate text using Google Generative AI.\"\n    icon = \"GoogleGenerativeAI\"\n    name = \"GoogleGenerativeAIModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_output_tokens\", display_name=\"Max Output Tokens\", info=\"The maximum number of tokens to generate.\"\n        ),\n        DropdownInput(\n            name=\"model\",\n            display_name=\"Model\",\n            info=\"The name of the model to use.\",\n            options=[\"gemini-1.5-pro\", \"gemini-1.5-flash\", \"gemini-1.0-pro\", \"gemini-1.0-pro-vision\"],\n            value=\"gemini-1.5-pro\",\n        ),\n        SecretStrInput(\n            name=\"google_api_key\",\n            display_name=\"Google API Key\",\n            info=\"The Google API Key to use for the Google Generative AI.\",\n        ),\n        FloatInput(\n            name=\"top_p\",\n            display_name=\"Top P\",\n            info=\"The maximum cumulative probability of tokens to consider when sampling.\",\n            advanced=True,\n        ),\n        FloatInput(name=\"temperature\", display_name=\"Temperature\", value=0.1),\n        IntInput(\n            name=\"n\",\n            display_name=\"N\",\n            info=\"Number of chat completions to generate for each prompt. \"\n            \"Note that the API may not return the full n completions if duplicates are generated.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"top_k\",\n            display_name=\"Top K\",\n            info=\"Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.\",\n            advanced=True,\n        ),\n        HandleInput(\n            name=\"output_parser\",\n            display_name=\"Output Parser\",\n            info=\"The parser to use to parse the output of the model\",\n            advanced=True,\n            input_types=[\"OutputParser\"],\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        try:\n            from langchain_google_genai import ChatGoogleGenerativeAI\n        except ImportError as e:\n            msg = \"The 'langchain_google_genai' package is required to use the Google Generative AI model.\"\n            raise ImportError(msg) from e\n\n        google_api_key = self.google_api_key\n        model = self.model\n        max_output_tokens = self.max_output_tokens\n        temperature = self.temperature\n        top_k = self.top_k\n        top_p = self.top_p\n        n = self.n\n\n        return ChatGoogleGenerativeAI(\n            model=model,\n            max_output_tokens=max_output_tokens or None,\n            temperature=temperature,\n            top_k=top_k or None,\n            top_p=top_p or None,\n            n=n or 1,\n            google_api_key=SecretStr(google_api_key).get_secret_value(),\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "google_api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "google_api_key",
    //                 "value": "",
    //                 "display_name": "Google API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The Google API Key to use for the Google Generative AI.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "max_output_tokens": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_output_tokens",
    //                 "value": "",
    //                 "display_name": "Max Output Tokens",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The maximum number of tokens to generate.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "model": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "gemini-1.5-pro",
    //                     "gemini-1.5-flash",
    //                     "gemini-1.0-pro",
    //                     "gemini-1.0-pro-vision"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model",
    //                 "value": "gemini-1.5-pro",
    //                 "display_name": "Model",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The name of the model to use.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "n": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "n",
    //                 "value": "",
    //                 "display_name": "N",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of chat completions to generate for each prompt. Note that the API may not return the full n completions if duplicates are generated.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "stream": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "stream",
    //                 "value": false,
    //                 "display_name": "Stream",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Stream the response from the model. Streaming works only in Chat.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "system_message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "system_message",
    //                 "value": "",
    //                 "display_name": "System Message",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "System message to pass to the model.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "temperature": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "temperature",
    //                 "value": 0.1,
    //                 "display_name": "Temperature",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "top_k": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "top_k",
    //                 "value": "",
    //                 "display_name": "Top K",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "top_p": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "top_p",
    //                 "value": "",
    //                 "display_name": "Top P",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The maximum cumulative probability of tokens to consider when sampling.",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             }
    //         },
    //         "description": "Generate text using Google Generative AI.",
    //         "icon": "GoogleGenerativeAI",
    //         "base_classes": [
    //             "LanguageModel",
    //             "Message"
    //         ],
    //         "display_name": "Google Generative AI",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text_output",
    //                 "display_name": "Text",
    //                 "method": "text_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "stream",
    //                     "system_message"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "LanguageModel"
    //                 ],
    //                 "selected": "LanguageModel",
    //                 "name": "model_output",
    //                 "display_name": "Language Model",
    //                 "method": "build_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "google_api_key",
    //                     "max_output_tokens",
    //                     "model",
    //                     "n",
    //                     "temperature",
    //                     "top_k",
    //                     "top_p"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "system_message",
    //             "stream",
    //             "max_output_tokens",
    //             "model",
    //             "google_api_key",
    //             "top_p",
    //             "temperature",
    //             "n",
    //             "top_k",
    //             "output_parser"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "GroqModel": {
    //         "template": {
    //             "_type": "Component",
    //             "output_parser": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "output_parser",
    //                 "value": "",
    //                 "display_name": "Output Parser",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "OutputParser"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The parser to use to parse the output of the model",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import requests\nfrom langchain_groq import ChatGroq\nfrom pydantic.v1 import SecretStr\nfrom typing_extensions import override\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import DropdownInput, FloatInput, IntInput, MessageTextInput, SecretStrInput\n\n\nclass GroqModel(LCModelComponent):\n    display_name: str = \"Groq\"\n    description: str = \"Generate text using Groq.\"\n    icon = \"Groq\"\n    name = \"GroqModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        SecretStrInput(name=\"groq_api_key\", display_name=\"Groq API Key\", info=\"API key for the Groq API.\"),\n        MessageTextInput(\n            name=\"groq_api_base\",\n            display_name=\"Groq API Base\",\n            info=\"Base URL path for API requests, leave blank if not using a proxy or service emulator.\",\n            advanced=True,\n            value=\"https://api.groq.com\",\n        ),\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Output Tokens\",\n            info=\"The maximum number of tokens to generate.\",\n            advanced=True,\n        ),\n        FloatInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            info=\"Run inference with this temperature. Must by in the closed interval [0.0, 1.0].\",\n            value=0.1,\n        ),\n        IntInput(\n            name=\"n\",\n            display_name=\"N\",\n            info=\"Number of chat completions to generate for each prompt. \"\n            \"Note that the API may not return the full n completions if duplicates are generated.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model\",\n            info=\"The name of the model to use.\",\n            options=[],\n            refresh_button=True,\n        ),\n        HandleInput(\n            name=\"output_parser\",\n            display_name=\"Output Parser\",\n            info=\"The parser to use to parse the output of the model\",\n            advanced=True,\n            input_types=[\"OutputParser\"],\n        ),\n    ]\n\n    def get_models(self) -> list[str]:\n        api_key = self.groq_api_key\n        base_url = self.groq_api_base or \"https://api.groq.com\"\n        url = f\"{base_url}/openai/v1/models\"\n\n        headers = {\"Authorization\": f\"Bearer {api_key}\", \"Content-Type\": \"application/json\"}\n\n        try:\n            response = requests.get(url, headers=headers, timeout=10)\n            response.raise_for_status()\n            model_list = response.json()\n            return [model[\"id\"] for model in model_list.get(\"data\", [])]\n        except requests.RequestException as e:\n            self.status = f\"Error fetching models: {e}\"\n            return []\n\n    @override\n    def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None):\n        if field_name in {\"groq_api_key\", \"groq_api_base\", \"model_name\"}:\n            models = self.get_models()\n            build_config[\"model_name\"][\"options\"] = models\n        return build_config\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        groq_api_key = self.groq_api_key\n        model_name = self.model_name\n        max_tokens = self.max_tokens\n        temperature = self.temperature\n        groq_api_base = self.groq_api_base\n        n = self.n\n        stream = self.stream\n\n        return ChatGroq(\n            model=model_name,\n            max_tokens=max_tokens or None,\n            temperature=temperature,\n            base_url=groq_api_base,\n            n=n or 1,\n            api_key=SecretStr(groq_api_key).get_secret_value(),\n            streaming=stream,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "groq_api_base": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "groq_api_base",
    //                 "value": "https://api.groq.com",
    //                 "display_name": "Groq API Base",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Base URL path for API requests, leave blank if not using a proxy or service emulator.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "groq_api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "groq_api_key",
    //                 "value": "",
    //                 "display_name": "Groq API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "API key for the Groq API.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "max_tokens": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_tokens",
    //                 "value": "",
    //                 "display_name": "Max Output Tokens",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The maximum number of tokens to generate.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "model_name": {
    //                 "trace_as_metadata": true,
    //                 "options": [],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_name",
    //                 "value": "",
    //                 "display_name": "Model",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The name of the model to use.",
    //                 "refresh_button": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "n": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "n",
    //                 "value": "",
    //                 "display_name": "N",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of chat completions to generate for each prompt. Note that the API may not return the full n completions if duplicates are generated.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "stream": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "stream",
    //                 "value": false,
    //                 "display_name": "Stream",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Stream the response from the model. Streaming works only in Chat.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "system_message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "system_message",
    //                 "value": "",
    //                 "display_name": "System Message",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "System message to pass to the model.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "temperature": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "temperature",
    //                 "value": 0.1,
    //                 "display_name": "Temperature",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Run inference with this temperature. Must by in the closed interval [0.0, 1.0].",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             }
    //         },
    //         "description": "Generate text using Groq.",
    //         "icon": "Groq",
    //         "base_classes": [
    //             "LanguageModel",
    //             "Message"
    //         ],
    //         "display_name": "Groq",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text_output",
    //                 "display_name": "Text",
    //                 "method": "text_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "stream",
    //                     "system_message"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "LanguageModel"
    //                 ],
    //                 "selected": "LanguageModel",
    //                 "name": "model_output",
    //                 "display_name": "Language Model",
    //                 "method": "build_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "groq_api_base",
    //                     "groq_api_key",
    //                     "max_tokens",
    //                     "model_name",
    //                     "n",
    //                     "stream",
    //                     "temperature"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "system_message",
    //             "stream",
    //             "groq_api_key",
    //             "groq_api_base",
    //             "max_tokens",
    //             "temperature",
    //             "n",
    //             "model_name",
    //             "output_parser"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "OpenAIModel": {
    //         "template": {
    //             "_type": "Component",
    //             "output_parser": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "output_parser",
    //                 "value": "",
    //                 "display_name": "Output Parser",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "OutputParser"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The parser to use to parse the output of the model",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "OPENAI_API_KEY",
    //                 "display_name": "OpenAI API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The OpenAI API Key to use for the OpenAI model.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import operator\nfrom functools import reduce\n\nfrom langchain_openai import ChatOpenAI\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.base.models.openai_constants import OPENAI_MODEL_NAMES\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import BoolInput, DictInput, DropdownInput, FloatInput, IntInput, SecretStrInput, StrInput\nfrom langflow.inputs.inputs import HandleInput\n\n\nclass OpenAIModelComponent(LCModelComponent):\n    display_name = \"OpenAI\"\n    description = \"Generates text using OpenAI LLMs.\"\n    icon = \"OpenAI\"\n    name = \"OpenAIModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n            range_spec=RangeSpec(min=0, max=128000),\n        ),\n        DictInput(name=\"model_kwargs\", display_name=\"Model Kwargs\", advanced=True),\n        BoolInput(\n            name=\"json_mode\",\n            display_name=\"JSON Mode\",\n            advanced=True,\n            info=\"If True, it will output JSON regardless of passing a schema.\",\n        ),\n        DictInput(\n            name=\"output_schema\",\n            is_list=True,\n            display_name=\"Schema\",\n            advanced=True,\n            info=\"The schema for the Output of the model. \"\n            \"You must pass the word JSON in the prompt. \"\n            \"If left blank, JSON mode will be disabled. [DEPRECATED]\",\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            advanced=False,\n            options=OPENAI_MODEL_NAMES,\n            value=OPENAI_MODEL_NAMES[0],\n        ),\n        StrInput(\n            name=\"openai_api_base\",\n            display_name=\"OpenAI API Base\",\n            advanced=True,\n            info=\"The base URL of the OpenAI API. \"\n            \"Defaults to https://api.openai.com/v1. \"\n            \"You can change this to use other APIs like JinaChat, LocalAI and Prem.\",\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"OpenAI API Key\",\n            info=\"The OpenAI API Key to use for the OpenAI model.\",\n            advanced=False,\n            value=\"OPENAI_API_KEY\",\n        ),\n        FloatInput(name=\"temperature\", display_name=\"Temperature\", value=0.1),\n        IntInput(\n            name=\"seed\",\n            display_name=\"Seed\",\n            info=\"The seed controls the reproducibility of the job.\",\n            advanced=True,\n            value=1,\n        ),\n        HandleInput(\n            name=\"output_parser\",\n            display_name=\"Output Parser\",\n            info=\"The parser to use to parse the output of the model\",\n            advanced=True,\n            input_types=[\"OutputParser\"],\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        # self.output_schema is a list of dictionaries\n        # let's convert it to a dictionary\n        output_schema_dict: dict[str, str] = reduce(operator.ior, self.output_schema or {}, {})\n        openai_api_key = self.api_key\n        temperature = self.temperature\n        model_name: str = self.model_name\n        max_tokens = self.max_tokens\n        model_kwargs = self.model_kwargs or {}\n        openai_api_base = self.openai_api_base or \"https://api.openai.com/v1\"\n        json_mode = bool(output_schema_dict) or self.json_mode\n        seed = self.seed\n\n        api_key = SecretStr(openai_api_key).get_secret_value() if openai_api_key else None\n        output = ChatOpenAI(\n            max_tokens=max_tokens or None,\n            model_kwargs=model_kwargs,\n            model=model_name,\n            base_url=openai_api_base,\n            api_key=api_key,\n            temperature=temperature if temperature is not None else 0.1,\n            seed=seed,\n        )\n        if json_mode:\n            if output_schema_dict:\n                output = output.with_structured_output(schema=output_schema_dict, method=\"json_mode\")\n            else:\n                output = output.bind(response_format={\"type\": \"json_object\"})\n\n        return output\n\n    def _get_exception_message(self, e: Exception):\n        \"\"\"Get a message from an OpenAI exception.\n\n        Args:\n            e (Exception): The exception to get the message from.\n\n        Returns:\n            str: The message from the exception.\n        \"\"\"\n        try:\n            from openai import BadRequestError\n        except ImportError:\n            return None\n        if isinstance(e, BadRequestError):\n            message = e.body.get(\"message\")\n            if message:\n                return message\n        return None\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "json_mode": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "json_mode",
    //                 "value": false,
    //                 "display_name": "JSON Mode",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "If True, it will output JSON regardless of passing a schema.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "max_tokens": {
    //                 "trace_as_metadata": true,
    //                 "range_spec": {
    //                     "step_type": "float",
    //                     "min": 0.0,
    //                     "max": 128000.0,
    //                     "step": 0.1
    //                 },
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_tokens",
    //                 "value": "",
    //                 "display_name": "Max Tokens",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "model_kwargs": {
    //                 "trace_as_input": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_kwargs",
    //                 "value": {},
    //                 "display_name": "Model Kwargs",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "model_name": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "gpt-4o-mini",
    //                     "gpt-4o",
    //                     "gpt-4-turbo",
    //                     "gpt-4-turbo-preview",
    //                     "gpt-4",
    //                     "gpt-3.5-turbo",
    //                     "gpt-3.5-turbo-0125"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_name",
    //                 "value": "gpt-4o-mini",
    //                 "display_name": "Model Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "openai_api_base": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "openai_api_base",
    //                 "value": "",
    //                 "display_name": "OpenAI API Base",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The base URL of the OpenAI API. Defaults to https://api.openai.com/v1. You can change this to use other APIs like JinaChat, LocalAI and Prem.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "output_schema": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "output_schema",
    //                 "value": {},
    //                 "display_name": "Schema",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The schema for the Output of the model. You must pass the word JSON in the prompt. If left blank, JSON mode will be disabled. [DEPRECATED]",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "seed": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "seed",
    //                 "value": 1,
    //                 "display_name": "Seed",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The seed controls the reproducibility of the job.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "stream": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "stream",
    //                 "value": false,
    //                 "display_name": "Stream",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Stream the response from the model. Streaming works only in Chat.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "system_message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "system_message",
    //                 "value": "",
    //                 "display_name": "System Message",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "System message to pass to the model.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "temperature": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "temperature",
    //                 "value": 0.1,
    //                 "display_name": "Temperature",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             }
    //         },
    //         "description": "Generates text using OpenAI LLMs.",
    //         "icon": "OpenAI",
    //         "base_classes": [
    //             "LanguageModel",
    //             "Message"
    //         ],
    //         "display_name": "OpenAI",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text_output",
    //                 "display_name": "Text",
    //                 "method": "text_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "stream",
    //                     "system_message"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "LanguageModel"
    //                 ],
    //                 "selected": "LanguageModel",
    //                 "name": "model_output",
    //                 "display_name": "Language Model",
    //                 "method": "build_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_key",
    //                     "json_mode",
    //                     "max_tokens",
    //                     "model_kwargs",
    //                     "model_name",
    //                     "openai_api_base",
    //                     "output_schema",
    //                     "seed",
    //                     "temperature"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "system_message",
    //             "stream",
    //             "max_tokens",
    //             "model_kwargs",
    //             "json_mode",
    //             "output_schema",
    //             "model_name",
    //             "openai_api_base",
    //             "api_key",
    //             "temperature",
    //             "seed",
    //             "output_parser"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AzureOpenAIModel": {
    //         "template": {
    //             "_type": "Component",
    //             "output_parser": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "output_parser",
    //                 "value": "",
    //                 "display_name": "Output Parser",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "OutputParser"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The parser to use to parse the output of the model",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "api_version": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "2024-10-01-preview",
    //                     "2024-09-01-preview",
    //                     "2024-08-01-preview",
    //                     "2024-07-01-preview",
    //                     "2024-06-01",
    //                     "2024-03-01-preview",
    //                     "2024-02-15-preview",
    //                     "2023-12-01-preview",
    //                     "2023-05-15"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_version",
    //                 "value": "2024-06-01",
    //                 "display_name": "API Version",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "azure_deployment": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "azure_deployment",
    //                 "value": "",
    //                 "display_name": "Deployment Name",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "azure_endpoint": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "azure_endpoint",
    //                 "value": "",
    //                 "display_name": "Azure Endpoint",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Your Azure endpoint, including the resource. Example: `https://example-resource.azure.openai.com/`",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_openai import AzureChatOpenAI\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.inputs import MessageTextInput\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import DropdownInput, FloatInput, IntInput, SecretStrInput\n\n\nclass AzureChatOpenAIComponent(LCModelComponent):\n    display_name: str = \"Azure OpenAI\"\n    description: str = \"Generate text using Azure OpenAI LLMs.\"\n    documentation: str = \"https://python.langchain.com/docs/integrations/llms/azure_openai\"\n    beta = False\n    icon = \"Azure\"\n    name = \"AzureOpenAIModel\"\n\n    AZURE_OPENAI_API_VERSIONS = [\n        \"2024-06-01\",\n        \"2024-07-01-preview\",\n        \"2024-08-01-preview\",\n        \"2024-09-01-preview\",\n        \"2024-10-01-preview\",\n        \"2023-05-15\",\n        \"2023-12-01-preview\",\n        \"2024-02-15-preview\",\n        \"2024-03-01-preview\",\n    ]\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        MessageTextInput(\n            name=\"azure_endpoint\",\n            display_name=\"Azure Endpoint\",\n            info=\"Your Azure endpoint, including the resource. Example: `https://example-resource.azure.openai.com/`\",\n            required=True,\n        ),\n        MessageTextInput(name=\"azure_deployment\", display_name=\"Deployment Name\", required=True),\n        SecretStrInput(name=\"api_key\", display_name=\"API Key\"),\n        DropdownInput(\n            name=\"api_version\",\n            display_name=\"API Version\",\n            options=sorted(AZURE_OPENAI_API_VERSIONS, reverse=True),\n            value=next(\n                (\n                    version\n                    for version in sorted(AZURE_OPENAI_API_VERSIONS, reverse=True)\n                    if not version.endswith(\"-preview\")\n                ),\n                AZURE_OPENAI_API_VERSIONS[0],\n            ),\n        ),\n        FloatInput(name=\"temperature\", display_name=\"Temperature\", value=0.7),\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n        ),\n        HandleInput(\n            name=\"output_parser\",\n            display_name=\"Output Parser\",\n            info=\"The parser to use to parse the output of the model\",\n            advanced=True,\n            input_types=[\"OutputParser\"],\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        azure_endpoint = self.azure_endpoint\n        azure_deployment = self.azure_deployment\n        api_version = self.api_version\n        api_key = self.api_key\n        temperature = self.temperature\n        max_tokens = self.max_tokens\n        stream = self.stream\n\n        try:\n            output = AzureChatOpenAI(\n                azure_endpoint=azure_endpoint,\n                azure_deployment=azure_deployment,\n                api_version=api_version,\n                api_key=api_key,\n                temperature=temperature,\n                max_tokens=max_tokens or None,\n                streaming=stream,\n            )\n        except Exception as e:\n            msg = f\"Could not connect to AzureOpenAI API: {e}\"\n            raise ValueError(msg) from e\n\n        return output\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "max_tokens": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_tokens",
    //                 "value": "",
    //                 "display_name": "Max Tokens",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "stream": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "stream",
    //                 "value": false,
    //                 "display_name": "Stream",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Stream the response from the model. Streaming works only in Chat.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "system_message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "system_message",
    //                 "value": "",
    //                 "display_name": "System Message",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "System message to pass to the model.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "temperature": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "temperature",
    //                 "value": 0.7,
    //                 "display_name": "Temperature",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             }
    //         },
    //         "description": "Generate text using Azure OpenAI LLMs.",
    //         "icon": "Azure",
    //         "base_classes": [
    //             "LanguageModel",
    //             "Message"
    //         ],
    //         "display_name": "Azure OpenAI",
    //         "documentation": "https://python.langchain.com/docs/integrations/llms/azure_openai",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text_output",
    //                 "display_name": "Text",
    //                 "method": "text_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "stream",
    //                     "system_message"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "LanguageModel"
    //                 ],
    //                 "selected": "LanguageModel",
    //                 "name": "model_output",
    //                 "display_name": "Language Model",
    //                 "method": "build_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_key",
    //                     "api_version",
    //                     "azure_deployment",
    //                     "azure_endpoint",
    //                     "max_tokens",
    //                     "stream",
    //                     "temperature"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "system_message",
    //             "stream",
    //             "azure_endpoint",
    //             "azure_deployment",
    //             "api_key",
    //             "api_version",
    //             "temperature",
    //             "max_tokens",
    //             "output_parser"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "LMStudioModel": {
    //         "template": {
    //             "_type": "Component",
    //             "output_parser": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "output_parser",
    //                 "value": "",
    //                 "display_name": "Output Parser",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "OutputParser"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The parser to use to parse the output of the model",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "LMSTUDIO_API_KEY",
    //                 "display_name": "LM Studio API Key",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The LM Studio API Key to use for LM Studio.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "base_url": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "base_url",
    //                 "value": "http://localhost:1234/v1",
    //                 "display_name": "Base URL",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Endpoint of the LM Studio API. Defaults to 'http://localhost:1234/v1' if not specified.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\nfrom urllib.parse import urljoin\n\nimport httpx\nfrom langchain_openai import ChatOpenAI\nfrom pydantic.v1 import SecretStr\nfrom typing_extensions import override\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import DictInput, DropdownInput, FloatInput, IntInput, SecretStrInput, StrInput\nfrom langflow.inputs.inputs import HandleInput\n\n\nclass LMStudioModelComponent(LCModelComponent):\n    display_name = \"LM Studio\"\n    description = \"Generate text using LM Studio Local LLMs.\"\n    icon = \"LMStudio\"\n    name = \"LMStudioModel\"\n\n    @override\n    def update_build_config(self, build_config: dict, field_value: Any, field_name: str | None = None):\n        if field_name == \"model_name\":\n            base_url_dict = build_config.get(\"base_url\", {})\n            base_url_load_from_db = base_url_dict.get(\"load_from_db\", False)\n            base_url_value = base_url_dict.get(\"value\")\n            if base_url_load_from_db:\n                base_url_value = self.variables(base_url_value)\n            elif not base_url_value:\n                base_url_value = \"http://localhost:1234/v1\"\n            build_config[\"model_name\"][\"options\"] = self.get_model(base_url_value)\n\n        return build_config\n\n    def get_model(self, base_url_value: str) -> list[str]:\n        try:\n            url = urljoin(base_url_value, \"/v1/models\")\n            with httpx.Client() as client:\n                response = client.get(url)\n                response.raise_for_status()\n                data = response.json()\n\n                return [model[\"id\"] for model in data.get(\"data\", [])]\n        except Exception as e:\n            msg = \"Could not retrieve models. Please, make sure the LM Studio server is running.\"\n            raise ValueError(msg) from e\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n            range_spec=RangeSpec(min=0, max=128000),\n        ),\n        DictInput(name=\"model_kwargs\", display_name=\"Model Kwargs\", advanced=True),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            advanced=False,\n            refresh_button=True,\n        ),\n        StrInput(\n            name=\"base_url\",\n            display_name=\"Base URL\",\n            advanced=False,\n            info=\"Endpoint of the LM Studio API. Defaults to 'http://localhost:1234/v1' if not specified.\",\n            value=\"http://localhost:1234/v1\",\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"LM Studio API Key\",\n            info=\"The LM Studio API Key to use for LM Studio.\",\n            advanced=True,\n            value=\"LMSTUDIO_API_KEY\",\n        ),\n        FloatInput(name=\"temperature\", display_name=\"Temperature\", value=0.1),\n        IntInput(\n            name=\"seed\",\n            display_name=\"Seed\",\n            info=\"The seed controls the reproducibility of the job.\",\n            advanced=True,\n            value=1,\n        ),\n        HandleInput(\n            name=\"output_parser\",\n            display_name=\"Output Parser\",\n            info=\"The parser to use to parse the output of the model\",\n            advanced=True,\n            input_types=[\"OutputParser\"],\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        lmstudio_api_key = self.api_key\n        temperature = self.temperature\n        model_name: str = self.model_name\n        max_tokens = self.max_tokens\n        model_kwargs = self.model_kwargs or {}\n        base_url = self.base_url or \"http://localhost:1234/v1\"\n        seed = self.seed\n\n        api_key = SecretStr(lmstudio_api_key) if lmstudio_api_key else None\n\n        return ChatOpenAI(\n            max_tokens=max_tokens or None,\n            model_kwargs=model_kwargs,\n            model=model_name,\n            base_url=base_url,\n            api_key=api_key,\n            temperature=temperature if temperature is not None else 0.1,\n            seed=seed,\n        )\n\n    def _get_exception_message(self, e: Exception):\n        \"\"\"Get a message from an LM Studio exception.\n\n        Args:\n            e (Exception): The exception to get the message from.\n\n        Returns:\n            str: The message from the exception.\n        \"\"\"\n        try:\n            from openai import BadRequestError\n        except ImportError:\n            return None\n        if isinstance(e, BadRequestError):\n            message = e.body.get(\"message\")\n            if message:\n                return message\n        return None\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "max_tokens": {
    //                 "trace_as_metadata": true,
    //                 "range_spec": {
    //                     "step_type": "float",
    //                     "min": 0.0,
    //                     "max": 128000.0,
    //                     "step": 0.1
    //                 },
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_tokens",
    //                 "value": "",
    //                 "display_name": "Max Tokens",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "model_kwargs": {
    //                 "trace_as_input": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_kwargs",
    //                 "value": {},
    //                 "display_name": "Model Kwargs",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "model_name": {
    //                 "trace_as_metadata": true,
    //                 "options": [],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_name",
    //                 "value": "",
    //                 "display_name": "Model Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "refresh_button": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "seed": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "seed",
    //                 "value": 1,
    //                 "display_name": "Seed",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The seed controls the reproducibility of the job.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "stream": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "stream",
    //                 "value": false,
    //                 "display_name": "Stream",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Stream the response from the model. Streaming works only in Chat.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "system_message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "system_message",
    //                 "value": "",
    //                 "display_name": "System Message",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "System message to pass to the model.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "temperature": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "temperature",
    //                 "value": 0.1,
    //                 "display_name": "Temperature",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             }
    //         },
    //         "description": "Generate text using LM Studio Local LLMs.",
    //         "icon": "LMStudio",
    //         "base_classes": [
    //             "LanguageModel",
    //             "Message"
    //         ],
    //         "display_name": "LM Studio",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text_output",
    //                 "display_name": "Text",
    //                 "method": "text_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "stream",
    //                     "system_message"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "LanguageModel"
    //                 ],
    //                 "selected": "LanguageModel",
    //                 "name": "model_output",
    //                 "display_name": "Language Model",
    //                 "method": "build_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_key",
    //                     "base_url",
    //                     "max_tokens",
    //                     "model_kwargs",
    //                     "model_name",
    //                     "seed",
    //                     "temperature"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "system_message",
    //             "stream",
    //             "max_tokens",
    //             "model_kwargs",
    //             "model_name",
    //             "base_url",
    //             "api_key",
    //             "temperature",
    //             "seed",
    //             "output_parser"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "HuggingFaceModel": {
    //         "template": {
    //             "_type": "Component",
    //             "output_parser": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "output_parser",
    //                 "value": "",
    //                 "display_name": "Output Parser",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "OutputParser"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The parser to use to parse the output of the model",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom langchain_community.llms.huggingface_endpoint import HuggingFaceEndpoint\nfrom tenacity import retry, stop_after_attempt, wait_fixed\n\n# TODO: langchain_community.llms.huggingface_endpoint is depreciated.\n#  Need to update to langchain_huggingface, but have dependency with langchain_core 0.3.0\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import DictInput, DropdownInput, IntInput, SecretStrInput, StrInput\n\n\nclass HuggingFaceEndpointsComponent(LCModelComponent):\n    display_name: str = \"HuggingFace\"\n    description: str = \"Generate text using Hugging Face Inference APIs.\"\n    icon = \"HuggingFace\"\n    name = \"HuggingFaceModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        StrInput(name=\"model_id\", display_name=\"Model ID\", value=\"openai-community/gpt2\"),\n        StrInput(\n            name=\"inference_endpoint\",\n            display_name=\"Inference Endpoint\",\n            value=\"https://api-inference.huggingface.co/models/\",\n            info=\"Custom inference endpoint URL.\",\n        ),\n        DropdownInput(\n            name=\"task\",\n            display_name=\"Task\",\n            options=[\"text2text-generation\", \"text-generation\", \"summarization\", \"translation\"],\n            advanced=True,\n            info=\"The task to call the model with. Should be a task that returns `generated_text` or `summary_text`.\",\n        ),\n        SecretStrInput(name=\"huggingfacehub_api_token\", display_name=\"API Token\", password=True),\n        DictInput(name=\"model_kwargs\", display_name=\"Model Keyword Arguments\", advanced=True),\n        IntInput(name=\"retry_attempts\", display_name=\"Retry Attempts\", value=1, advanced=True),\n        HandleInput(\n            name=\"output_parser\",\n            display_name=\"Output Parser\",\n            info=\"The parser to use to parse the output of the model\",\n            advanced=True,\n            input_types=[\"OutputParser\"],\n        ),\n    ]\n\n    def get_api_url(self) -> str:\n        if \"huggingface\" in self.inference_endpoint.lower():\n            return f\"{self.inference_endpoint}{self.model_id}\"\n        return self.inference_endpoint\n\n    def create_huggingface_endpoint(\n        self,\n        task: str | None,\n        huggingfacehub_api_token: str | None,\n        model_kwargs: dict[str, Any],\n        max_new_tokens: int,\n        top_k: int | None,\n        top_p: float,\n        typical_p: float | None,\n        temperature: float | None,\n        repetition_penalty: float | None,\n    ) -> HuggingFaceEndpoint:\n        retry_attempts = self.retry_attempts\n        endpoint_url = self.get_api_url()\n\n        @retry(stop=stop_after_attempt(retry_attempts), wait=wait_fixed(2))\n        def _attempt_create():\n            return HuggingFaceEndpoint(\n                endpoint_url=endpoint_url,\n                task=task,\n                huggingfacehub_api_token=huggingfacehub_api_token,\n                model_kwargs=model_kwargs,\n                max_new_tokens=max_new_tokens,\n                top_k=top_k,\n                top_p=top_p,\n                typical_p=typical_p,\n                temperature=temperature,\n                repetition_penalty=repetition_penalty,\n            )\n\n        return _attempt_create()\n\n    def build_model(self) -> LanguageModel:\n        task = self.task or None\n        huggingfacehub_api_token = self.huggingfacehub_api_token\n        model_kwargs = self.model_kwargs or {}\n        max_new_tokens = self.max_new_tokens\n        top_k = self.top_k or None\n        top_p = self.top_p\n        typical_p = self.typical_p or None\n        temperature = self.temperature or 0.8\n        repetition_penalty = self.repetition_penalty or None\n\n        try:\n            llm = self.create_huggingface_endpoint(\n                task=task,\n                huggingfacehub_api_token=huggingfacehub_api_token,\n                model_kwargs=model_kwargs,\n                max_new_tokens=max_new_tokens,\n                top_k=top_k,\n                top_p=top_p,\n                typical_p=typical_p,\n                temperature=temperature,\n                repetition_penalty=repetition_penalty,\n            )\n        except Exception as e:\n            msg = \"Could not connect to HuggingFace Endpoints API.\"\n            raise ValueError(msg) from e\n\n        return llm\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "huggingfacehub_api_token": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "huggingfacehub_api_token",
    //                 "value": "",
    //                 "display_name": "API Token",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "inference_endpoint": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "inference_endpoint",
    //                 "value": "https://api-inference.huggingface.co/models/",
    //                 "display_name": "Inference Endpoint",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Custom inference endpoint URL.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "model_id": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_id",
    //                 "value": "openai-community/gpt2",
    //                 "display_name": "Model ID",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "model_kwargs": {
    //                 "trace_as_input": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_kwargs",
    //                 "value": {},
    //                 "display_name": "Model Keyword Arguments",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "retry_attempts": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "retry_attempts",
    //                 "value": 1,
    //                 "display_name": "Retry Attempts",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "stream": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "stream",
    //                 "value": false,
    //                 "display_name": "Stream",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Stream the response from the model. Streaming works only in Chat.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "system_message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "system_message",
    //                 "value": "",
    //                 "display_name": "System Message",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "System message to pass to the model.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "task": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "text2text-generation",
    //                     "text-generation",
    //                     "summarization",
    //                     "translation"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "task",
    //                 "value": "",
    //                 "display_name": "Task",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The task to call the model with. Should be a task that returns `generated_text` or `summary_text`.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             }
    //         },
    //         "description": "Generate text using Hugging Face Inference APIs.",
    //         "icon": "HuggingFace",
    //         "base_classes": [
    //             "LanguageModel",
    //             "Message"
    //         ],
    //         "display_name": "HuggingFace",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text_output",
    //                 "display_name": "Text",
    //                 "method": "text_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "stream",
    //                     "system_message"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "LanguageModel"
    //                 ],
    //                 "selected": "LanguageModel",
    //                 "name": "model_output",
    //                 "display_name": "Language Model",
    //                 "method": "build_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "huggingfacehub_api_token",
    //                     "inference_endpoint",
    //                     "model_id",
    //                     "model_kwargs",
    //                     "retry_attempts",
    //                     "task"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "system_message",
    //             "stream",
    //             "model_id",
    //             "inference_endpoint",
    //             "task",
    //             "huggingfacehub_api_token",
    //             "model_kwargs",
    //             "retry_attempts",
    //             "output_parser"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AnthropicModel": {
    //         "template": {
    //             "_type": "Component",
    //             "output_parser": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "output_parser",
    //                 "value": "",
    //                 "display_name": "Output Parser",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "OutputParser"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The parser to use to parse the output of the model",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "anthropic_api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "anthropic_api_key",
    //                 "value": "",
    //                 "display_name": "Anthropic API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Your Anthropic API key.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "anthropic_api_url": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "anthropic_api_url",
    //                 "value": "",
    //                 "display_name": "Anthropic API URL",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Endpoint of the Anthropic API. Defaults to 'https://api.anthropic.com' if not specified.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from pydantic.v1 import SecretStr\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import DropdownInput, FloatInput, IntInput, MessageTextInput, SecretStrInput\n\n\nclass AnthropicModelComponent(LCModelComponent):\n    display_name = \"Anthropic\"\n    description = \"Generate text using Anthropic Chat&Completion LLMs with prefill support.\"\n    icon = \"Anthropic\"\n    name = \"AnthropicModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            value=4096,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n        ),\n        DropdownInput(\n            name=\"model\",\n            display_name=\"Model Name\",\n            options=[\n                \"claude-3-5-sonnet-20240620\",\n                \"claude-3-opus-20240229\",\n                \"claude-3-sonnet-20240229\",\n                \"claude-3-haiku-20240307\",\n            ],\n            info=\"https://python.langchain.com/docs/integrations/chat/anthropic\",\n            value=\"claude-3-5-sonnet-20240620\",\n        ),\n        SecretStrInput(name=\"anthropic_api_key\", display_name=\"Anthropic API Key\", info=\"Your Anthropic API key.\"),\n        FloatInput(name=\"temperature\", display_name=\"Temperature\", value=0.1),\n        MessageTextInput(\n            name=\"anthropic_api_url\",\n            display_name=\"Anthropic API URL\",\n            advanced=True,\n            info=\"Endpoint of the Anthropic API. Defaults to 'https://api.anthropic.com' if not specified.\",\n        ),\n        MessageTextInput(\n            name=\"prefill\", display_name=\"Prefill\", info=\"Prefill text to guide the model's response.\", advanced=True\n        ),\n        HandleInput(\n            name=\"output_parser\",\n            display_name=\"Output Parser\",\n            info=\"The parser to use to parse the output of the model\",\n            advanced=True,\n            input_types=[\"OutputParser\"],\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        try:\n            from langchain_anthropic.chat_models import ChatAnthropic\n        except ImportError as e:\n            msg = \"langchain_anthropic is not installed. Please install it with `pip install langchain_anthropic`.\"\n            raise ImportError(msg) from e\n        model = self.model\n        anthropic_api_key = self.anthropic_api_key\n        max_tokens = self.max_tokens\n        temperature = self.temperature\n        anthropic_api_url = self.anthropic_api_url or \"https://api.anthropic.com\"\n\n        try:\n            output = ChatAnthropic(\n                model=model,\n                anthropic_api_key=(SecretStr(anthropic_api_key).get_secret_value() if anthropic_api_key else None),\n                max_tokens_to_sample=max_tokens,\n                temperature=temperature,\n                anthropic_api_url=anthropic_api_url,\n                streaming=self.stream,\n            )\n        except Exception as e:\n            msg = \"Could not connect to Anthropic API.\"\n            raise ValueError(msg) from e\n\n        return output\n\n    def _get_exception_message(self, exception: Exception) -> str | None:\n        \"\"\"Get a message from an Anthropic exception.\n\n        Args:\n            exception (Exception): The exception to get the message from.\n\n        Returns:\n            str: The message from the exception.\n        \"\"\"\n        try:\n            from anthropic import BadRequestError\n        except ImportError:\n            return None\n        if isinstance(exception, BadRequestError):\n            message = exception.body.get(\"error\", {}).get(\"message\")\n            if message:\n                return message\n        return None\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "max_tokens": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_tokens",
    //                 "value": 4096,
    //                 "display_name": "Max Tokens",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "model": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "claude-3-5-sonnet-20240620",
    //                     "claude-3-opus-20240229",
    //                     "claude-3-sonnet-20240229",
    //                     "claude-3-haiku-20240307"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model",
    //                 "value": "claude-3-5-sonnet-20240620",
    //                 "display_name": "Model Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "https://python.langchain.com/docs/integrations/chat/anthropic",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "prefill": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "prefill",
    //                 "value": "",
    //                 "display_name": "Prefill",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Prefill text to guide the model's response.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "stream": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "stream",
    //                 "value": false,
    //                 "display_name": "Stream",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Stream the response from the model. Streaming works only in Chat.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "system_message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "system_message",
    //                 "value": "",
    //                 "display_name": "System Message",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "System message to pass to the model.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "temperature": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "temperature",
    //                 "value": 0.1,
    //                 "display_name": "Temperature",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             }
    //         },
    //         "description": "Generate text using Anthropic Chat&Completion LLMs with prefill support.",
    //         "icon": "Anthropic",
    //         "base_classes": [
    //             "LanguageModel",
    //             "Message"
    //         ],
    //         "display_name": "Anthropic",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text_output",
    //                 "display_name": "Text",
    //                 "method": "text_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "stream",
    //                     "system_message"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "LanguageModel"
    //                 ],
    //                 "selected": "LanguageModel",
    //                 "name": "model_output",
    //                 "display_name": "Language Model",
    //                 "method": "build_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "anthropic_api_key",
    //                     "anthropic_api_url",
    //                     "max_tokens",
    //                     "model",
    //                     "stream",
    //                     "temperature"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "system_message",
    //             "stream",
    //             "max_tokens",
    //             "model",
    //             "anthropic_api_key",
    //             "temperature",
    //             "anthropic_api_url",
    //             "prefill",
    //             "output_parser"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "OllamaModel": {
    //         "template": {
    //             "_type": "Component",
    //             "output_parser": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "output_parser",
    //                 "value": "",
    //                 "display_name": "Output Parser",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "OutputParser"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The parser to use to parse the output of the model",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "base_url": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "base_url",
    //                 "value": "http://localhost:11434",
    //                 "display_name": "Base URL",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Endpoint of the Ollama API. Defaults to 'http://localhost:11434' if not specified.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\nfrom urllib.parse import urljoin\n\nimport httpx\nfrom langchain_community.chat_models import ChatOllama\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import BoolInput, DictInput, DropdownInput, FloatInput, IntInput, StrInput\n\n\nclass ChatOllamaComponent(LCModelComponent):\n    display_name = \"Ollama\"\n    description = \"Generate text using Ollama Local LLMs.\"\n    icon = \"Ollama\"\n    name = \"OllamaModel\"\n\n    def update_build_config(self, build_config: dict, field_value: Any, field_name: str | None = None):\n        if field_name == \"mirostat\":\n            if field_value == \"Disabled\":\n                build_config[\"mirostat_eta\"][\"advanced\"] = True\n                build_config[\"mirostat_tau\"][\"advanced\"] = True\n                build_config[\"mirostat_eta\"][\"value\"] = None\n                build_config[\"mirostat_tau\"][\"value\"] = None\n\n            else:\n                build_config[\"mirostat_eta\"][\"advanced\"] = False\n                build_config[\"mirostat_tau\"][\"advanced\"] = False\n\n                if field_value == \"Mirostat 2.0\":\n                    build_config[\"mirostat_eta\"][\"value\"] = 0.2\n                    build_config[\"mirostat_tau\"][\"value\"] = 10\n                else:\n                    build_config[\"mirostat_eta\"][\"value\"] = 0.1\n                    build_config[\"mirostat_tau\"][\"value\"] = 5\n\n        if field_name == \"model_name\":\n            base_url_dict = build_config.get(\"base_url\", {})\n            base_url_load_from_db = base_url_dict.get(\"load_from_db\", False)\n            base_url_value = base_url_dict.get(\"value\")\n            if base_url_load_from_db:\n                base_url_value = self.variables(base_url_value, field_name)\n            elif not base_url_value:\n                base_url_value = \"http://localhost:11434\"\n            build_config[\"model_name\"][\"options\"] = self.get_model(base_url_value)\n        if field_name == \"keep_alive_flag\":\n            if field_value == \"Keep\":\n                build_config[\"keep_alive\"][\"value\"] = \"-1\"\n                build_config[\"keep_alive\"][\"advanced\"] = True\n            elif field_value == \"Immediately\":\n                build_config[\"keep_alive\"][\"value\"] = \"0\"\n                build_config[\"keep_alive\"][\"advanced\"] = True\n            else:\n                build_config[\"keep_alive\"][\"advanced\"] = False\n\n        return build_config\n\n    def get_model(self, base_url_value: str) -> list[str]:\n        try:\n            url = urljoin(base_url_value, \"/api/tags\")\n            with httpx.Client() as client:\n                response = client.get(url)\n                response.raise_for_status()\n                data = response.json()\n\n                return [model[\"name\"] for model in data.get(\"models\", [])]\n        except Exception as e:\n            msg = \"Could not retrieve models. Please, make sure Ollama is running.\"\n            raise ValueError(msg) from e\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        StrInput(\n            name=\"base_url\",\n            display_name=\"Base URL\",\n            info=\"Endpoint of the Ollama API. Defaults to 'http://localhost:11434' if not specified.\",\n            value=\"http://localhost:11434\",\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            value=\"llama3.1\",\n            info=\"Refer to https://ollama.com/library for more models.\",\n            refresh_button=True,\n        ),\n        FloatInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            value=0.2,\n            info=\"Controls the creativity of model responses.\",\n        ),\n        StrInput(\n            name=\"format\", display_name=\"Format\", info=\"Specify the format of the output (e.g., json).\", advanced=True\n        ),\n        DictInput(name=\"metadata\", display_name=\"Metadata\", info=\"Metadata to add to the run trace.\", advanced=True),\n        DropdownInput(\n            name=\"mirostat\",\n            display_name=\"Mirostat\",\n            options=[\"Disabled\", \"Mirostat\", \"Mirostat 2.0\"],\n            info=\"Enable/disable Mirostat sampling for controlling perplexity.\",\n            value=\"Disabled\",\n            advanced=True,\n            real_time_refresh=True,\n        ),\n        FloatInput(\n            name=\"mirostat_eta\",\n            display_name=\"Mirostat Eta\",\n            info=\"Learning rate for Mirostat algorithm. (Default: 0.1)\",\n            advanced=True,\n        ),\n        FloatInput(\n            name=\"mirostat_tau\",\n            display_name=\"Mirostat Tau\",\n            info=\"Controls the balance between coherence and diversity of the output. (Default: 5.0)\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"num_ctx\",\n            display_name=\"Context Window Size\",\n            info=\"Size of the context window for generating tokens. (Default: 2048)\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"num_gpu\",\n            display_name=\"Number of GPUs\",\n            info=\"Number of GPUs to use for computation. (Default: 1 on macOS, 0 to disable)\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"num_thread\",\n            display_name=\"Number of Threads\",\n            info=\"Number of threads to use during computation. (Default: detected for optimal performance)\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"repeat_last_n\",\n            display_name=\"Repeat Last N\",\n            info=\"How far back the model looks to prevent repetition. (Default: 64, 0 = disabled, -1 = num_ctx)\",\n            advanced=True,\n        ),\n        FloatInput(\n            name=\"repeat_penalty\",\n            display_name=\"Repeat Penalty\",\n            info=\"Penalty for repetitions in generated text. (Default: 1.1)\",\n            advanced=True,\n        ),\n        FloatInput(name=\"tfs_z\", display_name=\"TFS Z\", info=\"Tail free sampling value. (Default: 1)\", advanced=True),\n        IntInput(name=\"timeout\", display_name=\"Timeout\", info=\"Timeout for the request stream.\", advanced=True),\n        IntInput(\n            name=\"top_k\", display_name=\"Top K\", info=\"Limits token selection to top K. (Default: 40)\", advanced=True\n        ),\n        FloatInput(name=\"top_p\", display_name=\"Top P\", info=\"Works together with top-k. (Default: 0.9)\", advanced=True),\n        BoolInput(name=\"verbose\", display_name=\"Verbose\", info=\"Whether to print out response text.\"),\n        StrInput(\n            name=\"tags\",\n            display_name=\"Tags\",\n            info=\"Comma-separated list of tags to add to the run trace.\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"stop_tokens\",\n            display_name=\"Stop Tokens\",\n            info=\"Comma-separated list of tokens to signal the model to stop generating text.\",\n            advanced=True,\n        ),\n        StrInput(name=\"system\", display_name=\"System\", info=\"System to use for generating text.\", advanced=True),\n        StrInput(name=\"template\", display_name=\"Template\", info=\"Template to use for generating text.\", advanced=True),\n        HandleInput(\n            name=\"output_parser\",\n            display_name=\"Output Parser\",\n            info=\"The parser to use to parse the output of the model\",\n            advanced=True,\n            input_types=[\"OutputParser\"],\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        # Mapping mirostat settings to their corresponding values\n        mirostat_options = {\"Mirostat\": 1, \"Mirostat 2.0\": 2}\n\n        # Default to 0 for 'Disabled'\n        mirostat_value = mirostat_options.get(self.mirostat, 0)\n\n        # Set mirostat_eta and mirostat_tau to None if mirostat is disabled\n        if mirostat_value == 0:\n            mirostat_eta = None\n            mirostat_tau = None\n        else:\n            mirostat_eta = self.mirostat_eta\n            mirostat_tau = self.mirostat_tau\n\n        # Mapping system settings to their corresponding values\n        llm_params = {\n            \"base_url\": self.base_url,\n            \"model\": self.model_name,\n            \"mirostat\": mirostat_value,\n            \"format\": self.format,\n            \"metadata\": self.metadata,\n            \"tags\": self.tags.split(\",\") if self.tags else None,\n            \"mirostat_eta\": mirostat_eta,\n            \"mirostat_tau\": mirostat_tau,\n            \"num_ctx\": self.num_ctx or None,\n            \"num_gpu\": self.num_gpu or None,\n            \"num_thread\": self.num_thread or None,\n            \"repeat_last_n\": self.repeat_last_n or None,\n            \"repeat_penalty\": self.repeat_penalty or None,\n            \"temperature\": self.temperature or None,\n            \"stop\": self.stop_tokens.split(\",\") if self.stop_tokens else None,\n            \"system\": self.system,\n            \"template\": self.template,\n            \"tfs_z\": self.tfs_z or None,\n            \"timeout\": self.timeout or None,\n            \"top_k\": self.top_k or None,\n            \"top_p\": self.top_p or None,\n            \"verbose\": self.verbose,\n        }\n\n        # Remove parameters with None values\n        llm_params = {k: v for k, v in llm_params.items() if v is not None}\n\n        try:\n            output = ChatOllama(**llm_params)\n        except Exception as e:\n            msg = \"Could not initialize Ollama LLM.\"\n            raise ValueError(msg) from e\n\n        return output\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "format": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "format",
    //                 "value": "",
    //                 "display_name": "Format",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Specify the format of the output (e.g., json).",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "metadata": {
    //                 "trace_as_input": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "metadata",
    //                 "value": {},
    //                 "display_name": "Metadata",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Metadata to add to the run trace.",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "mirostat": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Disabled",
    //                     "Mirostat",
    //                     "Mirostat 2.0"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "mirostat",
    //                 "value": "Disabled",
    //                 "display_name": "Mirostat",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Enable/disable Mirostat sampling for controlling perplexity.",
    //                 "real_time_refresh": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "mirostat_eta": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "mirostat_eta",
    //                 "value": "",
    //                 "display_name": "Mirostat Eta",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Learning rate for Mirostat algorithm. (Default: 0.1)",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "mirostat_tau": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "mirostat_tau",
    //                 "value": "",
    //                 "display_name": "Mirostat Tau",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Controls the balance between coherence and diversity of the output. (Default: 5.0)",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "model_name": {
    //                 "trace_as_metadata": true,
    //                 "options": [],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_name",
    //                 "value": "llama3.1",
    //                 "display_name": "Model Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Refer to https://ollama.com/library for more models.",
    //                 "refresh_button": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "num_ctx": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "num_ctx",
    //                 "value": "",
    //                 "display_name": "Context Window Size",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Size of the context window for generating tokens. (Default: 2048)",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "num_gpu": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "num_gpu",
    //                 "value": "",
    //                 "display_name": "Number of GPUs",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of GPUs to use for computation. (Default: 1 on macOS, 0 to disable)",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "num_thread": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "num_thread",
    //                 "value": "",
    //                 "display_name": "Number of Threads",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of threads to use during computation. (Default: detected for optimal performance)",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "repeat_last_n": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "repeat_last_n",
    //                 "value": "",
    //                 "display_name": "Repeat Last N",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "How far back the model looks to prevent repetition. (Default: 64, 0 = disabled, -1 = num_ctx)",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "repeat_penalty": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "repeat_penalty",
    //                 "value": "",
    //                 "display_name": "Repeat Penalty",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Penalty for repetitions in generated text. (Default: 1.1)",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "stop_tokens": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "stop_tokens",
    //                 "value": "",
    //                 "display_name": "Stop Tokens",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Comma-separated list of tokens to signal the model to stop generating text.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "stream": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "stream",
    //                 "value": false,
    //                 "display_name": "Stream",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Stream the response from the model. Streaming works only in Chat.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "system": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "system",
    //                 "value": "",
    //                 "display_name": "System",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "System to use for generating text.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "system_message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "system_message",
    //                 "value": "",
    //                 "display_name": "System Message",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "System message to pass to the model.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "tags": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tags",
    //                 "value": "",
    //                 "display_name": "Tags",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Comma-separated list of tags to add to the run trace.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "temperature": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "temperature",
    //                 "value": 0.2,
    //                 "display_name": "Temperature",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Controls the creativity of model responses.",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "template": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "template",
    //                 "value": "",
    //                 "display_name": "Template",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Template to use for generating text.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "tfs_z": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tfs_z",
    //                 "value": "",
    //                 "display_name": "TFS Z",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Tail free sampling value. (Default: 1)",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "timeout": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "timeout",
    //                 "value": "",
    //                 "display_name": "Timeout",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Timeout for the request stream.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "top_k": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "top_k",
    //                 "value": "",
    //                 "display_name": "Top K",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Limits token selection to top K. (Default: 40)",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "top_p": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "top_p",
    //                 "value": "",
    //                 "display_name": "Top P",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Works together with top-k. (Default: 0.9)",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "verbose": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "verbose",
    //                 "value": false,
    //                 "display_name": "Verbose",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Whether to print out response text.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Generate text using Ollama Local LLMs.",
    //         "icon": "Ollama",
    //         "base_classes": [
    //             "LanguageModel",
    //             "Message"
    //         ],
    //         "display_name": "Ollama",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text_output",
    //                 "display_name": "Text",
    //                 "method": "text_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "stream",
    //                     "system_message"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "LanguageModel"
    //                 ],
    //                 "selected": "LanguageModel",
    //                 "name": "model_output",
    //                 "display_name": "Language Model",
    //                 "method": "build_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "base_url",
    //                     "format",
    //                     "metadata",
    //                     "mirostat",
    //                     "mirostat_eta",
    //                     "mirostat_tau",
    //                     "model_name",
    //                     "num_ctx",
    //                     "num_gpu",
    //                     "num_thread",
    //                     "repeat_last_n",
    //                     "repeat_penalty",
    //                     "stop_tokens",
    //                     "system",
    //                     "tags",
    //                     "temperature",
    //                     "template",
    //                     "tfs_z",
    //                     "timeout",
    //                     "top_k",
    //                     "top_p",
    //                     "verbose"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "system_message",
    //             "stream",
    //             "base_url",
    //             "model_name",
    //             "temperature",
    //             "format",
    //             "metadata",
    //             "mirostat",
    //             "mirostat_eta",
    //             "mirostat_tau",
    //             "num_ctx",
    //             "num_gpu",
    //             "num_thread",
    //             "repeat_last_n",
    //             "repeat_penalty",
    //             "tfs_z",
    //             "timeout",
    //             "top_k",
    //             "top_p",
    //             "verbose",
    //             "tags",
    //             "stop_tokens",
    //             "system",
    //             "template",
    //             "output_parser"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "Notion": {
    //     "NotionPageContent": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import requests\nfrom langchain.tools import StructuredTool\nfrom loguru import logger\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass NotionPageContent(LCToolComponent):\n    display_name = \"Page Content Viewer \"\n    description = \"Retrieve the content of a Notion page as plain text.\"\n    documentation = \"https://docs.langflow.org/integrations/notion/page-content-viewer\"\n    icon = \"NotionDirectoryLoader\"\n\n    inputs = [\n        StrInput(\n            name=\"page_id\",\n            display_name=\"Page ID\",\n            info=\"The ID of the Notion page to retrieve.\",\n        ),\n        SecretStrInput(\n            name=\"notion_secret\",\n            display_name=\"Notion Secret\",\n            info=\"The Notion integration token.\",\n            required=True,\n        ),\n    ]\n\n    class NotionPageContentSchema(BaseModel):\n        page_id: str = Field(..., description=\"The ID of the Notion page to retrieve.\")\n\n    def run_model(self) -> Data:\n        result = self._retrieve_page_content(self.page_id)\n        if isinstance(result, str) and result.startswith(\"Error:\"):\n            # An error occurred, return it as text\n            return Data(text=result)\n        # Success, return the content\n        return Data(text=result, data={\"content\": result})\n\n    def build_tool(self) -> Tool:\n        return StructuredTool.from_function(\n            name=\"notion_page_content\",\n            description=\"Retrieve the content of a Notion page as plain text.\",\n            func=self._retrieve_page_content,\n            args_schema=self.NotionPageContentSchema,\n        )\n\n    def _retrieve_page_content(self, page_id: str) -> str:\n        blocks_url = f\"https://api.notion.com/v1/blocks/{page_id}/children?page_size=100\"\n        headers = {\n            \"Authorization\": f\"Bearer {self.notion_secret}\",\n            \"Notion-Version\": \"2022-06-28\",\n        }\n        try:\n            blocks_response = requests.get(blocks_url, headers=headers, timeout=10)\n            blocks_response.raise_for_status()\n            blocks_data = blocks_response.json()\n            return self.parse_blocks(blocks_data.get(\"results\", []))\n        except requests.exceptions.RequestException as e:\n            error_message = f\"Error: Failed to retrieve Notion page content. {e}\"\n            if hasattr(e, \"response\") and e.response is not None:\n                error_message += f\" Status code: {e.response.status_code}, Response: {e.response.text}\"\n            return error_message\n        except Exception as e:  # noqa: BLE001\n            logger.opt(exception=True).debug(\"Error retrieving Notion page content\")\n            return f\"Error: An unexpected error occurred while retrieving Notion page content. {e}\"\n\n    def parse_blocks(self, blocks: list) -> str:\n        content = \"\"\n        for block in blocks:\n            block_type = block.get(\"type\")\n            if block_type in {\"paragraph\", \"heading_1\", \"heading_2\", \"heading_3\", \"quote\"}:\n                content += self.parse_rich_text(block[block_type].get(\"rich_text\", [])) + \"\\n\\n\"\n            elif block_type in {\"bulleted_list_item\", \"numbered_list_item\"}:\n                content += self.parse_rich_text(block[block_type].get(\"rich_text\", [])) + \"\\n\"\n            elif block_type == \"to_do\":\n                content += self.parse_rich_text(block[\"to_do\"].get(\"rich_text\", [])) + \"\\n\"\n            elif block_type == \"code\":\n                content += self.parse_rich_text(block[\"code\"].get(\"rich_text\", [])) + \"\\n\\n\"\n            elif block_type == \"image\":\n                content += f\"[Image: {block['image'].get('external', {}).get('url', 'No URL')}]\\n\\n\"\n            elif block_type == \"divider\":\n                content += \"---\\n\\n\"\n        return content.strip()\n\n    def parse_rich_text(self, rich_text: list) -> str:\n        return \"\".join(segment.get(\"plain_text\", \"\") for segment in rich_text)\n\n    def __call__(self, *args, **kwargs):\n        return self._retrieve_page_content(*args, **kwargs)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "notion_secret": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "notion_secret",
    //                 "value": "",
    //                 "display_name": "Notion Secret",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The Notion integration token.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "page_id": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "page_id",
    //                 "value": "",
    //                 "display_name": "Page ID",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The ID of the Notion page to retrieve.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Retrieve the content of a Notion page as plain text.",
    //         "icon": "NotionDirectoryLoader",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "Page Content Viewer ",
    //         "documentation": "https://docs.langflow.org/integrations/notion/page-content-viewer",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "notion_secret",
    //                     "page_id"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "notion_secret",
    //                     "page_id"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "page_id",
    //             "notion_secret"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "NotionPageUpdate": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import json\nfrom typing import Any\n\nimport requests\nfrom langchain.tools import StructuredTool\nfrom loguru import logger\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import MultilineInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass NotionPageUpdate(LCToolComponent):\n    display_name: str = \"Update Page Property \"\n    description: str = \"Update the properties of a Notion page.\"\n    documentation: str = \"https://docs.langflow.org/integrations/notion/page-update\"\n    icon = \"NotionDirectoryLoader\"\n\n    inputs = [\n        StrInput(\n            name=\"page_id\",\n            display_name=\"Page ID\",\n            info=\"The ID of the Notion page to update.\",\n        ),\n        MultilineInput(\n            name=\"properties\",\n            display_name=\"Properties\",\n            info=\"The properties to update on the page (as a JSON string or a dictionary).\",\n        ),\n        SecretStrInput(\n            name=\"notion_secret\",\n            display_name=\"Notion Secret\",\n            info=\"The Notion integration token.\",\n            required=True,\n        ),\n    ]\n\n    class NotionPageUpdateSchema(BaseModel):\n        page_id: str = Field(..., description=\"The ID of the Notion page to update.\")\n        properties: str | dict[str, Any] = Field(\n            ..., description=\"The properties to update on the page (as a JSON string or a dictionary).\"\n        )\n\n    def run_model(self) -> Data:\n        result = self._update_notion_page(self.page_id, self.properties)\n        if isinstance(result, str):\n            # An error occurred, return it as text\n            return Data(text=result)\n        # Success, return the updated page data\n        output = \"Updated page properties:\\n\"\n        for prop_name, prop_value in result.get(\"properties\", {}).items():\n            output += f\"{prop_name}: {prop_value}\\n\"\n        return Data(text=output, data=result)\n\n    def build_tool(self) -> Tool:\n        return StructuredTool.from_function(\n            name=\"update_notion_page\",\n            description=\"Update the properties of a Notion page. \"\n            \"IMPORTANT: Use the tool to check the Database properties for more details before using this tool.\",\n            func=self._update_notion_page,\n            args_schema=self.NotionPageUpdateSchema,\n        )\n\n    def _update_notion_page(self, page_id: str, properties: str | dict[str, Any]) -> dict[str, Any] | str:\n        url = f\"https://api.notion.com/v1/pages/{page_id}\"\n        headers = {\n            \"Authorization\": f\"Bearer {self.notion_secret}\",\n            \"Content-Type\": \"application/json\",\n            \"Notion-Version\": \"2022-06-28\",  # Use the latest supported version\n        }\n\n        # Parse properties if it's a string\n        if isinstance(properties, str):\n            try:\n                parsed_properties = json.loads(properties)\n            except json.JSONDecodeError as e:\n                error_message = f\"Invalid JSON format for properties: {e}\"\n                logger.exception(error_message)\n                return error_message\n\n        else:\n            parsed_properties = properties\n\n        data = {\"properties\": parsed_properties}\n\n        try:\n            logger.info(f\"Sending request to Notion API: URL: {url}, Data: {json.dumps(data)}\")\n            response = requests.patch(url, headers=headers, json=data, timeout=10)\n            response.raise_for_status()\n            updated_page = response.json()\n\n            logger.info(f\"Successfully updated Notion page. Response: {json.dumps(updated_page)}\")\n        except requests.exceptions.HTTPError as e:\n            error_message = f\"HTTP Error occurred: {e}\"\n            if e.response is not None:\n                error_message += f\"\\nStatus code: {e.response.status_code}\"\n                error_message += f\"\\nResponse body: {e.response.text}\"\n            logger.exception(error_message)\n            return error_message\n        except requests.exceptions.RequestException as e:\n            error_message = f\"An error occurred while making the request: {e}\"\n            logger.exception(error_message)\n            return error_message\n        except Exception as e:  # noqa: BLE001\n            error_message = f\"An unexpected error occurred: {e}\"\n            logger.exception(error_message)\n            return error_message\n\n        return updated_page\n\n    def __call__(self, *args, **kwargs):\n        return self._update_notion_page(*args, **kwargs)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "notion_secret": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "notion_secret",
    //                 "value": "",
    //                 "display_name": "Notion Secret",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The Notion integration token.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "page_id": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "page_id",
    //                 "value": "",
    //                 "display_name": "Page ID",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The ID of the Notion page to update.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "properties": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "properties",
    //                 "value": "",
    //                 "display_name": "Properties",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The properties to update on the page (as a JSON string or a dictionary).",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Update the properties of a Notion page.",
    //         "icon": "NotionDirectoryLoader",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "Update Page Property ",
    //         "documentation": "https://docs.langflow.org/integrations/notion/page-update",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "notion_secret",
    //                     "page_id",
    //                     "properties"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "notion_secret",
    //                     "page_id",
    //                     "properties"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "page_id",
    //             "properties",
    //             "notion_secret"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AddContentToPage": {
    //         "template": {
    //             "_type": "Component",
    //             "block_id": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "block_id",
    //                 "value": "",
    //                 "display_name": "Page/Block ID",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The ID of the page/block to add the content.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import json\nfrom typing import Any\n\nimport requests\nfrom bs4 import BeautifulSoup\nfrom langchain.tools import StructuredTool\nfrom loguru import logger\nfrom markdown import markdown\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import MultilineInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\nMIN_ROWS_IN_TABLE = 3\n\n\nclass AddContentToPage(LCToolComponent):\n    display_name: str = \"Add Content to Page \"\n    description: str = \"Convert markdown text to Notion blocks and append them to a Notion page.\"\n    documentation: str = \"https://developers.notion.com/reference/patch-block-children\"\n    icon = \"NotionDirectoryLoader\"\n\n    inputs = [\n        MultilineInput(\n            name=\"markdown_text\",\n            display_name=\"Markdown Text\",\n            info=\"The markdown text to convert to Notion blocks.\",\n        ),\n        StrInput(\n            name=\"block_id\",\n            display_name=\"Page/Block ID\",\n            info=\"The ID of the page/block to add the content.\",\n        ),\n        SecretStrInput(\n            name=\"notion_secret\",\n            display_name=\"Notion Secret\",\n            info=\"The Notion integration token.\",\n            required=True,\n        ),\n    ]\n\n    class AddContentToPageSchema(BaseModel):\n        markdown_text: str = Field(..., description=\"The markdown text to convert to Notion blocks.\")\n        block_id: str = Field(..., description=\"The ID of the page/block to add the content.\")\n\n    def run_model(self) -> Data:\n        result = self._add_content_to_page(self.markdown_text, self.block_id)\n        return Data(data=result, text=json.dumps(result))\n\n    def build_tool(self) -> Tool:\n        return StructuredTool.from_function(\n            name=\"add_content_to_notion_page\",\n            description=\"Convert markdown text to Notion blocks and append them to a Notion page.\",\n            func=self._add_content_to_page,\n            args_schema=self.AddContentToPageSchema,\n        )\n\n    def _add_content_to_page(self, markdown_text: str, block_id: str) -> dict[str, Any] | str:\n        try:\n            html_text = markdown(markdown_text)\n            soup = BeautifulSoup(html_text, \"html.parser\")\n            blocks = self.process_node(soup)\n\n            url = f\"https://api.notion.com/v1/blocks/{block_id}/children\"\n            headers = {\n                \"Authorization\": f\"Bearer {self.notion_secret}\",\n                \"Content-Type\": \"application/json\",\n                \"Notion-Version\": \"2022-06-28\",\n            }\n\n            data = {\n                \"children\": blocks,\n            }\n\n            response = requests.patch(url, headers=headers, json=data, timeout=10)\n            response.raise_for_status()\n\n            return response.json()\n        except requests.exceptions.RequestException as e:\n            error_message = f\"Error: Failed to add content to Notion page. {e}\"\n            if hasattr(e, \"response\") and e.response is not None:\n                error_message += f\" Status code: {e.response.status_code}, Response: {e.response.text}\"\n            return error_message\n        except Exception as e:  # noqa: BLE001\n            logger.opt(exception=True).debug(\"Error adding content to Notion page\")\n            return f\"Error: An unexpected error occurred while adding content to Notion page. {e}\"\n\n    def process_node(self, node):\n        blocks = []\n        if isinstance(node, str):\n            text = node.strip()\n            if text:\n                if text.startswith(\"#\"):\n                    heading_level = text.count(\"#\", 0, 6)\n                    heading_text = text[heading_level:].strip()\n                    if heading_level in range(3):\n                        blocks.append(self.create_block(f\"heading_{heading_level + 1}\", heading_text))\n                else:\n                    blocks.append(self.create_block(\"paragraph\", text))\n        elif node.name == \"h1\":\n            blocks.append(self.create_block(\"heading_1\", node.get_text(strip=True)))\n        elif node.name == \"h2\":\n            blocks.append(self.create_block(\"heading_2\", node.get_text(strip=True)))\n        elif node.name == \"h3\":\n            blocks.append(self.create_block(\"heading_3\", node.get_text(strip=True)))\n        elif node.name == \"p\":\n            code_node = node.find(\"code\")\n            if code_node:\n                code_text = code_node.get_text()\n                language, code = self.extract_language_and_code(code_text)\n                blocks.append(self.create_block(\"code\", code, language=language))\n            elif self.is_table(str(node)):\n                blocks.extend(self.process_table(node))\n            else:\n                blocks.append(self.create_block(\"paragraph\", node.get_text(strip=True)))\n        elif node.name == \"ul\":\n            blocks.extend(self.process_list(node, \"bulleted_list_item\"))\n        elif node.name == \"ol\":\n            blocks.extend(self.process_list(node, \"numbered_list_item\"))\n        elif node.name == \"blockquote\":\n            blocks.append(self.create_block(\"quote\", node.get_text(strip=True)))\n        elif node.name == \"hr\":\n            blocks.append(self.create_block(\"divider\", \"\"))\n        elif node.name == \"img\":\n            blocks.append(self.create_block(\"image\", \"\", image_url=node.get(\"src\")))\n        elif node.name == \"a\":\n            blocks.append(self.create_block(\"bookmark\", node.get_text(strip=True), link_url=node.get(\"href\")))\n        elif node.name == \"table\":\n            blocks.extend(self.process_table(node))\n\n        for child in node.children:\n            if isinstance(child, str):\n                continue\n            blocks.extend(self.process_node(child))\n\n        return blocks\n\n    def extract_language_and_code(self, code_text):\n        lines = code_text.split(\"\\n\")\n        language = lines[0].strip()\n        code = \"\\n\".join(lines[1:]).strip()\n        return language, code\n\n    def is_code_block(self, text):\n        return text.startswith(\"```\")\n\n    def extract_code_block(self, text):\n        lines = text.split(\"\\n\")\n        language = lines[0].strip(\"`\").strip()\n        code = \"\\n\".join(lines[1:]).strip(\"`\").strip()\n        return language, code\n\n    def is_table(self, text):\n        rows = text.split(\"\\n\")\n        if len(rows) < MIN_ROWS_IN_TABLE:\n            return False\n\n        has_separator = False\n        for i, row in enumerate(rows):\n            if \"|\" in row:\n                cells = [cell.strip() for cell in row.split(\"|\")]\n                cells = [cell for cell in cells if cell]  # Remove empty cells\n                if i == 1 and all(set(cell) <= set(\"-|\") for cell in cells):\n                    has_separator = True\n                elif not cells:\n                    return False\n\n        return has_separator\n\n    def process_list(self, node, list_type):\n        blocks = []\n        for item in node.find_all(\"li\"):\n            item_text = item.get_text(strip=True)\n            checked = item_text.startswith(\"[x]\")\n            is_checklist = item_text.startswith(\"[ ]\") or checked\n\n            if is_checklist:\n                item_text = item_text.replace(\"[x]\", \"\").replace(\"[ ]\", \"\").strip()\n                blocks.append(self.create_block(\"to_do\", item_text, checked=checked))\n            else:\n                blocks.append(self.create_block(list_type, item_text))\n        return blocks\n\n    def process_table(self, node):\n        blocks = []\n        header_row = node.find(\"thead\").find(\"tr\") if node.find(\"thead\") else None\n        body_rows = node.find(\"tbody\").find_all(\"tr\") if node.find(\"tbody\") else []\n\n        if header_row or body_rows:\n            table_width = max(\n                len(header_row.find_all([\"th\", \"td\"])) if header_row else 0,\n                *(len(row.find_all([\"th\", \"td\"])) for row in body_rows),\n            )\n\n            table_block = self.create_block(\"table\", \"\", table_width=table_width, has_column_header=bool(header_row))\n            blocks.append(table_block)\n\n            if header_row:\n                header_cells = [cell.get_text(strip=True) for cell in header_row.find_all([\"th\", \"td\"])]\n                header_row_block = self.create_block(\"table_row\", header_cells)\n                blocks.append(header_row_block)\n\n            for row in body_rows:\n                cells = [cell.get_text(strip=True) for cell in row.find_all([\"th\", \"td\"])]\n                row_block = self.create_block(\"table_row\", cells)\n                blocks.append(row_block)\n\n        return blocks\n\n    def create_block(self, block_type: str, content: str, **kwargs) -> dict[str, Any]:\n        block: dict[str, Any] = {\n            \"object\": \"block\",\n            \"type\": block_type,\n            block_type: {},\n        }\n\n        if block_type in {\n            \"paragraph\",\n            \"heading_1\",\n            \"heading_2\",\n            \"heading_3\",\n            \"bulleted_list_item\",\n            \"numbered_list_item\",\n            \"quote\",\n        }:\n            block[block_type][\"rich_text\"] = [\n                {\n                    \"type\": \"text\",\n                    \"text\": {\n                        \"content\": content,\n                    },\n                }\n            ]\n        elif block_type == \"to_do\":\n            block[block_type][\"rich_text\"] = [\n                {\n                    \"type\": \"text\",\n                    \"text\": {\n                        \"content\": content,\n                    },\n                }\n            ]\n            block[block_type][\"checked\"] = kwargs.get(\"checked\", False)\n        elif block_type == \"code\":\n            block[block_type][\"rich_text\"] = [\n                {\n                    \"type\": \"text\",\n                    \"text\": {\n                        \"content\": content,\n                    },\n                }\n            ]\n            block[block_type][\"language\"] = kwargs.get(\"language\", \"plain text\")\n        elif block_type == \"image\":\n            block[block_type] = {\"type\": \"external\", \"external\": {\"url\": kwargs.get(\"image_url\", \"\")}}\n        elif block_type == \"divider\":\n            pass\n        elif block_type == \"bookmark\":\n            block[block_type][\"url\"] = kwargs.get(\"link_url\", \"\")\n        elif block_type == \"table\":\n            block[block_type][\"table_width\"] = kwargs.get(\"table_width\", 0)\n            block[block_type][\"has_column_header\"] = kwargs.get(\"has_column_header\", False)\n            block[block_type][\"has_row_header\"] = kwargs.get(\"has_row_header\", False)\n        elif block_type == \"table_row\":\n            block[block_type][\"cells\"] = [[{\"type\": \"text\", \"text\": {\"content\": cell}} for cell in content]]\n\n        return block\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "markdown_text": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "markdown_text",
    //                 "value": "",
    //                 "display_name": "Markdown Text",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The markdown text to convert to Notion blocks.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "notion_secret": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "notion_secret",
    //                 "value": "",
    //                 "display_name": "Notion Secret",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The Notion integration token.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             }
    //         },
    //         "description": "Convert markdown text to Notion blocks and append them to a Notion page.",
    //         "icon": "NotionDirectoryLoader",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "Add Content to Page ",
    //         "documentation": "https://developers.notion.com/reference/patch-block-children",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "block_id",
    //                     "markdown_text",
    //                     "notion_secret"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "block_id",
    //                     "markdown_text",
    //                     "notion_secret"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "markdown_text",
    //             "block_id",
    //             "notion_secret"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "NotionListPages": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import json\nfrom typing import Any\n\nimport requests\nfrom langchain.tools import StructuredTool\nfrom loguru import logger\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import MultilineInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass NotionListPages(LCToolComponent):\n    display_name: str = \"List Pages \"\n    description: str = (\n        \"Query a Notion database with filtering and sorting. \"\n        \"The input should be a JSON string containing the 'filter' and 'sorts' objects. \"\n        \"Example input:\\n\"\n        '{\"filter\": {\"property\": \"Status\", \"select\": {\"equals\": \"Done\"}}, '\n        '\"sorts\": [{\"timestamp\": \"created_time\", \"direction\": \"descending\"}]}'\n    )\n    documentation: str = \"https://docs.langflow.org/integrations/notion/list-pages\"\n    icon = \"NotionDirectoryLoader\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"notion_secret\",\n            display_name=\"Notion Secret\",\n            info=\"The Notion integration token.\",\n            required=True,\n        ),\n        StrInput(\n            name=\"database_id\",\n            display_name=\"Database ID\",\n            info=\"The ID of the Notion database to query.\",\n        ),\n        MultilineInput(\n            name=\"query_json\",\n            display_name=\"Database query (JSON)\",\n            info=\"A JSON string containing the filters and sorts that will be used for querying the database. \"\n            \"Leave empty for no filters or sorts.\",\n        ),\n    ]\n\n    class NotionListPagesSchema(BaseModel):\n        database_id: str = Field(..., description=\"The ID of the Notion database to query.\")\n        query_json: str | None = Field(\n            default=\"\",\n            description=\"A JSON string containing the filters and sorts for querying the database. \"\n            \"Leave empty for no filters or sorts.\",\n        )\n\n    def run_model(self) -> list[Data]:\n        result = self._query_notion_database(self.database_id, self.query_json)\n\n        if isinstance(result, str):\n            # An error occurred, return it as a single record\n            return [Data(text=result)]\n\n        records = []\n        combined_text = f\"Pages found: {len(result)}\\n\\n\"\n\n        for page in result:\n            page_data = {\n                \"id\": page[\"id\"],\n                \"url\": page[\"url\"],\n                \"created_time\": page[\"created_time\"],\n                \"last_edited_time\": page[\"last_edited_time\"],\n                \"properties\": page[\"properties\"],\n            }\n\n            text = (\n                f\"id: {page['id']}\\n\"\n                f\"url: {page['url']}\\n\"\n                f\"created_time: {page['created_time']}\\n\"\n                f\"last_edited_time: {page['last_edited_time']}\\n\"\n                f\"properties: {json.dumps(page['properties'], indent=2)}\\n\\n\"\n            )\n\n            combined_text += text\n            records.append(Data(text=text, **page_data))\n\n        self.status = records\n        return records\n\n    def build_tool(self) -> Tool:\n        return StructuredTool.from_function(\n            name=\"notion_list_pages\",\n            description=self.description,\n            func=self._query_notion_database,\n            args_schema=self.NotionListPagesSchema,\n        )\n\n    def _query_notion_database(self, database_id: str, query_json: str | None = None) -> list[dict[str, Any]] | str:\n        url = f\"https://api.notion.com/v1/databases/{database_id}/query\"\n        headers = {\n            \"Authorization\": f\"Bearer {self.notion_secret}\",\n            \"Content-Type\": \"application/json\",\n            \"Notion-Version\": \"2022-06-28\",\n        }\n\n        query_payload = {}\n        if query_json and query_json.strip():\n            try:\n                query_payload = json.loads(query_json)\n            except json.JSONDecodeError as e:\n                return f\"Invalid JSON format for query: {e}\"\n\n        try:\n            response = requests.post(url, headers=headers, json=query_payload, timeout=10)\n            response.raise_for_status()\n            results = response.json()\n            return results[\"results\"]\n        except requests.exceptions.RequestException as e:\n            return f\"Error querying Notion database: {e}\"\n        except KeyError:\n            return \"Unexpected response format from Notion API\"\n        except Exception as e:  # noqa: BLE001\n            logger.opt(exception=True).debug(\"Error querying Notion database\")\n            return f\"An unexpected error occurred: {e}\"\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "database_id": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "database_id",
    //                 "value": "",
    //                 "display_name": "Database ID",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The ID of the Notion database to query.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "notion_secret": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "notion_secret",
    //                 "value": "",
    //                 "display_name": "Notion Secret",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The Notion integration token.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "query_json": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "query_json",
    //                 "value": "",
    //                 "display_name": "Database query (JSON)",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "A JSON string containing the filters and sorts that will be used for querying the database. Leave empty for no filters or sorts.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Query a Notion database with filtering and sorting. The input should be a JSON string containing the 'filter' and 'sorts' objects. Example input:\n{\"filter\": {\"property\": \"Status\", \"select\": {\"equals\": \"Done\"}}, \"sorts\": [{\"timestamp\": \"created_time\", \"direction\": \"descending\"}]}",
    //         "icon": "NotionDirectoryLoader",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "List Pages ",
    //         "documentation": "https://docs.langflow.org/integrations/notion/list-pages",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "database_id",
    //                     "notion_secret",
    //                     "query_json"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "database_id",
    //                     "notion_secret",
    //                     "query_json"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "notion_secret",
    //             "database_id",
    //             "query_json"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "NotionPageCreator": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import json\nfrom typing import Any\n\nimport requests\nfrom langchain.tools import StructuredTool\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import MultilineInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass NotionPageCreator(LCToolComponent):\n    display_name: str = \"Create Page \"\n    description: str = \"A component for creating Notion pages.\"\n    documentation: str = \"https://docs.langflow.org/integrations/notion/page-create\"\n    icon = \"NotionDirectoryLoader\"\n\n    inputs = [\n        StrInput(\n            name=\"database_id\",\n            display_name=\"Database ID\",\n            info=\"The ID of the Notion database.\",\n        ),\n        SecretStrInput(\n            name=\"notion_secret\",\n            display_name=\"Notion Secret\",\n            info=\"The Notion integration token.\",\n            required=True,\n        ),\n        MultilineInput(\n            name=\"properties_json\",\n            display_name=\"Properties (JSON)\",\n            info=\"The properties of the new page as a JSON string.\",\n        ),\n    ]\n\n    class NotionPageCreatorSchema(BaseModel):\n        database_id: str = Field(..., description=\"The ID of the Notion database.\")\n        properties_json: str = Field(..., description=\"The properties of the new page as a JSON string.\")\n\n    def run_model(self) -> Data:\n        result = self._create_notion_page(self.database_id, self.properties_json)\n        if isinstance(result, str):\n            # An error occurred, return it as text\n            return Data(text=result)\n        # Success, return the created page data\n        output = \"Created page properties:\\n\"\n        for prop_name, prop_value in result.get(\"properties\", {}).items():\n            output += f\"{prop_name}: {prop_value}\\n\"\n        return Data(text=output, data=result)\n\n    def build_tool(self) -> Tool:\n        return StructuredTool.from_function(\n            name=\"create_notion_page\",\n            description=\"Create a new page in a Notion database. \"\n            \"IMPORTANT: Use the tool to check the Database properties for more details before using this tool.\",\n            func=self._create_notion_page,\n            args_schema=self.NotionPageCreatorSchema,\n        )\n\n    def _create_notion_page(self, database_id: str, properties_json: str) -> dict[str, Any] | str:\n        if not database_id or not properties_json:\n            return \"Invalid input. Please provide 'database_id' and 'properties_json'.\"\n\n        try:\n            properties = json.loads(properties_json)\n        except json.JSONDecodeError as e:\n            return f\"Invalid properties format. Please provide a valid JSON string. Error: {e}\"\n\n        headers = {\n            \"Authorization\": f\"Bearer {self.notion_secret}\",\n            \"Content-Type\": \"application/json\",\n            \"Notion-Version\": \"2022-06-28\",\n        }\n\n        data = {\n            \"parent\": {\"database_id\": database_id},\n            \"properties\": properties,\n        }\n\n        try:\n            response = requests.post(\"https://api.notion.com/v1/pages\", headers=headers, json=data, timeout=10)\n            response.raise_for_status()\n            return response.json()\n        except requests.exceptions.RequestException as e:\n            error_message = f\"Failed to create Notion page. Error: {e}\"\n            if hasattr(e, \"response\") and e.response is not None:\n                error_message += f\" Status code: {e.response.status_code}, Response: {e.response.text}\"\n            return error_message\n\n    def __call__(self, *args, **kwargs):\n        return self._create_notion_page(*args, **kwargs)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "database_id": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "database_id",
    //                 "value": "",
    //                 "display_name": "Database ID",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The ID of the Notion database.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "notion_secret": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "notion_secret",
    //                 "value": "",
    //                 "display_name": "Notion Secret",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The Notion integration token.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "properties_json": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "properties_json",
    //                 "value": "",
    //                 "display_name": "Properties (JSON)",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The properties of the new page as a JSON string.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "A component for creating Notion pages.",
    //         "icon": "NotionDirectoryLoader",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "Create Page ",
    //         "documentation": "https://docs.langflow.org/integrations/notion/page-create",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "database_id",
    //                     "notion_secret",
    //                     "properties_json"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "database_id",
    //                     "notion_secret",
    //                     "properties_json"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "database_id",
    //             "notion_secret",
    //             "properties_json"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "NotionDatabaseProperties": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import requests\nfrom langchain.tools import StructuredTool\nfrom loguru import logger\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass NotionDatabaseProperties(LCToolComponent):\n    display_name: str = \"List Database Properties \"\n    description: str = \"Retrieve properties of a Notion database.\"\n    documentation: str = \"https://docs.langflow.org/integrations/notion/list-database-properties\"\n    icon = \"NotionDirectoryLoader\"\n\n    inputs = [\n        StrInput(\n            name=\"database_id\",\n            display_name=\"Database ID\",\n            info=\"The ID of the Notion database.\",\n        ),\n        SecretStrInput(\n            name=\"notion_secret\",\n            display_name=\"Notion Secret\",\n            info=\"The Notion integration token.\",\n            required=True,\n        ),\n    ]\n\n    class NotionDatabasePropertiesSchema(BaseModel):\n        database_id: str = Field(..., description=\"The ID of the Notion database.\")\n\n    def run_model(self) -> Data:\n        result = self._fetch_database_properties(self.database_id)\n        if isinstance(result, str):\n            # An error occurred, return it as text\n            return Data(text=result)\n        # Success, return the properties\n        return Data(text=str(result), data=result)\n\n    def build_tool(self) -> Tool:\n        return StructuredTool.from_function(\n            name=\"notion_database_properties\",\n            description=\"Retrieve properties of a Notion database. Input should include the database ID.\",\n            func=self._fetch_database_properties,\n            args_schema=self.NotionDatabasePropertiesSchema,\n        )\n\n    def _fetch_database_properties(self, database_id: str) -> dict | str:\n        url = f\"https://api.notion.com/v1/databases/{database_id}\"\n        headers = {\n            \"Authorization\": f\"Bearer {self.notion_secret}\",\n            \"Notion-Version\": \"2022-06-28\",  # Use the latest supported version\n        }\n        try:\n            response = requests.get(url, headers=headers, timeout=10)\n            response.raise_for_status()\n            data = response.json()\n            return data.get(\"properties\", {})\n        except requests.exceptions.RequestException as e:\n            return f\"Error fetching Notion database properties: {e}\"\n        except ValueError as e:\n            return f\"Error parsing Notion API response: {e}\"\n        except Exception as e:  # noqa: BLE001\n            logger.opt(exception=True).debug(\"Error fetching Notion database properties\")\n            return f\"An unexpected error occurred: {e}\"\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "database_id": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "database_id",
    //                 "value": "",
    //                 "display_name": "Database ID",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The ID of the Notion database.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "notion_secret": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "notion_secret",
    //                 "value": "",
    //                 "display_name": "Notion Secret",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The Notion integration token.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             }
    //         },
    //         "description": "Retrieve properties of a Notion database.",
    //         "icon": "NotionDirectoryLoader",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "List Database Properties ",
    //         "documentation": "https://docs.langflow.org/integrations/notion/list-database-properties",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "database_id",
    //                     "notion_secret"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "database_id",
    //                     "notion_secret"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "database_id",
    //             "notion_secret"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "NotionSearch": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nimport requests\nfrom langchain.tools import StructuredTool\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import DropdownInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass NotionSearch(LCToolComponent):\n    display_name: str = \"Search \"\n    description: str = \"Searches all pages and databases that have been shared with an integration.\"\n    documentation: str = \"https://docs.langflow.org/integrations/notion/search\"\n    icon = \"NotionDirectoryLoader\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"notion_secret\",\n            display_name=\"Notion Secret\",\n            info=\"The Notion integration token.\",\n            required=True,\n        ),\n        StrInput(\n            name=\"query\",\n            display_name=\"Search Query\",\n            info=\"The text that the API compares page and database titles against.\",\n        ),\n        DropdownInput(\n            name=\"filter_value\",\n            display_name=\"Filter Type\",\n            info=\"Limits the results to either only pages or only databases.\",\n            options=[\"page\", \"database\"],\n            value=\"page\",\n        ),\n        DropdownInput(\n            name=\"sort_direction\",\n            display_name=\"Sort Direction\",\n            info=\"The direction to sort the results.\",\n            options=[\"ascending\", \"descending\"],\n            value=\"descending\",\n        ),\n    ]\n\n    class NotionSearchSchema(BaseModel):\n        query: str = Field(..., description=\"The search query text.\")\n        filter_value: str = Field(default=\"page\", description=\"Filter type: 'page' or 'database'.\")\n        sort_direction: str = Field(default=\"descending\", description=\"Sort direction: 'ascending' or 'descending'.\")\n\n    def run_model(self) -> list[Data]:\n        results = self._search_notion(self.query, self.filter_value, self.sort_direction)\n        records = []\n        combined_text = f\"Results found: {len(results)}\\n\\n\"\n\n        for result in results:\n            result_data = {\n                \"id\": result[\"id\"],\n                \"type\": result[\"object\"],\n                \"last_edited_time\": result[\"last_edited_time\"],\n            }\n\n            if result[\"object\"] == \"page\":\n                result_data[\"title_or_url\"] = result[\"url\"]\n                text = f\"id: {result['id']}\\ntitle_or_url: {result['url']}\\n\"\n            elif result[\"object\"] == \"database\":\n                if \"title\" in result and isinstance(result[\"title\"], list) and len(result[\"title\"]) > 0:\n                    result_data[\"title_or_url\"] = result[\"title\"][0][\"plain_text\"]\n                    text = f\"id: {result['id']}\\ntitle_or_url: {result['title'][0]['plain_text']}\\n\"\n                else:\n                    result_data[\"title_or_url\"] = \"N/A\"\n                    text = f\"id: {result['id']}\\ntitle_or_url: N/A\\n\"\n\n            text += f\"type: {result['object']}\\nlast_edited_time: {result['last_edited_time']}\\n\\n\"\n            combined_text += text\n            records.append(Data(text=text, data=result_data))\n\n        self.status = records\n        return records\n\n    def build_tool(self) -> Tool:\n        return StructuredTool.from_function(\n            name=\"notion_search\",\n            description=\"Search Notion pages and databases. \"\n            \"Input should include the search query and optionally filter type and sort direction.\",\n            func=self._search_notion,\n            args_schema=self.NotionSearchSchema,\n        )\n\n    def _search_notion(\n        self, query: str, filter_value: str = \"page\", sort_direction: str = \"descending\"\n    ) -> list[dict[str, Any]]:\n        url = \"https://api.notion.com/v1/search\"\n        headers = {\n            \"Authorization\": f\"Bearer {self.notion_secret}\",\n            \"Content-Type\": \"application/json\",\n            \"Notion-Version\": \"2022-06-28\",\n        }\n\n        data = {\n            \"query\": query,\n            \"filter\": {\"value\": filter_value, \"property\": \"object\"},\n            \"sort\": {\"direction\": sort_direction, \"timestamp\": \"last_edited_time\"},\n        }\n\n        response = requests.post(url, headers=headers, json=data, timeout=10)\n        response.raise_for_status()\n\n        results = response.json()\n        return results[\"results\"]\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "filter_value": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "page",
    //                     "database"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "filter_value",
    //                 "value": "page",
    //                 "display_name": "Filter Type",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Limits the results to either only pages or only databases.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "notion_secret": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "notion_secret",
    //                 "value": "",
    //                 "display_name": "Notion Secret",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The Notion integration token.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "query": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "query",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The text that the API compares page and database titles against.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "sort_direction": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "ascending",
    //                     "descending"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "sort_direction",
    //                 "value": "descending",
    //                 "display_name": "Sort Direction",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The direction to sort the results.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             }
    //         },
    //         "description": "Searches all pages and databases that have been shared with an integration.",
    //         "icon": "NotionDirectoryLoader",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "Search ",
    //         "documentation": "https://docs.langflow.org/integrations/notion/search",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "filter_value",
    //                     "notion_secret",
    //                     "query",
    //                     "sort_direction"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "filter_value",
    //                     "notion_secret",
    //                     "query",
    //                     "sort_direction"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "notion_secret",
    //             "query",
    //             "filter_value",
    //             "sort_direction"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "NotionUserList": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import requests\nfrom langchain.tools import StructuredTool\nfrom pydantic import BaseModel\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import SecretStrInput\nfrom langflow.schema import Data\n\n\nclass NotionUserList(LCToolComponent):\n    display_name = \"List Users \"\n    description = \"Retrieve users from Notion.\"\n    documentation = \"https://docs.langflow.org/integrations/notion/list-users\"\n    icon = \"NotionDirectoryLoader\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"notion_secret\",\n            display_name=\"Notion Secret\",\n            info=\"The Notion integration token.\",\n            required=True,\n        ),\n    ]\n\n    class NotionUserListSchema(BaseModel):\n        pass\n\n    def run_model(self) -> list[Data]:\n        users = self._list_users()\n        records = []\n        combined_text = \"\"\n\n        for user in users:\n            output = \"User:\\n\"\n            for key, value in user.items():\n                output += f\"{key.replace('_', ' ').title()}: {value}\\n\"\n            output += \"________________________\\n\"\n\n            combined_text += output\n            records.append(Data(text=output, data=user))\n\n        self.status = records\n        return records\n\n    def build_tool(self) -> Tool:\n        return StructuredTool.from_function(\n            name=\"notion_list_users\",\n            description=\"Retrieve users from Notion.\",\n            func=self._list_users,\n            args_schema=self.NotionUserListSchema,\n        )\n\n    def _list_users(self) -> list[dict]:\n        url = \"https://api.notion.com/v1/users\"\n        headers = {\n            \"Authorization\": f\"Bearer {self.notion_secret}\",\n            \"Notion-Version\": \"2022-06-28\",\n        }\n\n        response = requests.get(url, headers=headers, timeout=10)\n        response.raise_for_status()\n\n        data = response.json()\n        results = data[\"results\"]\n\n        users = []\n        for user in results:\n            user_data = {\n                \"id\": user[\"id\"],\n                \"type\": user[\"type\"],\n                \"name\": user.get(\"name\", \"\"),\n                \"avatar_url\": user.get(\"avatar_url\", \"\"),\n            }\n            users.append(user_data)\n\n        return users\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "notion_secret": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "notion_secret",
    //                 "value": "",
    //                 "display_name": "Notion Secret",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The Notion integration token.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             }
    //         },
    //         "description": "Retrieve users from Notion.",
    //         "icon": "NotionDirectoryLoader",
    //         "base_classes": [
    //             "Data",
    //             "Tool"
    //         ],
    //         "display_name": "List Users ",
    //         "documentation": "https://docs.langflow.org/integrations/notion/list-users",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "api_run_model",
    //                 "display_name": "Data",
    //                 "method": "run_model",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "notion_secret"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "notion_secret"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "notion_secret"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "vectorstores": {
    //     "Cassandra": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingest Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "batch_size": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "batch_size",
    //                 "value": 16,
    //                 "display_name": "Batch Size",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional number of data to process in a single batch.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "body_search": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "body_search",
    //                 "value": "",
    //                 "display_name": "Search Body",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Document textual search terms to apply to the search query.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "cluster_kwargs": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "cluster_kwargs",
    //                 "value": {},
    //                 "display_name": "Cluster arguments",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional dictionary of additional keyword arguments for the Cassandra cluster.",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_community.vectorstores import Cassandra\nfrom loguru import logger\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.inputs import BoolInput, DictInput, FloatInput\nfrom langflow.io import (\n    DataInput,\n    DropdownInput,\n    HandleInput,\n    IntInput,\n    MessageTextInput,\n    MultilineInput,\n    SecretStrInput,\n)\nfrom langflow.schema import Data\n\n\nclass CassandraVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"Cassandra\"\n    description = \"Cassandra Vector Store with search capabilities\"\n    documentation = \"https://python.langchain.com/docs/modules/data_connection/vectorstores/integrations/cassandra\"\n    name = \"Cassandra\"\n    icon = \"Cassandra\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"database_ref\",\n            display_name=\"Contact Points / Astra Database ID\",\n            info=\"Contact points for the database (or AstraDB database ID)\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"username\", display_name=\"Username\", info=\"Username for the database (leave empty for AstraDB).\"\n        ),\n        SecretStrInput(\n            name=\"token\",\n            display_name=\"Password / AstraDB Token\",\n            info=\"User password for the database (or AstraDB token).\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"keyspace\",\n            display_name=\"Keyspace\",\n            info=\"Table Keyspace (or AstraDB namespace).\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"table_name\",\n            display_name=\"Table Name\",\n            info=\"The name of the table (or AstraDB collection) where vectors will be stored.\",\n            required=True,\n        ),\n        IntInput(\n            name=\"ttl_seconds\",\n            display_name=\"TTL Seconds\",\n            info=\"Optional time-to-live for the added texts.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"batch_size\",\n            display_name=\"Batch Size\",\n            info=\"Optional number of data to process in a single batch.\",\n            value=16,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"setup_mode\",\n            display_name=\"Setup Mode\",\n            info=\"Configuration mode for setting up the Cassandra table, with options like 'Sync', 'Async', or 'Off'.\",\n            options=[\"Sync\", \"Async\", \"Off\"],\n            value=\"Sync\",\n            advanced=True,\n        ),\n        DictInput(\n            name=\"cluster_kwargs\",\n            display_name=\"Cluster arguments\",\n            info=\"Optional dictionary of additional keyword arguments for the Cassandra cluster.\",\n            advanced=True,\n            is_list=True,\n        ),\n        MultilineInput(name=\"search_query\", display_name=\"Search Query\"),\n        DataInput(\n            name=\"ingest_data\",\n            display_name=\"Ingest Data\",\n            is_list=True,\n        ),\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"search_type\",\n            display_name=\"Search Type\",\n            info=\"Search type to use\",\n            options=[\"Similarity\", \"Similarity with score threshold\", \"MMR (Max Marginal Relevance)\"],\n            value=\"Similarity\",\n            advanced=True,\n        ),\n        FloatInput(\n            name=\"search_score_threshold\",\n            display_name=\"Search Score Threshold\",\n            info=\"Minimum similarity score threshold for search results. \"\n            \"(when using 'Similarity with score threshold')\",\n            value=0,\n            advanced=True,\n        ),\n        DictInput(\n            name=\"search_filter\",\n            display_name=\"Search Metadata Filter\",\n            info=\"Optional dictionary of filters to apply to the search query.\",\n            advanced=True,\n            is_list=True,\n        ),\n        MessageTextInput(\n            name=\"body_search\",\n            display_name=\"Search Body\",\n            info=\"Document textual search terms to apply to the search query.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"enable_body_search\",\n            display_name=\"Enable Body Search\",\n            info=\"Flag to enable body search. This must be enabled BEFORE the table is created.\",\n            value=False,\n            advanced=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> Cassandra:\n        try:\n            import cassio\n            from langchain_community.utilities.cassandra import SetupMode\n        except ImportError as e:\n            msg = \"Could not import cassio integration package. Please install it with `pip install cassio`.\"\n            raise ImportError(msg) from e\n\n        from uuid import UUID\n\n        database_ref = self.database_ref\n\n        try:\n            UUID(self.database_ref)\n            is_astra = True\n        except ValueError:\n            is_astra = False\n            if \",\" in self.database_ref:\n                # use a copy because we can't change the type of the parameter\n                database_ref = self.database_ref.split(\",\")\n\n        if is_astra:\n            cassio.init(\n                database_id=database_ref,\n                token=self.token,\n                cluster_kwargs=self.cluster_kwargs,\n            )\n        else:\n            cassio.init(\n                contact_points=database_ref,\n                username=self.username,\n                password=self.token,\n                cluster_kwargs=self.cluster_kwargs,\n            )\n        documents = []\n\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        body_index_options = [(\"index_analyzer\", \"STANDARD\")] if self.enable_body_search else None\n\n        if self.setup_mode == \"Off\":\n            setup_mode = SetupMode.OFF\n        elif self.setup_mode == \"Sync\":\n            setup_mode = SetupMode.SYNC\n        else:\n            setup_mode = SetupMode.ASYNC\n\n        if documents:\n            logger.debug(f\"Adding {len(documents)} documents to the Vector Store.\")\n            table = Cassandra.from_documents(\n                documents=documents,\n                embedding=self.embedding,\n                table_name=self.table_name,\n                keyspace=self.keyspace,\n                ttl_seconds=self.ttl_seconds or None,\n                batch_size=self.batch_size,\n                body_index_options=body_index_options,\n            )\n        else:\n            logger.debug(\"No documents to add to the Vector Store.\")\n            table = Cassandra(\n                embedding=self.embedding,\n                table_name=self.table_name,\n                keyspace=self.keyspace,\n                ttl_seconds=self.ttl_seconds or None,\n                body_index_options=body_index_options,\n                setup_mode=setup_mode,\n            )\n        return table\n\n    def _map_search_type(self) -> str:\n        if self.search_type == \"Similarity with score threshold\":\n            return \"similarity_score_threshold\"\n        if self.search_type == \"MMR (Max Marginal Relevance)\":\n            return \"mmr\"\n        return \"similarity\"\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        logger.debug(f\"Search input: {self.search_query}\")\n        logger.debug(f\"Search type: {self.search_type}\")\n        logger.debug(f\"Number of results: {self.number_of_results}\")\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            try:\n                search_type = self._map_search_type()\n                search_args = self._build_search_args()\n\n                logger.debug(f\"Search args: {search_args}\")\n\n                docs = vector_store.search(query=self.search_query, search_type=search_type, **search_args)\n            except KeyError as e:\n                if \"content\" in str(e):\n                    msg = (\n                        \"You should ingest data through Langflow (or LangChain) to query it in Langflow. \"\n                        \"Your collection does not contain a field name 'content'.\"\n                    )\n                    raise ValueError(msg) from e\n                raise\n\n            logger.debug(f\"Retrieved documents: {len(docs)}\")\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n\n    def _build_search_args(self):\n        args = {\n            \"k\": self.number_of_results,\n            \"score_threshold\": self.search_score_threshold,\n        }\n\n        if self.search_filter:\n            clean_filter = {k: v for k, v in self.search_filter.items() if k and v}\n            if len(clean_filter) > 0:\n                args[\"filter\"] = clean_filter\n        if self.body_search:\n            if not self.enable_body_search:\n                msg = \"You should enable body search when creating the table to search the body field.\"\n                raise ValueError(msg)\n            args[\"body_search\"] = self.body_search\n        return args\n\n    def get_retriever_kwargs(self):\n        search_args = self._build_search_args()\n        return {\n            \"search_type\": self._map_search_type(),\n            \"search_kwargs\": search_args,\n        }\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "database_ref": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "database_ref",
    //                 "value": "",
    //                 "display_name": "Contact Points / Astra Database ID",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Contact points for the database (or AstraDB database ID)",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "enable_body_search": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "enable_body_search",
    //                 "value": false,
    //                 "display_name": "Enable Body Search",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Flag to enable body search. This must be enabled BEFORE the table is created.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "keyspace": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "keyspace",
    //                 "value": "",
    //                 "display_name": "Keyspace",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Table Keyspace (or AstraDB namespace).",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 4,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "search_filter": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_filter",
    //                 "value": {},
    //                 "display_name": "Search Metadata Filter",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional dictionary of filters to apply to the search query.",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "search_query": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_query",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "search_score_threshold": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_score_threshold",
    //                 "value": 0.0,
    //                 "display_name": "Search Score Threshold",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Minimum similarity score threshold for search results. (when using 'Similarity with score threshold')",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "search_type": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Similarity",
    //                     "Similarity with score threshold",
    //                     "MMR (Max Marginal Relevance)"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_type",
    //                 "value": "Similarity",
    //                 "display_name": "Search Type",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Search type to use",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "setup_mode": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Sync",
    //                     "Async",
    //                     "Off"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "setup_mode",
    //                 "value": "Sync",
    //                 "display_name": "Setup Mode",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Configuration mode for setting up the Cassandra table, with options like 'Sync', 'Async', or 'Off'.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "table_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "table_name",
    //                 "value": "",
    //                 "display_name": "Table Name",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The name of the table (or AstraDB collection) where vectors will be stored.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "token": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "token",
    //                 "value": "",
    //                 "display_name": "Password / AstraDB Token",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "User password for the database (or AstraDB token).",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "ttl_seconds": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ttl_seconds",
    //                 "value": "",
    //                 "display_name": "TTL Seconds",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional time-to-live for the added texts.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "username": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "username",
    //                 "value": "",
    //                 "display_name": "Username",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Username for the database (leave empty for AstraDB).",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Cassandra Vector Store with search capabilities",
    //         "icon": "Cassandra",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "Cassandra",
    //         "documentation": "https://python.langchain.com/docs/modules/data_connection/vectorstores/integrations/cassandra",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "batch_size",
    //                     "body_search",
    //                     "cluster_kwargs",
    //                     "database_ref",
    //                     "embedding",
    //                     "enable_body_search",
    //                     "ingest_data",
    //                     "keyspace",
    //                     "number_of_results",
    //                     "search_filter",
    //                     "search_query",
    //                     "search_score_threshold",
    //                     "search_type",
    //                     "setup_mode",
    //                     "table_name",
    //                     "token",
    //                     "ttl_seconds",
    //                     "username"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "database_ref",
    //             "username",
    //             "token",
    //             "keyspace",
    //             "table_name",
    //             "ttl_seconds",
    //             "batch_size",
    //             "setup_mode",
    //             "cluster_kwargs",
    //             "search_query",
    //             "ingest_data",
    //             "embedding",
    //             "number_of_results",
    //             "search_type",
    //             "search_score_threshold",
    //             "search_filter",
    //             "body_search",
    //             "enable_body_search"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "VectaraRAG": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.custom import Component\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.io import DropdownInput, FloatInput, IntInput, MessageTextInput, Output, SecretStrInput, StrInput\nfrom langflow.schema.message import Message\n\n\nclass VectaraRagComponent(Component):\n    display_name = \"Vectara RAG\"\n    description = \"Vectara's full end to end RAG\"\n    documentation = \"https://docs.vectara.com/docs\"\n    icon = \"Vectara\"\n    name = \"VectaraRAG\"\n    SUMMARIZER_PROMPTS = [\n        \"vectara-summary-ext-24-05-sml\",\n        \"vectara-summary-ext-24-05-med-omni\",\n        \"vectara-summary-ext-24-05-large\",\n        \"vectara-summary-ext-24-05-med\",\n        \"vectara-summary-ext-v1.3.0\",\n    ]\n\n    RERANKER_TYPES = [\"mmr\", \"rerank_multilingual_v1\", \"none\"]\n\n    RESPONSE_LANGUAGES = [\n        \"auto\",\n        \"eng\",\n        \"spa\",\n        \"fra\",\n        \"zho\",\n        \"deu\",\n        \"hin\",\n        \"ara\",\n        \"por\",\n        \"ita\",\n        \"jpn\",\n        \"kor\",\n        \"rus\",\n        \"tur\",\n        \"fas\",\n        \"vie\",\n        \"tha\",\n        \"heb\",\n        \"nld\",\n        \"ind\",\n        \"pol\",\n        \"ukr\",\n        \"ron\",\n        \"swe\",\n        \"ces\",\n        \"ell\",\n        \"ben\",\n        \"msa\",\n        \"urd\",\n    ]\n\n    field_order = [\"vectara_customer_id\", \"vectara_corpus_id\", \"vectara_api_key\", \"search_query\", \"reranker\"]\n\n    inputs = [\n        StrInput(name=\"vectara_customer_id\", display_name=\"Vectara Customer ID\", required=True),\n        StrInput(name=\"vectara_corpus_id\", display_name=\"Vectara Corpus ID\", required=True),\n        SecretStrInput(name=\"vectara_api_key\", display_name=\"Vectara API Key\", required=True),\n        MessageTextInput(name=\"search_query\", display_name=\"Search Query\", info=\"The query to receive an answer on.\"),\n        FloatInput(\n            name=\"lexical_interpolation\",\n            display_name=\"Hybrid Search Factor\",\n            range_spec=RangeSpec(min=0.005, max=0.1, step=0.005),\n            value=0.005,\n            advanced=True,\n            info=\"How much to weigh lexical scores compared to the embedding score. \"\n            \"0 means lexical search is not used at all, and 1 means only lexical search is used.\",\n        ),\n        MessageTextInput(\n            name=\"filter\",\n            display_name=\"Metadata Filters\",\n            value=\"\",\n            advanced=True,\n            info=\"The filter string to narrow the search to according to metadata attributes.\",\n        ),\n        DropdownInput(\n            name=\"reranker\",\n            display_name=\"Reranker Type\",\n            options=RERANKER_TYPES,\n            value=RERANKER_TYPES[0],\n            info=\"How to rerank the retrieved search results.\",\n        ),\n        IntInput(\n            name=\"reranker_k\",\n            display_name=\"Number of Results to Rerank\",\n            value=50,\n            range_spec=RangeSpec(min=1, max=100, step=1),\n            advanced=True,\n        ),\n        FloatInput(\n            name=\"diversity_bias\",\n            display_name=\"Diversity Bias\",\n            value=0.2,\n            range_spec=RangeSpec(min=0, max=1, step=0.01),\n            advanced=True,\n            info=\"Ranges from 0 to 1, with higher values indicating greater diversity (only applies to MMR reranker).\",\n        ),\n        IntInput(\n            name=\"max_results\",\n            display_name=\"Max Results to Summarize\",\n            value=7,\n            range_spec=RangeSpec(min=1, max=100, step=1),\n            advanced=True,\n            info=\"The maximum number of search results to be available to the prompt.\",\n        ),\n        DropdownInput(\n            name=\"response_lang\",\n            display_name=\"Response Language\",\n            options=RESPONSE_LANGUAGES,\n            value=\"eng\",\n            advanced=True,\n            info=\"Use the ISO 639-1 or 639-3 language code or auto to automatically detect the language.\",\n        ),\n        DropdownInput(\n            name=\"prompt\",\n            display_name=\"Prompt Name\",\n            options=SUMMARIZER_PROMPTS,\n            value=SUMMARIZER_PROMPTS[0],\n            advanced=True,\n            info=\"Only vectara-summary-ext-24-05-sml is for Growth customers; \"\n            \"all other prompts are for Scale customers only.\",\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"answer\", display_name=\"Answer\", method=\"generate_response\"),\n    ]\n\n    def generate_response(\n        self,\n    ) -> Message:\n        text_output = \"\"\n\n        try:\n            from langchain_community.vectorstores import Vectara\n            from langchain_community.vectorstores.vectara import RerankConfig, SummaryConfig, VectaraQueryConfig\n        except ImportError as e:\n            msg = \"Could not import Vectara. Please install it with `pip install langchain-community`.\"\n            raise ImportError(msg) from e\n\n        vectara = Vectara(self.vectara_customer_id, self.vectara_corpus_id, self.vectara_api_key)\n        rerank_config = RerankConfig(self.reranker, self.reranker_k, self.diversity_bias)\n        summary_config = SummaryConfig(\n            is_enabled=True, max_results=self.max_results, response_lang=self.response_lang, prompt_name=self.prompt\n        )\n        config = VectaraQueryConfig(\n            lambda_val=self.lexical_interpolation,\n            filter=self.filter,\n            summary_config=summary_config,\n            rerank_config=rerank_config,\n        )\n        rag = vectara.as_rag(config)\n        response = rag.invoke(self.search_query, config={\"callbacks\": self.get_langchain_callbacks()})\n\n        text_output = response[\"answer\"]\n\n        return Message(text=text_output)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "diversity_bias": {
    //                 "trace_as_metadata": true,
    //                 "range_spec": {
    //                     "step_type": "float",
    //                     "min": 0.0,
    //                     "max": 1.0,
    //                     "step": 0.01
    //                 },
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "diversity_bias",
    //                 "value": 0.2,
    //                 "display_name": "Diversity Bias",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Ranges from 0 to 1, with higher values indicating greater diversity (only applies to MMR reranker).",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "filter": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "filter",
    //                 "value": "",
    //                 "display_name": "Metadata Filters",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The filter string to narrow the search to according to metadata attributes.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "lexical_interpolation": {
    //                 "trace_as_metadata": true,
    //                 "range_spec": {
    //                     "step_type": "float",
    //                     "min": 0.005,
    //                     "max": 0.1,
    //                     "step": 0.005
    //                 },
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "lexical_interpolation",
    //                 "value": 0.005,
    //                 "display_name": "Hybrid Search Factor",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "How much to weigh lexical scores compared to the embedding score. 0 means lexical search is not used at all, and 1 means only lexical search is used.",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "max_results": {
    //                 "trace_as_metadata": true,
    //                 "range_spec": {
    //                     "step_type": "float",
    //                     "min": 1.0,
    //                     "max": 100.0,
    //                     "step": 1.0
    //                 },
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_results",
    //                 "value": 7,
    //                 "display_name": "Max Results to Summarize",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The maximum number of search results to be available to the prompt.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "prompt": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "vectara-summary-ext-24-05-sml",
    //                     "vectara-summary-ext-24-05-med-omni",
    //                     "vectara-summary-ext-24-05-large",
    //                     "vectara-summary-ext-24-05-med",
    //                     "vectara-summary-ext-v1.3.0"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "prompt",
    //                 "value": "vectara-summary-ext-24-05-sml",
    //                 "display_name": "Prompt Name",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Only vectara-summary-ext-24-05-sml is for Growth customers; all other prompts are for Scale customers only.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "reranker": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "mmr",
    //                     "rerank_multilingual_v1",
    //                     "none"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "reranker",
    //                 "value": "mmr",
    //                 "display_name": "Reranker Type",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "How to rerank the retrieved search results.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "reranker_k": {
    //                 "trace_as_metadata": true,
    //                 "range_spec": {
    //                     "step_type": "float",
    //                     "min": 1.0,
    //                     "max": 100.0,
    //                     "step": 1.0
    //                 },
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "reranker_k",
    //                 "value": 50,
    //                 "display_name": "Number of Results to Rerank",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "response_lang": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "auto",
    //                     "eng",
    //                     "spa",
    //                     "fra",
    //                     "zho",
    //                     "deu",
    //                     "hin",
    //                     "ara",
    //                     "por",
    //                     "ita",
    //                     "jpn",
    //                     "kor",
    //                     "rus",
    //                     "tur",
    //                     "fas",
    //                     "vie",
    //                     "tha",
    //                     "heb",
    //                     "nld",
    //                     "ind",
    //                     "pol",
    //                     "ukr",
    //                     "ron",
    //                     "swe",
    //                     "ces",
    //                     "ell",
    //                     "ben",
    //                     "msa",
    //                     "urd"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "response_lang",
    //                 "value": "eng",
    //                 "display_name": "Response Language",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Use the ISO 639-1 or 639-3 language code or auto to automatically detect the language.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "search_query": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_query",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The query to receive an answer on.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "vectara_api_key": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "vectara_api_key",
    //                 "value": "",
    //                 "display_name": "Vectara API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "vectara_corpus_id": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "vectara_corpus_id",
    //                 "value": "",
    //                 "display_name": "Vectara Corpus ID",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "vectara_customer_id": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "vectara_customer_id",
    //                 "value": "",
    //                 "display_name": "Vectara Customer ID",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Vectara's full end to end RAG",
    //         "icon": "Vectara",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Vectara RAG",
    //         "documentation": "https://docs.vectara.com/docs",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "answer",
    //                 "display_name": "Answer",
    //                 "method": "generate_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "vectara_customer_id",
    //             "vectara_corpus_id",
    //             "vectara_api_key",
    //             "search_query",
    //             "lexical_interpolation",
    //             "filter",
    //             "reranker",
    //             "reranker_k",
    //             "diversity_bias",
    //             "max_results",
    //             "response_lang",
    //             "prompt"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "Elasticsearch": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingest Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "Elastic API Key",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "API Key for Elastic Cloud authentication. If used, 'username' and 'password' are not required.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "cloud_id": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "cloud_id",
    //                 "value": "",
    //                 "display_name": "Elastic Cloud ID",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Use this for Elastic Cloud deployments. Do not use together with 'Elasticsearch URL'.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom langchain.schema import Document\nfrom langchain_elasticsearch import ElasticsearchStore\nfrom loguru import logger\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.io import (\n    DataInput,\n    DropdownInput,\n    FloatInput,\n    HandleInput,\n    IntInput,\n    MultilineInput,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\n\n\nclass ElasticsearchVectorStoreComponent(LCVectorStoreComponent):\n    \"\"\"Elasticsearch Vector Store with with advanced, customizable search capabilities.\"\"\"\n\n    display_name: str = \"Elasticsearch\"\n    description: str = \"Elasticsearch Vector Store with with advanced, customizable search capabilities.\"\n    documentation = \"https://python.langchain.com/docs/integrations/vectorstores/elasticsearch\"\n    name = \"Elasticsearch\"\n    icon = \"ElasticsearchStore\"\n\n    inputs = [\n        StrInput(\n            name=\"elasticsearch_url\",\n            display_name=\"Elasticsearch URL\",\n            value=\"http://localhost:9200\",\n            info=\"URL for self-managed Elasticsearch deployments (e.g., http://localhost:9200). \"\n            \"Do not use with Elastic Cloud deployments, use Elastic Cloud ID instead.\",\n        ),\n        SecretStrInput(\n            name=\"cloud_id\",\n            display_name=\"Elastic Cloud ID\",\n            value=\"\",\n            info=\"Use this for Elastic Cloud deployments. Do not use together with 'Elasticsearch URL'.\",\n        ),\n        StrInput(\n            name=\"index_name\",\n            display_name=\"Index Name\",\n            value=\"langflow\",\n            info=\"The index name where the vectors will be stored in Elasticsearch cluster.\",\n        ),\n        MultilineInput(\n            name=\"search_input\",\n            display_name=\"Search Input\",\n            info=\"Enter a search query. Leave empty to retrieve all documents.\",\n        ),\n        StrInput(\n            name=\"username\",\n            display_name=\"Username\",\n            value=\"\",\n            advanced=False,\n            info=(\n                \"Elasticsearch username (e.g., 'elastic'). \"\n                \"Required for both local and Elastic Cloud setups unless API keys are used.\"\n            ),\n        ),\n        SecretStrInput(\n            name=\"password\",\n            display_name=\"Password\",\n            value=\"\",\n            advanced=False,\n            info=(\n                \"Elasticsearch password for the specified user. \"\n                \"Required for both local and Elastic Cloud setups unless API keys are used.\"\n            ),\n        ),\n        DataInput(\n            name=\"ingest_data\",\n            display_name=\"Ingest Data\",\n            is_list=True,\n        ),\n        HandleInput(\n            name=\"embedding\",\n            display_name=\"Embedding\",\n            input_types=[\"Embeddings\"],\n        ),\n        DropdownInput(\n            name=\"search_type\",\n            display_name=\"Search Type\",\n            options=[\"similarity\", \"mmr\"],\n            value=\"similarity\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            advanced=True,\n            value=4,\n        ),\n        FloatInput(\n            name=\"search_score_threshold\",\n            display_name=\"Search Score Threshold\",\n            info=\"Minimum similarity score threshold for search results.\",\n            value=0.0,\n            advanced=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Elastic API Key\",\n            value=\"\",\n            advanced=True,\n            info=\"API Key for Elastic Cloud authentication. If used, 'username' and 'password' are not required.\",\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> ElasticsearchStore:\n        \"\"\"Builds the Elasticsearch Vector Store object.\"\"\"\n        if self.cloud_id and self.elasticsearch_url:\n            msg = (\n                \"Both 'cloud_id' and 'elasticsearch_url' provided. \"\n                \"Please use only one based on your deployment (Cloud or Local).\"\n            )\n            raise ValueError(msg)\n\n        es_params = {\n            \"index_name\": self.index_name,\n            \"embedding\": self.embedding,\n            \"es_user\": self.username or None,\n            \"es_password\": self.password or None,\n        }\n\n        if self.cloud_id:\n            es_params[\"es_cloud_id\"] = self.cloud_id\n        else:\n            es_params[\"es_url\"] = self.elasticsearch_url\n\n        if self.api_key:\n            es_params[\"api_key\"] = self.api_key\n\n        elasticsearch = ElasticsearchStore(**es_params)\n\n        # If documents are provided, add them to the store\n        if self.ingest_data:\n            documents = self._prepare_documents()\n            if documents:\n                elasticsearch.add_documents(documents)\n\n        return elasticsearch\n\n    def _prepare_documents(self) -> list[Document]:\n        \"\"\"Prepares documents from the input data to add to the vector store.\"\"\"\n        documents = []\n        for data in self.ingest_data:\n            if isinstance(data, Data):\n                documents.append(data.to_lc_document())\n            else:\n                error_message = \"Vector Store Inputs must be Data objects.\"\n                logger.error(error_message)\n                raise TypeError(error_message)\n        return documents\n\n    def _add_documents_to_vector_store(self, vector_store: \"ElasticsearchStore\") -> None:\n        \"\"\"Adds documents to the Vector Store.\"\"\"\n        documents = self._prepare_documents()\n        if documents and self.embedding:\n            logger.debug(f\"Adding {len(documents)} documents to the Vector Store.\")\n            vector_store.add_documents(documents)\n        else:\n            logger.debug(\"No documents to add to the Vector Store.\")\n\n    def search(self, query: str | None = None) -> list[dict[str, Any]]:\n        \"\"\"Search for similar documents in the vector store or retrieve all documents if no query is provided.\"\"\"\n        vector_store = self.build_vector_store()\n        search_kwargs = {\n            \"k\": self.number_of_results,\n            \"score_threshold\": self.search_score_threshold,\n        }\n\n        if query:\n            search_type = self.search_type.lower()\n            if search_type not in {\"similarity\", \"mmr\"}:\n                msg = f\"Invalid search type: {self.search_type}\"\n                logger.error(msg)\n                raise ValueError(msg)\n            try:\n                if search_type == \"similarity\":\n                    results = vector_store.similarity_search_with_score(query, **search_kwargs)\n                elif search_type == \"mmr\":\n                    results = vector_store.max_marginal_relevance_search(query, **search_kwargs)\n            except Exception as e:\n                msg = (\n                    \"Error occurred while querying the Elasticsearch VectorStore,\"\n                    \" there is no Data into the VectorStore.\"\n                )\n                logger.exception(msg)\n                raise ValueError(msg) from e\n            return [\n                {\"page_content\": doc.page_content, \"metadata\": doc.metadata, \"score\": score} for doc, score in results\n            ]\n        results = self.get_all_documents(vector_store, **search_kwargs)\n        return [{\"page_content\": doc.page_content, \"metadata\": doc.metadata, \"score\": score} for doc, score in results]\n\n    def get_all_documents(self, vector_store: ElasticsearchStore, **kwargs) -> list[tuple[Document, float]]:\n        \"\"\"Retrieve all documents from the vector store.\"\"\"\n        client = vector_store.client\n        index_name = self.index_name\n\n        query = {\n            \"query\": {\"match_all\": {}},\n            \"size\": kwargs.get(\"k\", self.number_of_results),\n        }\n\n        response = client.search(index=index_name, body=query)\n\n        results = []\n        for hit in response[\"hits\"][\"hits\"]:\n            doc = Document(\n                page_content=hit[\"_source\"].get(\"text\", \"\"),\n                metadata=hit[\"_source\"].get(\"metadata\", {}),\n            )\n            score = hit[\"_score\"]\n            results.append((doc, score))\n\n        return results\n\n    def search_documents(self) -> list[Data]:\n        \"\"\"Search for documents in the vector store based on the search input.\n\n        If no search input is provided, retrieve all documents.\n        \"\"\"\n        results = self.search(self.search_input)\n        retrieved_data = [\n            Data(\n                text=result[\"page_content\"],\n                file_path=result[\"metadata\"].get(\"file_path\", \"\"),\n            )\n            for result in results\n        ]\n        self.status = retrieved_data\n        return retrieved_data\n\n    def get_retriever_kwargs(self):\n        \"\"\"Get the keyword arguments for the retriever.\"\"\"\n        return {\n            \"search_type\": self.search_type.lower(),\n            \"search_kwargs\": {\n                \"k\": self.number_of_results,\n                \"score_threshold\": self.search_score_threshold,\n            },\n        }\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "elasticsearch_url": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "elasticsearch_url",
    //                 "value": "http://localhost:9200",
    //                 "display_name": "Elasticsearch URL",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "URL for self-managed Elasticsearch deployments (e.g., http://localhost:9200). Do not use with Elastic Cloud deployments, use Elastic Cloud ID instead.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "index_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "index_name",
    //                 "value": "langflow",
    //                 "display_name": "Index Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The index name where the vectors will be stored in Elasticsearch cluster.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 4,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "password": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "password",
    //                 "value": "",
    //                 "display_name": "Password",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Elasticsearch password for the specified user. Required for both local and Elastic Cloud setups unless API keys are used.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "search_input": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_input",
    //                 "value": "",
    //                 "display_name": "Search Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Enter a search query. Leave empty to retrieve all documents.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "search_score_threshold": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_score_threshold",
    //                 "value": 0.0,
    //                 "display_name": "Search Score Threshold",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Minimum similarity score threshold for search results.",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "search_type": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "similarity",
    //                     "mmr"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_type",
    //                 "value": "similarity",
    //                 "display_name": "Search Type",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "username": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "username",
    //                 "value": "",
    //                 "display_name": "Username",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Elasticsearch username (e.g., 'elastic'). Required for both local and Elastic Cloud setups unless API keys are used.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Elasticsearch Vector Store with with advanced, customizable search capabilities.",
    //         "icon": "ElasticsearchStore",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "Elasticsearch",
    //         "documentation": "https://python.langchain.com/docs/integrations/vectorstores/elasticsearch",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_key",
    //                     "cloud_id",
    //                     "elasticsearch_url",
    //                     "embedding",
    //                     "index_name",
    //                     "ingest_data",
    //                     "number_of_results",
    //                     "password",
    //                     "search_input",
    //                     "search_score_threshold",
    //                     "search_type",
    //                     "username"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "elasticsearch_url",
    //             "cloud_id",
    //             "index_name",
    //             "search_input",
    //             "username",
    //             "password",
    //             "ingest_data",
    //             "embedding",
    //             "search_type",
    //             "number_of_results",
    //             "search_score_threshold",
    //             "api_key"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "CassandraGraph": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingest Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "cluster_kwargs": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "cluster_kwargs",
    //                 "value": {},
    //                 "display_name": "Cluster arguments",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional dictionary of additional keyword arguments for the Cassandra cluster.",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from uuid import UUID\n\nfrom langchain_community.graph_vectorstores import CassandraGraphVectorStore\nfrom loguru import logger\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.inputs import DictInput, FloatInput\nfrom langflow.io import (\n    DataInput,\n    DropdownInput,\n    HandleInput,\n    IntInput,\n    MessageTextInput,\n    MultilineInput,\n    SecretStrInput,\n)\nfrom langflow.schema import Data\n\n\nclass CassandraGraphVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"Cassandra Graph\"\n    description = \"Cassandra Graph Vector Store\"\n    documentation = \"https://python.langchain.com/v0.2/api_reference/community/graph_vectorstores.html\"\n    name = \"CassandraGraph\"\n    icon = \"Cassandra\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"database_ref\",\n            display_name=\"Contact Points / Astra Database ID\",\n            info=\"Contact points for the database (or AstraDB database ID)\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"username\", display_name=\"Username\", info=\"Username for the database (leave empty for AstraDB).\"\n        ),\n        SecretStrInput(\n            name=\"token\",\n            display_name=\"Password / AstraDB Token\",\n            info=\"User password for the database (or AstraDB token).\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"keyspace\",\n            display_name=\"Keyspace\",\n            info=\"Table Keyspace (or AstraDB namespace).\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"table_name\",\n            display_name=\"Table Name\",\n            info=\"The name of the table (or AstraDB collection) where vectors will be stored.\",\n            required=True,\n        ),\n        DropdownInput(\n            name=\"setup_mode\",\n            display_name=\"Setup Mode\",\n            info=\"Configuration mode for setting up the Cassandra table, with options like 'Sync' or 'Off'.\",\n            options=[\"Sync\", \"Off\"],\n            value=\"Sync\",\n            advanced=True,\n        ),\n        DictInput(\n            name=\"cluster_kwargs\",\n            display_name=\"Cluster arguments\",\n            info=\"Optional dictionary of additional keyword arguments for the Cassandra cluster.\",\n            advanced=True,\n            is_list=True,\n        ),\n        MultilineInput(name=\"search_query\", display_name=\"Search Query\"),\n        DataInput(\n            name=\"ingest_data\",\n            display_name=\"Ingest Data\",\n            is_list=True,\n        ),\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"search_type\",\n            display_name=\"Search Type\",\n            info=\"Search type to use\",\n            options=[\n                \"Traversal\",\n                \"MMR traversal\",\n                \"Similarity\",\n                \"Similarity with score threshold\",\n                \"MMR (Max Marginal Relevance)\",\n            ],\n            value=\"Traversal\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"depth\",\n            display_name=\"Depth of traversal\",\n            info=\"The maximum depth of edges to traverse. (when using 'Traversal' or 'MMR traversal')\",\n            value=1,\n            advanced=True,\n        ),\n        FloatInput(\n            name=\"search_score_threshold\",\n            display_name=\"Search Score Threshold\",\n            info=\"Minimum similarity score threshold for search results. \"\n            \"(when using 'Similarity with score threshold')\",\n            value=0,\n            advanced=True,\n        ),\n        DictInput(\n            name=\"search_filter\",\n            display_name=\"Search Metadata Filter\",\n            info=\"Optional dictionary of filters to apply to the search query.\",\n            advanced=True,\n            is_list=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> CassandraGraphVectorStore:\n        try:\n            import cassio\n            from langchain_community.utilities.cassandra import SetupMode\n        except ImportError as e:\n            msg = \"Could not import cassio integration package. Please install it with `pip install cassio`.\"\n            raise ImportError(msg) from e\n\n        database_ref = self.database_ref\n\n        try:\n            UUID(self.database_ref)\n            is_astra = True\n        except ValueError:\n            is_astra = False\n            if \",\" in self.database_ref:\n                # use a copy because we can't change the type of the parameter\n                database_ref = self.database_ref.split(\",\")\n\n        if is_astra:\n            cassio.init(\n                database_id=database_ref,\n                token=self.token,\n                cluster_kwargs=self.cluster_kwargs,\n            )\n        else:\n            cassio.init(\n                contact_points=database_ref,\n                username=self.username,\n                password=self.token,\n                cluster_kwargs=self.cluster_kwargs,\n            )\n        documents = []\n\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        setup_mode = SetupMode.OFF if self.setup_mode == \"Off\" else SetupMode.SYNC\n\n        if documents:\n            logger.debug(f\"Adding {len(documents)} documents to the Vector Store.\")\n            store = CassandraGraphVectorStore.from_documents(\n                documents=documents,\n                embedding=self.embedding,\n                node_table=self.table_name,\n                keyspace=self.keyspace,\n            )\n        else:\n            logger.debug(\"No documents to add to the Vector Store.\")\n            store = CassandraGraphVectorStore(\n                embedding=self.embedding,\n                node_table=self.table_name,\n                keyspace=self.keyspace,\n                setup_mode=setup_mode,\n            )\n        return store\n\n    def _map_search_type(self) -> str:\n        if self.search_type == \"Similarity\":\n            return \"similarity\"\n        if self.search_type == \"Similarity with score threshold\":\n            return \"similarity_score_threshold\"\n        if self.search_type == \"MMR (Max Marginal Relevance)\":\n            return \"mmr\"\n        if self.search_type == \"MMR Traversal\":\n            return \"mmr_traversal\"\n        return \"traversal\"\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        logger.debug(f\"Search input: {self.search_query}\")\n        logger.debug(f\"Search type: {self.search_type}\")\n        logger.debug(f\"Number of results: {self.number_of_results}\")\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            try:\n                search_type = self._map_search_type()\n                search_args = self._build_search_args()\n\n                logger.debug(f\"Search args: {search_args}\")\n\n                docs = vector_store.search(query=self.search_query, search_type=search_type, **search_args)\n            except KeyError as e:\n                if \"content\" in str(e):\n                    msg = (\n                        \"You should ingest data through Langflow (or LangChain) to query it in Langflow. \"\n                        \"Your collection does not contain a field name 'content'.\"\n                    )\n                    raise ValueError(msg) from e\n                raise\n\n            logger.debug(f\"Retrieved documents: {len(docs)}\")\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n\n    def _build_search_args(self):\n        args = {\n            \"k\": self.number_of_results,\n            \"score_threshold\": self.search_score_threshold,\n            \"depth\": self.depth,\n        }\n\n        if self.search_filter:\n            clean_filter = {k: v for k, v in self.search_filter.items() if k and v}\n            if len(clean_filter) > 0:\n                args[\"filter\"] = clean_filter\n        return args\n\n    def get_retriever_kwargs(self):\n        search_args = self._build_search_args()\n        return {\n            \"search_type\": self._map_search_type(),\n            \"search_kwargs\": search_args,\n        }\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "database_ref": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "database_ref",
    //                 "value": "",
    //                 "display_name": "Contact Points / Astra Database ID",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Contact points for the database (or AstraDB database ID)",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "depth": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "depth",
    //                 "value": 1,
    //                 "display_name": "Depth of traversal",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The maximum depth of edges to traverse. (when using 'Traversal' or 'MMR traversal')",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "keyspace": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "keyspace",
    //                 "value": "",
    //                 "display_name": "Keyspace",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Table Keyspace (or AstraDB namespace).",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 4,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "search_filter": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_filter",
    //                 "value": {},
    //                 "display_name": "Search Metadata Filter",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional dictionary of filters to apply to the search query.",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "search_query": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_query",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "search_score_threshold": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_score_threshold",
    //                 "value": 0.0,
    //                 "display_name": "Search Score Threshold",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Minimum similarity score threshold for search results. (when using 'Similarity with score threshold')",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "search_type": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Traversal",
    //                     "MMR traversal",
    //                     "Similarity",
    //                     "Similarity with score threshold",
    //                     "MMR (Max Marginal Relevance)"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_type",
    //                 "value": "Traversal",
    //                 "display_name": "Search Type",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Search type to use",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "setup_mode": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Sync",
    //                     "Off"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "setup_mode",
    //                 "value": "Sync",
    //                 "display_name": "Setup Mode",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Configuration mode for setting up the Cassandra table, with options like 'Sync' or 'Off'.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "table_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "table_name",
    //                 "value": "",
    //                 "display_name": "Table Name",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The name of the table (or AstraDB collection) where vectors will be stored.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "token": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "token",
    //                 "value": "",
    //                 "display_name": "Password / AstraDB Token",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "User password for the database (or AstraDB token).",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "username": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "username",
    //                 "value": "",
    //                 "display_name": "Username",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Username for the database (leave empty for AstraDB).",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Cassandra Graph Vector Store",
    //         "icon": "Cassandra",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "Cassandra Graph",
    //         "documentation": "https://python.langchain.com/v0.2/api_reference/community/graph_vectorstores.html",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "cluster_kwargs",
    //                     "database_ref",
    //                     "depth",
    //                     "embedding",
    //                     "ingest_data",
    //                     "keyspace",
    //                     "number_of_results",
    //                     "search_filter",
    //                     "search_query",
    //                     "search_score_threshold",
    //                     "search_type",
    //                     "setup_mode",
    //                     "table_name",
    //                     "token",
    //                     "username"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "database_ref",
    //             "username",
    //             "token",
    //             "keyspace",
    //             "table_name",
    //             "setup_mode",
    //             "cluster_kwargs",
    //             "search_query",
    //             "ingest_data",
    //             "embedding",
    //             "number_of_results",
    //             "search_type",
    //             "depth",
    //             "search_score_threshold",
    //             "search_filter"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "Milvus": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingest Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import (\n    BoolInput,\n    DataInput,\n    DictInput,\n    DropdownInput,\n    FloatInput,\n    HandleInput,\n    IntInput,\n    MultilineInput,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\n\n\nclass MilvusVectorStoreComponent(LCVectorStoreComponent):\n    \"\"\"Milvus vector store with search capabilities.\"\"\"\n\n    display_name: str = \"Milvus\"\n    description: str = \"Milvus vector store with search capabilities\"\n    documentation = \"https://python.langchain.com/docs/integrations/vectorstores/milvus\"\n    name = \"Milvus\"\n    icon = \"Milvus\"\n\n    inputs = [\n        StrInput(name=\"collection_name\", display_name=\"Collection Name\", value=\"langflow\"),\n        StrInput(name=\"collection_description\", display_name=\"Collection Description\", value=\"\"),\n        StrInput(\n            name=\"uri\",\n            display_name=\"Connection URI\",\n            value=\"http://localhost:19530\",\n        ),\n        SecretStrInput(\n            name=\"password\",\n            display_name=\"Connection Password\",\n            value=\"\",\n            info=\"Ignore this field if no password is required to make connection.\",\n        ),\n        DictInput(name=\"connection_args\", display_name=\"Other Connection Arguments\", advanced=True),\n        StrInput(name=\"primary_field\", display_name=\"Primary Field Name\", value=\"pk\"),\n        StrInput(name=\"text_field\", display_name=\"Text Field Name\", value=\"text\"),\n        StrInput(name=\"vector_field\", display_name=\"Vector Field Name\", value=\"vector\"),\n        DropdownInput(\n            name=\"consistency_level\",\n            display_name=\"Consistencey Level\",\n            options=[\"Bounded\", \"Session\", \"Strong\", \"Eventual\"],\n            value=\"Session\",\n            advanced=True,\n        ),\n        DictInput(name=\"index_params\", display_name=\"Index Parameters\", advanced=True),\n        DictInput(name=\"search_params\", display_name=\"Search Parameters\", advanced=True),\n        BoolInput(name=\"drop_old\", display_name=\"Drop Old Collection\", value=False, advanced=True),\n        FloatInput(name=\"timeout\", display_name=\"Timeout\", advanced=True),\n        MultilineInput(name=\"search_query\", display_name=\"Search Query\"),\n        DataInput(\n            name=\"ingest_data\",\n            display_name=\"Ingest Data\",\n            is_list=True,\n        ),\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self):\n        try:\n            from langchain_milvus.vectorstores import Milvus as LangchainMilvus\n        except ImportError as e:\n            msg = \"Could not import Milvus integration package. Please install it with `pip install langchain-milvus`.\"\n            raise ImportError(msg) from e\n        self.connection_args.update(uri=self.uri, token=self.password)\n        milvus_store = LangchainMilvus(\n            embedding_function=self.embedding,\n            collection_name=self.collection_name,\n            collection_description=self.collection_description,\n            connection_args=self.connection_args,\n            consistency_level=self.consistency_level,\n            index_params=self.index_params,\n            search_params=self.search_params,\n            drop_old=self.drop_old,\n            auto_id=True,\n            primary_field=self.primary_field,\n            text_field=self.text_field,\n            vector_field=self.vector_field,\n            timeout=self.timeout,\n        )\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        if documents:\n            milvus_store.add_documents(documents)\n\n        return milvus_store\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "collection_description": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "collection_description",
    //                 "value": "",
    //                 "display_name": "Collection Description",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "collection_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "collection_name",
    //                 "value": "langflow",
    //                 "display_name": "Collection Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "connection_args": {
    //                 "trace_as_input": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "connection_args",
    //                 "value": {},
    //                 "display_name": "Other Connection Arguments",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "consistency_level": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Bounded",
    //                     "Session",
    //                     "Strong",
    //                     "Eventual"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "consistency_level",
    //                 "value": "Session",
    //                 "display_name": "Consistencey Level",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "drop_old": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "drop_old",
    //                 "value": false,
    //                 "display_name": "Drop Old Collection",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "index_params": {
    //                 "trace_as_input": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "index_params",
    //                 "value": {},
    //                 "display_name": "Index Parameters",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 4,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "password": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "password",
    //                 "value": "",
    //                 "display_name": "Connection Password",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Ignore this field if no password is required to make connection.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "primary_field": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "primary_field",
    //                 "value": "pk",
    //                 "display_name": "Primary Field Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "search_params": {
    //                 "trace_as_input": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_params",
    //                 "value": {},
    //                 "display_name": "Search Parameters",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "search_query": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_query",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "text_field": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "text_field",
    //                 "value": "text",
    //                 "display_name": "Text Field Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "timeout": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "timeout",
    //                 "value": "",
    //                 "display_name": "Timeout",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "uri": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "uri",
    //                 "value": "http://localhost:19530",
    //                 "display_name": "Connection URI",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "vector_field": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "vector_field",
    //                 "value": "vector",
    //                 "display_name": "Vector Field Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Milvus vector store with search capabilities",
    //         "icon": "Milvus",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "Milvus",
    //         "documentation": "https://python.langchain.com/docs/integrations/vectorstores/milvus",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "collection_description",
    //                     "collection_name",
    //                     "connection_args",
    //                     "consistency_level",
    //                     "drop_old",
    //                     "embedding",
    //                     "index_params",
    //                     "ingest_data",
    //                     "number_of_results",
    //                     "password",
    //                     "primary_field",
    //                     "search_params",
    //                     "search_query",
    //                     "text_field",
    //                     "timeout",
    //                     "uri",
    //                     "vector_field"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "collection_name",
    //             "collection_description",
    //             "uri",
    //             "password",
    //             "connection_args",
    //             "primary_field",
    //             "text_field",
    //             "vector_field",
    //             "consistency_level",
    //             "index_params",
    //             "search_params",
    //             "drop_old",
    //             "timeout",
    //             "search_query",
    //             "ingest_data",
    //             "embedding",
    //             "number_of_results"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "Clickhouse": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingest Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_community.vectorstores import Clickhouse, ClickhouseSettings\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.inputs import BoolInput, FloatInput\nfrom langflow.io import (\n    DataInput,\n    DictInput,\n    DropdownInput,\n    HandleInput,\n    IntInput,\n    MultilineInput,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\n\n\nclass ClickhouseVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"Clickhouse\"\n    description = \"Clickhouse Vector Store with search capabilities\"\n    documentation = \"https://python.langchain.com/v0.2/docs/integrations/vectorstores/clickhouse/\"\n    name = \"Clickhouse\"\n    icon = \"Clickhouse\"\n\n    inputs = [\n        StrInput(name=\"host\", display_name=\"hostname\", required=True, value=\"localhost\"),\n        IntInput(name=\"port\", display_name=\"port\", required=True, value=8123),\n        StrInput(name=\"database\", display_name=\"database\", required=True),\n        StrInput(name=\"table\", display_name=\"Table name\", required=True),\n        StrInput(name=\"username\", display_name=\"The ClickHouse user name.\", required=True),\n        SecretStrInput(name=\"password\", display_name=\"The password for username.\", required=True),\n        DropdownInput(\n            name=\"index_type\",\n            display_name=\"index_type\",\n            options=[\"annoy\", \"vector_similarity\"],\n            info=\"Type of the index.\",\n            value=\"annoy\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"metric\",\n            display_name=\"metric\",\n            options=[\"angular\", \"euclidean\", \"manhattan\", \"hamming\", \"dot\"],\n            info=\"Metric to compute distance.\",\n            value=\"angular\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"secure\",\n            display_name=\"Use https/TLS. This overrides inferred values from the interface or port arguments.\",\n            value=False,\n            advanced=True,\n        ),\n        StrInput(name=\"index_param\", display_name=\"Param of the index\", value=\"'L2Distance',100\", advanced=True),\n        DictInput(name=\"index_query_params\", display_name=\"index query params\", advanced=True),\n        MultilineInput(name=\"search_query\", display_name=\"Search Query\"),\n        DataInput(name=\"ingest_data\", display_name=\"Ingest Data\", is_list=True),\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n        FloatInput(name=\"score_threshold\", display_name=\"Score threshold\", advanced=True),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> Clickhouse:\n        try:\n            import clickhouse_connect\n        except ImportError as e:\n            msg = (\n                \"Failed to import Clickhouse dependencies. \"\n                \"Install it using `pip install langflow[clickhouse-connect] --pre`\"\n            )\n            raise ImportError(msg) from e\n\n        try:\n            client = clickhouse_connect.get_client(host=self.host, username=self.username, password=self.password)\n            client.command(\"SELECT 1\")\n        except Exception as e:\n            msg = f\"Failed to connect to Clickhouse: {e}\"\n            raise ValueError(msg) from e\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        kwargs = {}\n        if self.index_param:\n            kwargs[\"index_param\"] = self.index_param.split(\",\")\n        if self.index_query_params:\n            kwargs[\"index_query_params\"] = self.index_query_params\n\n        settings = ClickhouseSettings(\n            table=self.table,\n            database=self.database,\n            host=self.host,\n            index_type=self.index_type,\n            metric=self.metric,\n            password=self.password,\n            port=self.port,\n            secure=self.secure,\n            username=self.username,\n            **kwargs,\n        )\n        if documents:\n            clickhouse_vs = Clickhouse.from_documents(documents=documents, embedding=self.embedding, config=settings)\n\n        else:\n            clickhouse_vs = Clickhouse(embedding=self.embedding, config=settings)\n\n        return clickhouse_vs\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            kwargs = {}\n            if self.score_threshold:\n                kwargs[\"score_threshold\"] = self.score_threshold\n\n            docs = vector_store.similarity_search(query=self.search_query, k=self.number_of_results, **kwargs)\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "database": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "database",
    //                 "value": "",
    //                 "display_name": "database",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "host": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "host",
    //                 "value": "localhost",
    //                 "display_name": "hostname",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "index_param": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "index_param",
    //                 "value": "'L2Distance',100",
    //                 "display_name": "Param of the index",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "index_query_params": {
    //                 "trace_as_input": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "index_query_params",
    //                 "value": {},
    //                 "display_name": "index query params",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "index_type": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "annoy",
    //                     "vector_similarity"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "index_type",
    //                 "value": "annoy",
    //                 "display_name": "index_type",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Type of the index.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "metric": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "angular",
    //                     "euclidean",
    //                     "manhattan",
    //                     "hamming",
    //                     "dot"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "metric",
    //                 "value": "angular",
    //                 "display_name": "metric",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Metric to compute distance.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 4,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "password": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "password",
    //                 "value": "",
    //                 "display_name": "The password for username.",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "port": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "port",
    //                 "value": 8123,
    //                 "display_name": "port",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "score_threshold": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "score_threshold",
    //                 "value": "",
    //                 "display_name": "Score threshold",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "search_query": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_query",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "secure": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "secure",
    //                 "value": false,
    //                 "display_name": "Use https/TLS. This overrides inferred values from the interface or port arguments.",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "table": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "table",
    //                 "value": "",
    //                 "display_name": "Table name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "username": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "username",
    //                 "value": "",
    //                 "display_name": "The ClickHouse user name.",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Clickhouse Vector Store with search capabilities",
    //         "icon": "Clickhouse",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "Clickhouse",
    //         "documentation": "https://python.langchain.com/v0.2/docs/integrations/vectorstores/clickhouse/",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "database",
    //                     "embedding",
    //                     "host",
    //                     "index_param",
    //                     "index_query_params",
    //                     "index_type",
    //                     "ingest_data",
    //                     "metric",
    //                     "number_of_results",
    //                     "password",
    //                     "port",
    //                     "score_threshold",
    //                     "search_query",
    //                     "secure",
    //                     "table",
    //                     "username"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "host",
    //             "port",
    //             "database",
    //             "table",
    //             "username",
    //             "password",
    //             "index_type",
    //             "metric",
    //             "secure",
    //             "index_param",
    //             "index_query_params",
    //             "search_query",
    //             "ingest_data",
    //             "embedding",
    //             "number_of_results",
    //             "score_threshold"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "Pinecone": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingest Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_pinecone import Pinecone\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import (\n    DataInput,\n    DropdownInput,\n    HandleInput,\n    IntInput,\n    MultilineInput,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\n\n\nclass PineconeVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"Pinecone\"\n    description = \"Pinecone Vector Store with search capabilities\"\n    documentation = \"https://python.langchain.com/v0.2/docs/integrations/vectorstores/pinecone/\"\n    name = \"Pinecone\"\n    icon = \"Pinecone\"\n\n    inputs = [\n        StrInput(name=\"index_name\", display_name=\"Index Name\", required=True),\n        StrInput(name=\"namespace\", display_name=\"Namespace\", info=\"Namespace for the index.\"),\n        DropdownInput(\n            name=\"distance_strategy\",\n            display_name=\"Distance Strategy\",\n            options=[\"Cosine\", \"Euclidean\", \"Dot Product\"],\n            value=\"Cosine\",\n            advanced=True,\n        ),\n        SecretStrInput(name=\"pinecone_api_key\", display_name=\"Pinecone API Key\", required=True),\n        StrInput(\n            name=\"text_key\",\n            display_name=\"Text Key\",\n            info=\"Key in the record to use as text.\",\n            value=\"text\",\n            advanced=True,\n        ),\n        MultilineInput(name=\"search_query\", display_name=\"Search Query\"),\n        DataInput(\n            name=\"ingest_data\",\n            display_name=\"Ingest Data\",\n            is_list=True,\n        ),\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> Pinecone:\n        from langchain_pinecone._utilities import DistanceStrategy\n        from langchain_pinecone.vectorstores import Pinecone\n\n        distance_strategy = self.distance_strategy.replace(\" \", \"_\").upper()\n        _distance_strategy = DistanceStrategy[distance_strategy]\n\n        pinecone = Pinecone(\n            index_name=self.index_name,\n            embedding=self.embedding,\n            text_key=self.text_key,\n            namespace=self.namespace,\n            distance_strategy=_distance_strategy,\n            pinecone_api_key=self.pinecone_api_key,\n        )\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        if documents:\n            pinecone.add_documents(documents)\n        return pinecone\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "distance_strategy": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Cosine",
    //                     "Euclidean",
    //                     "Dot Product"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "distance_strategy",
    //                 "value": "Cosine",
    //                 "display_name": "Distance Strategy",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "index_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "index_name",
    //                 "value": "",
    //                 "display_name": "Index Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "namespace": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "namespace",
    //                 "value": "",
    //                 "display_name": "Namespace",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Namespace for the index.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 4,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "pinecone_api_key": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "pinecone_api_key",
    //                 "value": "",
    //                 "display_name": "Pinecone API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "search_query": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_query",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "text_key": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "text_key",
    //                 "value": "text",
    //                 "display_name": "Text Key",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Key in the record to use as text.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Pinecone Vector Store with search capabilities",
    //         "icon": "Pinecone",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "Pinecone",
    //         "documentation": "https://python.langchain.com/v0.2/docs/integrations/vectorstores/pinecone/",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "distance_strategy",
    //                     "embedding",
    //                     "index_name",
    //                     "ingest_data",
    //                     "namespace",
    //                     "number_of_results",
    //                     "pinecone_api_key",
    //                     "search_query",
    //                     "text_key"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "index_name",
    //             "namespace",
    //             "distance_strategy",
    //             "pinecone_api_key",
    //             "text_key",
    //             "search_query",
    //             "ingest_data",
    //             "embedding",
    //             "number_of_results"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "OpenSearch": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingest Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import json\nfrom typing import Any\n\nfrom langchain_community.vectorstores import OpenSearchVectorSearch\nfrom loguru import logger\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.io import (\n    BoolInput,\n    DataInput,\n    DropdownInput,\n    FloatInput,\n    HandleInput,\n    IntInput,\n    MultilineInput,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\n\n\nclass OpenSearchVectorStoreComponent(LCVectorStoreComponent):\n    \"\"\"OpenSearch Vector Store with advanced, customizable search capabilities.\"\"\"\n\n    display_name: str = \"OpenSearch\"\n    description: str = \"OpenSearch Vector Store with advanced, customizable search capabilities.\"\n    documentation = \"https://python.langchain.com/docs/integrations/vectorstores/opensearch\"\n    name = \"OpenSearch\"\n    icon = \"OpenSearch\"\n\n    inputs = [\n        StrInput(\n            name=\"opensearch_url\",\n            display_name=\"OpenSearch URL\",\n            value=\"http://localhost:9200\",\n            info=\"URL for OpenSearch cluster (e.g. https://192.168.1.1:9200).\",\n        ),\n        StrInput(\n            name=\"index_name\",\n            display_name=\"Index Name\",\n            value=\"langflow\",\n            info=\"The index name where the vectors will be stored in OpenSearch cluster.\",\n        ),\n        MultilineInput(\n            name=\"search_input\",\n            display_name=\"Search Input\",\n            info=(\n                \"Enter a search query. Leave empty to retrieve all documents. \"\n                \"If you need a more advanced search consider using Hybrid Search Query instead.\"\n            ),\n            value=\"\",\n        ),\n        DataInput(\n            name=\"ingest_data\",\n            display_name=\"Ingest Data\",\n            is_list=True,\n        ),\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        DropdownInput(\n            name=\"search_type\",\n            display_name=\"Search Type\",\n            options=[\"similarity\", \"similarity_score_threshold\", \"mmr\"],\n            value=\"similarity\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            advanced=True,\n            value=4,\n        ),\n        FloatInput(\n            name=\"search_score_threshold\",\n            display_name=\"Search Score Threshold\",\n            info=\"Minimum similarity score threshold for search results.\",\n            value=0.0,\n            advanced=True,\n        ),\n        StrInput(\n            name=\"username\",\n            display_name=\"Username\",\n            value=\"admin\",\n            advanced=True,\n        ),\n        SecretStrInput(\n            name=\"password\",\n            display_name=\"Password\",\n            value=\"admin\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"use_ssl\",\n            display_name=\"Use SSL\",\n            value=True,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"verify_certs\",\n            display_name=\"Verify Certificates\",\n            value=False,\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"hybrid_search_query\",\n            display_name=\"Hybrid Search Query\",\n            value=\"\",\n            advanced=True,\n            info=(\n                \"Provide a custom hybrid search query in JSON format. This allows you to combine \"\n                \"vector similarity and keyword matching.\"\n            ),\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> OpenSearchVectorSearch:\n        \"\"\"Builds the OpenSearch Vector Store object.\"\"\"\n        try:\n            from langchain_community.vectorstores import OpenSearchVectorSearch\n        except ImportError as e:\n            error_message = f\"Failed to import required modules: {e}\"\n            logger.exception(error_message)\n            raise ImportError(error_message) from e\n\n        try:\n            opensearch = OpenSearchVectorSearch(\n                index_name=self.index_name,\n                embedding_function=self.embedding,\n                opensearch_url=self.opensearch_url,\n                http_auth=(self.username, self.password),\n                use_ssl=self.use_ssl,\n                verify_certs=self.verify_certs,\n                ssl_assert_hostname=False,\n                ssl_show_warn=False,\n            )\n        except Exception as e:\n            error_message = f\"Failed to create OpenSearchVectorSearch instance: {e}\"\n            logger.exception(error_message)\n            raise RuntimeError(error_message) from e\n\n        if self.ingest_data:\n            self._add_documents_to_vector_store(opensearch)\n\n        return opensearch\n\n    def _add_documents_to_vector_store(self, vector_store: \"OpenSearchVectorSearch\") -> None:\n        \"\"\"Adds documents to the Vector Store.\"\"\"\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                error_message = f\"Expected Data object, got {type(_input)}\"\n                logger.error(error_message)\n                raise TypeError(error_message)\n\n        if documents and self.embedding is not None:\n            logger.debug(f\"Adding {len(documents)} documents to the Vector Store.\")\n            try:\n                vector_store.add_documents(documents)\n            except Exception as e:\n                error_message = f\"Error adding documents to Vector Store: {e}\"\n                logger.exception(error_message)\n                raise RuntimeError(error_message) from e\n        else:\n            logger.debug(\"No documents to add to the Vector Store.\")\n\n    def search(self, query: str | None = None) -> list[dict[str, Any]]:\n        \"\"\"Search for similar documents in the vector store or retrieve all documents if no query is provided.\"\"\"\n        try:\n            vector_store = self.build_vector_store()\n\n            query = query or \"\"\n\n            if self.hybrid_search_query.strip():\n                try:\n                    hybrid_query = json.loads(self.hybrid_search_query)\n                except json.JSONDecodeError as e:\n                    error_message = f\"Invalid hybrid search query JSON: {e}\"\n                    logger.exception(error_message)\n                    raise ValueError(error_message) from e\n\n                results = vector_store.client.search(index=self.index_name, body=hybrid_query)\n\n                processed_results = []\n                for hit in results.get(\"hits\", {}).get(\"hits\", []):\n                    source = hit.get(\"_source\", {})\n                    text = source.get(\"text\", \"\")\n                    metadata = source.get(\"metadata\", {})\n\n                    if isinstance(text, dict):\n                        text = text.get(\"text\", \"\")\n\n                    processed_results.append(\n                        {\n                            \"page_content\": text,\n                            \"metadata\": metadata,\n                        }\n                    )\n                return processed_results\n\n            search_kwargs = {\"k\": self.number_of_results}\n            search_type = self.search_type.lower()\n\n            if search_type == \"similarity\":\n                results = vector_store.similarity_search(query, **search_kwargs)\n                return [{\"page_content\": doc.page_content, \"metadata\": doc.metadata} for doc in results]\n            if search_type == \"similarity_score_threshold\":\n                search_kwargs[\"score_threshold\"] = self.search_score_threshold\n                results = vector_store.similarity_search_with_relevance_scores(query, **search_kwargs)\n                return [\n                    {\n                        \"page_content\": doc.page_content,\n                        \"metadata\": doc.metadata,\n                        \"score\": score,\n                    }\n                    for doc, score in results\n                ]\n            if search_type == \"mmr\":\n                results = vector_store.max_marginal_relevance_search(query, **search_kwargs)\n                return [{\"page_content\": doc.page_content, \"metadata\": doc.metadata} for doc in results]\n\n        except Exception as e:\n            error_message = f\"Error during search: {e}\"\n            logger.exception(error_message)\n            raise RuntimeError(error_message) from e\n\n        error_message = f\"Error during search. Invalid search type: {self.search_type}\"\n        logger.error(error_message)\n        raise ValueError(error_message)\n\n    def search_documents(self) -> list[Data]:\n        \"\"\"Search for documents in the vector store based on the search input.\n\n        If no search input is provided, retrieve all documents.\n        \"\"\"\n        try:\n            query = self.search_input.strip() if self.search_input else None\n            results = self.search(query)\n            retrieved_data = [\n                Data(\n                    file_path=result[\"metadata\"].get(\"file_path\", \"\"),\n                    text=result[\"page_content\"],\n                )\n                for result in results\n            ]\n        except Exception as e:\n            error_message = f\"Error during document search: {e}\"\n            logger.exception(error_message)\n            raise RuntimeError(error_message) from e\n\n        self.status = retrieved_data\n        return retrieved_data\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "hybrid_search_query": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "hybrid_search_query",
    //                 "value": "",
    //                 "display_name": "Hybrid Search Query",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Provide a custom hybrid search query in JSON format. This allows you to combine vector similarity and keyword matching.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "index_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "index_name",
    //                 "value": "langflow",
    //                 "display_name": "Index Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The index name where the vectors will be stored in OpenSearch cluster.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 4,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "opensearch_url": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "opensearch_url",
    //                 "value": "http://localhost:9200",
    //                 "display_name": "OpenSearch URL",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "URL for OpenSearch cluster (e.g. https://192.168.1.1:9200).",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "password": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "password",
    //                 "value": "admin",
    //                 "display_name": "Password",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "search_input": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_input",
    //                 "value": "",
    //                 "display_name": "Search Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Enter a search query. Leave empty to retrieve all documents. If you need a more advanced search consider using Hybrid Search Query instead.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "search_score_threshold": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_score_threshold",
    //                 "value": 0.0,
    //                 "display_name": "Search Score Threshold",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Minimum similarity score threshold for search results.",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "search_type": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "similarity",
    //                     "similarity_score_threshold",
    //                     "mmr"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_type",
    //                 "value": "similarity",
    //                 "display_name": "Search Type",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "use_ssl": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "use_ssl",
    //                 "value": true,
    //                 "display_name": "Use SSL",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "username": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "username",
    //                 "value": "admin",
    //                 "display_name": "Username",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "verify_certs": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "verify_certs",
    //                 "value": false,
    //                 "display_name": "Verify Certificates",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "OpenSearch Vector Store with advanced, customizable search capabilities.",
    //         "icon": "OpenSearch",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "OpenSearch",
    //         "documentation": "https://python.langchain.com/docs/integrations/vectorstores/opensearch",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "embedding",
    //                     "hybrid_search_query",
    //                     "index_name",
    //                     "ingest_data",
    //                     "number_of_results",
    //                     "opensearch_url",
    //                     "password",
    //                     "search_input",
    //                     "search_score_threshold",
    //                     "search_type",
    //                     "use_ssl",
    //                     "username",
    //                     "verify_certs"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "opensearch_url",
    //             "index_name",
    //             "search_input",
    //             "ingest_data",
    //             "embedding",
    //             "search_type",
    //             "number_of_results",
    //             "search_score_threshold",
    //             "username",
    //             "password",
    //             "use_ssl",
    //             "verify_certs",
    //             "hybrid_search_query"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "SupabaseVectorStore": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingest Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_community.vectorstores import SupabaseVectorStore\nfrom supabase.client import Client, create_client\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import DataInput, HandleInput, IntInput, MultilineInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass SupabaseVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"Supabase\"\n    description = \"Supabase Vector Store with search capabilities\"\n    documentation = \"https://python.langchain.com/v0.2/docs/integrations/vectorstores/supabase/\"\n    name = \"SupabaseVectorStore\"\n    icon = \"Supabase\"\n\n    inputs = [\n        StrInput(name=\"supabase_url\", display_name=\"Supabase URL\", required=True),\n        SecretStrInput(name=\"supabase_service_key\", display_name=\"Supabase Service Key\", required=True),\n        StrInput(name=\"table_name\", display_name=\"Table Name\", advanced=True),\n        StrInput(name=\"query_name\", display_name=\"Query Name\"),\n        MultilineInput(name=\"search_query\", display_name=\"Search Query\"),\n        DataInput(\n            name=\"ingest_data\",\n            display_name=\"Ingest Data\",\n            is_list=True,\n        ),\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> SupabaseVectorStore:\n        supabase: Client = create_client(self.supabase_url, supabase_key=self.supabase_service_key)\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        if documents:\n            supabase_vs = SupabaseVectorStore.from_documents(\n                documents=documents,\n                embedding=self.embedding,\n                query_name=self.query_name,\n                client=supabase,\n                table_name=self.table_name,\n            )\n        else:\n            supabase_vs = SupabaseVectorStore(\n                client=supabase,\n                embedding=self.embedding,\n                table_name=self.table_name,\n                query_name=self.query_name,\n            )\n\n        return supabase_vs\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 4,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "query_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "query_name",
    //                 "value": "",
    //                 "display_name": "Query Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "search_query": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_query",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "supabase_service_key": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "supabase_service_key",
    //                 "value": "",
    //                 "display_name": "Supabase Service Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "supabase_url": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "supabase_url",
    //                 "value": "",
    //                 "display_name": "Supabase URL",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "table_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "table_name",
    //                 "value": "",
    //                 "display_name": "Table Name",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Supabase Vector Store with search capabilities",
    //         "icon": "Supabase",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "Supabase",
    //         "documentation": "https://python.langchain.com/v0.2/docs/integrations/vectorstores/supabase/",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "embedding",
    //                     "ingest_data",
    //                     "number_of_results",
    //                     "query_name",
    //                     "search_query",
    //                     "supabase_service_key",
    //                     "supabase_url",
    //                     "table_name"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "supabase_url",
    //             "supabase_service_key",
    //             "table_name",
    //             "query_name",
    //             "search_query",
    //             "ingest_data",
    //             "embedding",
    //             "number_of_results"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "QdrantVectorStoreComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingest Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "API Key",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain.embeddings.base import Embeddings\nfrom langchain_community.vectorstores import Qdrant\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import (\n    DataInput,\n    DropdownInput,\n    HandleInput,\n    IntInput,\n    MultilineInput,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\n\n\nclass QdrantVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"Qdrant\"\n    description = \"Qdrant Vector Store with search capabilities\"\n    documentation = \"https://python.langchain.com/docs/modules/data_connection/vectorstores/integrations/qdrant\"\n    icon = \"Qdrant\"\n\n    inputs = [\n        StrInput(name=\"collection_name\", display_name=\"Collection Name\", required=True),\n        StrInput(name=\"host\", display_name=\"Host\", value=\"localhost\", advanced=True),\n        IntInput(name=\"port\", display_name=\"Port\", value=6333, advanced=True),\n        IntInput(name=\"grpc_port\", display_name=\"gRPC Port\", value=6334, advanced=True),\n        SecretStrInput(name=\"api_key\", display_name=\"API Key\", advanced=True),\n        StrInput(name=\"prefix\", display_name=\"Prefix\", advanced=True),\n        IntInput(name=\"timeout\", display_name=\"Timeout\", advanced=True),\n        StrInput(name=\"path\", display_name=\"Path\", advanced=True),\n        StrInput(name=\"url\", display_name=\"URL\", advanced=True),\n        DropdownInput(\n            name=\"distance_func\",\n            display_name=\"Distance Function\",\n            options=[\"Cosine\", \"Euclidean\", \"Dot Product\"],\n            value=\"Cosine\",\n            advanced=True,\n        ),\n        StrInput(name=\"content_payload_key\", display_name=\"Content Payload Key\", value=\"page_content\", advanced=True),\n        StrInput(name=\"metadata_payload_key\", display_name=\"Metadata Payload Key\", value=\"metadata\", advanced=True),\n        MultilineInput(name=\"search_query\", display_name=\"Search Query\"),\n        DataInput(\n            name=\"ingest_data\",\n            display_name=\"Ingest Data\",\n            is_list=True,\n        ),\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> Qdrant:\n        qdrant_kwargs = {\n            \"collection_name\": self.collection_name,\n            \"content_payload_key\": self.content_payload_key,\n            \"metadata_payload_key\": self.metadata_payload_key,\n        }\n\n        server_kwargs = {\n            \"host\": self.host or None,\n            \"port\": int(self.port),  # Ensure port is an integer\n            \"grpc_port\": int(self.grpc_port),  # Ensure grpc_port is an integer\n            \"api_key\": self.api_key,\n            \"prefix\": self.prefix,\n            # Ensure timeout is an integer\n            \"timeout\": int(self.timeout) if self.timeout else None,\n            \"path\": self.path or None,\n            \"url\": self.url or None,\n        }\n\n        server_kwargs = {k: v for k, v in server_kwargs.items() if v is not None}\n        documents = []\n\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        if not isinstance(self.embedding, Embeddings):\n            msg = \"Invalid embedding object\"\n            raise TypeError(msg)\n\n        if documents:\n            qdrant = Qdrant.from_documents(documents, embedding=self.embedding, **qdrant_kwargs, **server_kwargs)\n        else:\n            from qdrant_client import QdrantClient\n\n            client = QdrantClient(**server_kwargs)\n            qdrant = Qdrant(embeddings=self.embedding, client=client, **qdrant_kwargs)\n\n        return qdrant\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "collection_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "collection_name",
    //                 "value": "",
    //                 "display_name": "Collection Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "content_payload_key": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "content_payload_key",
    //                 "value": "page_content",
    //                 "display_name": "Content Payload Key",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "distance_func": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Cosine",
    //                     "Euclidean",
    //                     "Dot Product"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "distance_func",
    //                 "value": "Cosine",
    //                 "display_name": "Distance Function",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "grpc_port": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "grpc_port",
    //                 "value": 6334,
    //                 "display_name": "gRPC Port",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "host": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "host",
    //                 "value": "localhost",
    //                 "display_name": "Host",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "metadata_payload_key": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "metadata_payload_key",
    //                 "value": "metadata",
    //                 "display_name": "Metadata Payload Key",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 4,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "path": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "path",
    //                 "value": "",
    //                 "display_name": "Path",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "port": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "port",
    //                 "value": 6333,
    //                 "display_name": "Port",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "prefix": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "prefix",
    //                 "value": "",
    //                 "display_name": "Prefix",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "search_query": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_query",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "timeout": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "timeout",
    //                 "value": "",
    //                 "display_name": "Timeout",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "url": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "url",
    //                 "value": "",
    //                 "display_name": "URL",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Qdrant Vector Store with search capabilities",
    //         "icon": "Qdrant",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "Qdrant",
    //         "documentation": "https://python.langchain.com/docs/modules/data_connection/vectorstores/integrations/qdrant",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_key",
    //                     "collection_name",
    //                     "content_payload_key",
    //                     "embedding",
    //                     "grpc_port",
    //                     "host",
    //                     "ingest_data",
    //                     "metadata_payload_key",
    //                     "number_of_results",
    //                     "path",
    //                     "port",
    //                     "prefix",
    //                     "search_query",
    //                     "timeout",
    //                     "url"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "collection_name",
    //             "host",
    //             "port",
    //             "grpc_port",
    //             "api_key",
    //             "prefix",
    //             "timeout",
    //             "path",
    //             "url",
    //             "distance_func",
    //             "content_payload_key",
    //             "metadata_payload_key",
    //             "search_query",
    //             "ingest_data",
    //             "embedding",
    //             "number_of_results"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AstraDB": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Allows an embedding model configuration.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingest Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "api_endpoint": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_endpoint",
    //                 "value": "ASTRA_DB_API_ENDPOINT",
    //                 "display_name": "API Endpoint",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "API endpoint URL for the Astra DB service.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "batch_size": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "batch_size",
    //                 "value": "",
    //                 "display_name": "Batch Size",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional number of data to process in a single batch.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "bulk_delete_concurrency": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "bulk_delete_concurrency",
    //                 "value": "",
    //                 "display_name": "Bulk Delete Concurrency",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional concurrency level for bulk delete operations.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "bulk_insert_batch_concurrency": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "bulk_insert_batch_concurrency",
    //                 "value": "",
    //                 "display_name": "Bulk Insert Batch Concurrency",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional concurrency level for bulk insert operations.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "bulk_insert_overwrite_concurrency": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "bulk_insert_overwrite_concurrency",
    //                 "value": "",
    //                 "display_name": "Bulk Insert Overwrite Concurrency",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional concurrency level for bulk insert operations that overwrite existing data.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import os\n\nfrom astrapy.admin import parse_api_endpoint\nfrom loguru import logger\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers import docs_to_data\nfrom langflow.inputs import DictInput, FloatInput, MessageTextInput\nfrom langflow.io import (\n    BoolInput,\n    DataInput,\n    DropdownInput,\n    HandleInput,\n    IntInput,\n    MultilineInput,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\n\n\nclass AstraVectorStoreComponent(LCVectorStoreComponent):\n    display_name: str = \"Astra DB\"\n    description: str = \"Implementation of Vector Store using Astra DB with search capabilities\"\n    documentation: str = \"https://docs.langflow.org/starter-projects-vector-store-rag\"\n    name = \"AstraDB\"\n    icon: str = \"AstraDB\"\n\n    VECTORIZE_PROVIDERS_MAPPING = {\n        \"Azure OpenAI\": [\"azureOpenAI\", [\"text-embedding-3-small\", \"text-embedding-3-large\", \"text-embedding-ada-002\"]],\n        \"Hugging Face - Dedicated\": [\"huggingfaceDedicated\", [\"endpoint-defined-model\"]],\n        \"Hugging Face - Serverless\": [\n            \"huggingface\",\n            [\n                \"sentence-transformers/all-MiniLM-L6-v2\",\n                \"intfloat/multilingual-e5-large\",\n                \"intfloat/multilingual-e5-large-instruct\",\n                \"BAAI/bge-small-en-v1.5\",\n                \"BAAI/bge-base-en-v1.5\",\n                \"BAAI/bge-large-en-v1.5\",\n            ],\n        ],\n        \"Jina AI\": [\n            \"jinaAI\",\n            [\n                \"jina-embeddings-v2-base-en\",\n                \"jina-embeddings-v2-base-de\",\n                \"jina-embeddings-v2-base-es\",\n                \"jina-embeddings-v2-base-code\",\n                \"jina-embeddings-v2-base-zh\",\n            ],\n        ],\n        \"Mistral AI\": [\"mistral\", [\"mistral-embed\"]],\n        \"NVIDIA\": [\"nvidia\", [\"NV-Embed-QA\"]],\n        \"OpenAI\": [\"openai\", [\"text-embedding-3-small\", \"text-embedding-3-large\", \"text-embedding-ada-002\"]],\n        \"Upstage\": [\"upstageAI\", [\"solar-embedding-1-large\"]],\n        \"Voyage AI\": [\n            \"voyageAI\",\n            [\"voyage-large-2-instruct\", \"voyage-law-2\", \"voyage-code-2\", \"voyage-large-2\", \"voyage-2\"],\n        ],\n    }\n\n    inputs = [\n        SecretStrInput(\n            name=\"token\",\n            display_name=\"Astra DB Application Token\",\n            info=\"Authentication token for accessing Astra DB.\",\n            value=\"ASTRA_DB_APPLICATION_TOKEN\",\n            required=True,\n            advanced=os.getenv(\"ASTRA_ENHANCED\", \"false\").lower() == \"true\",\n        ),\n        SecretStrInput(\n            name=\"api_endpoint\",\n            display_name=\"Database\" if os.getenv(\"ASTRA_ENHANCED\", \"false\").lower() == \"true\" else \"API Endpoint\",\n            info=\"API endpoint URL for the Astra DB service.\",\n            value=\"ASTRA_DB_API_ENDPOINT\",\n            required=True,\n        ),\n        StrInput(\n            name=\"collection_name\",\n            display_name=\"Collection Name\",\n            info=\"The name of the collection within Astra DB where the vectors will be stored.\",\n            required=True,\n        ),\n        MultilineInput(\n            name=\"search_input\",\n            display_name=\"Search Input\",\n        ),\n        DataInput(\n            name=\"ingest_data\",\n            display_name=\"Ingest Data\",\n            is_list=True,\n        ),\n        StrInput(\n            name=\"namespace\",\n            display_name=\"Namespace\",\n            info=\"Optional namespace within Astra DB to use for the collection.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"embedding_service\",\n            display_name=\"Embedding Model or Astra Vectorize\",\n            info=\"Determines whether to use Astra Vectorize for the collection.\",\n            options=[\"Embedding Model\", \"Astra Vectorize\"],\n            real_time_refresh=True,\n            value=\"Embedding Model\",\n        ),\n        HandleInput(\n            name=\"embedding\",\n            display_name=\"Embedding Model\",\n            input_types=[\"Embeddings\"],\n            info=\"Allows an embedding model configuration.\",\n        ),\n        DropdownInput(\n            name=\"metric\",\n            display_name=\"Metric\",\n            info=\"Optional distance metric for vector comparisons in the vector store.\",\n            options=[\"cosine\", \"dot_product\", \"euclidean\"],\n            advanced=True,\n        ),\n        IntInput(\n            name=\"batch_size\",\n            display_name=\"Batch Size\",\n            info=\"Optional number of data to process in a single batch.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"bulk_insert_batch_concurrency\",\n            display_name=\"Bulk Insert Batch Concurrency\",\n            info=\"Optional concurrency level for bulk insert operations.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"bulk_insert_overwrite_concurrency\",\n            display_name=\"Bulk Insert Overwrite Concurrency\",\n            info=\"Optional concurrency level for bulk insert operations that overwrite existing data.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"bulk_delete_concurrency\",\n            display_name=\"Bulk Delete Concurrency\",\n            info=\"Optional concurrency level for bulk delete operations.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"setup_mode\",\n            display_name=\"Setup Mode\",\n            info=\"Configuration mode for setting up the vector store, with options like 'Sync', 'Async', or 'Off'.\",\n            options=[\"Sync\", \"Async\", \"Off\"],\n            advanced=True,\n            value=\"Sync\",\n        ),\n        BoolInput(\n            name=\"pre_delete_collection\",\n            display_name=\"Pre Delete Collection\",\n            info=\"Boolean flag to determine whether to delete the collection before creating a new one.\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"metadata_indexing_include\",\n            display_name=\"Metadata Indexing Include\",\n            info=\"Optional list of metadata fields to include in the indexing.\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"metadata_indexing_exclude\",\n            display_name=\"Metadata Indexing Exclude\",\n            info=\"Optional list of metadata fields to exclude from the indexing.\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"collection_indexing_policy\",\n            display_name=\"Collection Indexing Policy\",\n            info=\"Optional dictionary defining the indexing policy for the collection.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            advanced=True,\n            value=4,\n        ),\n        DropdownInput(\n            name=\"search_type\",\n            display_name=\"Search Type\",\n            info=\"Search type to use\",\n            options=[\"Similarity\", \"Similarity with score threshold\", \"MMR (Max Marginal Relevance)\"],\n            value=\"Similarity\",\n            advanced=True,\n        ),\n        FloatInput(\n            name=\"search_score_threshold\",\n            display_name=\"Search Score Threshold\",\n            info=\"Minimum similarity score threshold for search results. \"\n            \"(when using 'Similarity with score threshold')\",\n            value=0,\n            advanced=True,\n        ),\n        DictInput(\n            name=\"search_filter\",\n            display_name=\"Search Metadata Filter\",\n            info=\"Optional dictionary of filters to apply to the search query.\",\n            advanced=True,\n            is_list=True,\n        ),\n    ]\n\n    def insert_in_dict(self, build_config, field_name, new_parameters):\n        # Insert the new key-value pair after the found key\n        for new_field_name, new_parameter in new_parameters.items():\n            # Get all the items as a list of tuples (key, value)\n            items = list(build_config.items())\n\n            # Find the index of the key to insert after\n            idx = len(items)\n            for i, (key, _value) in enumerate(items):\n                if key == field_name:\n                    idx = i + 1\n                    break\n\n            items.insert(idx, (new_field_name, new_parameter))\n\n            # Clear the original dictionary and update with the modified items\n            build_config.clear()\n            build_config.update(items)\n\n        return build_config\n\n    def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None):\n        if field_name == \"embedding_service\":\n            if field_value == \"Astra Vectorize\":\n                for field in [\"embedding\"]:\n                    if field in build_config:\n                        del build_config[field]\n\n                new_parameter = DropdownInput(\n                    name=\"provider\",\n                    display_name=\"Vectorize Provider\",\n                    options=self.VECTORIZE_PROVIDERS_MAPPING.keys(),\n                    value=\"\",\n                    required=True,\n                    real_time_refresh=True,\n                ).to_dict()\n\n                self.insert_in_dict(build_config, \"embedding_service\", {\"provider\": new_parameter})\n            else:\n                for field in [\n                    \"provider\",\n                    \"z_00_model_name\",\n                    \"z_01_model_parameters\",\n                    \"z_02_api_key_name\",\n                    \"z_03_provider_api_key\",\n                    \"z_04_authentication\",\n                ]:\n                    if field in build_config:\n                        del build_config[field]\n\n                new_parameter = HandleInput(\n                    name=\"embedding\",\n                    display_name=\"Embedding Model\",\n                    input_types=[\"Embeddings\"],\n                    info=\"Allows an embedding model configuration.\",\n                ).to_dict()\n\n                self.insert_in_dict(build_config, \"embedding_service\", {\"embedding\": new_parameter})\n\n        elif field_name == \"provider\":\n            for field in [\n                \"z_00_model_name\",\n                \"z_01_model_parameters\",\n                \"z_02_api_key_name\",\n                \"z_03_provider_api_key\",\n                \"z_04_authentication\",\n            ]:\n                if field in build_config:\n                    del build_config[field]\n\n            model_options = self.VECTORIZE_PROVIDERS_MAPPING[field_value][1]\n\n            new_parameter_0 = DropdownInput(\n                name=\"z_00_model_name\",\n                display_name=\"Model Name\",\n                info=\"The embedding model to use for the selected provider. Each provider has a different set of \"\n                \"models available (full list at \"\n                \"https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html):\\n\\n\"\n                f\"{', '.join(model_options)}\",\n                options=model_options,\n                required=True,\n            ).to_dict()\n\n            new_parameter_1 = DictInput(\n                name=\"z_01_model_parameters\",\n                display_name=\"Model Parameters\",\n                is_list=True,\n            ).to_dict()\n\n            new_parameter_2 = MessageTextInput(\n                name=\"z_02_api_key_name\",\n                display_name=\"API Key name\",\n                info=\"The name of the embeddings provider API key stored on Astra. \"\n                \"If set, it will override the 'ProviderKey' in the authentication parameters.\",\n            ).to_dict()\n\n            new_parameter_3 = SecretStrInput(\n                name=\"z_03_provider_api_key\",\n                display_name=\"Provider API Key\",\n                info=\"An alternative to the Astra Authentication that passes an API key for the provider \"\n                \"with each request to Astra DB. \"\n                \"This may be used when Vectorize is configured for the collection, \"\n                \"but no corresponding provider secret is stored within Astra's key management system.\",\n            ).to_dict()\n\n            new_parameter_4 = DictInput(\n                name=\"z_04_authentication\",\n                display_name=\"Authentication parameters\",\n                is_list=True,\n            ).to_dict()\n\n            self.insert_in_dict(\n                build_config,\n                \"provider\",\n                {\n                    \"z_00_model_name\": new_parameter_0,\n                    \"z_01_model_parameters\": new_parameter_1,\n                    \"z_02_api_key_name\": new_parameter_2,\n                    \"z_03_provider_api_key\": new_parameter_3,\n                    \"z_04_authentication\": new_parameter_4,\n                },\n            )\n\n        return build_config\n\n    def build_vectorize_options(self, **kwargs):\n        for attribute in [\n            \"provider\",\n            \"z_00_model_name\",\n            \"z_01_model_parameters\",\n            \"z_02_api_key_name\",\n            \"z_03_provider_api_key\",\n            \"z_04_authentication\",\n        ]:\n            if not hasattr(self, attribute):\n                setattr(self, attribute, None)\n\n        # Fetch values from kwargs if any self.* attributes are None\n        provider_value = self.VECTORIZE_PROVIDERS_MAPPING.get(self.provider, [None])[0] or kwargs.get(\"provider\")\n        authentication = {**(self.z_04_authentication or kwargs.get(\"z_04_authentication\", {}))}\n\n        api_key_name = self.z_02_api_key_name or kwargs.get(\"z_02_api_key_name\")\n        provider_key = self.z_03_provider_api_key or kwargs.get(\"z_03_provider_api_key\")\n        if api_key_name:\n            authentication[\"providerKey\"] = api_key_name\n\n        return {\n            # must match astrapy.info.CollectionVectorServiceOptions\n            \"collection_vector_service_options\": {\n                \"provider\": provider_value,\n                \"modelName\": self.z_00_model_name or kwargs.get(\"z_00_model_name\"),\n                \"authentication\": authentication,\n                \"parameters\": self.z_01_model_parameters or kwargs.get(\"z_01_model_parameters\", {}),\n            },\n            \"collection_embedding_api_key\": provider_key,\n        }\n\n    @check_cached_vector_store\n    def build_vector_store(self, vectorize_options=None):\n        try:\n            from langchain_astradb import AstraDBVectorStore\n            from langchain_astradb.utils.astradb import SetupMode\n        except ImportError as e:\n            msg = (\n                \"Could not import langchain Astra DB integration package. \"\n                \"Please install it with `pip install langchain-astradb`.\"\n            )\n            raise ImportError(msg) from e\n\n        try:\n            if not self.setup_mode:\n                self.setup_mode = self._inputs[\"setup_mode\"].options[0]\n\n            setup_mode_value = SetupMode[self.setup_mode.upper()]\n        except KeyError as e:\n            msg = f\"Invalid setup mode: {self.setup_mode}\"\n            raise ValueError(msg) from e\n\n        if self.embedding:\n            embedding_dict = {\"embedding\": self.embedding}\n        else:\n            from astrapy.info import CollectionVectorServiceOptions\n\n            dict_options = vectorize_options or self.build_vectorize_options()\n            dict_options[\"authentication\"] = {\n                k: v for k, v in dict_options.get(\"authentication\", {}).items() if k and v\n            }\n            dict_options[\"parameters\"] = {k: v for k, v in dict_options.get(\"parameters\", {}).items() if k and v}\n\n            embedding_dict = {\n                \"collection_vector_service_options\": CollectionVectorServiceOptions.from_dict(\n                    dict_options.get(\"collection_vector_service_options\", {})\n                ),\n            }\n\n        vector_store_kwargs = {\n            **embedding_dict,\n            \"collection_name\": self.collection_name,\n            \"token\": self.token,\n            \"api_endpoint\": self.api_endpoint,\n            \"namespace\": self.namespace or None,\n            \"environment\": parse_api_endpoint(self.api_endpoint).environment,\n            \"metric\": self.metric or None,\n            \"batch_size\": self.batch_size or None,\n            \"bulk_insert_batch_concurrency\": self.bulk_insert_batch_concurrency or None,\n            \"bulk_insert_overwrite_concurrency\": self.bulk_insert_overwrite_concurrency or None,\n            \"bulk_delete_concurrency\": self.bulk_delete_concurrency or None,\n            \"setup_mode\": setup_mode_value,\n            \"pre_delete_collection\": self.pre_delete_collection or False,\n        }\n\n        if self.metadata_indexing_include:\n            vector_store_kwargs[\"metadata_indexing_include\"] = self.metadata_indexing_include\n        elif self.metadata_indexing_exclude:\n            vector_store_kwargs[\"metadata_indexing_exclude\"] = self.metadata_indexing_exclude\n        elif self.collection_indexing_policy:\n            vector_store_kwargs[\"collection_indexing_policy\"] = self.collection_indexing_policy\n\n        try:\n            vector_store = AstraDBVectorStore(**vector_store_kwargs)\n        except Exception as e:\n            msg = f\"Error initializing AstraDBVectorStore: {e}\"\n            raise ValueError(msg) from e\n\n        self._add_documents_to_vector_store(vector_store)\n\n        return vector_store\n\n    def _add_documents_to_vector_store(self, vector_store) -> None:\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                msg = \"Vector Store Inputs must be Data objects.\"\n                raise TypeError(msg)\n\n        if documents:\n            logger.debug(f\"Adding {len(documents)} documents to the Vector Store.\")\n            try:\n                vector_store.add_documents(documents)\n            except Exception as e:\n                msg = f\"Error adding documents to AstraDBVectorStore: {e}\"\n                raise ValueError(msg) from e\n        else:\n            logger.debug(\"No documents to add to the Vector Store.\")\n\n    def _map_search_type(self) -> str:\n        if self.search_type == \"Similarity with score threshold\":\n            return \"similarity_score_threshold\"\n        if self.search_type == \"MMR (Max Marginal Relevance)\":\n            return \"mmr\"\n        return \"similarity\"\n\n    def _build_search_args(self):\n        args = {\n            \"k\": self.number_of_results,\n            \"score_threshold\": self.search_score_threshold,\n        }\n\n        if self.search_filter:\n            clean_filter = {k: v for k, v in self.search_filter.items() if k and v}\n            if len(clean_filter) > 0:\n                args[\"filter\"] = clean_filter\n        return args\n\n    def search_documents(self, vector_store=None) -> list[Data]:\n        if not vector_store:\n            vector_store = self.build_vector_store()\n\n        logger.debug(f\"Search input: {self.search_input}\")\n        logger.debug(f\"Search type: {self.search_type}\")\n        logger.debug(f\"Number of results: {self.number_of_results}\")\n\n        if self.search_input and isinstance(self.search_input, str) and self.search_input.strip():\n            try:\n                search_type = self._map_search_type()\n                search_args = self._build_search_args()\n\n                docs = vector_store.search(query=self.search_input, search_type=search_type, **search_args)\n            except Exception as e:\n                msg = f\"Error performing search in AstraDBVectorStore: {e}\"\n                raise ValueError(msg) from e\n\n            logger.debug(f\"Retrieved documents: {len(docs)}\")\n\n            data = docs_to_data(docs)\n            logger.debug(f\"Converted documents to data: {len(data)}\")\n            self.status = data\n            return data\n        logger.debug(\"No search input provided. Skipping search.\")\n        return []\n\n    def get_retriever_kwargs(self):\n        search_args = self._build_search_args()\n        return {\n            \"search_type\": self._map_search_type(),\n            \"search_kwargs\": search_args,\n        }\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "collection_indexing_policy": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "collection_indexing_policy",
    //                 "value": "",
    //                 "display_name": "Collection Indexing Policy",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional dictionary defining the indexing policy for the collection.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "collection_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "collection_name",
    //                 "value": "",
    //                 "display_name": "Collection Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The name of the collection within Astra DB where the vectors will be stored.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "embedding_service": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Embedding Model",
    //                     "Astra Vectorize"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding_service",
    //                 "value": "Embedding Model",
    //                 "display_name": "Embedding Model or Astra Vectorize",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Determines whether to use Astra Vectorize for the collection.",
    //                 "real_time_refresh": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "metadata_indexing_exclude": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "metadata_indexing_exclude",
    //                 "value": "",
    //                 "display_name": "Metadata Indexing Exclude",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional list of metadata fields to exclude from the indexing.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "metadata_indexing_include": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "metadata_indexing_include",
    //                 "value": "",
    //                 "display_name": "Metadata Indexing Include",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional list of metadata fields to include in the indexing.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "metric": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "cosine",
    //                     "dot_product",
    //                     "euclidean"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "metric",
    //                 "value": "",
    //                 "display_name": "Metric",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional distance metric for vector comparisons in the vector store.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "namespace": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "namespace",
    //                 "value": "",
    //                 "display_name": "Namespace",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional namespace within Astra DB to use for the collection.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 4,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "pre_delete_collection": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "pre_delete_collection",
    //                 "value": false,
    //                 "display_name": "Pre Delete Collection",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Boolean flag to determine whether to delete the collection before creating a new one.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "search_filter": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_filter",
    //                 "value": {},
    //                 "display_name": "Search Metadata Filter",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional dictionary of filters to apply to the search query.",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "search_input": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_input",
    //                 "value": "",
    //                 "display_name": "Search Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "search_score_threshold": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_score_threshold",
    //                 "value": 0.0,
    //                 "display_name": "Search Score Threshold",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Minimum similarity score threshold for search results. (when using 'Similarity with score threshold')",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "search_type": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Similarity",
    //                     "Similarity with score threshold",
    //                     "MMR (Max Marginal Relevance)"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_type",
    //                 "value": "Similarity",
    //                 "display_name": "Search Type",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Search type to use",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "setup_mode": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Sync",
    //                     "Async",
    //                     "Off"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "setup_mode",
    //                 "value": "Sync",
    //                 "display_name": "Setup Mode",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Configuration mode for setting up the vector store, with options like 'Sync', 'Async', or 'Off'.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "token": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "token",
    //                 "value": "ASTRA_DB_APPLICATION_TOKEN",
    //                 "display_name": "Astra DB Application Token",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Authentication token for accessing Astra DB.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             }
    //         },
    //         "description": "Implementation of Vector Store using Astra DB with search capabilities",
    //         "icon": "AstraDB",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "Astra DB",
    //         "documentation": "https://docs.langflow.org/starter-projects-vector-store-rag",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_endpoint",
    //                     "batch_size",
    //                     "bulk_delete_concurrency",
    //                     "bulk_insert_batch_concurrency",
    //                     "bulk_insert_overwrite_concurrency",
    //                     "collection_indexing_policy",
    //                     "collection_name",
    //                     "embedding",
    //                     "ingest_data",
    //                     "metadata_indexing_exclude",
    //                     "metadata_indexing_include",
    //                     "metric",
    //                     "namespace",
    //                     "number_of_results",
    //                     "pre_delete_collection",
    //                     "search_filter",
    //                     "search_input",
    //                     "search_score_threshold",
    //                     "search_type",
    //                     "setup_mode",
    //                     "token"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "token",
    //             "api_endpoint",
    //             "collection_name",
    //             "search_input",
    //             "ingest_data",
    //             "namespace",
    //             "embedding_service",
    //             "embedding",
    //             "metric",
    //             "batch_size",
    //             "bulk_insert_batch_concurrency",
    //             "bulk_insert_overwrite_concurrency",
    //             "bulk_delete_concurrency",
    //             "setup_mode",
    //             "pre_delete_collection",
    //             "metadata_indexing_include",
    //             "metadata_indexing_exclude",
    //             "collection_indexing_policy",
    //             "number_of_results",
    //             "search_type",
    //             "search_score_threshold",
    //             "search_filter"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "MongoDBAtlasVector": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingest Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_community.vectorstores import MongoDBAtlasVectorSearch\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import DataInput, HandleInput, IntInput, MultilineInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass MongoVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"MongoDB Atlas\"\n    description = \"MongoDB Atlas Vector Store with search capabilities\"\n    documentation = \"https://python.langchain.com/docs/modules/data_connection/vectorstores/integrations/mongodb_atlas\"\n    name = \"MongoDBAtlasVector\"\n    icon = \"MongoDB\"\n\n    inputs = [\n        SecretStrInput(name=\"mongodb_atlas_cluster_uri\", display_name=\"MongoDB Atlas Cluster URI\", required=True),\n        StrInput(name=\"db_name\", display_name=\"Database Name\", required=True),\n        StrInput(name=\"collection_name\", display_name=\"Collection Name\", required=True),\n        StrInput(name=\"index_name\", display_name=\"Index Name\", required=True),\n        MultilineInput(name=\"search_query\", display_name=\"Search Query\"),\n        DataInput(\n            name=\"ingest_data\",\n            display_name=\"Ingest Data\",\n            is_list=True,\n        ),\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> MongoDBAtlasVectorSearch:\n        try:\n            from pymongo import MongoClient\n        except ImportError as e:\n            msg = \"Please install pymongo to use MongoDB Atlas Vector Store\"\n            raise ImportError(msg) from e\n\n        try:\n            mongo_client: MongoClient = MongoClient(self.mongodb_atlas_cluster_uri)\n            collection = mongo_client[self.db_name][self.collection_name]\n        except Exception as e:\n            msg = f\"Failed to connect to MongoDB Atlas: {e}\"\n            raise ValueError(msg) from e\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        if documents:\n            return MongoDBAtlasVectorSearch.from_documents(\n                documents=documents, embedding=self.embedding, collection=collection, index_name=self.index_name\n            )\n        return MongoDBAtlasVectorSearch(\n            embedding=self.embedding,\n            collection=collection,\n            index_name=self.index_name,\n        )\n\n    def search_documents(self) -> list[Data]:\n        from bson.objectid import ObjectId\n\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str):\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n            for doc in docs:\n                doc.metadata = {\n                    key: str(value) if isinstance(value, ObjectId) else value for key, value in doc.metadata.items()\n                }\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "collection_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "collection_name",
    //                 "value": "",
    //                 "display_name": "Collection Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "db_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "db_name",
    //                 "value": "",
    //                 "display_name": "Database Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "index_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "index_name",
    //                 "value": "",
    //                 "display_name": "Index Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "mongodb_atlas_cluster_uri": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "mongodb_atlas_cluster_uri",
    //                 "value": "",
    //                 "display_name": "MongoDB Atlas Cluster URI",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 4,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "search_query": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_query",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "MongoDB Atlas Vector Store with search capabilities",
    //         "icon": "MongoDB",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "MongoDB Atlas",
    //         "documentation": "https://python.langchain.com/docs/modules/data_connection/vectorstores/integrations/mongodb_atlas",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "collection_name",
    //                     "db_name",
    //                     "embedding",
    //                     "index_name",
    //                     "ingest_data",
    //                     "mongodb_atlas_cluster_uri",
    //                     "number_of_results",
    //                     "search_query"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "mongodb_atlas_cluster_uri",
    //             "db_name",
    //             "collection_name",
    //             "index_name",
    //             "search_query",
    //             "ingest_data",
    //             "embedding",
    //             "number_of_results"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "FAISS": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingest Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "allow_dangerous_deserialization": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "allow_dangerous_deserialization",
    //                 "value": true,
    //                 "display_name": "Allow Dangerous Deserialization",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Set to True to allow loading pickle files from untrusted sources. Only enable this if you trust the source of the data.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_community.vectorstores import FAISS\nfrom loguru import logger\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import BoolInput, DataInput, HandleInput, IntInput, MultilineInput, StrInput\nfrom langflow.schema import Data\n\n\nclass FaissVectorStoreComponent(LCVectorStoreComponent):\n    \"\"\"FAISS Vector Store with search capabilities.\"\"\"\n\n    display_name: str = \"FAISS\"\n    description: str = \"FAISS Vector Store with search capabilities\"\n    documentation = \"https://python.langchain.com/docs/modules/data_connection/vectorstores/integrations/faiss\"\n    name = \"FAISS\"\n    icon = \"FAISS\"\n\n    inputs = [\n        StrInput(\n            name=\"index_name\",\n            display_name=\"Index Name\",\n            value=\"langflow_index\",\n        ),\n        StrInput(\n            name=\"persist_directory\",\n            display_name=\"Persist Directory\",\n            info=\"Path to save the FAISS index. It will be relative to where Langflow is running.\",\n        ),\n        MultilineInput(\n            name=\"search_query\",\n            display_name=\"Search Query\",\n        ),\n        DataInput(\n            name=\"ingest_data\",\n            display_name=\"Ingest Data\",\n            is_list=True,\n        ),\n        BoolInput(\n            name=\"allow_dangerous_deserialization\",\n            display_name=\"Allow Dangerous Deserialization\",\n            info=\"Set to True to allow loading pickle files from untrusted sources. \"\n            \"Only enable this if you trust the source of the data.\",\n            advanced=True,\n            value=True,\n        ),\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            advanced=True,\n            value=4,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> FAISS:\n        \"\"\"Builds the FAISS object.\"\"\"\n        if not self.persist_directory:\n            msg = \"Folder path is required to save the FAISS index.\"\n            raise ValueError(msg)\n        path = self.resolve_path(self.persist_directory)\n\n        documents = []\n\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        faiss = FAISS.from_documents(documents=documents, embedding=self.embedding)\n        faiss.save_local(str(path), self.index_name)\n\n        return faiss\n\n    def search_documents(self) -> list[Data]:\n        \"\"\"Search for documents in the FAISS vector store.\"\"\"\n        if not self.persist_directory:\n            msg = \"Folder path is required to load the FAISS index.\"\n            raise ValueError(msg)\n        path = self.resolve_path(self.persist_directory)\n\n        vector_store = FAISS.load_local(\n            folder_path=path,\n            embeddings=self.embedding,\n            index_name=self.index_name,\n            allow_dangerous_deserialization=self.allow_dangerous_deserialization,\n        )\n\n        if not vector_store:\n            msg = \"Failed to load the FAISS index.\"\n            raise ValueError(msg)\n\n        logger.debug(f\"Search input: {self.search_query}\")\n        logger.debug(f\"Number of results: {self.number_of_results}\")\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n\n            logger.debug(f\"Retrieved documents: {len(docs)}\")\n\n            data = docs_to_data(docs)\n            logger.debug(f\"Converted documents to data: {len(data)}\")\n            logger.debug(data)\n            return data  # Return the search results data\n        logger.debug(\"No search input provided. Skipping search.\")\n        return []\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "index_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "index_name",
    //                 "value": "langflow_index",
    //                 "display_name": "Index Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 4,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "persist_directory": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "persist_directory",
    //                 "value": "",
    //                 "display_name": "Persist Directory",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Path to save the FAISS index. It will be relative to where Langflow is running.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "search_query": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_query",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "FAISS Vector Store with search capabilities",
    //         "icon": "FAISS",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "FAISS",
    //         "documentation": "https://python.langchain.com/docs/modules/data_connection/vectorstores/integrations/faiss",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "allow_dangerous_deserialization",
    //                     "embedding",
    //                     "index_name",
    //                     "ingest_data",
    //                     "number_of_results",
    //                     "persist_directory",
    //                     "search_query"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "index_name",
    //             "persist_directory",
    //             "search_query",
    //             "ingest_data",
    //             "allow_dangerous_deserialization",
    //             "embedding",
    //             "number_of_results"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "pgvector": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingestion Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_community.vectorstores import PGVector\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import DataInput, HandleInput, IntInput, MultilineInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\nfrom langflow.utils.connection_string_parser import transform_connection_string\n\n\nclass PGVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"PGVector\"\n    description = \"PGVector Vector Store with search capabilities\"\n    documentation = \"https://python.langchain.com/v0.2/docs/integrations/vectorstores/pgvector/\"\n    name = \"pgvector\"\n    icon = \"PGVector\"\n\n    inputs = [\n        SecretStrInput(name=\"pg_server_url\", display_name=\"PostgreSQL Server Connection String\", required=True),\n        StrInput(name=\"collection_name\", display_name=\"Table\", required=True),\n        MultilineInput(name=\"search_query\", display_name=\"Search Query\"),\n        DataInput(\n            name=\"ingest_data\",\n            display_name=\"Ingestion Data\",\n            is_list=True,\n        ),\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> PGVector:\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        connection_string_parsed = transform_connection_string(self.pg_server_url)\n\n        if documents:\n            pgvector = PGVector.from_documents(\n                embedding=self.embedding,\n                documents=documents,\n                collection_name=self.collection_name,\n                connection_string=connection_string_parsed,\n            )\n        else:\n            pgvector = PGVector.from_existing_index(\n                embedding=self.embedding,\n                collection_name=self.collection_name,\n                connection_string=connection_string_parsed,\n            )\n\n        return pgvector\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "collection_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "collection_name",
    //                 "value": "",
    //                 "display_name": "Table",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 4,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "pg_server_url": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "pg_server_url",
    //                 "value": "",
    //                 "display_name": "PostgreSQL Server Connection String",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "search_query": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_query",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "PGVector Vector Store with search capabilities",
    //         "icon": "PGVector",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "PGVector",
    //         "documentation": "https://python.langchain.com/v0.2/docs/integrations/vectorstores/pgvector/",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "collection_name",
    //                     "embedding",
    //                     "ingest_data",
    //                     "number_of_results",
    //                     "pg_server_url",
    //                     "search_query"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "pg_server_url",
    //             "collection_name",
    //             "search_query",
    //             "ingest_data",
    //             "embedding",
    //             "number_of_results",
    //             "embedding"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "Redis": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingest Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from pathlib import Path\n\nfrom langchain.text_splitter import CharacterTextSplitter\nfrom langchain_community.vectorstores.redis import Redis\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import DataInput, HandleInput, IntInput, MultilineInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass RedisVectorStoreComponent(LCVectorStoreComponent):\n    \"\"\"A custom component for implementing a Vector Store using Redis.\"\"\"\n\n    display_name: str = \"Redis\"\n    description: str = \"Implementation of Vector Store using Redis\"\n    documentation = \"https://python.langchain.com/docs/integrations/vectorstores/redis\"\n    name = \"Redis\"\n\n    inputs = [\n        SecretStrInput(name=\"redis_server_url\", display_name=\"Redis Server Connection String\", required=True),\n        StrInput(\n            name=\"redis_index_name\",\n            display_name=\"Redis Index\",\n        ),\n        StrInput(name=\"code\", display_name=\"Code\", advanced=True),\n        StrInput(\n            name=\"schema\",\n            display_name=\"Schema\",\n        ),\n        MultilineInput(name=\"search_query\", display_name=\"Search Query\"),\n        DataInput(\n            name=\"ingest_data\",\n            display_name=\"Ingest Data\",\n            is_list=True,\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> Redis:\n        documents = []\n\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n        Path(\"docuemnts.txt\").write_text(str(documents), encoding=\"utf-8\")\n\n        if not documents:\n            if self.schema is None:\n                msg = \"If no documents are provided, a schema must be provided.\"\n                raise ValueError(msg)\n            redis_vs = Redis.from_existing_index(\n                embedding=self.embedding,\n                index_name=self.redis_index_name,\n                schema=self.schema,\n                key_prefix=None,\n                redis_url=self.redis_server_url,\n            )\n        else:\n            text_splitter = CharacterTextSplitter(chunk_size=1000, chunk_overlap=0)\n            docs = text_splitter.split_documents(documents)\n            redis_vs = Redis.from_documents(\n                documents=docs,\n                embedding=self.embedding,\n                redis_url=self.redis_server_url,\n                index_name=self.redis_index_name,\n            )\n        return redis_vs\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 4,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "redis_index_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "redis_index_name",
    //                 "value": "",
    //                 "display_name": "Redis Index",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "redis_server_url": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "redis_server_url",
    //                 "value": "",
    //                 "display_name": "Redis Server Connection String",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "schema": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "schema",
    //                 "value": "",
    //                 "display_name": "Schema",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "search_query": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_query",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Implementation of Vector Store using Redis",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "Redis",
    //         "documentation": "https://python.langchain.com/docs/integrations/vectorstores/redis",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "embedding",
    //                     "ingest_data",
    //                     "number_of_results",
    //                     "redis_index_name",
    //                     "redis_server_url",
    //                     "schema",
    //                     "search_query"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "redis_server_url",
    //             "redis_index_name",
    //             "code",
    //             "schema",
    //             "search_query",
    //             "ingest_data",
    //             "number_of_results",
    //             "embedding"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "Vectara": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingest Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Document",
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import TYPE_CHECKING\n\nfrom langchain_community.vectorstores import Vectara\nfrom loguru import logger\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import HandleInput, IntInput, MessageTextInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\nif TYPE_CHECKING:\n    from langchain_community.vectorstores import Vectara\n\n\nclass VectaraVectorStoreComponent(LCVectorStoreComponent):\n    \"\"\"Vectara Vector Store with search capabilities.\"\"\"\n\n    display_name: str = \"Vectara\"\n    description: str = \"Vectara Vector Store with search capabilities\"\n    documentation = \"https://python.langchain.com/docs/modules/data_connection/vectorstores/integrations/vectara\"\n    name = \"Vectara\"\n    icon = \"Vectara\"\n\n    inputs = [\n        StrInput(name=\"vectara_customer_id\", display_name=\"Vectara Customer ID\", required=True),\n        StrInput(name=\"vectara_corpus_id\", display_name=\"Vectara Corpus ID\", required=True),\n        SecretStrInput(name=\"vectara_api_key\", display_name=\"Vectara API Key\", required=True),\n        HandleInput(\n            name=\"embedding\",\n            display_name=\"Embedding\",\n            input_types=[\"Embeddings\"],\n        ),\n        HandleInput(\n            name=\"ingest_data\",\n            display_name=\"Ingest Data\",\n            input_types=[\"Document\", \"Data\"],\n            is_list=True,\n        ),\n        MessageTextInput(\n            name=\"search_query\",\n            display_name=\"Search Query\",\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> \"Vectara\":\n        \"\"\"Builds the Vectara object.\"\"\"\n        try:\n            from langchain_community.vectorstores import Vectara\n        except ImportError as e:\n            msg = \"Could not import Vectara. Please install it with `pip install langchain-community`.\"\n            raise ImportError(msg) from e\n\n        vectara = Vectara(\n            vectara_customer_id=self.vectara_customer_id,\n            vectara_corpus_id=self.vectara_corpus_id,\n            vectara_api_key=self.vectara_api_key,\n        )\n\n        self._add_documents_to_vector_store(vectara)\n        return vectara\n\n    def _add_documents_to_vector_store(self, vector_store: \"Vectara\") -> None:\n        \"\"\"Adds documents to the Vector Store.\"\"\"\n        if not self.ingest_data:\n            self.status = \"No documents to add to Vectara\"\n            return\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        if documents:\n            logger.debug(f\"Adding {len(documents)} documents to Vectara.\")\n            vector_store.add_documents(documents)\n            self.status = f\"Added {len(documents)} documents to Vectara\"\n        else:\n            logger.debug(\"No documents to add to Vectara.\")\n            self.status = \"No valid documents to add to Vectara\"\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n\n            data = docs_to_data(docs)\n            self.status = f\"Found {len(data)} results for the query: {self.search_query}\"\n            return data\n        self.status = \"No search query provided\"\n        return []\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 4,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "search_query": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_query",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "vectara_api_key": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "vectara_api_key",
    //                 "value": "",
    //                 "display_name": "Vectara API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "vectara_corpus_id": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "vectara_corpus_id",
    //                 "value": "",
    //                 "display_name": "Vectara Corpus ID",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "vectara_customer_id": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "vectara_customer_id",
    //                 "value": "",
    //                 "display_name": "Vectara Customer ID",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Vectara Vector Store with search capabilities",
    //         "icon": "Vectara",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "Vectara",
    //         "documentation": "https://python.langchain.com/docs/modules/data_connection/vectorstores/integrations/vectara",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "ingest_data",
    //                     "number_of_results",
    //                     "search_query",
    //                     "vectara_api_key",
    //                     "vectara_corpus_id",
    //                     "vectara_customer_id"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "vectara_customer_id",
    //             "vectara_corpus_id",
    //             "vectara_api_key",
    //             "embedding",
    //             "ingest_data",
    //             "search_query",
    //             "number_of_results"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "Weaviate": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingest Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import weaviate\nfrom langchain_community.vectorstores import Weaviate\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import BoolInput, DataInput, HandleInput, IntInput, MultilineInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass WeaviateVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"Weaviate\"\n    description = \"Weaviate Vector Store with search capabilities\"\n    documentation = \"https://python.langchain.com/docs/modules/data_connection/vectorstores/integrations/weaviate\"\n    name = \"Weaviate\"\n    icon = \"Weaviate\"\n\n    inputs = [\n        StrInput(name=\"url\", display_name=\"Weaviate URL\", value=\"http://localhost:8080\", required=True),\n        SecretStrInput(name=\"api_key\", display_name=\"API Key\", required=False),\n        StrInput(\n            name=\"index_name\",\n            display_name=\"Index Name\",\n            required=True,\n            info=\"Requires capitalized index name.\",\n        ),\n        StrInput(name=\"text_key\", display_name=\"Text Key\", value=\"text\", advanced=True),\n        MultilineInput(name=\"search_query\", display_name=\"Search Query\"),\n        DataInput(\n            name=\"ingest_data\",\n            display_name=\"Ingest Data\",\n            is_list=True,\n        ),\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n        BoolInput(name=\"search_by_text\", display_name=\"Search By Text\", advanced=True),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> Weaviate:\n        if self.api_key:\n            auth_config = weaviate.AuthApiKey(api_key=self.api_key)\n            client = weaviate.Client(url=self.url, auth_client_secret=auth_config)\n        else:\n            client = weaviate.Client(url=self.url)\n\n        if self.index_name != self.index_name.capitalize():\n            msg = f\"Weaviate requires the index name to be capitalized. Use: {self.index_name.capitalize()}\"\n            raise ValueError(msg)\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        if documents and self.embedding:\n            return Weaviate.from_documents(\n                client=client,\n                index_name=self.index_name,\n                documents=documents,\n                embedding=self.embedding,\n                by_text=self.search_by_text,\n            )\n\n        return Weaviate(\n            client=client,\n            index_name=self.index_name,\n            text_key=self.text_key,\n            embedding=self.embedding,\n            by_text=self.search_by_text,\n        )\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "index_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "index_name",
    //                 "value": "",
    //                 "display_name": "Index Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Requires capitalized index name.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 4,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "search_by_text": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_by_text",
    //                 "value": false,
    //                 "display_name": "Search By Text",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "search_query": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_query",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "text_key": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "text_key",
    //                 "value": "text",
    //                 "display_name": "Text Key",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "url": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "url",
    //                 "value": "http://localhost:8080",
    //                 "display_name": "Weaviate URL",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Weaviate Vector Store with search capabilities",
    //         "icon": "Weaviate",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "Weaviate",
    //         "documentation": "https://python.langchain.com/docs/modules/data_connection/vectorstores/integrations/weaviate",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_key",
    //                     "embedding",
    //                     "index_name",
    //                     "ingest_data",
    //                     "number_of_results",
    //                     "search_by_text",
    //                     "search_query",
    //                     "text_key",
    //                     "url"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "url",
    //             "api_key",
    //             "index_name",
    //             "text_key",
    //             "search_query",
    //             "ingest_data",
    //             "embedding",
    //             "number_of_results",
    //             "search_by_text"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AstraDBGraph": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Embedding model.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingest Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "api_endpoint": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_endpoint",
    //                 "value": "ASTRA_DB_API_ENDPOINT",
    //                 "display_name": "API Endpoint",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "API endpoint URL for the Astra DB service.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "batch_size": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "batch_size",
    //                 "value": "",
    //                 "display_name": "Batch Size",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional number of data to process in a single batch.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "bulk_delete_concurrency": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "bulk_delete_concurrency",
    //                 "value": "",
    //                 "display_name": "Bulk Delete Concurrency",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional concurrency level for bulk delete operations.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "bulk_insert_batch_concurrency": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "bulk_insert_batch_concurrency",
    //                 "value": "",
    //                 "display_name": "Bulk Insert Batch Concurrency",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional concurrency level for bulk insert operations.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "bulk_insert_overwrite_concurrency": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "bulk_insert_overwrite_concurrency",
    //                 "value": "",
    //                 "display_name": "Bulk Insert Overwrite Concurrency",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional concurrency level for bulk insert operations that overwrite existing data.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import os\n\nimport orjson\nfrom astrapy.admin import parse_api_endpoint\nfrom loguru import logger\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers import docs_to_data\nfrom langflow.inputs import DictInput, FloatInput\nfrom langflow.io import (\n    BoolInput,\n    DataInput,\n    DropdownInput,\n    HandleInput,\n    IntInput,\n    MultilineInput,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\n\n\nclass AstraGraphVectorStoreComponent(LCVectorStoreComponent):\n    display_name: str = \"Astra DB Graph\"\n    description: str = \"Implementation of Graph Vector Store using Astra DB\"\n    documentation: str = \"https://python.langchain.com/api_reference/astradb/graph_vectorstores/langchain_astradb.graph_vectorstores.AstraDBGraphVectorStore.html\"\n    name = \"AstraDBGraph\"\n    icon: str = \"AstraDB\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"token\",\n            display_name=\"Astra DB Application Token\",\n            info=\"Authentication token for accessing Astra DB.\",\n            value=\"ASTRA_DB_APPLICATION_TOKEN\",\n            required=True,\n            advanced=os.getenv(\"ASTRA_ENHANCED\", \"false\").lower() == \"true\",\n        ),\n        SecretStrInput(\n            name=\"api_endpoint\",\n            display_name=\"Database\" if os.getenv(\"ASTRA_ENHANCED\", \"false\").lower() == \"true\" else \"API Endpoint\",\n            info=\"API endpoint URL for the Astra DB service.\",\n            value=\"ASTRA_DB_API_ENDPOINT\",\n            required=True,\n        ),\n        StrInput(\n            name=\"collection_name\",\n            display_name=\"Collection Name\",\n            info=\"The name of the collection within Astra DB where the vectors will be stored.\",\n            required=True,\n        ),\n        StrInput(\n            name=\"link_to_metadata_key\",\n            display_name=\"Outgoing links metadata key\",\n            info=\"Metadata key used for outgoing links.\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"link_from_metadata_key\",\n            display_name=\"Incoming links metadata key\",\n            info=\"Metadata key used for incoming links.\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"namespace\",\n            display_name=\"Namespace\",\n            info=\"Optional namespace within Astra DB to use for the collection.\",\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"search_input\",\n            display_name=\"Search Input\",\n        ),\n        DataInput(\n            name=\"ingest_data\",\n            display_name=\"Ingest Data\",\n            is_list=True,\n        ),\n        StrInput(\n            name=\"namespace\",\n            display_name=\"Namespace\",\n            info=\"Optional namespace within Astra DB to use for the collection.\",\n            advanced=True,\n        ),\n        HandleInput(\n            name=\"embedding\",\n            display_name=\"Embedding Model\",\n            input_types=[\"Embeddings\"],\n            info=\"Embedding model.\",\n            required=True,\n        ),\n        DropdownInput(\n            name=\"metric\",\n            display_name=\"Metric\",\n            info=\"Optional distance metric for vector comparisons in the vector store.\",\n            options=[\"cosine\", \"dot_product\", \"euclidean\"],\n            value=\"cosine\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"batch_size\",\n            display_name=\"Batch Size\",\n            info=\"Optional number of data to process in a single batch.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"bulk_insert_batch_concurrency\",\n            display_name=\"Bulk Insert Batch Concurrency\",\n            info=\"Optional concurrency level for bulk insert operations.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"bulk_insert_overwrite_concurrency\",\n            display_name=\"Bulk Insert Overwrite Concurrency\",\n            info=\"Optional concurrency level for bulk insert operations that overwrite existing data.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"bulk_delete_concurrency\",\n            display_name=\"Bulk Delete Concurrency\",\n            info=\"Optional concurrency level for bulk delete operations.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"setup_mode\",\n            display_name=\"Setup Mode\",\n            info=\"Configuration mode for setting up the vector store, with options like 'Sync', or 'Off'.\",\n            options=[\"Sync\", \"Off\"],\n            advanced=True,\n            value=\"Sync\",\n        ),\n        BoolInput(\n            name=\"pre_delete_collection\",\n            display_name=\"Pre Delete Collection\",\n            info=\"Boolean flag to determine whether to delete the collection before creating a new one.\",\n            advanced=True,\n            value=False,\n        ),\n        StrInput(\n            name=\"metadata_indexing_include\",\n            display_name=\"Metadata Indexing Include\",\n            info=\"Optional list of metadata fields to include in the indexing.\",\n            advanced=True,\n            is_list=True,\n        ),\n        StrInput(\n            name=\"metadata_indexing_exclude\",\n            display_name=\"Metadata Indexing Exclude\",\n            info=\"Optional list of metadata fields to exclude from the indexing.\",\n            advanced=True,\n            is_list=True,\n        ),\n        StrInput(\n            name=\"collection_indexing_policy\",\n            display_name=\"Collection Indexing Policy\",\n            info='Optional JSON string for the \"indexing\" field of the collection. '\n            \"See https://docs.datastax.com/en/astra-db-serverless/api-reference/collections.html#the-indexing-option\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            advanced=True,\n            value=4,\n        ),\n        DropdownInput(\n            name=\"search_type\",\n            display_name=\"Search Type\",\n            info=\"Search type to use\",\n            options=[\"Similarity\", \"Similarity with score threshold\", \"MMR (Max Marginal Relevance)\"],\n            value=\"Similarity\",\n            advanced=True,\n        ),\n        FloatInput(\n            name=\"search_score_threshold\",\n            display_name=\"Search Score Threshold\",\n            info=\"Minimum similarity score threshold for search results. \"\n            \"(when using 'Similarity with score threshold')\",\n            value=0,\n            advanced=True,\n        ),\n        DictInput(\n            name=\"search_filter\",\n            display_name=\"Search Metadata Filter\",\n            info=\"Optional dictionary of filters to apply to the search query.\",\n            advanced=True,\n            is_list=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self):\n        try:\n            from langchain_astradb import AstraDBGraphVectorStore\n            from langchain_astradb.utils.astradb import SetupMode\n        except ImportError as e:\n            msg = (\n                \"Could not import langchain Astra DB integration package. \"\n                \"Please install it with `pip install langchain-astradb`.\"\n            )\n            raise ImportError(msg) from e\n\n        try:\n            vector_store = AstraDBGraphVectorStore(\n                embedding=self.embedding,\n                collection_name=self.collection_name,\n                link_to_metadata_key=self.link_to_metadata_key or \"links_to\",\n                link_from_metadata_key=self.link_from_metadata_key or \"links_from\",\n                token=self.token,\n                api_endpoint=self.api_endpoint,\n                namespace=self.namespace or None,\n                environment=parse_api_endpoint(self.api_endpoint).environment,\n                metric=self.metric,\n                batch_size=self.batch_size or None,\n                bulk_insert_batch_concurrency=self.bulk_insert_batch_concurrency or None,\n                bulk_insert_overwrite_concurrency=self.bulk_insert_overwrite_concurrency or None,\n                bulk_delete_concurrency=self.bulk_delete_concurrency or None,\n                setup_mode=SetupMode[self.setup_mode.upper()],\n                pre_delete_collection=self.pre_delete_collection,\n                metadata_indexing_include=[s for s in self.metadata_indexing_include if s],\n                metadata_indexing_exclude=[s for s in self.metadata_indexing_exclude if s],\n                collection_indexing_policy=orjson.dumps(self.collection_indexing_policy)\n                if self.collection_indexing_policy\n                else None,\n            )\n        except Exception as e:\n            msg = f\"Error initializing AstraDBGraphVectorStore: {e}\"\n            raise ValueError(msg) from e\n\n        self._add_documents_to_vector_store(vector_store)\n\n        return vector_store\n\n    def _add_documents_to_vector_store(self, vector_store) -> None:\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                msg = \"Vector Store Inputs must be Data objects.\"\n                raise TypeError(msg)\n\n        if documents:\n            logger.debug(f\"Adding {len(documents)} documents to the Vector Store.\")\n            try:\n                vector_store.add_documents(documents)\n            except Exception as e:\n                msg = f\"Error adding documents to AstraDBGraphVectorStore: {e}\"\n                raise ValueError(msg) from e\n        else:\n            logger.debug(\"No documents to add to the Vector Store.\")\n\n    def _map_search_type(self) -> str:\n        if self.search_type == \"Similarity with score threshold\":\n            return \"similarity_score_threshold\"\n        if self.search_type == \"MMR (Max Marginal Relevance)\":\n            return \"mmr\"\n        return \"similarity\"\n\n    def _build_search_args(self):\n        args = {\n            \"k\": self.number_of_results,\n            \"score_threshold\": self.search_score_threshold,\n        }\n\n        if self.search_filter:\n            clean_filter = {k: v for k, v in self.search_filter.items() if k and v}\n            if len(clean_filter) > 0:\n                args[\"filter\"] = clean_filter\n        return args\n\n    def search_documents(self, vector_store=None) -> list[Data]:\n        if not vector_store:\n            vector_store = self.build_vector_store()\n\n        logger.debug(f\"Search input: {self.search_input}\")\n        logger.debug(f\"Search type: {self.search_type}\")\n        logger.debug(f\"Number of results: {self.number_of_results}\")\n\n        if self.search_input and isinstance(self.search_input, str) and self.search_input.strip():\n            try:\n                search_type = self._map_search_type()\n                search_args = self._build_search_args()\n\n                docs = vector_store.search(query=self.search_input, search_type=search_type, **search_args)\n            except Exception as e:\n                msg = f\"Error performing search in AstraDBGraphVectorStore: {e}\"\n                raise ValueError(msg) from e\n\n            logger.debug(f\"Retrieved documents: {len(docs)}\")\n\n            data = docs_to_data(docs)\n            logger.debug(f\"Converted documents to data: {len(data)}\")\n            self.status = data\n            return data\n        logger.debug(\"No search input provided. Skipping search.\")\n        return []\n\n    def get_retriever_kwargs(self):\n        search_args = self._build_search_args()\n        return {\n            \"search_type\": self._map_search_type(),\n            \"search_kwargs\": search_args,\n        }\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "collection_indexing_policy": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "collection_indexing_policy",
    //                 "value": "",
    //                 "display_name": "Collection Indexing Policy",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional JSON string for the \"indexing\" field of the collection. See https://docs.datastax.com/en/astra-db-serverless/api-reference/collections.html#the-indexing-option",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "collection_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "collection_name",
    //                 "value": "",
    //                 "display_name": "Collection Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The name of the collection within Astra DB where the vectors will be stored.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "link_from_metadata_key": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "link_from_metadata_key",
    //                 "value": "",
    //                 "display_name": "Incoming links metadata key",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Metadata key used for incoming links.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "link_to_metadata_key": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "link_to_metadata_key",
    //                 "value": "",
    //                 "display_name": "Outgoing links metadata key",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Metadata key used for outgoing links.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "metadata_indexing_exclude": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "metadata_indexing_exclude",
    //                 "value": "",
    //                 "display_name": "Metadata Indexing Exclude",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional list of metadata fields to exclude from the indexing.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "metadata_indexing_include": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "metadata_indexing_include",
    //                 "value": "",
    //                 "display_name": "Metadata Indexing Include",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional list of metadata fields to include in the indexing.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "metric": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "cosine",
    //                     "dot_product",
    //                     "euclidean"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "metric",
    //                 "value": "cosine",
    //                 "display_name": "Metric",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional distance metric for vector comparisons in the vector store.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "namespace": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "namespace",
    //                 "value": "",
    //                 "display_name": "Namespace",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional namespace within Astra DB to use for the collection.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 4,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "pre_delete_collection": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "pre_delete_collection",
    //                 "value": false,
    //                 "display_name": "Pre Delete Collection",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Boolean flag to determine whether to delete the collection before creating a new one.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "search_filter": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_filter",
    //                 "value": {},
    //                 "display_name": "Search Metadata Filter",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional dictionary of filters to apply to the search query.",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "search_input": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_input",
    //                 "value": "",
    //                 "display_name": "Search Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "search_score_threshold": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_score_threshold",
    //                 "value": 0.0,
    //                 "display_name": "Search Score Threshold",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Minimum similarity score threshold for search results. (when using 'Similarity with score threshold')",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "search_type": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Similarity",
    //                     "Similarity with score threshold",
    //                     "MMR (Max Marginal Relevance)"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_type",
    //                 "value": "Similarity",
    //                 "display_name": "Search Type",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Search type to use",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "setup_mode": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Sync",
    //                     "Off"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "setup_mode",
    //                 "value": "Sync",
    //                 "display_name": "Setup Mode",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Configuration mode for setting up the vector store, with options like 'Sync', or 'Off'.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "token": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "token",
    //                 "value": "ASTRA_DB_APPLICATION_TOKEN",
    //                 "display_name": "Astra DB Application Token",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Authentication token for accessing Astra DB.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             }
    //         },
    //         "description": "Implementation of Graph Vector Store using Astra DB",
    //         "icon": "AstraDB",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "Astra DB Graph",
    //         "documentation": "https://python.langchain.com/api_reference/astradb/graph_vectorstores/langchain_astradb.graph_vectorstores.AstraDBGraphVectorStore.html",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_endpoint",
    //                     "batch_size",
    //                     "bulk_delete_concurrency",
    //                     "bulk_insert_batch_concurrency",
    //                     "bulk_insert_overwrite_concurrency",
    //                     "collection_indexing_policy",
    //                     "collection_name",
    //                     "embedding",
    //                     "ingest_data",
    //                     "link_from_metadata_key",
    //                     "link_to_metadata_key",
    //                     "metadata_indexing_exclude",
    //                     "metadata_indexing_include",
    //                     "metric",
    //                     "namespace",
    //                     "number_of_results",
    //                     "pre_delete_collection",
    //                     "search_filter",
    //                     "search_input",
    //                     "search_score_threshold",
    //                     "search_type",
    //                     "setup_mode",
    //                     "token"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "token",
    //             "api_endpoint",
    //             "collection_name",
    //             "link_to_metadata_key",
    //             "link_from_metadata_key",
    //             "namespace",
    //             "search_input",
    //             "ingest_data",
    //             "namespace",
    //             "embedding",
    //             "metric",
    //             "batch_size",
    //             "bulk_insert_batch_concurrency",
    //             "bulk_insert_overwrite_concurrency",
    //             "bulk_delete_concurrency",
    //             "setup_mode",
    //             "pre_delete_collection",
    //             "metadata_indexing_include",
    //             "metadata_indexing_exclude",
    //             "collection_indexing_policy",
    //             "number_of_results",
    //             "search_type",
    //             "search_score_threshold",
    //             "search_filter"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "HCD": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding or Astra Vectorize",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings",
    //                     "dict"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Allows either an embedding model or an Astra Vectorize configuration.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingest Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "api_endpoint": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_endpoint",
    //                 "value": "HCD_API_ENDPOINT",
    //                 "display_name": "HCD API Endpoint",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "API endpoint URL for the HCD service.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "batch_size": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "batch_size",
    //                 "value": "",
    //                 "display_name": "Batch Size",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional number of data to process in a single batch.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "bulk_delete_concurrency": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "bulk_delete_concurrency",
    //                 "value": "",
    //                 "display_name": "Bulk Delete Concurrency",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional concurrency level for bulk delete operations.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "bulk_insert_batch_concurrency": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "bulk_insert_batch_concurrency",
    //                 "value": "",
    //                 "display_name": "Bulk Insert Batch Concurrency",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional concurrency level for bulk insert operations.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "bulk_insert_overwrite_concurrency": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "bulk_insert_overwrite_concurrency",
    //                 "value": "",
    //                 "display_name": "Bulk Insert Overwrite Concurrency",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional concurrency level for bulk insert operations that overwrite existing data.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "ca_certificate": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ca_certificate",
    //                 "value": "",
    //                 "display_name": "CA Certificate",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Optional CA certificate for TLS connections to HCD.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from loguru import logger\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers import docs_to_data\nfrom langflow.inputs import DictInput, FloatInput\nfrom langflow.io import (\n    BoolInput,\n    DataInput,\n    DropdownInput,\n    HandleInput,\n    IntInput,\n    MultilineInput,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\n\n\nclass HCDVectorStoreComponent(LCVectorStoreComponent):\n    display_name: str = \"Hyper-Converged Database\"\n    description: str = \"Implementation of Vector Store using Hyper-Converged Database (HCD) with search capabilities\"\n    documentation: str = \"https://python.langchain.com/docs/integrations/vectorstores/astradb\"\n    name = \"HCD\"\n    icon: str = \"HCD\"\n\n    inputs = [\n        StrInput(\n            name=\"collection_name\",\n            display_name=\"Collection Name\",\n            info=\"The name of the collection within HCD where the vectors will be stored.\",\n            required=True,\n        ),\n        StrInput(\n            name=\"username\",\n            display_name=\"HCD Username\",\n            info=\"Authentication username for accessing HCD.\",\n            value=\"hcd-superuser\",\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"password\",\n            display_name=\"HCD Password\",\n            info=\"Authentication password for accessing HCD.\",\n            value=\"HCD_PASSWORD\",\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"api_endpoint\",\n            display_name=\"HCD API Endpoint\",\n            info=\"API endpoint URL for the HCD service.\",\n            value=\"HCD_API_ENDPOINT\",\n            required=True,\n        ),\n        MultilineInput(\n            name=\"search_input\",\n            display_name=\"Search Input\",\n        ),\n        DataInput(\n            name=\"ingest_data\",\n            display_name=\"Ingest Data\",\n            is_list=True,\n        ),\n        StrInput(\n            name=\"namespace\",\n            display_name=\"Namespace\",\n            info=\"Optional namespace within HCD to use for the collection.\",\n            value=\"default_namespace\",\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"ca_certificate\",\n            display_name=\"CA Certificate\",\n            info=\"Optional CA certificate for TLS connections to HCD.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"metric\",\n            display_name=\"Metric\",\n            info=\"Optional distance metric for vector comparisons in the vector store.\",\n            options=[\"cosine\", \"dot_product\", \"euclidean\"],\n            advanced=True,\n        ),\n        IntInput(\n            name=\"batch_size\",\n            display_name=\"Batch Size\",\n            info=\"Optional number of data to process in a single batch.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"bulk_insert_batch_concurrency\",\n            display_name=\"Bulk Insert Batch Concurrency\",\n            info=\"Optional concurrency level for bulk insert operations.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"bulk_insert_overwrite_concurrency\",\n            display_name=\"Bulk Insert Overwrite Concurrency\",\n            info=\"Optional concurrency level for bulk insert operations that overwrite existing data.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"bulk_delete_concurrency\",\n            display_name=\"Bulk Delete Concurrency\",\n            info=\"Optional concurrency level for bulk delete operations.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"setup_mode\",\n            display_name=\"Setup Mode\",\n            info=\"Configuration mode for setting up the vector store, with options like 'Sync', 'Async', or 'Off'.\",\n            options=[\"Sync\", \"Async\", \"Off\"],\n            advanced=True,\n            value=\"Sync\",\n        ),\n        BoolInput(\n            name=\"pre_delete_collection\",\n            display_name=\"Pre Delete Collection\",\n            info=\"Boolean flag to determine whether to delete the collection before creating a new one.\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"metadata_indexing_include\",\n            display_name=\"Metadata Indexing Include\",\n            info=\"Optional list of metadata fields to include in the indexing.\",\n            advanced=True,\n        ),\n        HandleInput(\n            name=\"embedding\",\n            display_name=\"Embedding or Astra Vectorize\",\n            input_types=[\"Embeddings\", \"dict\"],\n            # TODO: This should be optional, but need to refactor langchain-astradb first.\n            info=\"Allows either an embedding model or an Astra Vectorize configuration.\",\n        ),\n        StrInput(\n            name=\"metadata_indexing_exclude\",\n            display_name=\"Metadata Indexing Exclude\",\n            info=\"Optional list of metadata fields to exclude from the indexing.\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"collection_indexing_policy\",\n            display_name=\"Collection Indexing Policy\",\n            info=\"Optional dictionary defining the indexing policy for the collection.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            advanced=True,\n            value=4,\n        ),\n        DropdownInput(\n            name=\"search_type\",\n            display_name=\"Search Type\",\n            info=\"Search type to use\",\n            options=[\"Similarity\", \"Similarity with score threshold\", \"MMR (Max Marginal Relevance)\"],\n            value=\"Similarity\",\n            advanced=True,\n        ),\n        FloatInput(\n            name=\"search_score_threshold\",\n            display_name=\"Search Score Threshold\",\n            info=\"Minimum similarity score threshold for search results. \"\n            \"(when using 'Similarity with score threshold')\",\n            value=0,\n            advanced=True,\n        ),\n        DictInput(\n            name=\"search_filter\",\n            display_name=\"Search Metadata Filter\",\n            info=\"Optional dictionary of filters to apply to the search query.\",\n            advanced=True,\n            is_list=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self):\n        try:\n            from langchain_astradb import AstraDBVectorStore\n            from langchain_astradb.utils.astradb import SetupMode\n        except ImportError as e:\n            msg = (\n                \"Could not import langchain Astra DB integration package. \"\n                \"Please install it with `pip install langchain-astradb`.\"\n            )\n            raise ImportError(msg) from e\n\n        try:\n            from astrapy.authentication import UsernamePasswordTokenProvider\n            from astrapy.constants import Environment\n        except ImportError as e:\n            msg = \"Could not import astrapy integration package. Please install it with `pip install astrapy`.\"\n            raise ImportError(msg) from e\n\n        try:\n            if not self.setup_mode:\n                self.setup_mode = self._inputs[\"setup_mode\"].options[0]\n\n            setup_mode_value = SetupMode[self.setup_mode.upper()]\n        except KeyError as e:\n            msg = f\"Invalid setup mode: {self.setup_mode}\"\n            raise ValueError(msg) from e\n\n        if not isinstance(self.embedding, dict):\n            embedding_dict = {\"embedding\": self.embedding}\n        else:\n            from astrapy.info import CollectionVectorServiceOptions\n\n            dict_options = self.embedding.get(\"collection_vector_service_options\", {})\n            dict_options[\"authentication\"] = {\n                k: v for k, v in dict_options.get(\"authentication\", {}).items() if k and v\n            }\n            dict_options[\"parameters\"] = {k: v for k, v in dict_options.get(\"parameters\", {}).items() if k and v}\n            embedding_dict = {\n                \"collection_vector_service_options\": CollectionVectorServiceOptions.from_dict(dict_options)\n            }\n            collection_embedding_api_key = self.embedding.get(\"collection_embedding_api_key\")\n            if collection_embedding_api_key:\n                embedding_dict[\"collection_embedding_api_key\"] = collection_embedding_api_key\n\n        token_provider = UsernamePasswordTokenProvider(self.username, self.password)\n        vector_store_kwargs = {\n            **embedding_dict,\n            \"collection_name\": self.collection_name,\n            \"token\": token_provider,\n            \"api_endpoint\": self.api_endpoint,\n            \"namespace\": self.namespace,\n            \"metric\": self.metric or None,\n            \"batch_size\": self.batch_size or None,\n            \"bulk_insert_batch_concurrency\": self.bulk_insert_batch_concurrency or None,\n            \"bulk_insert_overwrite_concurrency\": self.bulk_insert_overwrite_concurrency or None,\n            \"bulk_delete_concurrency\": self.bulk_delete_concurrency or None,\n            \"setup_mode\": setup_mode_value,\n            \"pre_delete_collection\": self.pre_delete_collection or False,\n            \"environment\": Environment.HCD,\n        }\n\n        if self.metadata_indexing_include:\n            vector_store_kwargs[\"metadata_indexing_include\"] = self.metadata_indexing_include\n        elif self.metadata_indexing_exclude:\n            vector_store_kwargs[\"metadata_indexing_exclude\"] = self.metadata_indexing_exclude\n        elif self.collection_indexing_policy:\n            vector_store_kwargs[\"collection_indexing_policy\"] = self.collection_indexing_policy\n\n        try:\n            vector_store = AstraDBVectorStore(**vector_store_kwargs)\n        except Exception as e:\n            msg = f\"Error initializing AstraDBVectorStore: {e}\"\n            raise ValueError(msg) from e\n\n        self._add_documents_to_vector_store(vector_store)\n        return vector_store\n\n    def _add_documents_to_vector_store(self, vector_store) -> None:\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                msg = \"Vector Store Inputs must be Data objects.\"\n                raise TypeError(msg)\n\n        if documents:\n            logger.debug(f\"Adding {len(documents)} documents to the Vector Store.\")\n            try:\n                vector_store.add_documents(documents)\n            except Exception as e:\n                msg = f\"Error adding documents to AstraDBVectorStore: {e}\"\n                raise ValueError(msg) from e\n        else:\n            logger.debug(\"No documents to add to the Vector Store.\")\n\n    def _map_search_type(self) -> str:\n        if self.search_type == \"Similarity with score threshold\":\n            return \"similarity_score_threshold\"\n        if self.search_type == \"MMR (Max Marginal Relevance)\":\n            return \"mmr\"\n        return \"similarity\"\n\n    def _build_search_args(self):\n        args = {\n            \"k\": self.number_of_results,\n            \"score_threshold\": self.search_score_threshold,\n        }\n\n        if self.search_filter:\n            clean_filter = {k: v for k, v in self.search_filter.items() if k and v}\n            if len(clean_filter) > 0:\n                args[\"filter\"] = clean_filter\n        return args\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        logger.debug(f\"Search input: {self.search_input}\")\n        logger.debug(f\"Search type: {self.search_type}\")\n        logger.debug(f\"Number of results: {self.number_of_results}\")\n\n        if self.search_input and isinstance(self.search_input, str) and self.search_input.strip():\n            try:\n                search_type = self._map_search_type()\n                search_args = self._build_search_args()\n\n                docs = vector_store.search(query=self.search_input, search_type=search_type, **search_args)\n            except Exception as e:\n                msg = f\"Error performing search in AstraDBVectorStore: {e}\"\n                raise ValueError(msg) from e\n\n            logger.debug(f\"Retrieved documents: {len(docs)}\")\n\n            data = docs_to_data(docs)\n            logger.debug(f\"Converted documents to data: {len(data)}\")\n            self.status = data\n            return data\n        logger.debug(\"No search input provided. Skipping search.\")\n        return []\n\n    def get_retriever_kwargs(self):\n        search_args = self._build_search_args()\n        return {\n            \"search_type\": self._map_search_type(),\n            \"search_kwargs\": search_args,\n        }\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "collection_indexing_policy": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "collection_indexing_policy",
    //                 "value": "",
    //                 "display_name": "Collection Indexing Policy",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional dictionary defining the indexing policy for the collection.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "collection_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "collection_name",
    //                 "value": "",
    //                 "display_name": "Collection Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The name of the collection within HCD where the vectors will be stored.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "metadata_indexing_exclude": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "metadata_indexing_exclude",
    //                 "value": "",
    //                 "display_name": "Metadata Indexing Exclude",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional list of metadata fields to exclude from the indexing.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "metadata_indexing_include": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "metadata_indexing_include",
    //                 "value": "",
    //                 "display_name": "Metadata Indexing Include",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional list of metadata fields to include in the indexing.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "metric": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "cosine",
    //                     "dot_product",
    //                     "euclidean"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "metric",
    //                 "value": "",
    //                 "display_name": "Metric",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional distance metric for vector comparisons in the vector store.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "namespace": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "namespace",
    //                 "value": "default_namespace",
    //                 "display_name": "Namespace",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional namespace within HCD to use for the collection.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 4,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "password": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "password",
    //                 "value": "HCD_PASSWORD",
    //                 "display_name": "HCD Password",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Authentication password for accessing HCD.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "pre_delete_collection": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "pre_delete_collection",
    //                 "value": false,
    //                 "display_name": "Pre Delete Collection",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Boolean flag to determine whether to delete the collection before creating a new one.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "search_filter": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_filter",
    //                 "value": {},
    //                 "display_name": "Search Metadata Filter",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional dictionary of filters to apply to the search query.",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "search_input": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_input",
    //                 "value": "",
    //                 "display_name": "Search Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "search_score_threshold": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_score_threshold",
    //                 "value": 0.0,
    //                 "display_name": "Search Score Threshold",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Minimum similarity score threshold for search results. (when using 'Similarity with score threshold')",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "search_type": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Similarity",
    //                     "Similarity with score threshold",
    //                     "MMR (Max Marginal Relevance)"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_type",
    //                 "value": "Similarity",
    //                 "display_name": "Search Type",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Search type to use",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "setup_mode": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Sync",
    //                     "Async",
    //                     "Off"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "setup_mode",
    //                 "value": "Sync",
    //                 "display_name": "Setup Mode",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Configuration mode for setting up the vector store, with options like 'Sync', 'Async', or 'Off'.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "username": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "username",
    //                 "value": "hcd-superuser",
    //                 "display_name": "HCD Username",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Authentication username for accessing HCD.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Implementation of Vector Store using Hyper-Converged Database (HCD) with search capabilities",
    //         "icon": "HCD",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "Hyper-Converged Database",
    //         "documentation": "https://python.langchain.com/docs/integrations/vectorstores/astradb",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_endpoint",
    //                     "batch_size",
    //                     "bulk_delete_concurrency",
    //                     "bulk_insert_batch_concurrency",
    //                     "bulk_insert_overwrite_concurrency",
    //                     "collection_indexing_policy",
    //                     "collection_name",
    //                     "embedding",
    //                     "ingest_data",
    //                     "metadata_indexing_exclude",
    //                     "metadata_indexing_include",
    //                     "metric",
    //                     "namespace",
    //                     "number_of_results",
    //                     "password",
    //                     "pre_delete_collection",
    //                     "search_filter",
    //                     "search_input",
    //                     "search_score_threshold",
    //                     "search_type",
    //                     "setup_mode",
    //                     "username"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "collection_name",
    //             "username",
    //             "password",
    //             "api_endpoint",
    //             "search_input",
    //             "ingest_data",
    //             "namespace",
    //             "ca_certificate",
    //             "metric",
    //             "batch_size",
    //             "bulk_insert_batch_concurrency",
    //             "bulk_insert_overwrite_concurrency",
    //             "bulk_delete_concurrency",
    //             "setup_mode",
    //             "pre_delete_collection",
    //             "metadata_indexing_include",
    //             "embedding",
    //             "metadata_indexing_exclude",
    //             "collection_indexing_policy",
    //             "number_of_results",
    //             "search_type",
    //             "search_score_threshold",
    //             "search_filter"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "Chroma": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingest Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "allow_duplicates": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "allow_duplicates",
    //                 "value": false,
    //                 "display_name": "Allow Duplicates",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "If false, will not add documents that are already in the Vector Store.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "chroma_server_cors_allow_origins": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chroma_server_cors_allow_origins",
    //                 "value": "",
    //                 "display_name": "Server CORS Allow Origins",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "chroma_server_grpc_port": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chroma_server_grpc_port",
    //                 "value": "",
    //                 "display_name": "Server gRPC Port",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "chroma_server_host": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chroma_server_host",
    //                 "value": "",
    //                 "display_name": "Server Host",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "chroma_server_http_port": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chroma_server_http_port",
    //                 "value": "",
    //                 "display_name": "Server HTTP Port",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "chroma_server_ssl_enabled": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chroma_server_ssl_enabled",
    //                 "value": false,
    //                 "display_name": "Server SSL Enabled",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from copy import deepcopy\n\nfrom chromadb.config import Settings\nfrom langchain_chroma import Chroma\nfrom loguru import logger\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.base.vectorstores.utils import chroma_collection_to_data\nfrom langflow.io import BoolInput, DataInput, DropdownInput, HandleInput, IntInput, MultilineInput, StrInput\nfrom langflow.schema import Data\n\n\nclass ChromaVectorStoreComponent(LCVectorStoreComponent):\n    \"\"\"Chroma Vector Store with search capabilities.\"\"\"\n\n    display_name: str = \"Chroma DB\"\n    description: str = \"Chroma Vector Store with search capabilities\"\n    documentation = \"https://python.langchain.com/docs/integrations/vectorstores/chroma\"\n    name = \"Chroma\"\n    icon = \"Chroma\"\n\n    inputs = [\n        StrInput(\n            name=\"collection_name\",\n            display_name=\"Collection Name\",\n            value=\"langflow\",\n        ),\n        StrInput(\n            name=\"persist_directory\",\n            display_name=\"Persist Directory\",\n        ),\n        MultilineInput(\n            name=\"search_query\",\n            display_name=\"Search Query\",\n        ),\n        DataInput(\n            name=\"ingest_data\",\n            display_name=\"Ingest Data\",\n            is_list=True,\n        ),\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        StrInput(\n            name=\"chroma_server_cors_allow_origins\",\n            display_name=\"Server CORS Allow Origins\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"chroma_server_host\",\n            display_name=\"Server Host\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"chroma_server_http_port\",\n            display_name=\"Server HTTP Port\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"chroma_server_grpc_port\",\n            display_name=\"Server gRPC Port\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"chroma_server_ssl_enabled\",\n            display_name=\"Server SSL Enabled\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"allow_duplicates\",\n            display_name=\"Allow Duplicates\",\n            advanced=True,\n            info=\"If false, will not add documents that are already in the Vector Store.\",\n        ),\n        DropdownInput(\n            name=\"search_type\",\n            display_name=\"Search Type\",\n            options=[\"Similarity\", \"MMR\"],\n            value=\"Similarity\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            advanced=True,\n            value=10,\n        ),\n        IntInput(\n            name=\"limit\",\n            display_name=\"Limit\",\n            advanced=True,\n            info=\"Limit the number of records to compare when Allow Duplicates is False.\",\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> Chroma:\n        \"\"\"Builds the Chroma object.\"\"\"\n        try:\n            from chromadb import Client\n            from langchain_chroma import Chroma\n        except ImportError as e:\n            msg = \"Could not import Chroma integration package. Please install it with `pip install langchain-chroma`.\"\n            raise ImportError(msg) from e\n        # Chroma settings\n        chroma_settings = None\n        client = None\n        if self.chroma_server_host:\n            chroma_settings = Settings(\n                chroma_server_cors_allow_origins=self.chroma_server_cors_allow_origins or [],\n                chroma_server_host=self.chroma_server_host,\n                chroma_server_http_port=self.chroma_server_http_port or None,\n                chroma_server_grpc_port=self.chroma_server_grpc_port or None,\n                chroma_server_ssl_enabled=self.chroma_server_ssl_enabled,\n            )\n            client = Client(settings=chroma_settings)\n\n        # Check persist_directory and expand it if it is a relative path\n        persist_directory = self.resolve_path(self.persist_directory) if self.persist_directory is not None else None\n\n        chroma = Chroma(\n            persist_directory=persist_directory,\n            client=client,\n            embedding_function=self.embedding,\n            collection_name=self.collection_name,\n        )\n\n        self._add_documents_to_vector_store(chroma)\n        self.status = chroma_collection_to_data(chroma.get(limit=self.limit))\n        return chroma\n\n    def _add_documents_to_vector_store(self, vector_store: \"Chroma\") -> None:\n        \"\"\"Adds documents to the Vector Store.\"\"\"\n        if not self.ingest_data:\n            self.status = \"\"\n            return\n\n        _stored_documents_without_id = []\n        if self.allow_duplicates:\n            stored_data = []\n        else:\n            stored_data = chroma_collection_to_data(vector_store.get(limit=self.limit))\n            for value in deepcopy(stored_data):\n                del value.id\n                _stored_documents_without_id.append(value)\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                if _input not in _stored_documents_without_id:\n                    documents.append(_input.to_lc_document())\n            else:\n                msg = \"Vector Store Inputs must be Data objects.\"\n                raise TypeError(msg)\n\n        if documents and self.embedding is not None:\n            logger.debug(f\"Adding {len(documents)} documents to the Vector Store.\")\n            vector_store.add_documents(documents)\n        else:\n            logger.debug(\"No documents to add to the Vector Store.\")\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "collection_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "collection_name",
    //                 "value": "langflow",
    //                 "display_name": "Collection Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "limit": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "limit",
    //                 "value": "",
    //                 "display_name": "Limit",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Limit the number of records to compare when Allow Duplicates is False.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 10,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "persist_directory": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "persist_directory",
    //                 "value": "",
    //                 "display_name": "Persist Directory",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "search_query": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_query",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "search_type": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Similarity",
    //                     "MMR"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_type",
    //                 "value": "Similarity",
    //                 "display_name": "Search Type",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             }
    //         },
    //         "description": "Chroma Vector Store with search capabilities",
    //         "icon": "Chroma",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "Chroma DB",
    //         "documentation": "https://python.langchain.com/docs/integrations/vectorstores/chroma",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "number_of_results",
    //                     "search_query",
    //                     "search_type"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "collection_name",
    //             "persist_directory",
    //             "search_query",
    //             "ingest_data",
    //             "embedding",
    //             "chroma_server_cors_allow_origins",
    //             "chroma_server_host",
    //             "chroma_server_http_port",
    //             "chroma_server_grpc_port",
    //             "chroma_server_ssl_enabled",
    //             "allow_duplicates",
    //             "search_type",
    //             "number_of_results",
    //             "limit"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "Upstash": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "To use Upstash's embeddings, don't provide an embedding.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingest Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_community.vectorstores import UpstashVectorStore\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import (\n    DataInput,\n    HandleInput,\n    IntInput,\n    MultilineInput,\n    SecretStrInput,\n    StrInput,\n)\nfrom langflow.schema import Data\n\n\nclass UpstashVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"Upstash\"\n    description = \"Upstash Vector Store with search capabilities\"\n    documentation = \"https://python.langchain.com/v0.2/docs/integrations/vectorstores/upstash/\"\n    name = \"Upstash\"\n    icon = \"Upstash\"\n\n    inputs = [\n        StrInput(\n            name=\"index_url\",\n            display_name=\"Index URL\",\n            info=\"The URL of the Upstash index.\",\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"index_token\",\n            display_name=\"Index Token\",\n            info=\"The token for the Upstash index.\",\n            required=True,\n        ),\n        StrInput(\n            name=\"text_key\",\n            display_name=\"Text Key\",\n            info=\"The key in the record to use as text.\",\n            value=\"text\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"namespace\",\n            display_name=\"Namespace\",\n            info=\"Leave empty for default namespace.\",\n        ),\n        MultilineInput(name=\"search_query\", display_name=\"Search Query\"),\n        MultilineInput(\n            name=\"metadata_filter\",\n            display_name=\"Metadata Filter\",\n            info=\"Filters documents by metadata. Look at the documentation for more information.\",\n        ),\n        DataInput(\n            name=\"ingest_data\",\n            display_name=\"Ingest Data\",\n            is_list=True,\n        ),\n        HandleInput(\n            name=\"embedding\",\n            display_name=\"Embedding\",\n            input_types=[\"Embeddings\"],\n            info=\"To use Upstash's embeddings, don't provide an embedding.\",\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> UpstashVectorStore:\n        use_upstash_embedding = self.embedding is None\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        if documents:\n            if use_upstash_embedding:\n                upstash_vs = UpstashVectorStore(\n                    embedding=use_upstash_embedding,\n                    text_key=self.text_key,\n                    index_url=self.index_url,\n                    index_token=self.index_token,\n                    namespace=self.namespace,\n                )\n                upstash_vs.add_documents(documents)\n            else:\n                upstash_vs = UpstashVectorStore.from_documents(\n                    documents=documents,\n                    embedding=self.embedding,\n                    text_key=self.text_key,\n                    index_url=self.index_url,\n                    index_token=self.index_token,\n                    namespace=self.namespace,\n                )\n        else:\n            upstash_vs = UpstashVectorStore(\n                embedding=self.embedding or use_upstash_embedding,\n                text_key=self.text_key,\n                index_url=self.index_url,\n                index_token=self.index_token,\n                namespace=self.namespace,\n            )\n\n        return upstash_vs\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n                filter=self.metadata_filter,\n            )\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "index_token": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "index_token",
    //                 "value": "",
    //                 "display_name": "Index Token",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The token for the Upstash index.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "index_url": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "index_url",
    //                 "value": "",
    //                 "display_name": "Index URL",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The URL of the Upstash index.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "metadata_filter": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "metadata_filter",
    //                 "value": "",
    //                 "display_name": "Metadata Filter",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Filters documents by metadata. Look at the documentation for more information.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "namespace": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "namespace",
    //                 "value": "",
    //                 "display_name": "Namespace",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Leave empty for default namespace.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 4,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "search_query": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_query",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "text_key": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "text_key",
    //                 "value": "text",
    //                 "display_name": "Text Key",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The key in the record to use as text.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Upstash Vector Store with search capabilities",
    //         "icon": "Upstash",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "Upstash",
    //         "documentation": "https://python.langchain.com/v0.2/docs/integrations/vectorstores/upstash/",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "embedding",
    //                     "index_token",
    //                     "index_url",
    //                     "ingest_data",
    //                     "metadata_filter",
    //                     "namespace",
    //                     "number_of_results",
    //                     "search_query",
    //                     "text_key"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "index_url",
    //             "index_token",
    //             "text_key",
    //             "namespace",
    //             "search_query",
    //             "metadata_filter",
    //             "ingest_data",
    //             "embedding",
    //             "number_of_results"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "Couchbase": {
    //         "template": {
    //             "_type": "Component",
    //             "embedding": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "embedding",
    //                 "value": "",
    //                 "display_name": "Embedding",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Embeddings"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "ingest_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ingest_data",
    //                 "value": "",
    //                 "display_name": "Ingest Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "bucket_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "bucket_name",
    //                 "value": "",
    //                 "display_name": "Bucket Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from datetime import timedelta\n\nfrom langchain_community.vectorstores import CouchbaseVectorStore\n\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.io import DataInput, HandleInput, IntInput, MultilineInput, SecretStrInput, StrInput\nfrom langflow.schema import Data\n\n\nclass CouchbaseVectorStoreComponent(LCVectorStoreComponent):\n    display_name = \"Couchbase\"\n    description = \"Couchbase Vector Store with search capabilities\"\n    documentation = \"https://python.langchain.com/v0.1/docs/integrations/document_loaders/couchbase/\"\n    name = \"Couchbase\"\n    icon = \"Couchbase\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"couchbase_connection_string\", display_name=\"Couchbase Cluster connection string\", required=True\n        ),\n        StrInput(name=\"couchbase_username\", display_name=\"Couchbase username\", required=True),\n        SecretStrInput(name=\"couchbase_password\", display_name=\"Couchbase password\", required=True),\n        StrInput(name=\"bucket_name\", display_name=\"Bucket Name\", required=True),\n        StrInput(name=\"scope_name\", display_name=\"Scope Name\", required=True),\n        StrInput(name=\"collection_name\", display_name=\"Collection Name\", required=True),\n        StrInput(name=\"index_name\", display_name=\"Index Name\", required=True),\n        MultilineInput(name=\"search_query\", display_name=\"Search Query\"),\n        DataInput(\n            name=\"ingest_data\",\n            display_name=\"Ingest Data\",\n            is_list=True,\n        ),\n        HandleInput(name=\"embedding\", display_name=\"Embedding\", input_types=[\"Embeddings\"]),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Results\",\n            info=\"Number of results to return.\",\n            value=4,\n            advanced=True,\n        ),\n    ]\n\n    @check_cached_vector_store\n    def build_vector_store(self) -> CouchbaseVectorStore:\n        try:\n            from couchbase.auth import PasswordAuthenticator\n            from couchbase.cluster import Cluster\n            from couchbase.options import ClusterOptions\n        except ImportError as e:\n            msg = \"Failed to import Couchbase dependencies. Install it using `pip install langflow[couchbase] --pre`\"\n            raise ImportError(msg) from e\n\n        try:\n            auth = PasswordAuthenticator(self.couchbase_username, self.couchbase_password)\n            options = ClusterOptions(auth)\n            cluster = Cluster(self.couchbase_connection_string, options)\n\n            cluster.wait_until_ready(timedelta(seconds=5))\n        except Exception as e:\n            msg = f\"Failed to connect to Couchbase: {e}\"\n            raise ValueError(msg) from e\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                documents.append(_input)\n\n        if documents:\n            couchbase_vs = CouchbaseVectorStore.from_documents(\n                documents=documents,\n                cluster=cluster,\n                bucket_name=self.bucket_name,\n                scope_name=self.scope_name,\n                collection_name=self.collection_name,\n                embedding=self.embedding,\n                index_name=self.index_name,\n            )\n\n        else:\n            couchbase_vs = CouchbaseVectorStore(\n                cluster=cluster,\n                bucket_name=self.bucket_name,\n                scope_name=self.scope_name,\n                collection_name=self.collection_name,\n                embedding=self.embedding,\n                index_name=self.index_name,\n            )\n\n        return couchbase_vs\n\n    def search_documents(self) -> list[Data]:\n        vector_store = self.build_vector_store()\n\n        if self.search_query and isinstance(self.search_query, str) and self.search_query.strip():\n            docs = vector_store.similarity_search(\n                query=self.search_query,\n                k=self.number_of_results,\n            )\n\n            data = docs_to_data(docs)\n            self.status = data\n            return data\n        return []\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "collection_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "collection_name",
    //                 "value": "",
    //                 "display_name": "Collection Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "couchbase_connection_string": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "couchbase_connection_string",
    //                 "value": "",
    //                 "display_name": "Couchbase Cluster connection string",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "couchbase_password": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "couchbase_password",
    //                 "value": "",
    //                 "display_name": "Couchbase password",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "couchbase_username": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "couchbase_username",
    //                 "value": "",
    //                 "display_name": "Couchbase username",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "index_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "index_name",
    //                 "value": "",
    //                 "display_name": "Index Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "number_of_results": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_results",
    //                 "value": 4,
    //                 "display_name": "Number of Results",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of results to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "scope_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "scope_name",
    //                 "value": "",
    //                 "display_name": "Scope Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "search_query": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_query",
    //                 "value": "",
    //                 "display_name": "Search Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Couchbase Vector Store with search capabilities",
    //         "icon": "Couchbase",
    //         "base_classes": [
    //             "Data",
    //             "Retriever",
    //             "VectorStore"
    //         ],
    //         "display_name": "Couchbase",
    //         "documentation": "https://python.langchain.com/v0.1/docs/integrations/document_loaders/couchbase/",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Retriever"
    //                 ],
    //                 "selected": "Retriever",
    //                 "name": "base_retriever",
    //                 "display_name": "Retriever",
    //                 "method": "build_base_retriever",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "search_results",
    //                 "display_name": "Search Results",
    //                 "method": "search_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "bucket_name",
    //                     "collection_name",
    //                     "couchbase_connection_string",
    //                     "couchbase_password",
    //                     "couchbase_username",
    //                     "embedding",
    //                     "index_name",
    //                     "ingest_data",
    //                     "number_of_results",
    //                     "scope_name",
    //                     "search_query"
    //                 ]
    //             },
    //             {
    //                 "types": [
    //                     "VectorStore"
    //                 ],
    //                 "selected": "VectorStore",
    //                 "name": "vector_store",
    //                 "display_name": "Vector Store",
    //                 "method": "cast_vector_store",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "couchbase_connection_string",
    //             "couchbase_username",
    //             "couchbase_password",
    //             "bucket_name",
    //             "scope_name",
    //             "collection_name",
    //             "index_name",
    //             "search_query",
    //             "ingest_data",
    //             "embedding",
    //             "number_of_results"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "astra_assistants": {
    //     "AssistantsRun": {
    //         "template": {
    //             "_type": "Component",
    //             "assistant_id": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "assistant_id",
    //                 "value": "",
    //                 "display_name": "Assistant ID",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The ID of the assistant to run. \n\nCan be retrieved using the List Assistants component or created with the Create Assistant component.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom astra_assistants import patch\nfrom openai import OpenAI\nfrom openai.lib.streaming import AssistantEventHandler\n\nfrom langflow.base.astra_assistants.util import get_patched_openai_client\nfrom langflow.custom.custom_component.component_with_cache import ComponentWithCache\nfrom langflow.inputs import MultilineInput\nfrom langflow.schema import dotdict\nfrom langflow.schema.message import Message\nfrom langflow.template import Output\n\n\nclass AssistantsRun(ComponentWithCache):\n    display_name = \"Run Assistant\"\n    description = \"Executes an Assistant Run against a thread\"\n\n    def __init__(self, **kwargs) -> None:\n        super().__init__(**kwargs)\n        self.client = get_patched_openai_client(self._shared_component_cache)\n        self.thread_id = None\n\n    def update_build_config(\n        self,\n        build_config: dotdict,\n        field_value: Any,\n        field_name: str | None = None,\n    ) -> None:\n        if field_name == \"thread_id\":\n            if field_value is None:\n                thread = self.client.beta.threads.create()\n                self.thread_id = thread.id\n            build_config[\"thread_id\"] = field_value\n\n    inputs = [\n        MultilineInput(\n            name=\"assistant_id\",\n            display_name=\"Assistant ID\",\n            info=(\n                \"The ID of the assistant to run. \\n\\n\"\n                \"Can be retrieved using the List Assistants component or created with the Create Assistant component.\"\n            ),\n        ),\n        MultilineInput(\n            name=\"user_message\",\n            display_name=\"User Message\",\n            info=\"User message to pass to the run.\",\n        ),\n        MultilineInput(\n            name=\"thread_id\",\n            display_name=\"Thread ID\",\n            required=False,\n            info=\"Thread ID to use with the run. If not provided, a new thread will be created.\",\n        ),\n        MultilineInput(\n            name=\"env_set\",\n            display_name=\"Environment Set\",\n            info=\"Dummy input to allow chaining with Dotenv Component.\",\n        ),\n    ]\n\n    outputs = [Output(display_name=\"Assistant Response\", name=\"assistant_response\", method=\"process_inputs\")]\n\n    def process_inputs(self) -> Message:\n        patch(OpenAI())\n\n        text = \"\"\n\n        if self.thread_id is None:\n            thread = self.client.beta.threads.create()\n            self.thread_id = thread.id\n\n        # add the user message\n        self.client.beta.threads.messages.create(thread_id=self.thread_id, role=\"user\", content=self.user_message)\n\n        class EventHandler(AssistantEventHandler):\n            def __init__(self) -> None:\n                super().__init__()\n\n            def on_exception(self, exception: Exception) -> None:\n                raise exception\n\n        event_handler = EventHandler()\n        with self.client.beta.threads.runs.create_and_stream(\n            thread_id=self.thread_id,\n            assistant_id=self.assistant_id,\n            event_handler=event_handler,\n        ) as stream:\n            for part in stream.text_deltas:\n                text += part\n        return Message(text=text)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "env_set": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "env_set",
    //                 "value": "",
    //                 "display_name": "Environment Set",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Dummy input to allow chaining with Dotenv Component.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "thread_id": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "thread_id",
    //                 "value": "",
    //                 "display_name": "Thread ID",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Thread ID to use with the run. If not provided, a new thread will be created.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "user_message": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "user_message",
    //                 "value": "",
    //                 "display_name": "User Message",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "User message to pass to the run.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Executes an Assistant Run against a thread",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Run Assistant",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "assistant_response",
    //                 "display_name": "Assistant Response",
    //                 "method": "process_inputs",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "assistant_id",
    //             "user_message",
    //             "thread_id",
    //             "env_set"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AssistantsCreateAssistant": {
    //         "template": {
    //             "_type": "Component",
    //             "assistant_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "assistant_name",
    //                 "value": "",
    //                 "display_name": "Assistant Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Name for the assistant being created",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from loguru import logger\n\nfrom langflow.base.astra_assistants.util import get_patched_openai_client\nfrom langflow.custom.custom_component.component_with_cache import ComponentWithCache\nfrom langflow.inputs import MultilineInput, StrInput\nfrom langflow.schema.message import Message\nfrom langflow.template import Output\n\n\nclass AssistantsCreateAssistant(ComponentWithCache):\n    icon = \"bot\"\n    display_name = \"Create Assistant\"\n    description = \"Creates an Assistant and returns it's id\"\n\n    inputs = [\n        StrInput(\n            name=\"assistant_name\",\n            display_name=\"Assistant Name\",\n            info=\"Name for the assistant being created\",\n        ),\n        StrInput(\n            name=\"instructions\",\n            display_name=\"Instructions\",\n            info=\"Instructions for the assistant, think of these as the system prompt.\",\n        ),\n        StrInput(\n            name=\"model\",\n            display_name=\"Model name\",\n            info=(\n                \"Model for the assistant.\\n\\n\"\n                \"Environment variables for provider credentials can be set with the Dotenv Component.\\n\\n\"\n                \"Models are supported via LiteLLM, \"\n                \"see (https://docs.litellm.ai/docs/providers) for supported model names and env vars.\"\n            ),\n            # refresh_model=True\n        ),\n        MultilineInput(\n            name=\"env_set\",\n            display_name=\"Environment Set\",\n            info=\"Dummy input to allow chaining with Dotenv Component.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Assistant ID\", name=\"assistant_id\", method=\"process_inputs\"),\n    ]\n\n    def __init__(self, **kwargs) -> None:\n        super().__init__(**kwargs)\n        self.client = get_patched_openai_client(self._shared_component_cache)\n\n    def process_inputs(self) -> Message:\n        logger.info(f\"env_set is {self.env_set}\")\n        assistant = self.client.beta.assistants.create(\n            name=self.assistant_name,\n            instructions=self.instructions,\n            model=self.model,\n        )\n        return Message(text=assistant.id)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "env_set": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "env_set",
    //                 "value": "",
    //                 "display_name": "Environment Set",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Dummy input to allow chaining with Dotenv Component.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "instructions": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "instructions",
    //                 "value": "",
    //                 "display_name": "Instructions",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Instructions for the assistant, think of these as the system prompt.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "model": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model",
    //                 "value": "",
    //                 "display_name": "Model name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Model for the assistant.\n\nEnvironment variables for provider credentials can be set with the Dotenv Component.\n\nModels are supported via LiteLLM, see (https://docs.litellm.ai/docs/providers) for supported model names and env vars.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Creates an Assistant and returns it's id",
    //         "icon": "bot",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Create Assistant",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "assistant_id",
    //                 "display_name": "Assistant ID",
    //                 "method": "process_inputs",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "assistant_name",
    //             "instructions",
    //             "model",
    //             "env_set"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AstraAssistantManager": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import asyncio\n\nfrom astra_assistants.astra_assistants_manager import AssistantManager\nfrom loguru import logger\n\nfrom langflow.base.astra_assistants.util import (\n    get_patched_openai_client,\n    litellm_model_names,\n    tool_names,\n    tools_and_names,\n)\nfrom langflow.custom.custom_component.component_with_cache import ComponentWithCache\nfrom langflow.inputs import DropdownInput, MultilineInput, StrInput\nfrom langflow.schema.message import Message\nfrom langflow.template import Output\n\n\nclass AstraAssistantManager(ComponentWithCache):\n    display_name = \"Astra Assistant Manager\"\n    description = \"Manages Assistant Interactions\"\n    icon = \"bot\"\n\n    inputs = [\n        StrInput(\n            name=\"instructions\",\n            display_name=\"Instructions\",\n            info=\"Instructions for the assistant, think of these as the system prompt.\",\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            advanced=False,\n            options=litellm_model_names,\n            value=\"gpt-4o-mini\",\n        ),\n        DropdownInput(\n            display_name=\"Tool\",\n            name=\"tool\",\n            options=tool_names,\n        ),\n        MultilineInput(\n            name=\"user_message\",\n            display_name=\"User Message\",\n            info=\"User message to pass to the run.\",\n        ),\n        MultilineInput(\n            name=\"input_thread_id\",\n            display_name=\"Thread ID (optional)\",\n            info=\"ID of the thread\",\n        ),\n        MultilineInput(\n            name=\"input_assistant_id\",\n            display_name=\"Assistant ID (optional)\",\n            info=\"ID of the assistant\",\n        ),\n        MultilineInput(\n            name=\"env_set\",\n            display_name=\"Environment Set\",\n            info=\"Dummy input to allow chaining with Dotenv Component.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Assistant Response\", name=\"assistant_response\", method=\"get_assistant_response\"),\n        Output(display_name=\"Tool output\", name=\"tool_output\", method=\"get_tool_output\"),\n        Output(display_name=\"Thread Id\", name=\"output_thread_id\", method=\"get_thread_id\"),\n        Output(display_name=\"Assistant Id\", name=\"output_assistant_id\", method=\"get_assistant_id\"),\n    ]\n\n    def __init__(self, **kwargs) -> None:\n        super().__init__(**kwargs)\n        self.lock = asyncio.Lock()\n        self.initialized: bool = False\n        self._assistant_response: Message = None  # type: ignore[assignment]\n        self._tool_output: Message = None  # type: ignore[assignment]\n        self._thread_id: Message = None  # type: ignore[assignment]\n        self._assistant_id: Message = None  # type: ignore[assignment]\n        self.client = get_patched_openai_client(self._shared_component_cache)\n\n    async def get_assistant_response(self) -> Message:\n        await self.initialize()\n        return self._assistant_response\n\n    async def get_tool_output(self) -> Message:\n        await self.initialize()\n        return self._tool_output\n\n    async def get_thread_id(self) -> Message:\n        await self.initialize()\n        return self._thread_id\n\n    async def get_assistant_id(self) -> Message:\n        await self.initialize()\n        return self._assistant_id\n\n    async def initialize(self) -> None:\n        async with self.lock:\n            if not self.initialized:\n                await self.process_inputs()\n                self.initialized = True\n\n    async def process_inputs(self) -> None:\n        logger.info(f\"env_set is {self.env_set}\")\n        logger.info(self.tool)\n        tools = []\n        tool_obj = None\n        if self.tool:\n            tool_cls = tools_and_names[self.tool]\n            tool_obj = tool_cls()\n            tools.append(tool_obj)\n        assistant_id = None\n        thread_id = None\n        if self.input_assistant_id:\n            assistant_id = self.input_assistant_id\n        if self.input_thread_id:\n            thread_id = self.input_thread_id\n        assistant_manager = AssistantManager(\n            instructions=self.instructions,\n            model=self.model_name,\n            name=\"managed_assistant\",\n            tools=tools,\n            client=self.client,\n            thread_id=thread_id,\n            assistant_id=assistant_id,\n        )\n\n        content = self.user_message\n        result = await assistant_manager.run_thread(content=content, tool=tool_obj)\n        self._assistant_response = Message(text=result[\"text\"])\n        if \"decision\" in result:\n            self._tool_output = Message(text=str(result[\"decision\"].is_complete))\n        else:\n            self._tool_output = Message(text=result[\"text\"])\n        self._thread_id = Message(text=assistant_manager.thread.id)\n        self._assistant_id = Message(text=assistant_manager.assistant.id)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "env_set": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "env_set",
    //                 "value": "",
    //                 "display_name": "Environment Set",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Dummy input to allow chaining with Dotenv Component.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "input_assistant_id": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_assistant_id",
    //                 "value": "",
    //                 "display_name": "Assistant ID (optional)",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "ID of the assistant",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "input_thread_id": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_thread_id",
    //                 "value": "",
    //                 "display_name": "Thread ID (optional)",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "ID of the thread",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "instructions": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "instructions",
    //                 "value": "",
    //                 "display_name": "Instructions",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Instructions for the assistant, think of these as the system prompt.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "model_name": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "gpt-4",
    //                     "gpt-4o",
    //                     "gpt-4o-audio-preview",
    //                     "gpt-4o-audio-preview-2024-10-01",
    //                     "gpt-4o-mini",
    //                     "gpt-4o-mini-2024-07-18",
    //                     "o1-mini",
    //                     "o1-mini-2024-09-12",
    //                     "o1-preview",
    //                     "o1-preview-2024-09-12",
    //                     "chatgpt-4o-latest",
    //                     "gpt-4o-2024-05-13",
    //                     "gpt-4o-2024-08-06",
    //                     "gpt-4-turbo-preview",
    //                     "gpt-4-0314",
    //                     "gpt-4-0613",
    //                     "gpt-4-32k",
    //                     "gpt-4-32k-0314",
    //                     "gpt-4-32k-0613",
    //                     "gpt-4-turbo",
    //                     "gpt-4-turbo-2024-04-09",
    //                     "gpt-4-1106-preview",
    //                     "gpt-4-0125-preview",
    //                     "gpt-4-vision-preview",
    //                     "gpt-4-1106-vision-preview",
    //                     "gpt-3.5-turbo",
    //                     "gpt-3.5-turbo-0301",
    //                     "gpt-3.5-turbo-0613",
    //                     "gpt-3.5-turbo-1106",
    //                     "gpt-3.5-turbo-0125",
    //                     "gpt-3.5-turbo-16k",
    //                     "gpt-3.5-turbo-16k-0613",
    //                     "ft:gpt-3.5-turbo",
    //                     "ft:gpt-3.5-turbo-0125",
    //                     "ft:gpt-3.5-turbo-1106",
    //                     "ft:gpt-3.5-turbo-0613",
    //                     "ft:gpt-4-0613",
    //                     "ft:gpt-4o-2024-08-06",
    //                     "ft:gpt-4o-mini-2024-07-18",
    //                     "ft:davinci-002",
    //                     "ft:babbage-002",
    //                     "text-embedding-3-large",
    //                     "text-embedding-3-small",
    //                     "text-embedding-ada-002",
    //                     "text-embedding-ada-002-v2",
    //                     "text-moderation-stable",
    //                     "text-moderation-007",
    //                     "text-moderation-latest",
    //                     "256-x-256/dall-e-2",
    //                     "512-x-512/dall-e-2",
    //                     "1024-x-1024/dall-e-2",
    //                     "hd/1024-x-1792/dall-e-3",
    //                     "hd/1792-x-1024/dall-e-3",
    //                     "hd/1024-x-1024/dall-e-3",
    //                     "standard/1024-x-1792/dall-e-3",
    //                     "standard/1792-x-1024/dall-e-3",
    //                     "standard/1024-x-1024/dall-e-3",
    //                     "whisper-1",
    //                     "tts-1",
    //                     "tts-1-hd",
    //                     "azure/tts-1",
    //                     "azure/tts-1-hd",
    //                     "azure/whisper-1",
    //                     "azure/o1-mini",
    //                     "azure/o1-mini-2024-09-12",
    //                     "azure/o1-preview",
    //                     "azure/o1-preview-2024-09-12",
    //                     "azure/gpt-4o",
    //                     "azure/gpt-4o-2024-08-06",
    //                     "azure/gpt-4o-2024-05-13",
    //                     "azure/global-standard/gpt-4o-2024-08-06",
    //                     "azure/global-standard/gpt-4o-mini",
    //                     "azure/gpt-4o-mini",
    //                     "azure/gpt-4-turbo-2024-04-09",
    //                     "azure/gpt-4-0125-preview",
    //                     "azure/gpt-4-1106-preview",
    //                     "azure/gpt-4-0613",
    //                     "azure/gpt-4-32k-0613",
    //                     "azure/gpt-4-32k",
    //                     "azure/gpt-4",
    //                     "azure/gpt-4-turbo",
    //                     "azure/gpt-4-turbo-vision-preview",
    //                     "azure/gpt-35-turbo-16k-0613",
    //                     "azure/gpt-35-turbo-1106",
    //                     "azure/gpt-35-turbo-0613",
    //                     "azure/gpt-35-turbo-0301",
    //                     "azure/gpt-35-turbo-0125",
    //                     "azure/gpt-35-turbo-16k",
    //                     "azure/gpt-35-turbo",
    //                     "azure/gpt-3.5-turbo-instruct-0914",
    //                     "azure/gpt-35-turbo-instruct",
    //                     "azure/gpt-35-turbo-instruct-0914",
    //                     "azure/mistral-large-latest",
    //                     "azure/mistral-large-2402",
    //                     "azure/command-r-plus",
    //                     "azure/ada",
    //                     "azure/text-embedding-ada-002",
    //                     "azure/text-embedding-3-large",
    //                     "azure/text-embedding-3-small",
    //                     "azure/standard/1024-x-1024/dall-e-3",
    //                     "azure/hd/1024-x-1024/dall-e-3",
    //                     "azure/standard/1024-x-1792/dall-e-3",
    //                     "azure/standard/1792-x-1024/dall-e-3",
    //                     "azure/hd/1024-x-1792/dall-e-3",
    //                     "azure/hd/1792-x-1024/dall-e-3",
    //                     "azure/standard/1024-x-1024/dall-e-2",
    //                     "azure_ai/jamba-instruct",
    //                     "azure_ai/mistral-large",
    //                     "azure_ai/mistral-small",
    //                     "azure_ai/Meta-Llama-3-70B-Instruct",
    //                     "azure_ai/Meta-Llama-3.1-8B-Instruct",
    //                     "azure_ai/Meta-Llama-3.1-70B-Instruct",
    //                     "azure_ai/Meta-Llama-3.1-405B-Instruct",
    //                     "azure_ai/cohere-rerank-v3-multilingual",
    //                     "azure_ai/cohere-rerank-v3-english",
    //                     "azure_ai/Cohere-embed-v3-english",
    //                     "azure_ai/Cohere-embed-v3-multilingual",
    //                     "babbage-002",
    //                     "davinci-002",
    //                     "gpt-3.5-turbo-instruct",
    //                     "gpt-3.5-turbo-instruct-0914",
    //                     "claude-instant-1",
    //                     "mistral/mistral-tiny",
    //                     "mistral/mistral-small",
    //                     "mistral/mistral-small-latest",
    //                     "mistral/mistral-medium",
    //                     "mistral/mistral-medium-latest",
    //                     "mistral/mistral-medium-2312",
    //                     "mistral/mistral-large-latest",
    //                     "mistral/mistral-large-2402",
    //                     "mistral/mistral-large-2407",
    //                     "mistral/pixtral-12b-2409",
    //                     "mistral/open-mistral-7b",
    //                     "mistral/open-mixtral-8x7b",
    //                     "mistral/open-mixtral-8x22b",
    //                     "mistral/codestral-latest",
    //                     "mistral/codestral-2405",
    //                     "mistral/open-mistral-nemo",
    //                     "mistral/open-mistral-nemo-2407",
    //                     "mistral/open-codestral-mamba",
    //                     "mistral/codestral-mamba-latest",
    //                     "mistral/mistral-embed",
    //                     "deepseek-chat",
    //                     "codestral/codestral-latest",
    //                     "codestral/codestral-2405",
    //                     "text-completion-codestral/codestral-latest",
    //                     "text-completion-codestral/codestral-2405",
    //                     "deepseek-coder",
    //                     "groq/llama2-70b-4096",
    //                     "groq/llama3-8b-8192",
    //                     "groq/llama3-70b-8192",
    //                     "groq/llama-3.1-8b-instant",
    //                     "groq/llama-3.1-70b-versatile",
    //                     "groq/llama-3.1-405b-reasoning",
    //                     "groq/mixtral-8x7b-32768",
    //                     "groq/gemma-7b-it",
    //                     "groq/gemma2-9b-it",
    //                     "groq/llama3-groq-70b-8192-tool-use-preview",
    //                     "groq/llama3-groq-8b-8192-tool-use-preview",
    //                     "cerebras/llama3.1-8b",
    //                     "cerebras/llama3.1-70b",
    //                     "friendliai/mixtral-8x7b-instruct-v0-1",
    //                     "friendliai/meta-llama-3-8b-instruct",
    //                     "friendliai/meta-llama-3-70b-instruct",
    //                     "claude-instant-1.2",
    //                     "claude-2",
    //                     "claude-2.1",
    //                     "claude-3-haiku-20240307",
    //                     "claude-3-opus-20240229",
    //                     "claude-3-sonnet-20240229",
    //                     "claude-3-5-sonnet-20240620",
    //                     "claude-3-5-sonnet-20241022",
    //                     "text-bison",
    //                     "text-bison@001",
    //                     "text-bison@002",
    //                     "text-bison32k",
    //                     "text-bison32k@002",
    //                     "text-unicorn",
    //                     "text-unicorn@001",
    //                     "chat-bison",
    //                     "chat-bison@001",
    //                     "chat-bison@002",
    //                     "chat-bison-32k",
    //                     "chat-bison-32k@002",
    //                     "code-bison",
    //                     "code-bison@001",
    //                     "code-bison@002",
    //                     "code-bison32k",
    //                     "code-bison-32k@002",
    //                     "code-gecko@001",
    //                     "code-gecko@002",
    //                     "code-gecko",
    //                     "code-gecko-latest",
    //                     "codechat-bison@latest",
    //                     "codechat-bison",
    //                     "codechat-bison@001",
    //                     "codechat-bison@002",
    //                     "codechat-bison-32k",
    //                     "codechat-bison-32k@002",
    //                     "gemini-pro",
    //                     "gemini-1.0-pro",
    //                     "gemini-1.0-pro-001",
    //                     "gemini-1.0-ultra",
    //                     "gemini-1.0-ultra-001",
    //                     "gemini-1.0-pro-002",
    //                     "gemini-1.5-pro",
    //                     "gemini-1.5-pro-002",
    //                     "gemini-1.5-pro-001",
    //                     "gemini-1.5-pro-preview-0514",
    //                     "gemini-1.5-pro-preview-0215",
    //                     "gemini-1.5-pro-preview-0409",
    //                     "gemini-1.5-flash",
    //                     "gemini-1.5-flash-exp-0827",
    //                     "gemini-1.5-flash-002",
    //                     "gemini-1.5-flash-001",
    //                     "gemini-1.5-flash-preview-0514",
    //                     "gemini-pro-experimental",
    //                     "gemini-flash-experimental",
    //                     "gemini-pro-vision",
    //                     "gemini-1.0-pro-vision",
    //                     "gemini-1.0-pro-vision-001",
    //                     "medlm-medium",
    //                     "medlm-large",
    //                     "vertex_ai/claude-3-sonnet@20240229",
    //                     "vertex_ai/claude-3-5-sonnet@20240620",
    //                     "vertex_ai/claude-3-5-sonnet-v2@20241022",
    //                     "vertex_ai/claude-3-haiku@20240307",
    //                     "vertex_ai/claude-3-opus@20240229",
    //                     "vertex_ai/meta/llama3-405b-instruct-maas",
    //                     "vertex_ai/meta/llama3-70b-instruct-maas",
    //                     "vertex_ai/meta/llama3-8b-instruct-maas",
    //                     "vertex_ai/meta/llama-3.2-90b-vision-instruct-maas",
    //                     "vertex_ai/mistral-large@latest",
    //                     "vertex_ai/mistral-large@2407",
    //                     "vertex_ai/mistral-nemo@latest",
    //                     "vertex_ai/jamba-1.5-mini@001",
    //                     "vertex_ai/jamba-1.5-large@001",
    //                     "vertex_ai/jamba-1.5",
    //                     "vertex_ai/jamba-1.5-mini",
    //                     "vertex_ai/jamba-1.5-large",
    //                     "vertex_ai/mistral-nemo@2407",
    //                     "vertex_ai/codestral@latest",
    //                     "vertex_ai/codestral@2405",
    //                     "vertex_ai/imagegeneration@006",
    //                     "vertex_ai/imagen-3.0-generate-001",
    //                     "vertex_ai/imagen-3.0-fast-generate-001",
    //                     "text-embedding-004",
    //                     "text-multilingual-embedding-002",
    //                     "textembedding-gecko",
    //                     "textembedding-gecko-multilingual",
    //                     "textembedding-gecko-multilingual@001",
    //                     "textembedding-gecko@001",
    //                     "textembedding-gecko@003",
    //                     "text-embedding-preview-0409",
    //                     "text-multilingual-embedding-preview-0409",
    //                     "palm/chat-bison",
    //                     "palm/chat-bison-001",
    //                     "palm/text-bison",
    //                     "palm/text-bison-001",
    //                     "palm/text-bison-safety-off",
    //                     "palm/text-bison-safety-recitation-off",
    //                     "gemini/gemini-1.5-flash-002",
    //                     "gemini/gemini-1.5-flash-001",
    //                     "gemini/gemini-1.5-flash",
    //                     "gemini/gemini-1.5-flash-latest",
    //                     "gemini/gemini-1.5-flash-8b-exp-0924",
    //                     "gemini/gemini-1.5-flash-exp-0827",
    //                     "gemini/gemini-1.5-flash-8b-exp-0827",
    //                     "gemini/gemini-pro",
    //                     "gemini/gemini-1.5-pro",
    //                     "gemini/gemini-1.5-pro-002",
    //                     "gemini/gemini-1.5-pro-001",
    //                     "gemini/gemini-1.5-pro-exp-0801",
    //                     "gemini/gemini-1.5-pro-exp-0827",
    //                     "gemini/gemini-1.5-pro-latest",
    //                     "gemini/gemini-pro-vision",
    //                     "gemini/gemini-gemma-2-27b-it",
    //                     "gemini/gemini-gemma-2-9b-it",
    //                     "command-r",
    //                     "command-r-08-2024",
    //                     "command-light",
    //                     "command-r-plus",
    //                     "command-r-plus-08-2024",
    //                     "command-nightly",
    //                     "command",
    //                     "rerank-english-v3.0",
    //                     "rerank-multilingual-v3.0",
    //                     "rerank-english-v2.0",
    //                     "rerank-multilingual-v2.0",
    //                     "embed-english-light-v3.0",
    //                     "embed-multilingual-v3.0",
    //                     "embed-english-v2.0",
    //                     "embed-english-light-v2.0",
    //                     "embed-multilingual-v2.0",
    //                     "embed-english-v3.0",
    //                     "replicate/meta/llama-2-13b",
    //                     "replicate/meta/llama-2-13b-chat",
    //                     "replicate/meta/llama-2-70b",
    //                     "replicate/meta/llama-2-70b-chat",
    //                     "replicate/meta/llama-2-7b",
    //                     "replicate/meta/llama-2-7b-chat",
    //                     "replicate/meta/llama-3-70b",
    //                     "replicate/meta/llama-3-70b-instruct",
    //                     "replicate/meta/llama-3-8b",
    //                     "replicate/meta/llama-3-8b-instruct",
    //                     "replicate/mistralai/mistral-7b-v0.1",
    //                     "replicate/mistralai/mistral-7b-instruct-v0.2",
    //                     "replicate/mistralai/mixtral-8x7b-instruct-v0.1",
    //                     "openrouter/deepseek/deepseek-coder",
    //                     "openrouter/microsoft/wizardlm-2-8x22b:nitro",
    //                     "openrouter/google/gemini-pro-1.5",
    //                     "openrouter/mistralai/mixtral-8x22b-instruct",
    //                     "openrouter/cohere/command-r-plus",
    //                     "openrouter/databricks/dbrx-instruct",
    //                     "openrouter/anthropic/claude-3-haiku",
    //                     "openrouter/anthropic/claude-3-haiku-20240307",
    //                     "anthropic/claude-3-5-sonnet-20241022",
    //                     "openrouter/anthropic/claude-3.5-sonnet",
    //                     "openrouter/anthropic/claude-3.5-sonnet:beta",
    //                     "openrouter/anthropic/claude-3-sonnet",
    //                     "openrouter/mistralai/mistral-large",
    //                     "openrouter/cognitivecomputations/dolphin-mixtral-8x7b",
    //                     "openrouter/google/gemini-pro-vision",
    //                     "openrouter/fireworks/firellava-13b",
    //                     "openrouter/meta-llama/llama-3-8b-instruct:free",
    //                     "openrouter/meta-llama/llama-3-8b-instruct:extended",
    //                     "openrouter/meta-llama/llama-3-70b-instruct:nitro",
    //                     "openrouter/meta-llama/llama-3-70b-instruct",
    //                     "openrouter/openai/o1-mini",
    //                     "openrouter/openai/o1-mini-2024-09-12",
    //                     "openrouter/openai/o1-preview",
    //                     "openrouter/openai/o1-preview-2024-09-12",
    //                     "openrouter/openai/gpt-4o",
    //                     "openrouter/openai/gpt-4o-2024-05-13",
    //                     "openrouter/openai/gpt-4-vision-preview",
    //                     "openrouter/openai/gpt-3.5-turbo",
    //                     "openrouter/openai/gpt-3.5-turbo-16k",
    //                     "openrouter/openai/gpt-4",
    //                     "openrouter/anthropic/claude-instant-v1",
    //                     "openrouter/anthropic/claude-2",
    //                     "openrouter/anthropic/claude-3-opus",
    //                     "openrouter/google/palm-2-chat-bison",
    //                     "openrouter/google/palm-2-codechat-bison",
    //                     "openrouter/meta-llama/llama-2-13b-chat",
    //                     "openrouter/meta-llama/llama-2-70b-chat",
    //                     "openrouter/meta-llama/codellama-34b-instruct",
    //                     "openrouter/nousresearch/nous-hermes-llama2-13b",
    //                     "openrouter/mancer/weaver",
    //                     "openrouter/gryphe/mythomax-l2-13b",
    //                     "openrouter/jondurbin/airoboros-l2-70b-2.1",
    //                     "openrouter/undi95/remm-slerp-l2-13b",
    //                     "openrouter/pygmalionai/mythalion-13b",
    //                     "openrouter/mistralai/mistral-7b-instruct",
    //                     "openrouter/mistralai/mistral-7b-instruct:free",
    //                     "j2-ultra",
    //                     "jamba-1.5-mini@001",
    //                     "jamba-1.5-large@001",
    //                     "jamba-1.5",
    //                     "jamba-1.5-mini",
    //                     "jamba-1.5-large",
    //                     "j2-mid",
    //                     "j2-light",
    //                     "dolphin",
    //                     "chatdolphin",
    //                     "luminous-base",
    //                     "luminous-base-control",
    //                     "luminous-extended",
    //                     "luminous-extended-control",
    //                     "luminous-supreme",
    //                     "luminous-supreme-control",
    //                     "ai21.j2-mid-v1",
    //                     "ai21.j2-ultra-v1",
    //                     "ai21.jamba-instruct-v1:0",
    //                     "amazon.titan-text-lite-v1",
    //                     "amazon.titan-text-express-v1",
    //                     "amazon.titan-text-premier-v1:0",
    //                     "amazon.titan-embed-text-v1",
    //                     "amazon.titan-embed-text-v2:0",
    //                     "mistral.mistral-7b-instruct-v0:2",
    //                     "mistral.mixtral-8x7b-instruct-v0:1",
    //                     "mistral.mistral-large-2402-v1:0",
    //                     "mistral.mistral-large-2407-v1:0",
    //                     "mistral.mistral-small-2402-v1:0",
    //                     "bedrock/us-west-2/mistral.mixtral-8x7b-instruct-v0:1",
    //                     "bedrock/us-east-1/mistral.mixtral-8x7b-instruct-v0:1",
    //                     "bedrock/eu-west-3/mistral.mixtral-8x7b-instruct-v0:1",
    //                     "bedrock/us-west-2/mistral.mistral-7b-instruct-v0:2",
    //                     "bedrock/us-east-1/mistral.mistral-7b-instruct-v0:2",
    //                     "bedrock/eu-west-3/mistral.mistral-7b-instruct-v0:2",
    //                     "bedrock/us-east-1/mistral.mistral-large-2402-v1:0",
    //                     "bedrock/us-west-2/mistral.mistral-large-2402-v1:0",
    //                     "bedrock/eu-west-3/mistral.mistral-large-2402-v1:0",
    //                     "anthropic.claude-3-sonnet-20240229-v1:0",
    //                     "anthropic.claude-3-5-sonnet-20240620-v1:0",
    //                     "anthropic.claude-3-5-sonnet-20241022-v2:0",
    //                     "anthropic.claude-3-haiku-20240307-v1:0",
    //                     "anthropic.claude-3-opus-20240229-v1:0",
    //                     "us.anthropic.claude-3-sonnet-20240229-v1:0",
    //                     "us.anthropic.claude-3-5-sonnet-20240620-v1:0",
    //                     "us.anthropic.claude-3-5-sonnet-20241022-v2:0",
    //                     "us.anthropic.claude-3-haiku-20240307-v1:0",
    //                     "us.anthropic.claude-3-opus-20240229-v1:0",
    //                     "eu.anthropic.claude-3-sonnet-20240229-v1:0",
    //                     "eu.anthropic.claude-3-5-sonnet-20240620-v1:0",
    //                     "eu.anthropic.claude-3-5-sonnet-20241022-v2:0",
    //                     "eu.anthropic.claude-3-haiku-20240307-v1:0",
    //                     "eu.anthropic.claude-3-opus-20240229-v1:0",
    //                     "anthropic.claude-v1",
    //                     "bedrock/us-east-1/anthropic.claude-v1",
    //                     "bedrock/us-west-2/anthropic.claude-v1",
    //                     "bedrock/ap-northeast-1/anthropic.claude-v1",
    //                     "bedrock/ap-northeast-1/1-month-commitment/anthropic.claude-v1",
    //                     "bedrock/ap-northeast-1/6-month-commitment/anthropic.claude-v1",
    //                     "bedrock/eu-central-1/anthropic.claude-v1",
    //                     "bedrock/eu-central-1/1-month-commitment/anthropic.claude-v1",
    //                     "bedrock/eu-central-1/6-month-commitment/anthropic.claude-v1",
    //                     "bedrock/us-east-1/1-month-commitment/anthropic.claude-v1",
    //                     "bedrock/us-east-1/6-month-commitment/anthropic.claude-v1",
    //                     "bedrock/us-west-2/1-month-commitment/anthropic.claude-v1",
    //                     "bedrock/us-west-2/6-month-commitment/anthropic.claude-v1",
    //                     "anthropic.claude-v2",
    //                     "bedrock/us-east-1/anthropic.claude-v2",
    //                     "bedrock/us-west-2/anthropic.claude-v2",
    //                     "bedrock/ap-northeast-1/anthropic.claude-v2",
    //                     "bedrock/ap-northeast-1/1-month-commitment/anthropic.claude-v2",
    //                     "bedrock/ap-northeast-1/6-month-commitment/anthropic.claude-v2",
    //                     "bedrock/eu-central-1/anthropic.claude-v2",
    //                     "bedrock/eu-central-1/1-month-commitment/anthropic.claude-v2",
    //                     "bedrock/eu-central-1/6-month-commitment/anthropic.claude-v2",
    //                     "bedrock/us-east-1/1-month-commitment/anthropic.claude-v2",
    //                     "bedrock/us-east-1/6-month-commitment/anthropic.claude-v2",
    //                     "bedrock/us-west-2/1-month-commitment/anthropic.claude-v2",
    //                     "bedrock/us-west-2/6-month-commitment/anthropic.claude-v2",
    //                     "anthropic.claude-v2:1",
    //                     "bedrock/us-east-1/anthropic.claude-v2:1",
    //                     "bedrock/us-west-2/anthropic.claude-v2:1",
    //                     "bedrock/ap-northeast-1/anthropic.claude-v2:1",
    //                     "bedrock/ap-northeast-1/1-month-commitment/anthropic.claude-v2:1",
    //                     "bedrock/ap-northeast-1/6-month-commitment/anthropic.claude-v2:1",
    //                     "bedrock/eu-central-1/anthropic.claude-v2:1",
    //                     "bedrock/eu-central-1/1-month-commitment/anthropic.claude-v2:1",
    //                     "bedrock/eu-central-1/6-month-commitment/anthropic.claude-v2:1",
    //                     "bedrock/us-east-1/1-month-commitment/anthropic.claude-v2:1",
    //                     "bedrock/us-east-1/6-month-commitment/anthropic.claude-v2:1",
    //                     "bedrock/us-west-2/1-month-commitment/anthropic.claude-v2:1",
    //                     "bedrock/us-west-2/6-month-commitment/anthropic.claude-v2:1",
    //                     "anthropic.claude-instant-v1",
    //                     "bedrock/us-east-1/anthropic.claude-instant-v1",
    //                     "bedrock/us-east-1/1-month-commitment/anthropic.claude-instant-v1",
    //                     "bedrock/us-east-1/6-month-commitment/anthropic.claude-instant-v1",
    //                     "bedrock/us-west-2/1-month-commitment/anthropic.claude-instant-v1",
    //                     "bedrock/us-west-2/6-month-commitment/anthropic.claude-instant-v1",
    //                     "bedrock/us-west-2/anthropic.claude-instant-v1",
    //                     "bedrock/ap-northeast-1/anthropic.claude-instant-v1",
    //                     "bedrock/ap-northeast-1/1-month-commitment/anthropic.claude-instant-v1",
    //                     "bedrock/ap-northeast-1/6-month-commitment/anthropic.claude-instant-v1",
    //                     "bedrock/eu-central-1/anthropic.claude-instant-v1",
    //                     "bedrock/eu-central-1/1-month-commitment/anthropic.claude-instant-v1",
    //                     "bedrock/eu-central-1/6-month-commitment/anthropic.claude-instant-v1",
    //                     "cohere.command-text-v14",
    //                     "bedrock/*/1-month-commitment/cohere.command-text-v14",
    //                     "bedrock/*/6-month-commitment/cohere.command-text-v14",
    //                     "cohere.command-light-text-v14",
    //                     "bedrock/*/1-month-commitment/cohere.command-light-text-v14",
    //                     "bedrock/*/6-month-commitment/cohere.command-light-text-v14",
    //                     "cohere.command-r-plus-v1:0",
    //                     "cohere.command-r-v1:0",
    //                     "cohere.embed-english-v3",
    //                     "cohere.embed-multilingual-v3",
    //                     "meta.llama2-13b-chat-v1",
    //                     "meta.llama2-70b-chat-v1",
    //                     "meta.llama3-8b-instruct-v1:0",
    //                     "bedrock/us-east-1/meta.llama3-8b-instruct-v1:0",
    //                     "bedrock/us-west-1/meta.llama3-8b-instruct-v1:0",
    //                     "bedrock/ap-south-1/meta.llama3-8b-instruct-v1:0",
    //                     "bedrock/ca-central-1/meta.llama3-8b-instruct-v1:0",
    //                     "bedrock/eu-west-1/meta.llama3-8b-instruct-v1:0",
    //                     "bedrock/eu-west-2/meta.llama3-8b-instruct-v1:0",
    //                     "bedrock/sa-east-1/meta.llama3-8b-instruct-v1:0",
    //                     "meta.llama3-70b-instruct-v1:0",
    //                     "bedrock/us-east-1/meta.llama3-70b-instruct-v1:0",
    //                     "bedrock/us-west-1/meta.llama3-70b-instruct-v1:0",
    //                     "bedrock/ap-south-1/meta.llama3-70b-instruct-v1:0",
    //                     "bedrock/ca-central-1/meta.llama3-70b-instruct-v1:0",
    //                     "bedrock/eu-west-1/meta.llama3-70b-instruct-v1:0",
    //                     "bedrock/eu-west-2/meta.llama3-70b-instruct-v1:0",
    //                     "bedrock/sa-east-1/meta.llama3-70b-instruct-v1:0",
    //                     "meta.llama3-1-8b-instruct-v1:0",
    //                     "meta.llama3-1-70b-instruct-v1:0",
    //                     "meta.llama3-1-405b-instruct-v1:0",
    //                     "meta.llama3-2-1b-instruct-v1:0",
    //                     "us.meta.llama3-2-1b-instruct-v1:0",
    //                     "eu.meta.llama3-2-1b-instruct-v1:0",
    //                     "meta.llama3-2-3b-instruct-v1:0",
    //                     "us.meta.llama3-2-3b-instruct-v1:0",
    //                     "eu.meta.llama3-2-3b-instruct-v1:0",
    //                     "meta.llama3-2-11b-instruct-v1:0",
    //                     "us.meta.llama3-2-11b-instruct-v1:0",
    //                     "meta.llama3-2-90b-instruct-v1:0",
    //                     "us.meta.llama3-2-90b-instruct-v1:0",
    //                     "512-x-512/50-steps/stability.stable-diffusion-xl-v0",
    //                     "512-x-512/max-steps/stability.stable-diffusion-xl-v0",
    //                     "max-x-max/50-steps/stability.stable-diffusion-xl-v0",
    //                     "max-x-max/max-steps/stability.stable-diffusion-xl-v0",
    //                     "1024-x-1024/50-steps/stability.stable-diffusion-xl-v1",
    //                     "1024-x-1024/max-steps/stability.stable-diffusion-xl-v1",
    //                     "sagemaker/meta-textgeneration-llama-2-7b",
    //                     "sagemaker/meta-textgeneration-llama-2-7b-f",
    //                     "sagemaker/meta-textgeneration-llama-2-13b",
    //                     "sagemaker/meta-textgeneration-llama-2-13b-f",
    //                     "sagemaker/meta-textgeneration-llama-2-70b",
    //                     "sagemaker/meta-textgeneration-llama-2-70b-b-f",
    //                     "together-ai-up-to-4b",
    //                     "together-ai-4.1b-8b",
    //                     "together-ai-8.1b-21b",
    //                     "together-ai-21.1b-41b",
    //                     "together-ai-41.1b-80b",
    //                     "together-ai-81.1b-110b",
    //                     "together-ai-embedding-up-to-150m",
    //                     "together-ai-embedding-151m-to-350m",
    //                     "together_ai/mistralai/Mixtral-8x7B-Instruct-v0.1",
    //                     "together_ai/mistralai/Mistral-7B-Instruct-v0.1",
    //                     "together_ai/togethercomputer/CodeLlama-34b-Instruct",
    //                     "ollama/codegemma",
    //                     "ollama/codegeex4",
    //                     "ollama/deepseek-coder-v2-instruct",
    //                     "ollama/deepseek-coder-v2-base",
    //                     "ollama/deepseek-coder-v2-lite-instruct",
    //                     "ollama/deepseek-coder-v2-lite-base",
    //                     "ollama/internlm2_5-20b-chat",
    //                     "ollama/llama2",
    //                     "ollama/llama2:7b",
    //                     "ollama/llama2:13b",
    //                     "ollama/llama2:70b",
    //                     "ollama/llama2-uncensored",
    //                     "ollama/llama3",
    //                     "ollama/llama3:8b",
    //                     "ollama/llama3:70b",
    //                     "ollama/llama3.1",
    //                     "ollama/mistral-large-instruct-2407",
    //                     "ollama/mistral",
    //                     "ollama/mistral-7B-Instruct-v0.1",
    //                     "ollama/mistral-7B-Instruct-v0.2",
    //                     "ollama/mixtral-8x7B-Instruct-v0.1",
    //                     "ollama/mixtral-8x22B-Instruct-v0.1",
    //                     "ollama/codellama",
    //                     "ollama/orca-mini",
    //                     "ollama/vicuna",
    //                     "deepinfra/lizpreciatior/lzlv_70b_fp16_hf",
    //                     "deepinfra/Gryphe/MythoMax-L2-13b",
    //                     "deepinfra/mistralai/Mistral-7B-Instruct-v0.1",
    //                     "deepinfra/meta-llama/Llama-2-70b-chat-hf",
    //                     "deepinfra/cognitivecomputations/dolphin-2.6-mixtral-8x7b",
    //                     "deepinfra/codellama/CodeLlama-34b-Instruct-hf",
    //                     "deepinfra/deepinfra/mixtral",
    //                     "deepinfra/Phind/Phind-CodeLlama-34B-v2",
    //                     "deepinfra/mistralai/Mixtral-8x7B-Instruct-v0.1",
    //                     "deepinfra/deepinfra/airoboros-70b",
    //                     "deepinfra/01-ai/Yi-34B-Chat",
    //                     "deepinfra/01-ai/Yi-6B-200K",
    //                     "deepinfra/jondurbin/airoboros-l2-70b-gpt4-1.4.1",
    //                     "deepinfra/meta-llama/Llama-2-13b-chat-hf",
    //                     "deepinfra/amazon/MistralLite",
    //                     "deepinfra/meta-llama/Llama-2-7b-chat-hf",
    //                     "deepinfra/meta-llama/Meta-Llama-3-8B-Instruct",
    //                     "deepinfra/meta-llama/Meta-Llama-3-70B-Instruct",
    //                     "deepinfra/01-ai/Yi-34B-200K",
    //                     "deepinfra/openchat/openchat_3.5",
    //                     "perplexity/codellama-34b-instruct",
    //                     "perplexity/codellama-70b-instruct",
    //                     "perplexity/llama-3.1-70b-instruct",
    //                     "perplexity/llama-3.1-8b-instruct",
    //                     "perplexity/llama-3.1-sonar-huge-128k-online",
    //                     "perplexity/llama-3.1-sonar-large-128k-online",
    //                     "perplexity/llama-3.1-sonar-large-128k-chat",
    //                     "perplexity/llama-3.1-sonar-small-128k-chat",
    //                     "perplexity/llama-3.1-sonar-small-128k-online",
    //                     "perplexity/pplx-7b-chat",
    //                     "perplexity/pplx-70b-chat",
    //                     "perplexity/pplx-7b-online",
    //                     "perplexity/pplx-70b-online",
    //                     "perplexity/llama-2-70b-chat",
    //                     "perplexity/mistral-7b-instruct",
    //                     "perplexity/mixtral-8x7b-instruct",
    //                     "perplexity/sonar-small-chat",
    //                     "perplexity/sonar-small-online",
    //                     "perplexity/sonar-medium-chat",
    //                     "perplexity/sonar-medium-online",
    //                     "fireworks_ai/accounts/fireworks/models/llama-v3p2-1b-instruct",
    //                     "fireworks_ai/accounts/fireworks/models/llama-v3p2-3b-instruct",
    //                     "fireworks_ai/accounts/fireworks/models/llama-v3p2-11b-vision-instruct",
    //                     "accounts/fireworks/models/llama-v3p2-90b-vision-instruct",
    //                     "fireworks_ai/accounts/fireworks/models/firefunction-v2",
    //                     "fireworks_ai/accounts/fireworks/models/mixtral-8x22b-instruct-hf",
    //                     "fireworks_ai/accounts/fireworks/models/qwen2-72b-instruct",
    //                     "fireworks_ai/accounts/fireworks/models/yi-large",
    //                     "fireworks_ai/accounts/fireworks/models/deepseek-coder-v2-instruct",
    //                     "fireworks_ai/nomic-ai/nomic-embed-text-v1.5",
    //                     "fireworks_ai/nomic-ai/nomic-embed-text-v1",
    //                     "fireworks_ai/WhereIsAI/UAE-Large-V1",
    //                     "fireworks_ai/thenlper/gte-large",
    //                     "fireworks_ai/thenlper/gte-base",
    //                     "fireworks-ai-up-to-16b",
    //                     "fireworks-ai-16.1b-to-80b",
    //                     "fireworks-ai-moe-up-to-56b",
    //                     "fireworks-ai-56b-to-176b",
    //                     "fireworks-ai-default",
    //                     "fireworks-ai-embedding-up-to-150m",
    //                     "fireworks-ai-embedding-150m-to-350m",
    //                     "anyscale/mistralai/Mistral-7B-Instruct-v0.1",
    //                     "anyscale/mistralai/Mixtral-8x7B-Instruct-v0.1",
    //                     "anyscale/mistralai/Mixtral-8x22B-Instruct-v0.1",
    //                     "anyscale/HuggingFaceH4/zephyr-7b-beta",
    //                     "anyscale/google/gemma-7b-it",
    //                     "anyscale/meta-llama/Llama-2-7b-chat-hf",
    //                     "anyscale/meta-llama/Llama-2-13b-chat-hf",
    //                     "anyscale/meta-llama/Llama-2-70b-chat-hf",
    //                     "anyscale/codellama/CodeLlama-34b-Instruct-hf",
    //                     "anyscale/codellama/CodeLlama-70b-Instruct-hf",
    //                     "anyscale/meta-llama/Meta-Llama-3-8B-Instruct",
    //                     "anyscale/meta-llama/Meta-Llama-3-70B-Instruct",
    //                     "cloudflare/@cf/meta/llama-2-7b-chat-fp16",
    //                     "cloudflare/@cf/meta/llama-2-7b-chat-int8",
    //                     "cloudflare/@cf/mistral/mistral-7b-instruct-v0.1",
    //                     "cloudflare/@hf/thebloke/codellama-7b-instruct-awq",
    //                     "voyage/voyage-01",
    //                     "voyage/voyage-lite-01",
    //                     "voyage/voyage-large-2",
    //                     "voyage/voyage-law-2",
    //                     "voyage/voyage-code-2",
    //                     "voyage/voyage-2",
    //                     "voyage/voyage-lite-02-instruct",
    //                     "voyage/voyage-finance-2",
    //                     "databricks/databricks-meta-llama-3-1-405b-instruct",
    //                     "databricks/databricks-meta-llama-3-1-70b-instruct",
    //                     "databricks/databricks-dbrx-instruct",
    //                     "databricks/databricks-meta-llama-3-70b-instruct",
    //                     "databricks/databricks-llama-2-70b-chat",
    //                     "databricks/databricks-mixtral-8x7b-instruct",
    //                     "databricks/databricks-mpt-30b-instruct",
    //                     "databricks/databricks-mpt-7b-instruct",
    //                     "databricks/databricks-bge-large-en",
    //                     "databricks/databricks-gte-large-en"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "model_name",
    //                 "value": "gpt-4o-mini",
    //                 "display_name": "Model Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "tool": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "AstraDataAPITool",
    //                     "ChainOfThoughtTool",
    //                     "E2BCodeInterpreter"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tool",
    //                 "value": "",
    //                 "display_name": "Tool",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "user_message": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "user_message",
    //                 "value": "",
    //                 "display_name": "User Message",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "User message to pass to the run.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Manages Assistant Interactions",
    //         "icon": "bot",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Astra Assistant Manager",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "assistant_response",
    //                 "display_name": "Assistant Response",
    //                 "method": "get_assistant_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             },
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "tool_output",
    //                 "display_name": "Tool output",
    //                 "method": "get_tool_output",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             },
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "output_thread_id",
    //                 "display_name": "Thread Id",
    //                 "method": "get_thread_id",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             },
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "output_assistant_id",
    //                 "display_name": "Assistant Id",
    //                 "method": "get_assistant_id",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "instructions",
    //             "model_name",
    //             "tool",
    //             "user_message",
    //             "input_thread_id",
    //             "input_assistant_id",
    //             "env_set"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "Dotenv": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import io\n\nfrom dotenv import load_dotenv\n\nfrom langflow.custom import Component\nfrom langflow.inputs import MultilineSecretInput\nfrom langflow.schema.message import Message\nfrom langflow.template import Output\n\n\nclass Dotenv(Component):\n    display_name = \"Dotenv\"\n    description = \"Load .env file into env vars\"\n\n    inputs = [\n        MultilineSecretInput(\n            name=\"dotenv_file_content\",\n            display_name=\"Dotenv file content\",\n            info=\"Paste the content of your .env file directly, since contents are sensitive, \"\n            \"using a Global variable set as 'password' is recommended\",\n        )\n    ]\n\n    outputs = [\n        Output(display_name=\"env_set\", name=\"env_set\", method=\"process_inputs\"),\n    ]\n\n    def process_inputs(self) -> Message:\n        fake_file = io.StringIO(self.dotenv_file_content)\n        result = load_dotenv(stream=fake_file, override=True)\n\n        message = Message(text=\"No variables found in .env\")\n        if result:\n            message = Message(text=\"Loaded .env\")\n        return message\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "dotenv_file_content": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "dotenv_file_content",
    //                 "value": "",
    //                 "display_name": "Dotenv file content",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Paste the content of your .env file directly, since contents are sensitive, using a Global variable set as 'password' is recommended",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "MultilineSecretInput"
    //             }
    //         },
    //         "description": "Load .env file into env vars",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Dotenv",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "env_set",
    //                 "display_name": "env_set",
    //                 "method": "process_inputs",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "dotenv_file_content"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AssistantsListAssistants": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.base.astra_assistants.util import get_patched_openai_client\nfrom langflow.custom.custom_component.component_with_cache import ComponentWithCache\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass AssistantsListAssistants(ComponentWithCache):\n    display_name = \"List Assistants\"\n    description = \"Returns a list of assistant id's\"\n\n    outputs = [\n        Output(display_name=\"Assistants\", name=\"assistants\", method=\"process_inputs\"),\n    ]\n\n    def __init__(self, **kwargs) -> None:\n        super().__init__(**kwargs)\n        self.client = get_patched_openai_client(self._shared_component_cache)\n\n    def process_inputs(self) -> Message:\n        assistants = self.client.beta.assistants.list().data\n        id_list = [assistant.id for assistant in assistants]\n        return Message(\n            # get text from list\n            text=\"\\n\".join(id_list)\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             }
    //         },
    //         "description": "Returns a list of assistant id's",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "List Assistants",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "assistants",
    //                 "display_name": "Assistants",
    //                 "method": "process_inputs",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AssistantsGetAssistantName": {
    //         "template": {
    //             "_type": "Component",
    //             "assistant_id": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "assistant_id",
    //                 "value": "",
    //                 "display_name": "Assistant ID",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "ID of the assistant",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.base.astra_assistants.util import get_patched_openai_client\nfrom langflow.custom.custom_component.component_with_cache import ComponentWithCache\nfrom langflow.inputs import MultilineInput, StrInput\nfrom langflow.schema.message import Message\nfrom langflow.template import Output\n\n\nclass AssistantsGetAssistantName(ComponentWithCache):\n    display_name = \"Get Assistant name\"\n    description = \"Assistant by id\"\n\n    inputs = [\n        StrInput(\n            name=\"assistant_id\",\n            display_name=\"Assistant ID\",\n            info=\"ID of the assistant\",\n        ),\n        MultilineInput(\n            name=\"env_set\",\n            display_name=\"Environment Set\",\n            info=\"Dummy input to allow chaining with Dotenv Component.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Assistant Name\", name=\"assistant_name\", method=\"process_inputs\"),\n    ]\n\n    def __init__(self, **kwargs) -> None:\n        super().__init__(**kwargs)\n        self.client = get_patched_openai_client(self._shared_component_cache)\n\n    def process_inputs(self) -> Message:\n        assistant = self.client.beta.assistants.retrieve(\n            assistant_id=self.assistant_id,\n        )\n        return Message(text=assistant.name)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "env_set": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "env_set",
    //                 "value": "",
    //                 "display_name": "Environment Set",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Dummy input to allow chaining with Dotenv Component.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Assistant by id",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Get Assistant name",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "assistant_name",
    //                 "display_name": "Assistant Name",
    //                 "method": "process_inputs",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "assistant_id",
    //             "env_set"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "GetEnvVar": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import os\n\nfrom langflow.custom import Component\nfrom langflow.inputs import StrInput\nfrom langflow.schema.message import Message\nfrom langflow.template import Output\n\n\nclass GetEnvVar(Component):\n    display_name = \"Get env var\"\n    description = \"Get env var\"\n    icon = \"custom_components\"\n\n    inputs = [\n        StrInput(\n            name=\"env_var_name\",\n            display_name=\"Env var name\",\n            info=\"Name of the environment variable to get\",\n        )\n    ]\n\n    outputs = [\n        Output(display_name=\"Env var value\", name=\"env_var_value\", method=\"process_inputs\"),\n    ]\n\n    def process_inputs(self) -> Message:\n        if self.env_var_name not in os.environ:\n            msg = f\"Environment variable {self.env_var_name} not set\"\n            raise ValueError(msg)\n        return Message(text=os.environ[self.env_var_name])\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "env_var_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "env_var_name",
    //                 "value": "",
    //                 "display_name": "Env var name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Name of the environment variable to get",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Get env var",
    //         "icon": "custom_components",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Get env var",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "env_var_value",
    //                 "display_name": "Env var value",
    //                 "method": "process_inputs",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "env_var_name"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AssistantsCreateThread": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.base.astra_assistants.util import get_patched_openai_client\nfrom langflow.custom.custom_component.component_with_cache import ComponentWithCache\nfrom langflow.inputs import MultilineInput\nfrom langflow.schema.message import Message\nfrom langflow.template import Output\n\n\nclass AssistantsCreateThread(ComponentWithCache):\n    display_name = \"Create Assistant Thread\"\n    description = \"Creates a thread and returns the thread id\"\n\n    inputs = [\n        MultilineInput(\n            name=\"env_set\",\n            display_name=\"Environment Set\",\n            info=\"Dummy input to allow chaining with Dotenv Component.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Thread ID\", name=\"thread_id\", method=\"process_inputs\"),\n    ]\n\n    def __init__(self, **kwargs) -> None:\n        super().__init__(**kwargs)\n        self.client = get_patched_openai_client(self._shared_component_cache)\n\n    def process_inputs(self) -> Message:\n        thread = self.client.beta.threads.create()\n        thread_id = thread.id\n\n        return Message(text=thread_id)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "env_set": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "env_set",
    //                 "value": "",
    //                 "display_name": "Environment Set",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Dummy input to allow chaining with Dotenv Component.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Creates a thread and returns the thread id",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Create Assistant Thread",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "thread_id",
    //                 "display_name": "Thread ID",
    //                 "method": "process_inputs",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "env_set"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "link_extractors": {
    //     "HtmlLinkExtractor": {
    //         "template": {
    //             "_type": "Component",
    //             "data_input": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "data_input",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Document",
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The texts from which to extract links.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom langchain_community.graph_vectorstores.extractors import HtmlLinkExtractor, LinkExtractorTransformer\nfrom langchain_core.documents import BaseDocumentTransformer\n\nfrom langflow.base.document_transformers.model import LCDocumentTransformerComponent\nfrom langflow.inputs import BoolInput, DataInput, StrInput\n\n\nclass HtmlLinkExtractorComponent(LCDocumentTransformerComponent):\n    display_name = \"HTML Link Extractor\"\n    description = \"Extract hyperlinks from HTML content.\"\n    documentation = \"https://python.langchain.com/v0.2/api_reference/community/graph_vectorstores/langchain_community.graph_vectorstores.extractors.html_link_extractor.HtmlLinkExtractor.html\"\n    name = \"HtmlLinkExtractor\"\n\n    inputs = [\n        StrInput(name=\"kind\", display_name=\"Kind of edge\", value=\"hyperlink\", required=False),\n        BoolInput(name=\"drop_fragments\", display_name=\"Drop URL fragments\", value=True, required=False),\n        DataInput(\n            name=\"data_input\",\n            display_name=\"Input\",\n            info=\"The texts from which to extract links.\",\n            input_types=[\"Document\", \"Data\"],\n        ),\n    ]\n\n    def get_data_input(self) -> Any:\n        return self.data_input\n\n    def build_document_transformer(self) -> BaseDocumentTransformer:\n        return LinkExtractorTransformer(\n            [HtmlLinkExtractor(kind=self.kind, drop_fragments=self.drop_fragments).as_document_extractor()]\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "drop_fragments": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "drop_fragments",
    //                 "value": true,
    //                 "display_name": "Drop URL fragments",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "kind": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "kind",
    //                 "value": "hyperlink",
    //                 "display_name": "Kind of edge",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Extract hyperlinks from HTML content.",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "HTML Link Extractor",
    //         "documentation": "https://python.langchain.com/v0.2/api_reference/community/graph_vectorstores/langchain_community.graph_vectorstores.extractors.html_link_extractor.HtmlLinkExtractor.html",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "display_name": "Data",
    //                 "method": "transform_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "kind",
    //             "drop_fragments",
    //             "data_input"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "output_parsers": {
    //     "OutputParser": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_core.output_parsers import CommaSeparatedListOutputParser\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.field_typing.constants import OutputParser\nfrom langflow.io import DropdownInput, Output\nfrom langflow.schema.message import Message\n\n\nclass OutputParserComponent(Component):\n    display_name = \"Output Parser\"\n    description = \"Transforms the output of an LLM into a specified format.\"\n    icon = \"type\"\n    name = \"OutputParser\"\n\n    inputs = [\n        DropdownInput(\n            name=\"parser_type\",\n            display_name=\"Parser\",\n            options=[\"CSV\"],\n            value=\"CSV\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Format Instructions\",\n            name=\"format_instructions\",\n            info=\"Pass to a prompt template to include formatting instructions for LLM responses.\",\n            method=\"format_instructions\",\n        ),\n        Output(display_name=\"Output Parser\", name=\"output_parser\", method=\"build_parser\"),\n    ]\n\n    def build_parser(self) -> OutputParser:\n        if self.parser_type == \"CSV\":\n            return CommaSeparatedListOutputParser()\n        msg = \"Unsupported or missing parser\"\n        raise ValueError(msg)\n\n    def format_instructions(self) -> Message:\n        if self.parser_type == \"CSV\":\n            return Message(text=CommaSeparatedListOutputParser().get_format_instructions())\n        msg = \"Unsupported or missing parser\"\n        raise ValueError(msg)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "parser_type": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "CSV"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "parser_type",
    //                 "value": "CSV",
    //                 "display_name": "Parser",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             }
    //         },
    //         "description": "Transforms the output of an LLM into a specified format.",
    //         "icon": "type",
    //         "base_classes": [
    //             "Message",
    //             "OutputParser"
    //         ],
    //         "display_name": "Output Parser",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "format_instructions",
    //                 "display_name": "Format Instructions",
    //                 "method": "format_instructions",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             },
    //             {
    //                 "types": [
    //                     "OutputParser"
    //                 ],
    //                 "selected": "OutputParser",
    //                 "name": "output_parser",
    //                 "display_name": "Output Parser",
    //                 "method": "build_parser",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "parser_type"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "prototypes": {
    //     "FlowTool": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom loguru import logger\nfrom typing_extensions import override\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.base.tools.flow_tool import FlowTool\nfrom langflow.field_typing import Tool\nfrom langflow.graph.graph.base import Graph\nfrom langflow.helpers.flow import get_flow_inputs\nfrom langflow.io import BoolInput, DropdownInput, Output, StrInput\nfrom langflow.schema import Data\nfrom langflow.schema.dotdict import dotdict\n\n\nclass FlowToolComponent(LCToolComponent):\n    display_name = \"Flow as Tool\"\n    description = \"Construct a Tool from a function that runs the loaded Flow.\"\n    field_order = [\"flow_name\", \"name\", \"description\", \"return_direct\"]\n    trace_type = \"tool\"\n    name = \"FlowTool\"\n    beta = True\n\n    def get_flow_names(self) -> list[str]:\n        flow_datas = self.list_flows()\n        return [flow_data.data[\"name\"] for flow_data in flow_datas]\n\n    def get_flow(self, flow_name: str) -> Data | None:\n        \"\"\"Retrieves a flow by its name.\n\n        Args:\n            flow_name (str): The name of the flow to retrieve.\n\n        Returns:\n            Optional[Text]: The flow record if found, None otherwise.\n        \"\"\"\n        flow_datas = self.list_flows()\n        for flow_data in flow_datas:\n            if flow_data.data[\"name\"] == flow_name:\n                return flow_data\n        return None\n\n    @override\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"flow_name\":\n            build_config[\"flow_name\"][\"options\"] = self.get_flow_names()\n\n        return build_config\n\n    inputs = [\n        DropdownInput(\n            name=\"flow_name\", display_name=\"Flow Name\", info=\"The name of the flow to run.\", refresh_button=True\n        ),\n        StrInput(\n            name=\"tool_name\",\n            display_name=\"Name\",\n            info=\"The name of the tool.\",\n        ),\n        StrInput(\n            name=\"tool_description\",\n            display_name=\"Description\",\n            info=\"The description of the tool.\",\n        ),\n        BoolInput(\n            name=\"return_direct\",\n            display_name=\"Return Direct\",\n            info=\"Return the result directly from the Tool.\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"api_build_tool\", display_name=\"Tool\", method=\"build_tool\"),\n    ]\n\n    def build_tool(self) -> Tool:\n        FlowTool.update_forward_refs()\n        if \"flow_name\" not in self._attributes or not self._attributes[\"flow_name\"]:\n            msg = \"Flow name is required\"\n            raise ValueError(msg)\n        flow_name = self._attributes[\"flow_name\"]\n        flow_data = self.get_flow(flow_name)\n        if not flow_data:\n            msg = \"Flow not found.\"\n            raise ValueError(msg)\n        graph = Graph.from_payload(flow_data.data[\"data\"])\n        try:\n            graph.set_run_id(self.graph.run_id)\n        except Exception:  # noqa: BLE001\n            logger.opt(exception=True).warning(\"Failed to set run_id\")\n        inputs = get_flow_inputs(graph)\n        tool = FlowTool(\n            name=self.tool_name,\n            description=self.tool_description,\n            graph=graph,\n            return_direct=self.return_direct,\n            inputs=inputs,\n            flow_id=str(flow_data.id),\n            user_id=str(self.user_id),\n        )\n        description_repr = repr(tool.description).strip(\"'\")\n        args_str = \"\\n\".join([f\"- {arg_name}: {arg_data['description']}\" for arg_name, arg_data in tool.args.items()])\n        self.status = f\"{description_repr}\\nArguments:\\n{args_str}\"\n        return tool\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "flow_name": {
    //                 "trace_as_metadata": true,
    //                 "options": [],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "flow_name",
    //                 "value": "",
    //                 "display_name": "Flow Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The name of the flow to run.",
    //                 "refresh_button": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "return_direct": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "return_direct",
    //                 "value": false,
    //                 "display_name": "Return Direct",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Return the result directly from the Tool.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "tool_description": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tool_description",
    //                 "value": "",
    //                 "display_name": "Description",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The description of the tool.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "tool_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tool_name",
    //                 "value": "",
    //                 "display_name": "Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The name of the tool.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Construct a Tool from a function that runs the loaded Flow.",
    //         "base_classes": [
    //             "Tool"
    //         ],
    //         "display_name": "Flow as Tool",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Tool"
    //                 ],
    //                 "selected": "Tool",
    //                 "name": "api_build_tool",
    //                 "display_name": "Tool",
    //                 "method": "build_tool",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "flow_name",
    //             "tool_name",
    //             "tool_description",
    //             "return_direct"
    //         ],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "SubFlow": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom loguru import logger\n\nfrom langflow.base.flow_processing.utils import build_data_from_result_data\nfrom langflow.custom import Component\nfrom langflow.graph.graph.base import Graph\nfrom langflow.graph.vertex.base import Vertex\nfrom langflow.helpers.flow import get_flow_inputs\nfrom langflow.io import DropdownInput, Output\nfrom langflow.schema import Data, dotdict\n\n\nclass SubFlowComponent(Component):\n    display_name = \"Sub Flow\"\n    description = \"Generates a Component from a Flow, with all of its inputs, and \"\n    name = \"SubFlow\"\n    beta: bool = True\n\n    def get_flow_names(self) -> list[str]:\n        flow_data = self.list_flows()\n        return [flow_data.data[\"name\"] for flow_data in flow_data]\n\n    def get_flow(self, flow_name: str) -> Data | None:\n        flow_datas = self.list_flows()\n        for flow_data in flow_datas:\n            if flow_data.data[\"name\"] == flow_name:\n                return flow_data\n        return None\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"flow_name\":\n            build_config[\"flow_name\"][\"options\"] = self.get_flow_names()\n\n        for key in list(build_config.keys()):\n            if key not in [x.name for x in self.inputs] + [\"code\", \"_type\", \"get_final_results_only\"]:\n                del build_config[key]\n        if field_value is not None and field_name == \"flow_name\":\n            try:\n                flow_data = self.get_flow(field_value)\n            except Exception:  # noqa: BLE001\n                logger.exception(f\"Error getting flow {field_value}\")\n            else:\n                if not flow_data:\n                    msg = f\"Flow {field_value} not found.\"\n                    logger.error(msg)\n                else:\n                    try:\n                        graph = Graph.from_payload(flow_data.data[\"data\"])\n                        # Get all inputs from the graph\n                        inputs = get_flow_inputs(graph)\n                        # Add inputs to the build config\n                        build_config = self.add_inputs_to_build_config(inputs, build_config)\n                    except Exception:  # noqa: BLE001\n                        logger.exception(f\"Error building graph for flow {field_value}\")\n\n        return build_config\n\n    def add_inputs_to_build_config(self, inputs_vertex: list[Vertex], build_config: dotdict):\n        new_fields: list[dotdict] = []\n\n        for vertex in inputs_vertex:\n            new_vertex_inputs = []\n            field_template = vertex.data[\"node\"][\"template\"]\n            for inp in field_template:\n                if inp not in {\"code\", \"_type\"}:\n                    field_template[inp][\"display_name\"] = (\n                        vertex.display_name + \" - \" + field_template[inp][\"display_name\"]\n                    )\n                    field_template[inp][\"name\"] = vertex.id + \"|\" + inp\n                    new_vertex_inputs.append(field_template[inp])\n            new_fields += new_vertex_inputs\n        for field in new_fields:\n            build_config[field[\"name\"]] = field\n        return build_config\n\n    inputs = [\n        DropdownInput(\n            name=\"flow_name\",\n            display_name=\"Flow Name\",\n            info=\"The name of the flow to run.\",\n            options=[],\n            refresh_button=True,\n            real_time_refresh=True,\n        ),\n    ]\n\n    outputs = [Output(name=\"flow_outputs\", display_name=\"Flow Outputs\", method=\"generate_results\")]\n\n    async def generate_results(self) -> list[Data]:\n        tweaks: dict = {}\n        for field in self._attributes:\n            if field != \"flow_name\" and \"|\" in field:\n                [node, name] = field.split(\"|\")\n                if node not in tweaks:\n                    tweaks[node] = {}\n                tweaks[node][name] = self._attributes[field]\n        flow_name = self._attributes.get(\"flow_name\")\n        run_outputs = await self.run_flow(\n            tweaks=tweaks,\n            flow_name=flow_name,\n            output_type=\"all\",\n        )\n        data: list[Data] = []\n        if not run_outputs:\n            return data\n        run_output = run_outputs[0]\n\n        if run_output is not None:\n            for output in run_output.outputs:\n                if output:\n                    data.extend(build_data_from_result_data(output))\n        return data\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "flow_name": {
    //                 "trace_as_metadata": true,
    //                 "options": [],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "flow_name",
    //                 "value": "",
    //                 "display_name": "Flow Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The name of the flow to run.",
    //                 "real_time_refresh": true,
    //                 "refresh_button": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             }
    //         },
    //         "description": "Generates a Component from a Flow, with all of its inputs, and ",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Sub Flow",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "flow_outputs",
    //                 "display_name": "Flow Outputs",
    //                 "method": "generate_results",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "flow_name"
    //         ],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "PythonFunction": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from collections.abc import Callable\n\nfrom loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.custom.utils import get_function\nfrom langflow.io import CodeInput, Output\nfrom langflow.schema import Data, dotdict\nfrom langflow.schema.message import Message\n\n\nclass PythonFunctionComponent(Component):\n    display_name = \"Python Function\"\n    description = \"Define and execute a Python function that returns a Data object or a Message.\"\n    icon = \"Python\"\n    name = \"PythonFunction\"\n    beta = True\n\n    inputs = [\n        CodeInput(\n            name=\"function_code\",\n            display_name=\"Function Code\",\n            info=\"The code for the function.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            name=\"function_output\",\n            display_name=\"Function Callable\",\n            method=\"get_function_callable\",\n        ),\n        Output(\n            name=\"function_output_data\",\n            display_name=\"Function Output (Data)\",\n            method=\"execute_function_data\",\n        ),\n        Output(\n            name=\"function_output_str\",\n            display_name=\"Function Output (Message)\",\n            method=\"execute_function_message\",\n        ),\n    ]\n\n    def get_function_callable(self) -> Callable:\n        function_code = self.function_code\n        self.status = function_code\n        return get_function(function_code)\n\n    def execute_function(self) -> list[dotdict | str] | dotdict | str:\n        function_code = self.function_code\n\n        if not function_code:\n            return \"No function code provided.\"\n\n        try:\n            func = get_function(function_code)\n            return func()\n        except Exception as e:  # noqa: BLE001\n            logger.opt(exception=True).debug(\"Error executing function\")\n            return f\"Error executing function: {e}\"\n\n    def execute_function_data(self) -> list[Data]:\n        results = self.execute_function()\n        results = results if isinstance(results, list) else [results]\n        return [(Data(text=x) if isinstance(x, str) else Data(**x)) for x in results]\n\n    def execute_function_message(self) -> Message:\n        results = self.execute_function()\n        results = results if isinstance(results, list) else [results]\n        results_list = [str(x) for x in results]\n        results_str = \"\\n\".join(results_list)\n        return Message(text=results_str)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "function_code": {
    //                 "trace_as_input": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "function_code",
    //                 "value": "",
    //                 "display_name": "Function Code",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The code for the function.",
    //                 "title_case": false,
    //                 "type": "code",
    //                 "_input_type": "CodeInput"
    //             }
    //         },
    //         "description": "Define and execute a Python function that returns a Data object or a Message.",
    //         "icon": "Python",
    //         "base_classes": [
    //             "Callable",
    //             "Data",
    //             "Message"
    //         ],
    //         "display_name": "Python Function",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Callable"
    //                 ],
    //                 "selected": "Callable",
    //                 "name": "function_output",
    //                 "display_name": "Function Callable",
    //                 "method": "get_function_callable",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "function_output_data",
    //                 "display_name": "Function Output (Data)",
    //                 "method": "execute_function_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             },
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "function_output_str",
    //                 "display_name": "Function Output (Message)",
    //                 "method": "execute_function_message",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "function_code"
    //         ],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "SQLExecutor": {
    //         "template": {
    //             "_type": "CustomComponent",
    //             "add_error": {
    //                 "type": "bool",
    //                 "required": false,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "value": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "add_error",
    //                 "display_name": "Add Error",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Add the error to the result.",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_community.tools.sql_database.tool import QuerySQLDataBaseTool\nfrom langchain_community.utilities import SQLDatabase\n\nfrom langflow.custom import CustomComponent\nfrom langflow.field_typing import Text\n\n\nclass SQLExecutorComponent(CustomComponent):\n    display_name = \"SQL Executor\"\n    description = \"Execute SQL query.\"\n    name = \"SQLExecutor\"\n    beta: bool = True\n\n    def build_config(self):\n        return {\n            \"database_url\": {\n                \"display_name\": \"Database URL\",\n                \"info\": \"The URL of the database.\",\n            },\n            \"include_columns\": {\n                \"display_name\": \"Include Columns\",\n                \"info\": \"Include columns in the result.\",\n            },\n            \"passthrough\": {\n                \"display_name\": \"Passthrough\",\n                \"info\": \"If an error occurs, return the query instead of raising an exception.\",\n            },\n            \"add_error\": {\n                \"display_name\": \"Add Error\",\n                \"info\": \"Add the error to the result.\",\n            },\n        }\n\n    def clean_up_uri(self, uri: str) -> str:\n        if uri.startswith(\"postgresql://\"):\n            uri = uri.replace(\"postgresql://\", \"postgres://\")\n        return uri.strip()\n\n    def build(\n        self,\n        query: str,\n        database_url: str,\n        *,\n        include_columns: bool = False,\n        passthrough: bool = False,\n        add_error: bool = False,\n    ) -> Text:\n        error = None\n        try:\n            database = SQLDatabase.from_uri(database_url)\n        except Exception as e:\n            msg = f\"An error occurred while connecting to the database: {e}\"\n            raise ValueError(msg) from e\n        try:\n            tool = QuerySQLDataBaseTool(db=database)\n            result = tool.run(query, include_columns=include_columns)\n            self.status = result\n        except Exception as e:\n            result = str(e)\n            self.status = result\n            if not passthrough:\n                raise\n            error = repr(e)\n\n        if add_error and error is not None:\n            result = f\"{result}\\n\\nError: {error}\\n\\nQuery: {query}\"\n        elif error is not None:\n            # Then we won't add the error to the result\n            # but since we are in passthrough mode, we will return the query\n            result = query\n\n        return result\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "database_url": {
    //                 "type": "str",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "database_url",
    //                 "display_name": "Database URL",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The URL of the database.",
    //                 "load_from_db": false,
    //                 "title_case": false,
    //                 "input_types": [
    //                     "Text"
    //                 ]
    //             },
    //             "include_columns": {
    //                 "type": "bool",
    //                 "required": false,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "value": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "include_columns",
    //                 "display_name": "Include Columns",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Include columns in the result.",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "passthrough": {
    //                 "type": "bool",
    //                 "required": false,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "value": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "passthrough",
    //                 "display_name": "Passthrough",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "If an error occurs, return the query instead of raising an exception.",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "query": {
    //                 "type": "str",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "query",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false,
    //                 "input_types": [
    //                     "Text"
    //                 ]
    //             }
    //         },
    //         "description": "Execute SQL query.",
    //         "base_classes": [
    //             "object",
    //             "str",
    //             "Text"
    //         ],
    //         "display_name": "SQL Executor",
    //         "documentation": "",
    //         "custom_fields": {
    //             "query": null,
    //             "database_url": null,
    //             "include_columns": null,
    //             "passthrough": null,
    //             "add_error": null
    //         },
    //         "output_types": [
    //             "Text"
    //         ],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Text"
    //                 ],
    //                 "selected": "Text",
    //                 "name": "text",
    //                 "hidden": null,
    //                 "display_name": "Text",
    //                 "method": null,
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": null
    //             }
    //         ],
    //         "field_order": [],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "UpdateData": {
    //         "template": {
    //             "_type": "Component",
    //             "old_data": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "old_data",
    //                 "value": "",
    //                 "display_name": "Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The record to update.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs.inputs import BoolInput, DataInput, DictInput, IntInput, MessageTextInput\nfrom langflow.io import Output\nfrom langflow.schema import Data\nfrom langflow.schema.dotdict import dotdict\n\nMAX_NUMBER_OF_FIELDS = 15\n\n\nclass UpdateDataComponent(Component):\n    display_name: str = \"Update data\"\n    description: str = \"Dynamically update or append data with the specified fields.\"\n    name: str = \"UpdateData\"\n\n    inputs = [\n        DataInput(\n            name=\"old_data\",\n            display_name=\"Data\",\n            info=\"The record to update.\",\n            is_list=False,\n        ),\n        IntInput(\n            name=\"number_of_fields\",\n            display_name=\"Number of Fields\",\n            info=\"Number of fields to be added to the record.\",\n            real_time_refresh=True,\n            value=0,\n            range_spec=RangeSpec(min=1, max=15, step=1, step_type=\"int\"),\n        ),\n        MessageTextInput(\n            name=\"text_key\",\n            display_name=\"Text Key\",\n            info=\"Key that identifies the field to be used as the text content.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"text_key_validator\",\n            display_name=\"Text Key Validator\",\n            advanced=True,\n            info=\"If enabled, checks if the given 'Text Key' is present in the given 'Data'.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"build_data\"),\n    ]\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"number_of_fields\":\n            default_keys = [\"code\", \"_type\", \"number_of_fields\", \"text_key\", \"old_data\", \"text_key_validator\"]\n            try:\n                field_value_int = int(field_value)\n            except ValueError:\n                return build_config\n            existing_fields = {}\n            if field_value_int > MAX_NUMBER_OF_FIELDS:\n                build_config[\"number_of_fields\"][\"value\"] = MAX_NUMBER_OF_FIELDS\n                msg = (\n                    f\"Number of fields cannot exceed {MAX_NUMBER_OF_FIELDS}. Try using a Component to combine two Data.\"\n                )\n                raise ValueError(msg)\n            if len(build_config) > len(default_keys):\n                # back up the existing template fields\n                for key in build_config.copy():\n                    if key not in default_keys:\n                        existing_fields[key] = build_config.pop(key)\n\n            for i in range(1, field_value_int + 1):\n                key = f\"field_{i}_key\"\n                if key in existing_fields:\n                    field = existing_fields[key]\n                    build_config[key] = field\n                else:\n                    field = DictInput(\n                        display_name=f\"Field {i}\",\n                        name=key,\n                        info=f\"Key for field {i}.\",\n                        input_types=[\"Text\", \"Data\"],\n                    )\n                    build_config[field.name] = field.to_dict()\n\n            build_config[\"number_of_fields\"][\"value\"] = field_value_int\n        return build_config\n\n    async def build_data(self) -> Data:\n        new_data = self.get_data()\n        self.old_data.data.update(new_data)\n        if self.text_key:\n            self.old_data.text_key = self.text_key\n        self.status = self.old_data\n        self.validate_text_key(self.old_data)\n        return self.old_data\n\n    def get_data(self):\n        \"\"\"Function to get the Data from the attributes.\"\"\"\n        data = {}\n        for value_dict in self._attributes.values():\n            if isinstance(value_dict, dict):\n                # Check if the value of the value_dict is a Data\n                _value_dict = {\n                    key: value.get_text() if isinstance(value, Data) else value for key, value in value_dict.items()\n                }\n                data.update(_value_dict)\n        return data\n\n    def validate_text_key(self, data: Data) -> None:\n        \"\"\"This function validates that the Text Key is one of the keys in the Data.\"\"\"\n        data_keys = data.data.keys()\n        if self.text_key not in data_keys and self.text_key != \"\":\n            msg = f\"Text Key: {self.text_key} not found in the Data keys: {','.join(data_keys)}\"\n            raise ValueError(msg)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "number_of_fields": {
    //                 "trace_as_metadata": true,
    //                 "range_spec": {
    //                     "step_type": "int",
    //                     "min": 1.0,
    //                     "max": 15.0,
    //                     "step": 1.0
    //                 },
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_fields",
    //                 "value": 0,
    //                 "display_name": "Number of Fields",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Number of fields to be added to the record.",
    //                 "real_time_refresh": true,
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "text_key": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "text_key",
    //                 "value": "",
    //                 "display_name": "Text Key",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Key that identifies the field to be used as the text content.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "text_key_validator": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "text_key_validator",
    //                 "value": false,
    //                 "display_name": "Text Key Validator",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "If enabled, checks if the given 'Text Key' is present in the given 'Data'.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Dynamically update or append data with the specified fields.",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Update data",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "display_name": "Data",
    //                 "method": "build_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "old_data",
    //             "number_of_fields",
    //             "text_key",
    //             "text_key_validator"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "JSONCleaner": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import json\nimport re\nimport unicodedata\n\nfrom langflow.custom import Component\nfrom langflow.inputs import BoolInput, MessageTextInput\nfrom langflow.schema.message import Message\nfrom langflow.template import Output\n\n\nclass JSONCleaner(Component):\n    display_name = \"JSON Cleaner\"\n    description = (\n        \"Cleans the messy and sometimes incorrect JSON strings produced by LLMs \"\n        \"so that they are fully compliant with the JSON spec.\"\n    )\n    icon = \"custom_components\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"json_str\", display_name=\"JSON String\", info=\"The JSON string to be cleaned.\", required=True\n        ),\n        BoolInput(\n            name=\"remove_control_chars\",\n            display_name=\"Remove Control Characters\",\n            info=\"Remove control characters from the JSON string.\",\n            required=False,\n        ),\n        BoolInput(\n            name=\"normalize_unicode\",\n            display_name=\"Normalize Unicode\",\n            info=\"Normalize Unicode characters in the JSON string.\",\n            required=False,\n        ),\n        BoolInput(\n            name=\"validate_json\",\n            display_name=\"Validate JSON\",\n            info=\"Validate the JSON string to ensure it is well-formed.\",\n            required=False,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Cleaned JSON String\", name=\"output\", method=\"clean_json\"),\n    ]\n\n    def clean_json(self) -> Message:\n        try:\n            from json_repair import repair_json\n        except ImportError as e:\n            msg = \"Could not import the json_repair package. Please install it with `pip install json_repair`.\"\n            raise ImportError(msg) from e\n\n        \"\"\"Clean the input JSON string based on provided options and return the cleaned JSON string.\"\"\"\n        json_str = self.json_str\n        remove_control_chars = self.remove_control_chars\n        normalize_unicode = self.normalize_unicode\n        validate_json = self.validate_json\n\n        start = json_str.find(\"{\")\n        end = json_str.rfind(\"}\")\n        if start == -1 or end == -1:\n            msg = \"Invalid JSON string: Missing '{' or '}'\"\n            raise ValueError(msg)\n        try:\n            json_str = json_str[start : end + 1]\n\n            if remove_control_chars:\n                json_str = self._remove_control_characters(json_str)\n            if normalize_unicode:\n                json_str = self._normalize_unicode(json_str)\n            if validate_json:\n                json_str = self._validate_json(json_str)\n\n            cleaned_json_str = repair_json(json_str)\n            result = str(cleaned_json_str)\n\n            self.status = result\n            return Message(text=result)\n        except Exception as e:\n            msg = f\"Error cleaning JSON string: {e}\"\n            raise ValueError(msg) from e\n\n    def _remove_control_characters(self, s: str) -> str:\n        \"\"\"Remove control characters from the string.\"\"\"\n        return re.sub(r\"[\\x00-\\x1F\\x7F]\", \"\", s)\n\n    def _normalize_unicode(self, s: str) -> str:\n        \"\"\"Normalize Unicode characters in the string.\"\"\"\n        return unicodedata.normalize(\"NFC\", s)\n\n    def _validate_json(self, s: str) -> str:\n        \"\"\"Validate the JSON string.\"\"\"\n        try:\n            json.loads(s)\n        except json.JSONDecodeError as e:\n            msg = f\"Invalid JSON string: {e}\"\n            raise ValueError(msg) from e\n        return s\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "json_str": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "json_str",
    //                 "value": "",
    //                 "display_name": "JSON String",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The JSON string to be cleaned.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "normalize_unicode": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "normalize_unicode",
    //                 "value": false,
    //                 "display_name": "Normalize Unicode",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Normalize Unicode characters in the JSON string.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "remove_control_chars": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "remove_control_chars",
    //                 "value": false,
    //                 "display_name": "Remove Control Characters",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Remove control characters from the JSON string.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "validate_json": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "validate_json",
    //                 "value": false,
    //                 "display_name": "Validate JSON",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Validate the JSON string to ensure it is well-formed.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Cleans the messy and sometimes incorrect JSON strings produced by LLMs so that they are fully compliant with the JSON spec.",
    //         "icon": "custom_components",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "JSON Cleaner",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "output",
    //                 "display_name": "Cleaned JSON String",
    //                 "method": "clean_json",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "json_str",
    //             "remove_control_chars",
    //             "normalize_unicode",
    //             "validate_json"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "Notify": {
    //         "template": {
    //             "_type": "CustomComponent",
    //             "data": {
    //                 "type": "Data | None",
    //                 "required": false,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "data",
    //                 "display_name": "Data",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The data to store.",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "append": {
    //                 "type": "bool",
    //                 "required": false,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "value": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "append",
    //                 "display_name": "Append",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "If True, the record will be appended to the notification.",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.custom import CustomComponent\nfrom langflow.schema import Data\n\n\nclass NotifyComponent(CustomComponent):\n    display_name = \"Notify\"\n    description = \"A component to generate a notification to Get Notified component.\"\n    icon = \"Notify\"\n    name = \"Notify\"\n    beta: bool = True\n\n    def build_config(self):\n        return {\n            \"name\": {\"display_name\": \"Name\", \"info\": \"The name of the notification.\"},\n            \"data\": {\"display_name\": \"Data\", \"info\": \"The data to store.\"},\n            \"append\": {\n                \"display_name\": \"Append\",\n                \"info\": \"If True, the record will be appended to the notification.\",\n            },\n        }\n\n    def build(self, name: str, *, data: Data | None = None, append: bool = False) -> Data:\n        if data and not isinstance(data, Data):\n            if isinstance(data, str):\n                data = Data(text=data)\n            elif isinstance(data, dict):\n                data = Data(data=data)\n            else:\n                data = Data(text=str(data))\n        elif not data:\n            data = Data(text=\"\")\n        if data:\n            if append:\n                self.append_state(name, data)\n            else:\n                self.update_state(name, data)\n        else:\n            self.status = \"No record provided.\"\n        self.status = data\n        self._set_successors_ids()\n        return data\n\n    def _set_successors_ids(self):\n        self._vertex.is_state = True\n        successors = self._vertex.graph.successor_map.get(self._vertex.id, [])\n        return successors + self._vertex.graph.activated_vertices\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "name": {
    //                 "type": "str",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "name",
    //                 "display_name": "Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The name of the notification.",
    //                 "load_from_db": false,
    //                 "title_case": false,
    //                 "input_types": [
    //                     "Text"
    //                 ]
    //             }
    //         },
    //         "description": "A component to generate a notification to Get Notified component.",
    //         "icon": "Notify",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Notify",
    //         "documentation": "",
    //         "custom_fields": {
    //             "name": null,
    //             "data": null,
    //             "append": null
    //         },
    //         "output_types": [
    //             "Data"
    //         ],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "hidden": null,
    //                 "display_name": "Data",
    //                 "method": null,
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": null
    //             }
    //         ],
    //         "field_order": [],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "RunnableExecutor": {
    //         "template": {
    //             "_type": "Component",
    //             "runnable": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "runnable",
    //                 "value": "",
    //                 "display_name": "Agent Executor",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Chain",
    //                     "AgentExecutor",
    //                     "Agent",
    //                     "Runnable"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain.agents import AgentExecutor\n\nfrom langflow.custom import Component\nfrom langflow.inputs import BoolInput, HandleInput, MessageTextInput\nfrom langflow.schema.message import Message\nfrom langflow.template import Output\n\n\nclass RunnableExecComponent(Component):\n    description = \"Execute a runnable. It will try to guess the input and output keys.\"\n    display_name = \"Runnable Executor\"\n    name = \"RunnableExecutor\"\n    beta: bool = True\n\n    inputs = [\n        MessageTextInput(name=\"input_value\", display_name=\"Input\", required=True),\n        HandleInput(\n            name=\"runnable\",\n            display_name=\"Agent Executor\",\n            input_types=[\"Chain\", \"AgentExecutor\", \"Agent\", \"Runnable\"],\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"input_key\",\n            display_name=\"Input Key\",\n            value=\"input\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"output_key\",\n            display_name=\"Output Key\",\n            value=\"output\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"use_stream\",\n            display_name=\"Stream\",\n            value=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Text\",\n            name=\"text\",\n            method=\"build_executor\",\n        ),\n    ]\n\n    def get_output(self, result, input_key, output_key):\n        \"\"\"Retrieves the output value from the given result dictionary based on the specified input and output keys.\n\n        Args:\n            result (dict): The result dictionary containing the output value.\n            input_key (str): The key used to retrieve the input value from the result dictionary.\n            output_key (str): The key used to retrieve the output value from the result dictionary.\n\n        Returns:\n            tuple: A tuple containing the output value and the status message.\n\n        \"\"\"\n        possible_output_keys = [\"answer\", \"response\", \"output\", \"result\", \"text\"]\n        status = \"\"\n        result_value = None\n\n        if output_key in result:\n            result_value = result.get(output_key)\n        elif len(result) == 2 and input_key in result:  # noqa: PLR2004\n            # get the other key from the result dict\n            other_key = next(k for k in result if k != input_key)\n            if other_key == output_key:\n                result_value = result.get(output_key)\n            else:\n                status += f\"Warning: The output key is not '{output_key}'. The output key is '{other_key}'.\"\n                result_value = result.get(other_key)\n        elif len(result) == 1:\n            result_value = next(iter(result.values()))\n        elif any(k in result for k in possible_output_keys):\n            for key in possible_output_keys:\n                if key in result:\n                    result_value = result.get(key)\n                    status += f\"Output key: '{key}'.\"\n                    break\n            if result_value is None:\n                result_value = result\n                status += f\"Warning: The output key is not '{output_key}'.\"\n        else:\n            result_value = result\n            status += f\"Warning: The output key is not '{output_key}'.\"\n\n        return result_value, status\n\n    def get_input_dict(self, runnable, input_key, input_value):\n        \"\"\"Returns a dictionary containing the input key-value pair for the given runnable.\n\n        Args:\n            runnable: The runnable object.\n            input_key: The key for the input value.\n            input_value: The value for the input key.\n\n        Returns:\n            input_dict: A dictionary containing the input key-value pair.\n            status: A status message indicating if the input key is not in the runnable's input keys.\n        \"\"\"\n        input_dict = {}\n        status = \"\"\n        if hasattr(runnable, \"input_keys\"):\n            # Check if input_key is in the runnable's input_keys\n            if input_key in runnable.input_keys:\n                input_dict[input_key] = input_value\n            else:\n                input_dict = dict.fromkeys(runnable.input_keys, input_value)\n                status = f\"Warning: The input key is not '{input_key}'. The input key is '{runnable.input_keys}'.\"\n        return input_dict, status\n\n    async def build_executor(self) -> Message:\n        input_dict, status = self.get_input_dict(self.runnable, self.input_key, self.input_value)\n        if not isinstance(self.runnable, AgentExecutor):\n            msg = \"The runnable must be an AgentExecutor\"\n            raise TypeError(msg)\n\n        if self.use_stream:\n            return self.astream_events(input_dict)\n        result = await self.runnable.ainvoke(input_dict)\n        result_value, _status = self.get_output(result, self.input_key, self.output_key)\n        status += _status\n        status += f\"\\n\\nOutput: {result_value}\\n\\nRaw Output: {result}\"\n        self.status = status\n        return result_value\n\n    async def astream_events(self, runnable_input):\n        async for event in self.runnable.astream_events(runnable_input, version=\"v1\"):\n            if event.get(\"event\") != \"on_chat_model_stream\":\n                continue\n\n            yield event.get(\"data\").get(\"chunk\")\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_key": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_key",
    //                 "value": "input",
    //                 "display_name": "Input Key",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "output_key": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "output_key",
    //                 "value": "output",
    //                 "display_name": "Output Key",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "use_stream": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "use_stream",
    //                 "value": false,
    //                 "display_name": "Stream",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Execute a runnable. It will try to guess the input and output keys.",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Runnable Executor",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text",
    //                 "display_name": "Text",
    //                 "method": "build_executor",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "runnable",
    //             "input_key",
    //             "output_key",
    //             "use_stream"
    //         ],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "ConditionalRouter": {
    //         "template": {
    //             "_type": "Component",
    //             "case_sensitive": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "case_sensitive",
    //                 "value": false,
    //                 "display_name": "Case Sensitive",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "If true, the comparison will be case sensitive.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DropdownInput, MessageInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\n\n\nclass ConditionalRouterComponent(Component):\n    display_name = \"Conditional Router\"\n    description = \"Routes an input message to a corresponding output based on text comparison.\"\n    icon = \"equal\"\n    name = \"ConditionalRouter\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_text\",\n            display_name=\"Input Text\",\n            info=\"The primary text input for the operation.\",\n        ),\n        MessageTextInput(\n            name=\"match_text\",\n            display_name=\"Match Text\",\n            info=\"The text input to compare against.\",\n        ),\n        DropdownInput(\n            name=\"operator\",\n            display_name=\"Operator\",\n            options=[\"equals\", \"not equals\", \"contains\", \"starts with\", \"ends with\"],\n            info=\"The operator to apply for comparing the texts.\",\n            value=\"equals\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"case_sensitive\",\n            display_name=\"Case Sensitive\",\n            info=\"If true, the comparison will be case sensitive.\",\n            value=False,\n            advanced=True,\n        ),\n        MessageInput(\n            name=\"message\",\n            display_name=\"Message\",\n            info=\"The message to pass through either route.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"True Route\", name=\"true_result\", method=\"true_response\"),\n        Output(display_name=\"False Route\", name=\"false_result\", method=\"false_response\"),\n    ]\n\n    def evaluate_condition(self, input_text: str, match_text: str, operator: str, *, case_sensitive: bool) -> bool:\n        if not case_sensitive:\n            input_text = input_text.lower()\n            match_text = match_text.lower()\n\n        if operator == \"equals\":\n            return input_text == match_text\n        if operator == \"not equals\":\n            return input_text != match_text\n        if operator == \"contains\":\n            return match_text in input_text\n        if operator == \"starts with\":\n            return input_text.startswith(match_text)\n        if operator == \"ends with\":\n            return input_text.endswith(match_text)\n        return False\n\n    def true_response(self) -> Message:\n        result = self.evaluate_condition(\n            self.input_text, self.match_text, self.operator, case_sensitive=self.case_sensitive\n        )\n        if result:\n            self.status = self.message\n            return self.message\n        self.stop(\"true_result\")\n        return None  # type: ignore[return-value]\n\n    def false_response(self) -> Message:\n        result = self.evaluate_condition(\n            self.input_text, self.match_text, self.operator, case_sensitive=self.case_sensitive\n        )\n        if not result:\n            self.status = self.message\n            return self.message\n        self.stop(\"false_result\")\n        return None  # type: ignore[return-value]\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_text": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_text",
    //                 "value": "",
    //                 "display_name": "Input Text",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The primary text input for the operation.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "match_text": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "match_text",
    //                 "value": "",
    //                 "display_name": "Match Text",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The text input to compare against.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "message",
    //                 "value": "",
    //                 "display_name": "Message",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The message to pass through either route.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "operator": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "equals",
    //                     "not equals",
    //                     "contains",
    //                     "starts with",
    //                     "ends with"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "operator",
    //                 "value": "equals",
    //                 "display_name": "Operator",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The operator to apply for comparing the texts.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             }
    //         },
    //         "description": "Routes an input message to a corresponding output based on text comparison.",
    //         "icon": "equal",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Conditional Router",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "true_result",
    //                 "display_name": "True Route",
    //                 "method": "true_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             },
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "false_result",
    //                 "display_name": "False Route",
    //                 "method": "false_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "input_text",
    //             "match_text",
    //             "operator",
    //             "case_sensitive",
    //             "message"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "RunFlow": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import TYPE_CHECKING, Any\n\nfrom typing_extensions import override\n\nfrom langflow.base.flow_processing.utils import build_data_from_run_outputs\nfrom langflow.custom import Component\nfrom langflow.io import DropdownInput, MessageTextInput, NestedDictInput, Output\nfrom langflow.schema import Data, dotdict\n\nif TYPE_CHECKING:\n    from langflow.graph.schema import RunOutputs\n\n\nclass RunFlowComponent(Component):\n    display_name = \"Run Flow\"\n    description = \"A component to run a flow.\"\n    name = \"RunFlow\"\n    beta: bool = True\n\n    def get_flow_names(self) -> list[str]:\n        flow_data = self.list_flows()\n        return [flow_data.data[\"name\"] for flow_data in flow_data]\n\n    @override\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"flow_name\":\n            build_config[\"flow_name\"][\"options\"] = self.get_flow_names()\n\n        return build_config\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_value\",\n            display_name=\"Input Value\",\n            info=\"The input value to be processed by the flow.\",\n        ),\n        DropdownInput(\n            name=\"flow_name\",\n            display_name=\"Flow Name\",\n            info=\"The name of the flow to run.\",\n            options=[],\n            refresh_button=True,\n        ),\n        NestedDictInput(\n            name=\"tweaks\",\n            display_name=\"Tweaks\",\n            info=\"Tweaks to apply to the flow.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Run Outputs\", name=\"run_outputs\", method=\"generate_results\"),\n    ]\n\n    async def generate_results(self) -> list[Data]:\n        if \"flow_name\" not in self._attributes or not self._attributes[\"flow_name\"]:\n            msg = \"Flow name is required\"\n            raise ValueError(msg)\n        flow_name = self._attributes[\"flow_name\"]\n\n        results: list[RunOutputs | None] = await self.run_flow(\n            inputs={\"input_value\": self.input_value}, flow_name=flow_name, tweaks=self.tweaks\n        )\n        if isinstance(results, list):\n            data = []\n            for result in results:\n                if result:\n                    data.extend(build_data_from_run_outputs(result))\n        else:\n            data = build_data_from_run_outputs()(results)\n\n        self.status = data\n        return data\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "flow_name": {
    //                 "trace_as_metadata": true,
    //                 "options": [],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "flow_name",
    //                 "value": "",
    //                 "display_name": "Flow Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The name of the flow to run.",
    //                 "refresh_button": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input Value",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The input value to be processed by the flow.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "tweaks": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tweaks",
    //                 "value": {},
    //                 "display_name": "Tweaks",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Tweaks to apply to the flow.",
    //                 "title_case": false,
    //                 "type": "NestedDict",
    //                 "_input_type": "NestedDictInput"
    //             }
    //         },
    //         "description": "A component to run a flow.",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Run Flow",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "run_outputs",
    //                 "display_name": "Run Outputs",
    //                 "method": "generate_results",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "flow_name",
    //             "tweaks"
    //         ],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "SelectData": {
    //         "template": {
    //             "_type": "Component",
    //             "data_list": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "data_list",
    //                 "value": "",
    //                 "display_name": "Data List",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "List of data to select from.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.custom import Component\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs.inputs import DataInput, IntInput\nfrom langflow.io import Output\nfrom langflow.schema import Data\n\n\nclass SelectDataComponent(Component):\n    display_name: str = \"Select Data\"\n    description: str = \"Select a single data from a list of data.\"\n    name: str = \"SelectData\"\n    icon = \"prototypes\"\n\n    inputs = [\n        DataInput(\n            name=\"data_list\",\n            display_name=\"Data List\",\n            info=\"List of data to select from.\",\n            is_list=True,  # Specify that this input takes a list of Data objects\n        ),\n        IntInput(\n            name=\"data_index\",\n            display_name=\"Data Index\",\n            info=\"Index of the data to select.\",\n            value=0,  # Will be populated dynamically based on the length of data_list\n            range_spec=RangeSpec(min=0, max=15, step=1, step_type=\"int\"),\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Selected Data\", name=\"selected_data\", method=\"select_data\"),\n    ]\n\n    async def select_data(self) -> Data:\n        # Retrieve the selected index from the dropdown\n        selected_index = int(self.data_index)\n        # Get the data list\n\n        # Validate that the selected index is within bounds\n        if selected_index < 0 or selected_index >= len(self.data_list):\n            msg = f\"Selected index {selected_index} is out of range.\"\n            raise ValueError(msg)\n\n        # Return the selected Data object\n        selected_data = self.data_list[selected_index]\n        self.status = selected_data  # Update the component status to reflect the selected data\n        return selected_data\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "data_index": {
    //                 "trace_as_metadata": true,
    //                 "range_spec": {
    //                     "step_type": "int",
    //                     "min": 0.0,
    //                     "max": 15.0,
    //                     "step": 1.0
    //                 },
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "data_index",
    //                 "value": 0,
    //                 "display_name": "Data Index",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Index of the data to select.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             }
    //         },
    //         "description": "Select a single data from a list of data.",
    //         "icon": "prototypes",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Select Data",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "selected_data",
    //                 "display_name": "Selected Data",
    //                 "method": "select_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "data_list",
    //             "data_index"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "Listen": {
    //         "template": {
    //             "_type": "CustomComponent",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.custom import CustomComponent\nfrom langflow.schema import Data\n\n\nclass ListenComponent(CustomComponent):\n    display_name = \"Listen\"\n    description = \"A component to listen for a notification.\"\n    name = \"Listen\"\n    beta: bool = True\n\n    def build_config(self):\n        return {\n            \"name\": {\n                \"display_name\": \"Name\",\n                \"info\": \"The name of the notification to listen for.\",\n            },\n        }\n\n    def build(self, name: str) -> Data:\n        state = self.get_state(name)\n        self._set_successors_ids()\n        self.status = state\n        return state\n\n    def _set_successors_ids(self):\n        self._vertex.is_state = True\n        successors = self._vertex.graph.successor_map.get(self._vertex.id, [])\n        return successors + self._vertex.graph.activated_vertices\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "name": {
    //                 "type": "str",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": false,
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "name": "name",
    //                 "display_name": "Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The name of the notification to listen for.",
    //                 "load_from_db": false,
    //                 "title_case": false,
    //                 "input_types": [
    //                     "Text"
    //                 ]
    //             }
    //         },
    //         "description": "A component to listen for a notification.",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Listen",
    //         "documentation": "",
    //         "custom_fields": {
    //             "name": null
    //         },
    //         "output_types": [
    //             "Data"
    //         ],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "hidden": null,
    //                 "display_name": "Data",
    //                 "method": null,
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": null
    //             }
    //         ],
    //         "field_order": [],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "CreateData": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs.inputs import BoolInput, DictInput, IntInput, MessageTextInput\nfrom langflow.io import Output\nfrom langflow.schema import Data\nfrom langflow.schema.dotdict import dotdict\n\nMAX_NUMBER_OF_FIELDS = 15\n\n\nclass CreateDataComponent(Component):\n    display_name: str = \"Create Data\"\n    description: str = \"Dynamically create a Data with a specified number of fields.\"\n    name: str = \"CreateData\"\n\n    inputs = [\n        IntInput(\n            name=\"number_of_fields\",\n            display_name=\"Number of Fields\",\n            info=\"Number of fields to be added to the record.\",\n            real_time_refresh=True,\n            value=1,\n            range_spec=RangeSpec(min=1, max=15, step=1, step_type=\"int\"),\n        ),\n        MessageTextInput(\n            name=\"text_key\",\n            display_name=\"Text Key\",\n            info=\"Key that identifies the field to be used as the text content.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"text_key_validator\",\n            display_name=\"Text Key Validator\",\n            advanced=True,\n            info=\"If enabled, checks if the given 'Text Key' is present in the given 'Data'.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"build_data\"),\n    ]\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"number_of_fields\":\n            default_keys = [\"code\", \"_type\", \"number_of_fields\", \"text_key\", \"text_key_validator\"]\n            try:\n                field_value_int = int(field_value)\n            except ValueError:\n                return build_config\n            existing_fields = {}\n            if field_value_int > MAX_NUMBER_OF_FIELDS:\n                build_config[\"number_of_fields\"][\"value\"] = MAX_NUMBER_OF_FIELDS\n                msg = (\n                    f\"Number of fields cannot exceed {MAX_NUMBER_OF_FIELDS}. Try using a Component to combine two Data.\"\n                )\n                raise ValueError(msg)\n            if len(build_config) > len(default_keys):\n                # back up the existing template fields\n                for key in build_config.copy():\n                    if key not in default_keys:\n                        existing_fields[key] = build_config.pop(key)\n\n            for i in range(1, field_value_int + 1):\n                key = f\"field_{i}_key\"\n                if key in existing_fields:\n                    field = existing_fields[key]\n                    build_config[key] = field\n                else:\n                    field = DictInput(\n                        display_name=f\"Field {i}\",\n                        name=key,\n                        info=f\"Key for field {i}.\",\n                        input_types=[\"Text\", \"Data\"],\n                    )\n                    build_config[field.name] = field.to_dict()\n\n            build_config[\"number_of_fields\"][\"value\"] = field_value_int\n        return build_config\n\n    async def build_data(self) -> Data:\n        data = self.get_data()\n        return_data = Data(data=data, text_key=self.text_key)\n        self.status = return_data\n        if self.text_key_validator:\n            self.validate_text_key()\n        return return_data\n\n    def get_data(self):\n        \"\"\"Function to get the Data from the attributes.\"\"\"\n        data = {}\n        for value_dict in self._attributes.values():\n            if isinstance(value_dict, dict):\n                # Check if the value of the value_dict is a Data\n                _value_dict = {\n                    key: value.get_text() if isinstance(value, Data) else value for key, value in value_dict.items()\n                }\n                data.update(_value_dict)\n        return data\n\n    def validate_text_key(self) -> None:\n        \"\"\"This function validates that the Text Key is one of the keys in the Data.\"\"\"\n        data_keys = self.get_data().keys()\n        if self.text_key not in data_keys and self.text_key != \"\":\n            formatted_data_keys = \", \".join(data_keys)\n            msg = f\"Text Key: '{self.text_key}' not found in the Data keys: '{formatted_data_keys}'\"\n            raise ValueError(msg)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "number_of_fields": {
    //                 "trace_as_metadata": true,
    //                 "range_spec": {
    //                     "step_type": "int",
    //                     "min": 1.0,
    //                     "max": 15.0,
    //                     "step": 1.0
    //                 },
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "number_of_fields",
    //                 "value": 1,
    //                 "display_name": "Number of Fields",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Number of fields to be added to the record.",
    //                 "real_time_refresh": true,
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "text_key": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "text_key",
    //                 "value": "",
    //                 "display_name": "Text Key",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Key that identifies the field to be used as the text content.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "text_key_validator": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "text_key_validator",
    //                 "value": false,
    //                 "display_name": "Text Key Validator",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "If enabled, checks if the given 'Text Key' is present in the given 'Data'.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Dynamically create a Data with a specified number of fields.",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Create Data",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "display_name": "Data",
    //                 "method": "build_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "number_of_fields",
    //             "text_key",
    //             "text_key_validator"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "Pass": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.custom import Component\nfrom langflow.io import MessageInput\nfrom langflow.schema.message import Message\nfrom langflow.template import Output\n\n\nclass PassMessageComponent(Component):\n    display_name = \"Pass\"\n    description = \"Forwards the input message, unchanged.\"\n    name = \"Pass\"\n    icon = \"arrow-right\"\n\n    inputs = [\n        MessageInput(\n            name=\"input_message\",\n            display_name=\"Input Message\",\n            info=\"The message to be passed forward.\",\n        ),\n        MessageInput(\n            name=\"ignored_message\",\n            display_name=\"Ignored Message\",\n            info=\"A second message to be ignored. Used as a workaround for continuity.\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Output Message\", name=\"output_message\", method=\"pass_message\"),\n    ]\n\n    def pass_message(self) -> Message:\n        self.status = self.input_message\n        return self.input_message\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "ignored_message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "ignored_message",
    //                 "value": "",
    //                 "display_name": "Ignored Message",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "A second message to be ignored. Used as a workaround for continuity.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "input_message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_message",
    //                 "value": "",
    //                 "display_name": "Input Message",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The message to be passed forward.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             }
    //         },
    //         "description": "Forwards the input message, unchanged.",
    //         "icon": "arrow-right",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Pass",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "output_message",
    //                 "display_name": "Output Message",
    //                 "method": "pass_message",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "input_message",
    //             "ignored_message"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "textsplitters": {
    //     "LanguageRecursiveTextSplitter": {
    //         "template": {
    //             "_type": "Component",
    //             "data_input": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "data_input",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Document",
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The texts to split.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "chunk_overlap": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chunk_overlap",
    //                 "value": 200,
    //                 "display_name": "Chunk Overlap",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The amount of overlap between chunks.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "chunk_size": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chunk_size",
    //                 "value": 1000,
    //                 "display_name": "Chunk Size",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The maximum length of each chunk.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom langchain_text_splitters import Language, RecursiveCharacterTextSplitter, TextSplitter\n\nfrom langflow.base.textsplitters.model import LCTextSplitterComponent\nfrom langflow.inputs import DataInput, DropdownInput, IntInput\n\n\nclass LanguageRecursiveTextSplitterComponent(LCTextSplitterComponent):\n    display_name: str = \"Language Recursive Text Splitter\"\n    description: str = \"Split text into chunks of a specified length based on language.\"\n    documentation: str = \"https://docs.langflow.org/components/text-splitters#languagerecursivetextsplitter\"\n    name = \"LanguageRecursiveTextSplitter\"\n\n    inputs = [\n        IntInput(\n            name=\"chunk_size\",\n            display_name=\"Chunk Size\",\n            info=\"The maximum length of each chunk.\",\n            value=1000,\n        ),\n        IntInput(\n            name=\"chunk_overlap\",\n            display_name=\"Chunk Overlap\",\n            info=\"The amount of overlap between chunks.\",\n            value=200,\n        ),\n        DataInput(\n            name=\"data_input\",\n            display_name=\"Input\",\n            info=\"The texts to split.\",\n            input_types=[\"Document\", \"Data\"],\n        ),\n        DropdownInput(\n            name=\"code_language\", display_name=\"Code Language\", options=[x.value for x in Language], value=\"python\"\n        ),\n    ]\n\n    def get_data_input(self) -> Any:\n        return self.data_input\n\n    def build_text_splitter(self) -> TextSplitter:\n        return RecursiveCharacterTextSplitter.from_language(\n            language=Language(self.code_language),\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "code_language": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "cpp",
    //                     "go",
    //                     "java",
    //                     "kotlin",
    //                     "js",
    //                     "ts",
    //                     "php",
    //                     "proto",
    //                     "python",
    //                     "rst",
    //                     "ruby",
    //                     "rust",
    //                     "scala",
    //                     "swift",
    //                     "markdown",
    //                     "latex",
    //                     "html",
    //                     "sol",
    //                     "csharp",
    //                     "cobol",
    //                     "c",
    //                     "lua",
    //                     "perl",
    //                     "haskell",
    //                     "elixir",
    //                     "powershell"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "code_language",
    //                 "value": "python",
    //                 "display_name": "Code Language",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             }
    //         },
    //         "description": "Split text into chunks of a specified length based on language.",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Language Recursive Text Splitter",
    //         "documentation": "https://docs.langflow.org/components/text-splitters#languagerecursivetextsplitter",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "display_name": "Data",
    //                 "method": "transform_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "chunk_size",
    //             "chunk_overlap",
    //             "data_input",
    //             "code_language"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "NaturalLanguageTextSplitter": {
    //         "template": {
    //             "_type": "Component",
    //             "data_input": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "data_input",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Document",
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The text data to be split.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "chunk_overlap": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chunk_overlap",
    //                 "value": 200,
    //                 "display_name": "Chunk Overlap",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The number of characters that overlap between consecutive chunks.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "chunk_size": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chunk_size",
    //                 "value": 1000,
    //                 "display_name": "Chunk Size",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The maximum number of characters in each chunk after splitting.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom langchain_text_splitters import NLTKTextSplitter, TextSplitter\n\nfrom langflow.base.textsplitters.model import LCTextSplitterComponent\nfrom langflow.inputs import DataInput, IntInput, MessageTextInput\nfrom langflow.utils.util import unescape_string\n\n\nclass NaturalLanguageTextSplitterComponent(LCTextSplitterComponent):\n    display_name = \"Natural Language Text Splitter\"\n    description = \"Split text based on natural language boundaries, optimized for a specified language.\"\n    documentation = (\n        \"https://python.langchain.com/v0.1/docs/modules/data_connection/document_transformers/split_by_token/#nltk\"\n    )\n    name = \"NaturalLanguageTextSplitter\"\n\n    inputs = [\n        IntInput(\n            name=\"chunk_size\",\n            display_name=\"Chunk Size\",\n            info=\"The maximum number of characters in each chunk after splitting.\",\n            value=1000,\n        ),\n        IntInput(\n            name=\"chunk_overlap\",\n            display_name=\"Chunk Overlap\",\n            info=\"The number of characters that overlap between consecutive chunks.\",\n            value=200,\n        ),\n        DataInput(\n            name=\"data_input\",\n            display_name=\"Input\",\n            info=\"The text data to be split.\",\n            input_types=[\"Document\", \"Data\"],\n        ),\n        MessageTextInput(\n            name=\"separator\",\n            display_name=\"Separator\",\n            info='The character(s) to use as a delimiter when splitting text.\\nDefaults to \"\\\\n\\\\n\" if left empty.',\n        ),\n        MessageTextInput(\n            name=\"language\",\n            display_name=\"Language\",\n            info='The language of the text. Default is \"English\". '\n            \"Supports multiple languages for better text boundary recognition.\",\n        ),\n    ]\n\n    def get_data_input(self) -> Any:\n        return self.data_input\n\n    def build_text_splitter(self) -> TextSplitter:\n        separator = unescape_string(self.separator) if self.separator else \"\\n\\n\"\n        return NLTKTextSplitter(\n            language=self.language.lower() if self.language else \"english\",\n            separator=separator,\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "language": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "language",
    //                 "value": "",
    //                 "display_name": "Language",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The language of the text. Default is \"English\". Supports multiple languages for better text boundary recognition.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "separator": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "separator",
    //                 "value": "",
    //                 "display_name": "Separator",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The character(s) to use as a delimiter when splitting text.\nDefaults to \"\\n\\n\" if left empty.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Split text based on natural language boundaries, optimized for a specified language.",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Natural Language Text Splitter",
    //         "documentation": "https://python.langchain.com/v0.1/docs/modules/data_connection/document_transformers/split_by_token/#nltk",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "display_name": "Data",
    //                 "method": "transform_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "chunk_size",
    //             "chunk_overlap",
    //             "data_input",
    //             "separator",
    //             "language"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "CharacterTextSplitter": {
    //         "template": {
    //             "_type": "Component",
    //             "data_input": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "data_input",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Document",
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The texts to split.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "chunk_overlap": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chunk_overlap",
    //                 "value": 200,
    //                 "display_name": "Chunk Overlap",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The amount of overlap between chunks.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "chunk_size": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chunk_size",
    //                 "value": 1000,
    //                 "display_name": "Chunk Size",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The maximum length of each chunk.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom langchain_text_splitters import CharacterTextSplitter, TextSplitter\n\nfrom langflow.base.textsplitters.model import LCTextSplitterComponent\nfrom langflow.inputs import DataInput, IntInput, MessageTextInput\nfrom langflow.utils.util import unescape_string\n\n\nclass CharacterTextSplitterComponent(LCTextSplitterComponent):\n    display_name = \"CharacterTextSplitter\"\n    description = \"Split text by number of characters.\"\n    documentation = \"https://docs.langflow.org/components/text-splitters#charactertextsplitter\"\n    name = \"CharacterTextSplitter\"\n\n    inputs = [\n        IntInput(\n            name=\"chunk_size\",\n            display_name=\"Chunk Size\",\n            info=\"The maximum length of each chunk.\",\n            value=1000,\n        ),\n        IntInput(\n            name=\"chunk_overlap\",\n            display_name=\"Chunk Overlap\",\n            info=\"The amount of overlap between chunks.\",\n            value=200,\n        ),\n        DataInput(\n            name=\"data_input\",\n            display_name=\"Input\",\n            info=\"The texts to split.\",\n            input_types=[\"Document\", \"Data\"],\n        ),\n        MessageTextInput(\n            name=\"separator\",\n            display_name=\"Separator\",\n            info='The characters to split on.\\nIf left empty defaults to \"\\\\n\\\\n\".',\n        ),\n    ]\n\n    def get_data_input(self) -> Any:\n        return self.data_input\n\n    def build_text_splitter(self) -> TextSplitter:\n        separator = unescape_string(self.separator) if self.separator else \"\\n\\n\"\n        return CharacterTextSplitter(\n            chunk_overlap=self.chunk_overlap,\n            chunk_size=self.chunk_size,\n            separator=separator,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "separator": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "separator",
    //                 "value": "",
    //                 "display_name": "Separator",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The characters to split on.\nIf left empty defaults to \"\\n\\n\".",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Split text by number of characters.",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "CharacterTextSplitter",
    //         "documentation": "https://docs.langflow.org/components/text-splitters#charactertextsplitter",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "display_name": "Data",
    //                 "method": "transform_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "chunk_size",
    //             "chunk_overlap",
    //             "data_input",
    //             "separator"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "RecursiveCharacterTextSplitter": {
    //         "template": {
    //             "_type": "Component",
    //             "data_input": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "data_input",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Document",
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The texts to split.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "chunk_overlap": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chunk_overlap",
    //                 "value": 200,
    //                 "display_name": "Chunk Overlap",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The amount of overlap between chunks.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "chunk_size": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chunk_size",
    //                 "value": 1000,
    //                 "display_name": "Chunk Size",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The maximum length of each chunk.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom langchain_text_splitters import RecursiveCharacterTextSplitter, TextSplitter\n\nfrom langflow.base.textsplitters.model import LCTextSplitterComponent\nfrom langflow.inputs.inputs import DataInput, IntInput, MessageTextInput\nfrom langflow.utils.util import unescape_string\n\n\nclass RecursiveCharacterTextSplitterComponent(LCTextSplitterComponent):\n    display_name: str = \"Recursive Character Text Splitter\"\n    description: str = \"Split text trying to keep all related text together.\"\n    documentation: str = \"https://docs.langflow.org/components/text-splitters#recursivecharactertextsplitter\"\n    name = \"RecursiveCharacterTextSplitter\"\n\n    inputs = [\n        IntInput(\n            name=\"chunk_size\",\n            display_name=\"Chunk Size\",\n            info=\"The maximum length of each chunk.\",\n            value=1000,\n        ),\n        IntInput(\n            name=\"chunk_overlap\",\n            display_name=\"Chunk Overlap\",\n            info=\"The amount of overlap between chunks.\",\n            value=200,\n        ),\n        DataInput(\n            name=\"data_input\",\n            display_name=\"Input\",\n            info=\"The texts to split.\",\n            input_types=[\"Document\", \"Data\"],\n        ),\n        MessageTextInput(\n            name=\"separators\",\n            display_name=\"Separators\",\n            info='The characters to split on.\\nIf left empty defaults to [\"\\\\n\\\\n\", \"\\\\n\", \" \", \"\"].',\n            is_list=True,\n        ),\n    ]\n\n    def get_data_input(self) -> Any:\n        return self.data_input\n\n    def build_text_splitter(self) -> TextSplitter:\n        if not self.separators:\n            separators: list[str] | None = None\n        else:\n            # check if the separators list has escaped characters\n            # if there are escaped characters, unescape them\n            separators = [unescape_string(x) for x in self.separators]\n\n        return RecursiveCharacterTextSplitter(\n            separators=separators,\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "separators": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "separators",
    //                 "value": "",
    //                 "display_name": "Separators",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The characters to split on.\nIf left empty defaults to [\"\\n\\n\", \"\\n\", \" \", \"\"].",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Split text trying to keep all related text together.",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Recursive Character Text Splitter",
    //         "documentation": "https://docs.langflow.org/components/text-splitters#recursivecharactertextsplitter",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "display_name": "Data",
    //                 "method": "transform_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": []
    //             }
    //         ],
    //         "field_order": [
    //             "chunk_size",
    //             "chunk_overlap",
    //             "data_input",
    //             "separators"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "assemblyai": {
    //     "AssemblyAIListTranscripts": {
    //         "template": {
    //             "_type": "Component",
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "Assembly API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Your AssemblyAI API key. You can get one from https://www.assemblyai.com/",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import assemblyai as aai\nfrom loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageTextInput, Output, SecretStrInput\nfrom langflow.schema import Data\n\n\nclass AssemblyAIListTranscripts(Component):\n    display_name = \"AssemblyAI List Transcripts\"\n    description = \"Retrieve a list of transcripts from AssemblyAI with filtering options\"\n    documentation = \"https://www.assemblyai.com/docs\"\n    icon = \"AssemblyAI\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Assembly API Key\",\n            info=\"Your AssemblyAI API key. You can get one from https://www.assemblyai.com/\",\n        ),\n        IntInput(\n            name=\"limit\",\n            display_name=\"Limit\",\n            info=\"Maximum number of transcripts to retrieve (default: 20, use 0 for all)\",\n            value=20,\n        ),\n        DropdownInput(\n            name=\"status_filter\",\n            display_name=\"Status Filter\",\n            options=[\"all\", \"queued\", \"processing\", \"completed\", \"error\"],\n            value=\"all\",\n            info=\"Filter by transcript status\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"created_on\",\n            display_name=\"Created On\",\n            info=\"Only get transcripts created on this date (YYYY-MM-DD)\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"throttled_only\",\n            display_name=\"Throttled Only\",\n            info=\"Only get throttled transcripts, overrides the status filter\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Transcript List\", name=\"transcript_list\", method=\"list_transcripts\"),\n    ]\n\n    def list_transcripts(self) -> list[Data]:\n        aai.settings.api_key = self.api_key\n\n        params = aai.ListTranscriptParameters()\n        if self.limit:\n            params.limit = self.limit\n        if self.status_filter != \"all\":\n            params.status = self.status_filter\n        if self.created_on and self.created_on.text:\n            params.created_on = self.created_on.text\n        if self.throttled_only:\n            params.throttled_only = True\n\n        try:\n            transcriber = aai.Transcriber()\n\n            def convert_page_to_data_list(page):\n                return [Data(**t.dict()) for t in page.transcripts]\n\n            if self.limit == 0:\n                # paginate over all pages\n                params.limit = 100\n                page = transcriber.list_transcripts(params)\n                transcripts = convert_page_to_data_list(page)\n\n                while page.page_details.before_id_of_prev_url is not None:\n                    params.before_id = page.page_details.before_id_of_prev_url\n                    page = transcriber.list_transcripts(params)\n                    transcripts.extend(convert_page_to_data_list(page))\n            else:\n                # just one page\n                page = transcriber.list_transcripts(params)\n                transcripts = convert_page_to_data_list(page)\n\n        except Exception as e:  # noqa: BLE001\n            logger.opt(exception=True).debug(\"Error listing transcripts\")\n            error_data = Data(data={\"error\": f\"An error occurred: {e}\"})\n            self.status = [error_data]\n            return [error_data]\n\n        self.status = transcripts\n        return transcripts\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "created_on": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "created_on",
    //                 "value": "",
    //                 "display_name": "Created On",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Only get transcripts created on this date (YYYY-MM-DD)",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "limit": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "limit",
    //                 "value": 20,
    //                 "display_name": "Limit",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Maximum number of transcripts to retrieve (default: 20, use 0 for all)",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "status_filter": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "all",
    //                     "queued",
    //                     "processing",
    //                     "completed",
    //                     "error"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "status_filter",
    //                 "value": "all",
    //                 "display_name": "Status Filter",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Filter by transcript status",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "throttled_only": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "throttled_only",
    //                 "value": false,
    //                 "display_name": "Throttled Only",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Only get throttled transcripts, overrides the status filter",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Retrieve a list of transcripts from AssemblyAI with filtering options",
    //         "icon": "AssemblyAI",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "AssemblyAI List Transcripts",
    //         "documentation": "https://www.assemblyai.com/docs",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "transcript_list",
    //                 "display_name": "Transcript List",
    //                 "method": "list_transcripts",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "api_key",
    //             "limit",
    //             "status_filter",
    //             "created_on",
    //             "throttled_only"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AssemblyAILeMUR": {
    //         "template": {
    //             "_type": "Component",
    //             "transcription_result": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "transcription_result",
    //                 "value": "",
    //                 "display_name": "Transcription Result",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The transcription result from AssemblyAI",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "Assembly API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Your AssemblyAI API key. You can get one from https://www.assemblyai.com/",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import assemblyai as aai\nfrom loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.io import DataInput, DropdownInput, FloatInput, IntInput, MultilineInput, Output, SecretStrInput\nfrom langflow.schema import Data\n\n\nclass AssemblyAILeMUR(Component):\n    display_name = \"AssemblyAI LeMUR\"\n    description = \"Apply Large Language Models to spoken data using the AssemblyAI LeMUR framework\"\n    documentation = \"https://www.assemblyai.com/docs/lemur\"\n    icon = \"AssemblyAI\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Assembly API Key\",\n            info=\"Your AssemblyAI API key. You can get one from https://www.assemblyai.com/\",\n            advanced=False,\n        ),\n        DataInput(\n            name=\"transcription_result\",\n            display_name=\"Transcription Result\",\n            info=\"The transcription result from AssemblyAI\",\n        ),\n        MultilineInput(\n            name=\"prompt\",\n            display_name=\"Input Prompt\",\n            info=\"The text to prompt the model\",\n        ),\n        DropdownInput(\n            name=\"final_model\",\n            display_name=\"Final Model\",\n            options=[\"claude3_5_sonnet\", \"claude3_opus\", \"claude3_haiku\", \"claude3_sonnet\"],\n            value=\"claude3_5_sonnet\",\n            info=\"The model that is used for the final prompt after compression is performed\",\n            advanced=True,\n        ),\n        FloatInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            advanced=True,\n            value=0.0,\n            info=\"The temperature to use for the model\",\n        ),\n        IntInput(\n            name=\"max_output_size\",\n            display_name=\" Max Output Size\",\n            advanced=True,\n            value=2000,\n            info=\"Max output size in tokens, up to 4000\",\n        ),\n        DropdownInput(\n            name=\"endpoint\",\n            display_name=\"Endpoint\",\n            options=[\"task\", \"summary\", \"question-answer\"],\n            value=\"task\",\n            info=(\n                \"The LeMUR endpoint to use. For 'summary' and 'question-answer',\"\n                \" no prompt input is needed. See https://www.assemblyai.com/docs/api-reference/lemur/ for more info.\"\n            ),\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"questions\",\n            display_name=\"Questions\",\n            info=\"Comma-separated list of your questions. Only used if Endpoint is 'question-answer'\",\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"transcript_ids\",\n            display_name=\"Transcript IDs\",\n            info=(\n                \"Comma-separated list of transcript IDs. LeMUR can perform actions over multiple transcripts.\"\n                \" If provided, the Transcription Result is ignored.\"\n            ),\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"LeMUR Response\", name=\"lemur_response\", method=\"run_lemur\"),\n    ]\n\n    def run_lemur(self) -> Data:\n        \"\"\"Use the LeMUR task endpoint to input the LLM prompt.\"\"\"\n        aai.settings.api_key = self.api_key\n\n        if not self.transcription_result and not self.transcript_ids:\n            error = \"Either a Transcription Result or Transcript IDs must be provided\"\n            self.status = error\n            return Data(data={\"error\": error})\n        if self.transcription_result and self.transcription_result.data.get(\"error\"):\n            # error message from the previous step\n            self.status = self.transcription_result.data[\"error\"]\n            return self.transcription_result\n        if self.endpoint == \"task\" and not self.prompt:\n            self.status = \"No prompt specified for the task endpoint\"\n            return Data(data={\"error\": \"No prompt specified\"})\n        if self.endpoint == \"question-answer\" and not self.questions:\n            error = \"No Questions were provided for the question-answer endpoint\"\n            self.status = error\n            return Data(data={\"error\": error})\n\n        # Check for valid transcripts\n        transcript_ids = None\n        if self.transcription_result and \"id\" in self.transcription_result.data:\n            transcript_ids = [self.transcription_result.data[\"id\"]]\n        elif self.transcript_ids:\n            transcript_ids = self.transcript_ids.split(\",\") or []\n            transcript_ids = [t.strip() for t in transcript_ids]\n\n        if not transcript_ids:\n            error = \"Either a valid Transcription Result or valid Transcript IDs must be provided\"\n            self.status = error\n            return Data(data={\"error\": error})\n\n        # Get TranscriptGroup and check if there is any error\n        transcript_group = aai.TranscriptGroup(transcript_ids=transcript_ids)\n        transcript_group, failures = transcript_group.wait_for_completion(return_failures=True)\n        if failures:\n            error = f\"Getting transcriptions failed: {failures[0]}\"\n            self.status = error\n            return Data(data={\"error\": error})\n\n        for t in transcript_group.transcripts:\n            if t.status == aai.TranscriptStatus.error:\n                self.status = t.error\n                return Data(data={\"error\": t.error})\n\n        # Perform LeMUR action\n        try:\n            response = self.perform_lemur_action(transcript_group, self.endpoint)\n        except Exception as e:  # noqa: BLE001\n            logger.opt(exception=True).debug(\"Error running LeMUR\")\n            error = f\"An Error happened: {e}\"\n            self.status = error\n            return Data(data={\"error\": error})\n\n        result = Data(data=response)\n        self.status = result\n        return result\n\n    def perform_lemur_action(self, transcript_group: aai.TranscriptGroup, endpoint: str) -> dict:\n        logger.info(\"Endpoint:\", endpoint, type(endpoint))\n        if endpoint == \"task\":\n            result = transcript_group.lemur.task(\n                prompt=self.prompt,\n                final_model=self.get_final_model(self.final_model),\n                temperature=self.temperature,\n                max_output_size=self.max_output_size,\n            )\n        elif endpoint == \"summary\":\n            result = transcript_group.lemur.summarize(\n                final_model=self.get_final_model(self.final_model),\n                temperature=self.temperature,\n                max_output_size=self.max_output_size,\n            )\n        elif endpoint == \"question-answer\":\n            questions = self.questions.split(\",\")\n            questions = [aai.LemurQuestion(question=q) for q in questions]\n            result = transcript_group.lemur.question(\n                questions=questions,\n                final_model=self.get_final_model(self.final_model),\n                temperature=self.temperature,\n                max_output_size=self.max_output_size,\n            )\n        else:\n            msg = f\"Endpoint not supported: {endpoint}\"\n            raise ValueError(msg)\n\n        return result.dict()\n\n    def get_final_model(self, model_name: str) -> aai.LemurModel:\n        if model_name == \"claude3_5_sonnet\":\n            return aai.LemurModel.claude3_5_sonnet\n        if model_name == \"claude3_opus\":\n            return aai.LemurModel.claude3_opus\n        if model_name == \"claude3_haiku\":\n            return aai.LemurModel.claude3_haiku\n        if model_name == \"claude3_sonnet\":\n            return aai.LemurModel.claude3_sonnet\n        msg = f\"Model name not supported: {model_name}\"\n        raise ValueError(msg)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "endpoint": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "task",
    //                     "summary",
    //                     "question-answer"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "endpoint",
    //                 "value": "task",
    //                 "display_name": "Endpoint",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The LeMUR endpoint to use. For 'summary' and 'question-answer', no prompt input is needed. See https://www.assemblyai.com/docs/api-reference/lemur/ for more info.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "final_model": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "claude3_5_sonnet",
    //                     "claude3_opus",
    //                     "claude3_haiku",
    //                     "claude3_sonnet"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "final_model",
    //                 "value": "claude3_5_sonnet",
    //                 "display_name": "Final Model",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The model that is used for the final prompt after compression is performed",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "max_output_size": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_output_size",
    //                 "value": 2000,
    //                 "display_name": " Max Output Size",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Max output size in tokens, up to 4000",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "prompt": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "prompt",
    //                 "value": "",
    //                 "display_name": "Input Prompt",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The text to prompt the model",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "questions": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "questions",
    //                 "value": "",
    //                 "display_name": "Questions",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Comma-separated list of your questions. Only used if Endpoint is 'question-answer'",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "temperature": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "temperature",
    //                 "value": 0.0,
    //                 "display_name": "Temperature",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The temperature to use for the model",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             },
    //             "transcript_ids": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "transcript_ids",
    //                 "value": "",
    //                 "display_name": "Transcript IDs",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Comma-separated list of transcript IDs. LeMUR can perform actions over multiple transcripts. If provided, the Transcription Result is ignored.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Apply Large Language Models to spoken data using the AssemblyAI LeMUR framework",
    //         "icon": "AssemblyAI",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "AssemblyAI LeMUR",
    //         "documentation": "https://www.assemblyai.com/docs/lemur",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "lemur_response",
    //                 "display_name": "LeMUR Response",
    //                 "method": "run_lemur",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "api_key",
    //             "transcription_result",
    //             "prompt",
    //             "final_model",
    //             "temperature",
    //             "max_output_size",
    //             "endpoint",
    //             "questions",
    //             "transcript_ids"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AssemblyAIGetSubtitles": {
    //         "template": {
    //             "_type": "Component",
    //             "transcription_result": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "transcription_result",
    //                 "value": "",
    //                 "display_name": "Transcription Result",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The transcription result from AssemblyAI",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "Assembly API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Your AssemblyAI API key. You can get one from https://www.assemblyai.com/",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "chars_per_caption": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chars_per_caption",
    //                 "value": 0,
    //                 "display_name": "Characters per Caption",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The maximum number of characters per caption (0 for no limit)",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import assemblyai as aai\nfrom loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.io import DataInput, DropdownInput, IntInput, Output, SecretStrInput\nfrom langflow.schema import Data\n\n\nclass AssemblyAIGetSubtitles(Component):\n    display_name = \"AssemblyAI Get Subtitles\"\n    description = \"Export your transcript in SRT or VTT format for subtitles and closed captions\"\n    documentation = \"https://www.assemblyai.com/docs\"\n    icon = \"AssemblyAI\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Assembly API Key\",\n            info=\"Your AssemblyAI API key. You can get one from https://www.assemblyai.com/\",\n        ),\n        DataInput(\n            name=\"transcription_result\",\n            display_name=\"Transcription Result\",\n            info=\"The transcription result from AssemblyAI\",\n        ),\n        DropdownInput(\n            name=\"subtitle_format\",\n            display_name=\"Subtitle Format\",\n            options=[\"srt\", \"vtt\"],\n            value=\"srt\",\n            info=\"The format of the captions (SRT or VTT)\",\n        ),\n        IntInput(\n            name=\"chars_per_caption\",\n            display_name=\"Characters per Caption\",\n            info=\"The maximum number of characters per caption (0 for no limit)\",\n            value=0,\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Subtitles\", name=\"subtitles\", method=\"get_subtitles\"),\n    ]\n\n    def get_subtitles(self) -> Data:\n        aai.settings.api_key = self.api_key\n\n        # check if it's an error message from the previous step\n        if self.transcription_result.data.get(\"error\"):\n            self.status = self.transcription_result.data[\"error\"]\n            return self.transcription_result\n\n        try:\n            transcript_id = self.transcription_result.data[\"id\"]\n            transcript = aai.Transcript.get_by_id(transcript_id)\n        except Exception as e:  # noqa: BLE001\n            error = f\"Getting transcription failed: {e}\"\n            logger.opt(exception=True).debug(error)\n            self.status = error\n            return Data(data={\"error\": error})\n\n        if transcript.status == aai.TranscriptStatus.completed:\n            subtitles = None\n            chars_per_caption = self.chars_per_caption if self.chars_per_caption > 0 else None\n            if self.subtitle_format == \"srt\":\n                subtitles = transcript.export_subtitles_srt(chars_per_caption)\n            else:\n                subtitles = transcript.export_subtitles_vtt(chars_per_caption)\n\n            result = Data(\n                subtitles=subtitles,\n                format=self.subtitle_format,\n                transcript_id=transcript_id,\n                chars_per_caption=chars_per_caption,\n            )\n\n            self.status = result\n            return result\n        self.status = transcript.error\n        return Data(data={\"error\": transcript.error})\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "subtitle_format": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "srt",
    //                     "vtt"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "subtitle_format",
    //                 "value": "srt",
    //                 "display_name": "Subtitle Format",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The format of the captions (SRT or VTT)",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             }
    //         },
    //         "description": "Export your transcript in SRT or VTT format for subtitles and closed captions",
    //         "icon": "AssemblyAI",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "AssemblyAI Get Subtitles",
    //         "documentation": "https://www.assemblyai.com/docs",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "subtitles",
    //                 "display_name": "Subtitles",
    //                 "method": "get_subtitles",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "api_key",
    //             "transcription_result",
    //             "subtitle_format",
    //             "chars_per_caption"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AssemblyAITranscriptionJobCreator": {
    //         "template": {
    //             "_type": "Component",
    //             "audio_file": {
    //                 "trace_as_metadata": true,
    //                 "file_path": "",
    //                 "fileTypes": [
    //                     "3ga",
    //                     "8svx",
    //                     "aac",
    //                     "ac3",
    //                     "aif",
    //                     "aiff",
    //                     "alac",
    //                     "amr",
    //                     "ape",
    //                     "au",
    //                     "dss",
    //                     "flac",
    //                     "flv",
    //                     "m4a",
    //                     "m4b",
    //                     "m4p",
    //                     "m4r",
    //                     "mp3",
    //                     "mpga",
    //                     "ogg",
    //                     "oga",
    //                     "mogg",
    //                     "opus",
    //                     "qcp",
    //                     "tta",
    //                     "voc",
    //                     "wav",
    //                     "wma",
    //                     "wv",
    //                     "webm",
    //                     "mts",
    //                     "m2ts",
    //                     "ts",
    //                     "mov",
    //                     "mp2",
    //                     "mp4",
    //                     "m4p",
    //                     "m4v",
    //                     "mxf"
    //                 ],
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "audio_file",
    //                 "value": "",
    //                 "display_name": "Audio File",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The audio file to transcribe",
    //                 "title_case": false,
    //                 "type": "file",
    //                 "_input_type": "FileInput"
    //             },
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "Assembly API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Your AssemblyAI API key. You can get one from https://www.assemblyai.com/",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "audio_file_url": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "audio_file_url",
    //                 "value": "",
    //                 "display_name": "Audio File URL",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The URL of the audio file to transcribe (Can be used instead of a File)",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from pathlib import Path\n\nimport assemblyai as aai\nfrom loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.io import BoolInput, DropdownInput, FileInput, MessageTextInput, Output, SecretStrInput\nfrom langflow.schema import Data\n\n\nclass AssemblyAITranscriptionJobCreator(Component):\n    display_name = \"AssemblyAI Start Transcript\"\n    description = \"Create a transcription job for an audio file using AssemblyAI with advanced options\"\n    documentation = \"https://www.assemblyai.com/docs\"\n    icon = \"AssemblyAI\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Assembly API Key\",\n            info=\"Your AssemblyAI API key. You can get one from https://www.assemblyai.com/\",\n        ),\n        FileInput(\n            name=\"audio_file\",\n            display_name=\"Audio File\",\n            file_types=[\n                \"3ga\",\n                \"8svx\",\n                \"aac\",\n                \"ac3\",\n                \"aif\",\n                \"aiff\",\n                \"alac\",\n                \"amr\",\n                \"ape\",\n                \"au\",\n                \"dss\",\n                \"flac\",\n                \"flv\",\n                \"m4a\",\n                \"m4b\",\n                \"m4p\",\n                \"m4r\",\n                \"mp3\",\n                \"mpga\",\n                \"ogg\",\n                \"oga\",\n                \"mogg\",\n                \"opus\",\n                \"qcp\",\n                \"tta\",\n                \"voc\",\n                \"wav\",\n                \"wma\",\n                \"wv\",\n                \"webm\",\n                \"mts\",\n                \"m2ts\",\n                \"ts\",\n                \"mov\",\n                \"mp2\",\n                \"mp4\",\n                \"m4p\",\n                \"m4v\",\n                \"mxf\",\n            ],\n            info=\"The audio file to transcribe\",\n        ),\n        MessageTextInput(\n            name=\"audio_file_url\",\n            display_name=\"Audio File URL\",\n            info=\"The URL of the audio file to transcribe (Can be used instead of a File)\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"speech_model\",\n            display_name=\"Speech Model\",\n            options=[\n                \"best\",\n                \"nano\",\n            ],\n            value=\"best\",\n            info=\"The speech model to use for the transcription\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"language_detection\",\n            display_name=\"Automatic Language Detection\",\n            info=\"Enable automatic language detection\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"language_code\",\n            display_name=\"Language\",\n            info=(\n                \"\"\"\n            The language of the audio file. Can be set manually if automatic language detection is disabled.\n            See https://www.assemblyai.com/docs/getting-started/supported-languages \"\"\"\n                \"for a list of supported language codes.\"\n            ),\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"speaker_labels\",\n            display_name=\"Enable Speaker Labels\",\n            info=\"Enable speaker diarization\",\n        ),\n        MessageTextInput(\n            name=\"speakers_expected\",\n            display_name=\"Expected Number of Speakers\",\n            info=\"Set the expected number of speakers (optional, enter a number)\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"punctuate\",\n            display_name=\"Punctuate\",\n            info=\"Enable automatic punctuation\",\n            advanced=True,\n            value=True,\n        ),\n        BoolInput(\n            name=\"format_text\",\n            display_name=\"Format Text\",\n            info=\"Enable text formatting\",\n            advanced=True,\n            value=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Transcript ID\", name=\"transcript_id\", method=\"create_transcription_job\"),\n    ]\n\n    def create_transcription_job(self) -> Data:\n        aai.settings.api_key = self.api_key\n\n        # Convert speakers_expected to int if it's not empty\n        speakers_expected = None\n        if self.speakers_expected and self.speakers_expected.strip():\n            try:\n                speakers_expected = int(self.speakers_expected)\n            except ValueError:\n                self.status = \"Error: Expected Number of Speakers must be a valid integer\"\n                return Data(data={\"error\": \"Error: Expected Number of Speakers must be a valid integer\"})\n\n        language_code = self.language_code or None\n\n        config = aai.TranscriptionConfig(\n            speech_model=self.speech_model,\n            language_detection=self.language_detection,\n            language_code=language_code,\n            speaker_labels=self.speaker_labels,\n            speakers_expected=speakers_expected,\n            punctuate=self.punctuate,\n            format_text=self.format_text,\n        )\n\n        audio = None\n        if self.audio_file:\n            if self.audio_file_url:\n                logger.warning(\"Both an audio file an audio URL were specified. The audio URL was ignored.\")\n\n            # Check if the file exists\n            if not Path(self.audio_file).exists():\n                self.status = \"Error: Audio file not found\"\n                return Data(data={\"error\": \"Error: Audio file not found\"})\n            audio = self.audio_file\n        elif self.audio_file_url:\n            audio = self.audio_file_url\n        else:\n            self.status = \"Error: Either an audio file or an audio URL must be specified\"\n            return Data(data={\"error\": \"Error: Either an audio file or an audio URL must be specified\"})\n\n        try:\n            transcript = aai.Transcriber().submit(audio, config=config)\n        except Exception as e:  # noqa: BLE001\n            logger.opt(exception=True).debug(\"Error submitting transcription job\")\n            self.status = f\"An error occurred: {e}\"\n            return Data(data={\"error\": f\"An error occurred: {e}\"})\n\n        if transcript.error:\n            self.status = transcript.error\n            return Data(data={\"error\": transcript.error})\n        result = Data(data={\"transcript_id\": transcript.id})\n        self.status = result\n        return result\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "format_text": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "format_text",
    //                 "value": true,
    //                 "display_name": "Format Text",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Enable text formatting",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "language_code": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "language_code",
    //                 "value": "",
    //                 "display_name": "Language",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "\n            The language of the audio file. Can be set manually if automatic language detection is disabled.\n            See https://www.assemblyai.com/docs/getting-started/supported-languages for a list of supported language codes.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "language_detection": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "language_detection",
    //                 "value": false,
    //                 "display_name": "Automatic Language Detection",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Enable automatic language detection",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "punctuate": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "punctuate",
    //                 "value": true,
    //                 "display_name": "Punctuate",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Enable automatic punctuation",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "speaker_labels": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "speaker_labels",
    //                 "value": false,
    //                 "display_name": "Enable Speaker Labels",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Enable speaker diarization",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "speakers_expected": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "speakers_expected",
    //                 "value": "",
    //                 "display_name": "Expected Number of Speakers",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Set the expected number of speakers (optional, enter a number)",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "speech_model": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "best",
    //                     "nano"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "speech_model",
    //                 "value": "best",
    //                 "display_name": "Speech Model",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The speech model to use for the transcription",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             }
    //         },
    //         "description": "Create a transcription job for an audio file using AssemblyAI with advanced options",
    //         "icon": "AssemblyAI",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "AssemblyAI Start Transcript",
    //         "documentation": "https://www.assemblyai.com/docs",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "transcript_id",
    //                 "display_name": "Transcript ID",
    //                 "method": "create_transcription_job",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "api_key",
    //             "audio_file",
    //             "audio_file_url",
    //             "speech_model",
    //             "language_detection",
    //             "language_code",
    //             "speaker_labels",
    //             "speakers_expected",
    //             "punctuate",
    //             "format_text"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AssemblyAITranscriptionJobPoller": {
    //         "template": {
    //             "_type": "Component",
    //             "transcript_id": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "transcript_id",
    //                 "value": "",
    //                 "display_name": "Transcript ID",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The ID of the transcription job to poll",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "Assembly API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Your AssemblyAI API key. You can get one from https://www.assemblyai.com/",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import assemblyai as aai\nfrom loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.io import DataInput, FloatInput, Output, SecretStrInput\nfrom langflow.schema import Data\n\n\nclass AssemblyAITranscriptionJobPoller(Component):\n    display_name = \"AssemblyAI Poll Transcript\"\n    description = \"Poll for the status of a transcription job using AssemblyAI\"\n    documentation = \"https://www.assemblyai.com/docs\"\n    icon = \"AssemblyAI\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Assembly API Key\",\n            info=\"Your AssemblyAI API key. You can get one from https://www.assemblyai.com/\",\n        ),\n        DataInput(\n            name=\"transcript_id\",\n            display_name=\"Transcript ID\",\n            info=\"The ID of the transcription job to poll\",\n        ),\n        FloatInput(\n            name=\"polling_interval\",\n            display_name=\"Polling Interval\",\n            value=3.0,\n            info=\"The polling interval in seconds\",\n            advanced=True,\n            range_spec=RangeSpec(min=3, max=30),\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Transcription Result\", name=\"transcription_result\", method=\"poll_transcription_job\"),\n    ]\n\n    def poll_transcription_job(self) -> Data:\n        \"\"\"Polls the transcription status until completion and returns the Data.\"\"\"\n        aai.settings.api_key = self.api_key\n        aai.settings.polling_interval = self.polling_interval\n\n        # check if it's an error message from the previous step\n        if self.transcript_id.data.get(\"error\"):\n            self.status = self.transcript_id.data[\"error\"]\n            return self.transcript_id\n\n        try:\n            transcript = aai.Transcript.get_by_id(self.transcript_id.data[\"transcript_id\"])\n        except Exception as e:  # noqa: BLE001\n            error = f\"Getting transcription failed: {e}\"\n            logger.opt(exception=True).debug(error)\n            self.status = error\n            return Data(data={\"error\": error})\n\n        if transcript.status == aai.TranscriptStatus.completed:\n            json_response = transcript.json_response\n            text = json_response.pop(\"text\", None)\n            utterances = json_response.pop(\"utterances\", None)\n            transcript_id = json_response.pop(\"id\", None)\n            sorted_data = {\"text\": text, \"utterances\": utterances, \"id\": transcript_id}\n            sorted_data.update(json_response)\n            data = Data(data=sorted_data)\n            self.status = data\n            return data\n        self.status = transcript.error\n        return Data(data={\"error\": transcript.error})\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "polling_interval": {
    //                 "trace_as_metadata": true,
    //                 "range_spec": {
    //                     "step_type": "float",
    //                     "min": 3.0,
    //                     "max": 30.0,
    //                     "step": 0.1
    //                 },
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "polling_interval",
    //                 "value": 3.0,
    //                 "display_name": "Polling Interval",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The polling interval in seconds",
    //                 "title_case": false,
    //                 "type": "float",
    //                 "_input_type": "FloatInput"
    //             }
    //         },
    //         "description": "Poll for the status of a transcription job using AssemblyAI",
    //         "icon": "AssemblyAI",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "AssemblyAI Poll Transcript",
    //         "documentation": "https://www.assemblyai.com/docs",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "transcription_result",
    //                 "display_name": "Transcription Result",
    //                 "method": "poll_transcription_job",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "api_key",
    //             "transcript_id",
    //             "polling_interval"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "prompts": {
    //     "Prompt": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt\"\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt Message\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(\n        self,\n    ) -> Message:\n        prompt = await Message.from_template_and_variables(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    def post_code_processing(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = super().post_code_processing(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "template": {
    //                 "trace_as_input": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "template",
    //                 "value": "",
    //                 "display_name": "Template",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "prompt",
    //                 "_input_type": "PromptInput"
    //             }
    //         },
    //         "description": "Create a prompt template with dynamic variables.",
    //         "icon": "prompts",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Prompt",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "prompt",
    //                 "display_name": "Prompt Message",
    //                 "method": "build_prompt",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "template"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "LangChain Hub Prompt": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import re\n\nfrom langchain_core.prompts import HumanMessagePromptTemplate\n\nfrom langflow.custom import Component\nfrom langflow.inputs import DefaultPromptField, SecretStrInput, StrInput\nfrom langflow.io import Output\nfrom langflow.schema.message import Message\n\n\nclass LangChainHubPromptComponent(Component):\n    display_name: str = \"LangChain Hub\"\n    description: str = \"Prompt Component that uses LangChain Hub prompts\"\n    beta = True\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"LangChain Hub Prompt\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"langchain_api_key\",\n            display_name=\"Your LangChain API Key\",\n            info=\"The LangChain API Key to use.\",\n            required=True,\n        ),\n        StrInput(\n            name=\"langchain_hub_prompt\",\n            display_name=\"LangChain Hub Prompt\",\n            info=\"The LangChain Hub prompt to use, i.e., 'efriis/my-first-prompt'\",\n            refresh_button=True,\n            required=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Build Prompt\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None):\n        # If the field is not langchain_hub_prompt or the value is empty, return the build config as is\n        if field_name != \"langchain_hub_prompt\" or not field_value:\n            return build_config\n\n        # Fetch the template\n        template = self._fetch_langchain_hub_template()\n\n        # Get the template's messages\n        if hasattr(template, \"messages\"):\n            template_messages = template.messages\n        else:\n            template_messages = [HumanMessagePromptTemplate(prompt=template)]\n\n        # Extract the messages from the prompt data\n        prompt_template = [message_data.prompt for message_data in template_messages]\n\n        # Regular expression to find all instances of {<string>}\n        pattern = r\"\\{(.*?)\\}\"\n\n        # Get all the custom fields\n        custom_fields: list[str] = []\n        full_template = \"\"\n        for message in prompt_template:\n            # Find all matches\n            matches = re.findall(pattern, message.template)\n            custom_fields += matches\n\n            # Create a string version of the full template\n            full_template = full_template + \"\\n\" + message.template\n\n        # No need to reprocess if we have them already\n        if all(\"param_\" + custom_field in build_config for custom_field in custom_fields):\n            return build_config\n\n        # Easter egg: Show template in info popup\n        build_config[\"langchain_hub_prompt\"][\"info\"] = full_template\n\n        # Remove old parameter inputs if any\n        for key in build_config.copy():\n            if key.startswith(\"param_\"):\n                del build_config[key]\n\n        # Now create inputs for each\n        for custom_field in custom_fields:\n            new_parameter = DefaultPromptField(\n                name=f\"param_{custom_field}\",\n                display_name=custom_field,\n                info=\"Fill in the value for {\" + custom_field + \"}\",\n            ).to_dict()\n\n            # Add the new parameter to the build config\n            build_config[f\"param_{custom_field}\"] = new_parameter\n\n        return build_config\n\n    async def build_prompt(\n        self,\n    ) -> Message:\n        # Fetch the template\n        template = self._fetch_langchain_hub_template()\n\n        # Get the parameters from the attributes\n        original_params = {k.removeprefix(\"param_\"): v for k, v in self._attributes.items()}\n        prompt_value = template.invoke(original_params)\n\n        original_params[\"template\"] = prompt_value.to_string()\n\n        # Now pass the filtered attributes to the function\n        prompt = await Message.from_template_and_variables(**original_params)\n\n        self.status = prompt.text\n\n        return prompt\n\n    def _fetch_langchain_hub_template(self):\n        import langchain.hub\n\n        # Check if the api key is provided\n        if not self.langchain_api_key:\n            msg = \"Please provide a LangChain API Key\"\n\n            raise ValueError(msg)\n\n        # Pull the prompt from LangChain Hub\n        return langchain.hub.pull(self.langchain_hub_prompt, api_key=self.langchain_api_key)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "langchain_api_key": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "langchain_api_key",
    //                 "value": "",
    //                 "display_name": "Your LangChain API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The LangChain API Key to use.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "langchain_hub_prompt": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "langchain_hub_prompt",
    //                 "value": "",
    //                 "display_name": "LangChain Hub Prompt",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The LangChain Hub prompt to use, i.e., 'efriis/my-first-prompt'",
    //                 "refresh_button": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Prompt Component that uses LangChain Hub prompts",
    //         "icon": "prompts",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "LangChain Hub",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "prompt",
    //                 "display_name": "Build Prompt",
    //                 "method": "build_prompt",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "langchain_api_key",
    //             "langchain_hub_prompt"
    //         ],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "chains": {
    //     "LLMMathChain": {
    //         "template": {
    //             "_type": "Component",
    //             "llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "llm",
    //                 "value": "",
    //                 "display_name": "Language Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "LanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain.chains import LLMMathChain\n\nfrom langflow.base.chains.model import LCChainComponent\nfrom langflow.field_typing import Message\nfrom langflow.inputs import HandleInput, MultilineInput\nfrom langflow.template import Output\n\n\nclass LLMMathChainComponent(LCChainComponent):\n    display_name = \"LLMMathChain\"\n    description = \"Chain that interprets a prompt and executes python code to do math.\"\n    documentation = \"https://python.langchain.com/docs/modules/chains/additional/llm_math\"\n    name = \"LLMMathChain\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\", display_name=\"Input\", info=\"The input value to pass to the chain.\", required=True\n        ),\n        HandleInput(name=\"llm\", display_name=\"Language Model\", input_types=[\"LanguageModel\"], required=True),\n    ]\n\n    outputs = [Output(display_name=\"Text\", name=\"text\", method=\"invoke_chain\")]\n\n    def invoke_chain(self) -> Message:\n        chain = LLMMathChain.from_llm(llm=self.llm)\n        response = chain.invoke(\n            {chain.input_key: self.input_value}, config={\"callbacks\": self.get_langchain_callbacks()}\n        )\n        result = response.get(chain.output_key, \"\")\n        result = str(result)\n        self.status = result\n        return Message(text=result)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The input value to pass to the chain.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Chain that interprets a prompt and executes python code to do math.",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "LLMMathChain",
    //         "documentation": "https://python.langchain.com/docs/modules/chains/additional/llm_math",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text",
    //                 "display_name": "Text",
    //                 "method": "invoke_chain",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "llm"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "ConversationChain": {
    //         "template": {
    //             "_type": "Component",
    //             "llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "llm",
    //                 "value": "",
    //                 "display_name": "Language Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "LanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "memory": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "memory",
    //                 "value": "",
    //                 "display_name": "Memory",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "BaseChatMemory"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain.chains import ConversationChain\n\nfrom langflow.base.chains.model import LCChainComponent\nfrom langflow.field_typing import Message\nfrom langflow.inputs import HandleInput, MultilineInput\n\n\nclass ConversationChainComponent(LCChainComponent):\n    display_name = \"ConversationChain\"\n    description = \"Chain to have a conversation and load context from memory.\"\n    name = \"ConversationChain\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\", display_name=\"Input\", info=\"The input value to pass to the chain.\", required=True\n        ),\n        HandleInput(name=\"llm\", display_name=\"Language Model\", input_types=[\"LanguageModel\"], required=True),\n        HandleInput(\n            name=\"memory\",\n            display_name=\"Memory\",\n            input_types=[\"BaseChatMemory\"],\n        ),\n    ]\n\n    def invoke_chain(self) -> Message:\n        if not self.memory:\n            chain = ConversationChain(llm=self.llm)\n        else:\n            chain = ConversationChain(llm=self.llm, memory=self.memory)\n\n        result = chain.invoke({\"input\": self.input_value}, config={\"callbacks\": self.get_langchain_callbacks()})\n        if isinstance(result, dict):\n            result = result.get(chain.output_key, \"\")\n\n        elif not isinstance(result, str):\n            result = result.get(\"response\")\n        result = str(result)\n        self.status = result\n        return Message(text=result)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The input value to pass to the chain.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Chain to have a conversation and load context from memory.",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "ConversationChain",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text",
    //                 "display_name": "Text",
    //                 "method": "invoke_chain",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "llm",
    //                     "memory"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "llm",
    //             "memory"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "RetrievalQA": {
    //         "template": {
    //             "_type": "Component",
    //             "llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "llm",
    //                 "value": "",
    //                 "display_name": "Language Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "LanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "memory": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "memory",
    //                 "value": "",
    //                 "display_name": "Memory",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "BaseChatMemory"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "retriever": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "retriever",
    //                 "value": "",
    //                 "display_name": "Retriever",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Retriever"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "chain_type": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Stuff",
    //                     "Map Reduce",
    //                     "Refine",
    //                     "Map Rerank"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chain_type",
    //                 "value": "Stuff",
    //                 "display_name": "Chain Type",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Chain type to use.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain.chains import RetrievalQA\n\nfrom langflow.base.chains.model import LCChainComponent\nfrom langflow.field_typing import Message\nfrom langflow.inputs import BoolInput, DropdownInput, HandleInput, MultilineInput\n\n\nclass RetrievalQAComponent(LCChainComponent):\n    display_name = \"Retrieval QA\"\n    description = \"Chain for question-answering querying sources from a retriever.\"\n    name = \"RetrievalQA\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\", display_name=\"Input\", info=\"The input value to pass to the chain.\", required=True\n        ),\n        DropdownInput(\n            name=\"chain_type\",\n            display_name=\"Chain Type\",\n            info=\"Chain type to use.\",\n            options=[\"Stuff\", \"Map Reduce\", \"Refine\", \"Map Rerank\"],\n            value=\"Stuff\",\n            advanced=True,\n        ),\n        HandleInput(name=\"llm\", display_name=\"Language Model\", input_types=[\"LanguageModel\"], required=True),\n        HandleInput(name=\"retriever\", display_name=\"Retriever\", input_types=[\"Retriever\"], required=True),\n        HandleInput(\n            name=\"memory\",\n            display_name=\"Memory\",\n            input_types=[\"BaseChatMemory\"],\n        ),\n        BoolInput(\n            name=\"return_source_documents\",\n            display_name=\"Return Source Documents\",\n            value=False,\n        ),\n    ]\n\n    def invoke_chain(self) -> Message:\n        chain_type = self.chain_type.lower().replace(\" \", \"_\")\n        if self.memory:\n            self.memory.input_key = \"query\"\n            self.memory.output_key = \"result\"\n\n        runnable = RetrievalQA.from_chain_type(\n            llm=self.llm,\n            chain_type=chain_type,\n            retriever=self.retriever,\n            memory=self.memory,\n            # always include to help debugging\n            #\n            return_source_documents=True,\n        )\n\n        result = runnable.invoke({\"query\": self.input_value}, config={\"callbacks\": self.get_langchain_callbacks()})\n\n        source_docs = self.to_data(result.get(\"source_documents\", keys=[]))\n        result_str = str(result.get(\"result\", \"\"))\n        if self.return_source_documents and len(source_docs):\n            references_str = self.create_references_from_data(source_docs)\n            result_str = f\"{result_str}\\n{references_str}\"\n        # put the entire result to debug history, query and content\n        self.status = {**result, \"source_documents\": source_docs, \"output\": result_str}\n        return result_str\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The input value to pass to the chain.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "return_source_documents": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "return_source_documents",
    //                 "value": false,
    //                 "display_name": "Return Source Documents",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Chain for question-answering querying sources from a retriever.",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Retrieval QA",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text",
    //                 "display_name": "Text",
    //                 "method": "invoke_chain",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "chain_type",
    //                     "input_value",
    //                     "llm",
    //                     "memory",
    //                     "retriever",
    //                     "return_source_documents"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "chain_type",
    //             "llm",
    //             "retriever",
    //             "memory",
    //             "return_source_documents"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "SQLGenerator": {
    //         "template": {
    //             "_type": "Component",
    //             "db": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "db",
    //                 "value": "",
    //                 "display_name": "SQLDatabase",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "SQLDatabase"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "llm",
    //                 "value": "",
    //                 "display_name": "Language Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "LanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import TYPE_CHECKING\n\nfrom langchain.chains import create_sql_query_chain\nfrom langchain_core.prompts import PromptTemplate\n\nfrom langflow.base.chains.model import LCChainComponent\nfrom langflow.field_typing import Message\nfrom langflow.inputs import HandleInput, IntInput, MultilineInput\nfrom langflow.template import Output\n\nif TYPE_CHECKING:\n    from langchain_core.runnables import Runnable\n\n\nclass SQLGeneratorComponent(LCChainComponent):\n    display_name = \"Natural Language to SQL\"\n    description = \"Generate SQL from natural language.\"\n    name = \"SQLGenerator\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\", display_name=\"Input\", info=\"The input value to pass to the chain.\", required=True\n        ),\n        HandleInput(name=\"llm\", display_name=\"Language Model\", input_types=[\"LanguageModel\"], required=True),\n        HandleInput(name=\"db\", display_name=\"SQLDatabase\", input_types=[\"SQLDatabase\"], required=True),\n        IntInput(\n            name=\"top_k\", display_name=\"Top K\", info=\"The number of results per select statement to return.\", value=5\n        ),\n        MultilineInput(name=\"prompt\", display_name=\"Prompt\", info=\"The prompt must contain `{question}`.\"),\n    ]\n\n    outputs = [Output(display_name=\"Text\", name=\"text\", method=\"invoke_chain\")]\n\n    def invoke_chain(self) -> Message:\n        prompt_template = PromptTemplate.from_template(template=self.prompt) if self.prompt else None\n\n        if self.top_k < 1:\n            msg = \"Top K must be greater than 0.\"\n            raise ValueError(msg)\n\n        if not prompt_template:\n            sql_query_chain = create_sql_query_chain(llm=self.llm, db=self.db, k=self.top_k)\n        else:\n            # Check if {question} is in the prompt\n            if \"{question}\" not in prompt_template.template or \"question\" not in prompt_template.input_variables:\n                msg = \"Prompt must contain `{question}` to be used with Natural Language to SQL.\"\n                raise ValueError(msg)\n            sql_query_chain = create_sql_query_chain(llm=self.llm, db=self.db, prompt=prompt_template, k=self.top_k)\n        query_writer: Runnable = sql_query_chain | {\"query\": lambda x: x.replace(\"SQLQuery:\", \"\").strip()}\n        response = query_writer.invoke(\n            {\"question\": self.input_value}, config={\"callbacks\": self.get_langchain_callbacks()}\n        )\n        query = response.get(\"query\")\n        self.status = query\n        return query\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The input value to pass to the chain.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "prompt": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "prompt",
    //                 "value": "",
    //                 "display_name": "Prompt",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The prompt must contain `{question}`.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "top_k": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "top_k",
    //                 "value": 5,
    //                 "display_name": "Top K",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The number of results per select statement to return.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             }
    //         },
    //         "description": "Generate SQL from natural language.",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Natural Language to SQL",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text",
    //                 "display_name": "Text",
    //                 "method": "invoke_chain",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "llm",
    //             "db",
    //             "top_k",
    //             "prompt"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "LLMCheckerChain": {
    //         "template": {
    //             "_type": "Component",
    //             "llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "llm",
    //                 "value": "",
    //                 "display_name": "Language Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "LanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain.chains import LLMCheckerChain\n\nfrom langflow.base.chains.model import LCChainComponent\nfrom langflow.field_typing import Message\nfrom langflow.inputs import HandleInput, MultilineInput\n\n\nclass LLMCheckerChainComponent(LCChainComponent):\n    display_name = \"LLMCheckerChain\"\n    description = \"Chain for question-answering with self-verification.\"\n    documentation = \"https://python.langchain.com/docs/modules/chains/additional/llm_checker\"\n    name = \"LLMCheckerChain\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\", display_name=\"Input\", info=\"The input value to pass to the chain.\", required=True\n        ),\n        HandleInput(name=\"llm\", display_name=\"Language Model\", input_types=[\"LanguageModel\"], required=True),\n    ]\n\n    def invoke_chain(self) -> Message:\n        chain = LLMCheckerChain.from_llm(llm=self.llm)\n        response = chain.invoke(\n            {chain.input_key: self.input_value}, config={\"callbacks\": self.get_langchain_callbacks()}\n        )\n        result = response.get(chain.output_key, \"\")\n        result = str(result)\n        self.status = result\n        return Message(text=result)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The input value to pass to the chain.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Chain for question-answering with self-verification.",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "LLMCheckerChain",
    //         "documentation": "https://python.langchain.com/docs/modules/chains/additional/llm_checker",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text",
    //                 "display_name": "Text",
    //                 "method": "invoke_chain",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "input_value",
    //                     "llm"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "llm"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "data": {
    //     "Webhook": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import json\n\nfrom langflow.custom import Component\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema import Data\n\n\nclass WebhookComponent(Component):\n    display_name = \"Webhook Input\"\n    description = \"Defines a webhook input for the flow.\"\n    name = \"Webhook\"\n\n    inputs = [\n        MultilineInput(\n            name=\"data\",\n            display_name=\"Data\",\n            info=\"Use this field to quickly test the webhook component by providing a JSON payload.\",\n        )\n    ]\n    outputs = [\n        Output(display_name=\"Data\", name=\"output_data\", method=\"build_data\"),\n    ]\n\n    def build_data(self) -> Data:\n        message: str | Data = \"\"\n        if not self.data:\n            self.status = \"No data provided.\"\n            return Data(data={})\n        try:\n            body = json.loads(self.data or \"{}\")\n        except json.JSONDecodeError:\n            body = {\"payload\": self.data}\n            message = f\"Invalid JSON payload. Please check the format.\\n\\n{self.data}\"\n        data = Data(data=body)\n        if not message:\n            message = data\n        self.status = message\n        return data\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "data": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "data",
    //                 "value": "",
    //                 "display_name": "Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Use this field to quickly test the webhook component by providing a JSON payload.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Defines a webhook input for the flow.",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Webhook Input",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "output_data",
    //                 "display_name": "Data",
    //                 "method": "build_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "data"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "APIRequest": {
    //         "template": {
    //             "_type": "Component",
    //             "query_params": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "query_params",
    //                 "value": "",
    //                 "display_name": "Query Parameters",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The query parameters to append to the URL.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "body": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "body",
    //                 "value": {},
    //                 "display_name": "Body",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The body to send with the request as a dictionary (for POST, PATCH, PUT). This is populated when using the CURL field.",
    //                 "title_case": false,
    //                 "type": "NestedDict",
    //                 "_input_type": "NestedDictInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import asyncio\nimport json\nfrom typing import Any\nfrom urllib.parse import parse_qsl, urlencode, urlparse, urlunparse\n\nimport httpx\nfrom loguru import logger\n\nfrom langflow.base.curl.parse import parse_context\nfrom langflow.custom import Component\nfrom langflow.io import DataInput, DropdownInput, IntInput, MessageTextInput, NestedDictInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.dotdict import dotdict\n\n\nclass APIRequestComponent(Component):\n    display_name = \"API Request\"\n    description = (\n        \"This component allows you to make HTTP requests to one or more URLs. \"\n        \"You can provide headers and body as either dictionaries or Data objects. \"\n        \"Additionally, you can append query parameters to the URLs.\\n\\n\"\n        \"**Note:** Check advanced options for more settings.\"\n    )\n    icon = \"Globe\"\n    name = \"APIRequest\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            is_list=True,\n            info=\"Enter one or more URLs, separated by commas.\",\n        ),\n        MessageTextInput(\n            name=\"curl\",\n            display_name=\"Curl\",\n            info=\"Paste a curl command to populate the fields. \"\n            \"This will fill in the dictionary fields for headers and body.\",\n            advanced=False,\n            refresh_button=True,\n        ),\n        DropdownInput(\n            name=\"method\",\n            display_name=\"Method\",\n            options=[\"GET\", \"POST\", \"PATCH\", \"PUT\"],\n            value=\"GET\",\n            info=\"The HTTP method to use (GET, POST, PATCH, PUT).\",\n        ),\n        NestedDictInput(\n            name=\"headers\",\n            display_name=\"Headers\",\n            info=\"The headers to send with the request as a dictionary. This is populated when using the CURL field.\",\n            input_types=[\"Data\"],\n        ),\n        NestedDictInput(\n            name=\"body\",\n            display_name=\"Body\",\n            info=\"The body to send with the request as a dictionary (for POST, PATCH, PUT). \"\n            \"This is populated when using the CURL field.\",\n            input_types=[\"Data\"],\n        ),\n        DataInput(\n            name=\"query_params\",\n            display_name=\"Query Parameters\",\n            info=\"The query parameters to append to the URL.\",\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            value=5,\n            info=\"The timeout to use for the request.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"make_requests\"),\n    ]\n\n    def parse_curl(self, curl: str, build_config: dotdict) -> dotdict:\n        try:\n            parsed = parse_context(curl)\n            build_config[\"urls\"][\"value\"] = [parsed.url]\n            build_config[\"method\"][\"value\"] = parsed.method.upper()\n            build_config[\"headers\"][\"value\"] = dict(parsed.headers)\n\n            if parsed.data:\n                try:\n                    json_data = json.loads(parsed.data)\n                    build_config[\"body\"][\"value\"] = json_data\n                except json.JSONDecodeError:\n                    logger.exception(\"Error decoding JSON data\")\n            else:\n                build_config[\"body\"][\"value\"] = {}\n        except Exception as exc:\n            msg = f\"Error parsing curl: {exc}\"\n            logger.exception(msg)\n            raise ValueError(msg) from exc\n        return build_config\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"curl\" and field_value:\n            build_config = self.parse_curl(field_value, build_config)\n        return build_config\n\n    async def make_request(\n        self,\n        client: httpx.AsyncClient,\n        method: str,\n        url: str,\n        headers: dict | None = None,\n        body: dict | None = None,\n        timeout: int = 5,\n    ) -> Data:\n        method = method.upper()\n        if method not in {\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"}:\n            msg = f\"Unsupported method: {method}\"\n            raise ValueError(msg)\n\n        if isinstance(body, str) and body:\n            try:\n                body = json.loads(body)\n            except Exception as e:\n                msg = f\"Error decoding JSON data: {e}\"\n                logger.exception(msg)\n                body = None\n                raise ValueError(msg) from e\n\n        data = body or None\n\n        try:\n            response = await client.request(method, url, headers=headers, json=data, timeout=timeout)\n            try:\n                result = response.json()\n            except Exception:  # noqa: BLE001\n                logger.opt(exception=True).debug(\"Error decoding JSON response\")\n                result = response.text\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": response.status_code,\n                    \"result\": result,\n                },\n            )\n        except httpx.TimeoutException:\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": 408,\n                    \"error\": \"Request timed out\",\n                },\n            )\n        except Exception as exc:  # noqa: BLE001\n            logger.opt(exception=True).debug(f\"Error making request to {url}\")\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": 500,\n                    \"error\": str(exc),\n                },\n            )\n\n    def add_query_params(self, url: str, params: dict) -> str:\n        url_parts = list(urlparse(url))\n        query = dict(parse_qsl(url_parts[4]))\n        query.update(params)\n        url_parts[4] = urlencode(query)\n        return urlunparse(url_parts)\n\n    async def make_requests(self) -> list[Data]:\n        method = self.method\n        urls = [url.strip() for url in self.urls if url.strip()]\n        curl = self.curl\n        headers = self.headers or {}\n        body = self.body or {}\n        timeout = self.timeout\n        query_params = self.query_params.data if self.query_params else {}\n\n        if curl:\n            self._build_config = self.parse_curl(curl, dotdict())\n\n        if isinstance(headers, Data):\n            headers = headers.data\n\n        if isinstance(body, Data):\n            body = body.data\n\n        bodies = [body] * len(urls)\n\n        urls = [self.add_query_params(url, query_params) for url in urls]\n\n        async with httpx.AsyncClient() as client:\n            results = await asyncio.gather(\n                *[\n                    self.make_request(client, method, u, headers, rec, timeout)\n                    for u, rec in zip(urls, bodies, strict=True)\n                ]\n            )\n        self.status = results\n        return results\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "curl": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "curl",
    //                 "value": "",
    //                 "display_name": "Curl",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Paste a curl command to populate the fields. This will fill in the dictionary fields for headers and body.",
    //                 "refresh_button": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "headers": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "headers",
    //                 "value": {},
    //                 "display_name": "Headers",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The headers to send with the request as a dictionary. This is populated when using the CURL field.",
    //                 "title_case": false,
    //                 "type": "NestedDict",
    //                 "_input_type": "NestedDictInput"
    //             },
    //             "method": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "GET",
    //                     "POST",
    //                     "PATCH",
    //                     "PUT"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "method",
    //                 "value": "GET",
    //                 "display_name": "Method",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The HTTP method to use (GET, POST, PATCH, PUT).",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "timeout": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "timeout",
    //                 "value": 5,
    //                 "display_name": "Timeout",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The timeout to use for the request.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "urls": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "urls",
    //                 "value": "",
    //                 "display_name": "URLs",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Enter one or more URLs, separated by commas.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "This component allows you to make HTTP requests to one or more URLs. You can provide headers and body as either dictionaries or Data objects. Additionally, you can append query parameters to the URLs.\n\n**Note:** Check advanced options for more settings.",
    //         "icon": "Globe",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "API Request",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "display_name": "Data",
    //                 "method": "make_requests",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "urls",
    //             "curl",
    //             "method",
    //             "headers",
    //             "body",
    //             "query_params",
    //             "timeout"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "GoogleDriveSearchComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import json\n\nfrom google.oauth2.credentials import Credentials\nfrom googleapiclient.discovery import build\n\nfrom langflow.custom import Component\nfrom langflow.inputs import DropdownInput, MessageTextInput\nfrom langflow.io import SecretStrInput\nfrom langflow.schema import Data\nfrom langflow.template import Output\n\n\nclass GoogleDriveSearchComponent(Component):\n    display_name = \"Google Drive Search\"\n    description = \"Searches Google Drive files using provided credentials and query parameters.\"\n    icon = \"Google\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"token_string\",\n            display_name=\"Token String\",\n            info=\"JSON string containing OAuth 2.0 access token information for service account access\",\n            required=True,\n        ),\n        DropdownInput(\n            name=\"query_item\",\n            display_name=\"Query Item\",\n            options=[\n                \"name\",\n                \"fullText\",\n                \"mimeType\",\n                \"modifiedTime\",\n                \"viewedByMeTime\",\n                \"trashed\",\n                \"starred\",\n                \"parents\",\n                \"owners\",\n                \"writers\",\n                \"readers\",\n                \"sharedWithMe\",\n                \"createdTime\",\n                \"properties\",\n                \"appProperties\",\n                \"visibility\",\n                \"shortcutDetails.targetId\",\n            ],\n            info=\"The field to query.\",\n            required=True,\n        ),\n        DropdownInput(\n            name=\"valid_operator\",\n            display_name=\"Valid Operator\",\n            options=[\"contains\", \"=\", \"!=\", \"<=\", \"<\", \">\", \">=\", \"in\", \"has\"],\n            info=\"Operator to use in the query.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"search_term\",\n            display_name=\"Search Term\",\n            info=\"The value to search for in the specified query item.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"query_string\",\n            display_name=\"Query String\",\n            info=\"The query string used for searching. You can edit this manually.\",\n            value=\"\",  # This will be updated with the generated query string\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Document URLs\", name=\"doc_urls\", method=\"search_doc_urls\"),\n        Output(display_name=\"Document IDs\", name=\"doc_ids\", method=\"search_doc_ids\"),\n        Output(display_name=\"Document Titles\", name=\"doc_titles\", method=\"search_doc_titles\"),\n        Output(display_name=\"Data\", name=\"Data\", method=\"search_data\"),\n    ]\n\n    def generate_query_string(self) -> str:\n        query_item = self.query_item\n        valid_operator = self.valid_operator\n        search_term = self.search_term\n\n        # Construct the query string\n        query = f\"{query_item} {valid_operator} '{search_term}'\"\n\n        # Update the editable query string input with the generated query\n        self.query_string = query\n\n        return query\n\n    def on_inputs_changed(self) -> None:\n        # Automatically regenerate the query string when inputs change\n        self.generate_query_string()\n\n    def generate_file_url(self, file_id: str, mime_type: str) -> str:\n        \"\"\"Generates the appropriate Google Drive URL for a file based on its MIME type.\"\"\"\n        return {\n            \"application/vnd.google-apps.document\": f\"https://docs.google.com/document/d/{file_id}/edit\",\n            \"application/vnd.google-apps.spreadsheet\": f\"https://docs.google.com/spreadsheets/d/{file_id}/edit\",\n            \"application/vnd.google-apps.presentation\": f\"https://docs.google.com/presentation/d/{file_id}/edit\",\n            \"application/vnd.google-apps.drawing\": f\"https://docs.google.com/drawings/d/{file_id}/edit\",\n            \"application/pdf\": f\"https://drive.google.com/file/d/{file_id}/view?usp=drivesdk\",\n        }.get(mime_type, f\"https://drive.google.com/file/d/{file_id}/view?usp=drivesdk\")\n\n    def search_files(self) -> dict:\n        # Load the token information from the JSON string\n        token_info = json.loads(self.token_string)\n        creds = Credentials.from_authorized_user_info(token_info)\n\n        # Use the query string from the input (which might have been edited by the user)\n        query = self.query_string or self.generate_query_string()\n\n        # Initialize the Google Drive API service\n        service = build(\"drive\", \"v3\", credentials=creds)\n\n        # Perform the search\n        results = service.files().list(q=query, pageSize=5, fields=\"nextPageToken, files(id, name, mimeType)\").execute()\n        items = results.get(\"files\", [])\n\n        doc_urls = []\n        doc_ids = []\n        doc_titles_urls = []\n        doc_titles = []\n\n        if items:\n            for item in items:\n                # Directly use the file ID, title, and MIME type to generate the URL\n                file_id = item[\"id\"]\n                file_title = item[\"name\"]\n                mime_type = item[\"mimeType\"]\n                file_url = self.generate_file_url(file_id, mime_type)\n\n                # Store the URL, ID, and title+URL in their respective lists\n                doc_urls.append(file_url)\n                doc_ids.append(file_id)\n                doc_titles.append(file_title)\n                doc_titles_urls.append({\"title\": file_title, \"url\": file_url})\n\n        return {\"doc_urls\": doc_urls, \"doc_ids\": doc_ids, \"doc_titles_urls\": doc_titles_urls, \"doc_titles\": doc_titles}\n\n    def search_doc_ids(self) -> list[str]:\n        return self.search_files()[\"doc_ids\"]\n\n    def search_doc_urls(self) -> list[str]:\n        return self.search_files()[\"doc_urls\"]\n\n    def search_doc_titles(self) -> list[str]:\n        return self.search_files()[\"doc_titles\"]\n\n    def search_data(self) -> Data:\n        return Data(data={\"text\": self.search_files()[\"doc_titles_urls\"]})\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "query_item": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "name",
    //                     "fullText",
    //                     "mimeType",
    //                     "modifiedTime",
    //                     "viewedByMeTime",
    //                     "trashed",
    //                     "starred",
    //                     "parents",
    //                     "owners",
    //                     "writers",
    //                     "readers",
    //                     "sharedWithMe",
    //                     "createdTime",
    //                     "properties",
    //                     "appProperties",
    //                     "visibility",
    //                     "shortcutDetails.targetId"
    //                 ],
    //                 "combobox": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "query_item",
    //                 "value": "",
    //                 "display_name": "Query Item",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The field to query.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "query_string": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "query_string",
    //                 "value": "",
    //                 "display_name": "Query String",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The query string used for searching. You can edit this manually.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "search_term": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "search_term",
    //                 "value": "",
    //                 "display_name": "Search Term",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The value to search for in the specified query item.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "token_string": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "token_string",
    //                 "value": "",
    //                 "display_name": "Token String",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "JSON string containing OAuth 2.0 access token information for service account access",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "valid_operator": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "contains",
    //                     "=",
    //                     "!=",
    //                     "<=",
    //                     "<",
    //                     ">",
    //                     ">=",
    //                     "in",
    //                     "has"
    //                 ],
    //                 "combobox": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "valid_operator",
    //                 "value": "",
    //                 "display_name": "Valid Operator",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Operator to use in the query.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             }
    //         },
    //         "description": "Searches Google Drive files using provided credentials and query parameters.",
    //         "icon": "Google",
    //         "base_classes": [
    //             "Data",
    //             "Text"
    //         ],
    //         "display_name": "Google Drive Search",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Text"
    //                 ],
    //                 "selected": "Text",
    //                 "name": "doc_urls",
    //                 "display_name": "Document URLs",
    //                 "method": "search_doc_urls",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             },
    //             {
    //                 "types": [
    //                     "Text"
    //                 ],
    //                 "selected": "Text",
    //                 "name": "doc_ids",
    //                 "display_name": "Document IDs",
    //                 "method": "search_doc_ids",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             },
    //             {
    //                 "types": [
    //                     "Text"
    //                 ],
    //                 "selected": "Text",
    //                 "name": "doc_titles",
    //                 "display_name": "Document Titles",
    //                 "method": "search_doc_titles",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "Data",
    //                 "display_name": "Data",
    //                 "method": "search_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "token_string",
    //             "query_item",
    //             "valid_operator",
    //             "search_term",
    //             "query_string"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "URL": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import re\n\nfrom langchain_community.document_loaders import AsyncHtmlLoader, WebBaseLoader\n\nfrom langflow.custom import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import DropdownInput, MessageTextInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\n\n\nclass URLComponent(Component):\n    display_name = \"URL\"\n    description = \"Fetch content from one or more URLs.\"\n    icon = \"layout-template\"\n    name = \"URL\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            info=\"Enter one or more URLs, by clicking the '+' button.\",\n            is_list=True,\n        ),\n        DropdownInput(\n            name=\"format\",\n            display_name=\"Output format\",\n            info=\"Output format. Use 'Text' to extract the text from the HTML or 'Raw HTML' for the raw HTML content.\",\n            options=[\"Text\", \"Raw HTML\"],\n            value=\"Text\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\"),\n        Output(display_name=\"Text\", name=\"text\", method=\"fetch_content_text\"),\n    ]\n\n    def ensure_url(self, string: str) -> str:\n        \"\"\"Ensures the given string is a URL by adding 'http://' if it doesn't start with 'http://' or 'https://'.\n\n        Raises an error if the string is not a valid URL.\n\n        Parameters:\n            string (str): The string to be checked and possibly modified.\n\n        Returns:\n            str: The modified string that is ensured to be a URL.\n\n        Raises:\n            ValueError: If the string is not a valid URL.\n        \"\"\"\n        if not string.startswith((\"http://\", \"https://\")):\n            string = \"http://\" + string\n\n        # Basic URL validation regex\n        url_regex = re.compile(\n            r\"^(https?:\\/\\/)?\"  # optional protocol\n            r\"(www\\.)?\"  # optional www\n            r\"([a-zA-Z0-9.-]+)\"  # domain\n            r\"(\\.[a-zA-Z]{2,})?\"  # top-level domain\n            r\"(:\\d+)?\"  # optional port\n            r\"(\\/[^\\s]*)?$\",  # optional path\n            re.IGNORECASE,\n        )\n\n        if not url_regex.match(string):\n            msg = f\"Invalid URL: {string}\"\n            raise ValueError(msg)\n\n        return string\n\n    def fetch_content(self) -> list[Data]:\n        urls = [self.ensure_url(url.strip()) for url in self.urls if url.strip()]\n        if self.format == \"Raw HTML\":\n            loader = AsyncHtmlLoader(web_path=urls, encoding=\"utf-8\")\n        else:\n            loader = WebBaseLoader(web_paths=urls, encoding=\"utf-8\")\n        docs = loader.load()\n        data = [Data(text=doc.page_content, **doc.metadata) for doc in docs]\n        self.status = data\n        return data\n\n    def fetch_content_text(self) -> Message:\n        data = self.fetch_content()\n\n        result_string = data_to_text(\"{text}\", data)\n        self.status = result_string\n        return Message(text=result_string)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "format": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Text",
    //                     "Raw HTML"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "format",
    //                 "value": "Text",
    //                 "display_name": "Output format",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Output format. Use 'Text' to extract the text from the HTML or 'Raw HTML' for the raw HTML content.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "urls": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "urls",
    //                 "value": "",
    //                 "display_name": "URLs",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Enter one or more URLs, by clicking the '+' button.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Fetch content from one or more URLs.",
    //         "icon": "layout-template",
    //         "base_classes": [
    //             "Data",
    //             "Message"
    //         ],
    //         "display_name": "URL",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "display_name": "Data",
    //                 "method": "fetch_content",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             },
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text",
    //                 "display_name": "Text",
    //                 "method": "fetch_content_text",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "urls",
    //             "format"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "File": {
    //         "template": {
    //             "_type": "Component",
    //             "path": {
    //                 "trace_as_metadata": true,
    //                 "file_path": "",
    //                 "fileTypes": [
    //                     "txt",
    //                     "md",
    //                     "mdx",
    //                     "csv",
    //                     "json",
    //                     "yaml",
    //                     "yml",
    //                     "xml",
    //                     "html",
    //                     "htm",
    //                     "pdf",
    //                     "docx",
    //                     "py",
    //                     "sh",
    //                     "sql",
    //                     "js",
    //                     "ts",
    //                     "tsx"
    //                 ],
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "path",
    //                 "value": "",
    //                 "display_name": "Path",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Supported file types: txt, md, mdx, csv, json, yaml, yml, xml, html, htm, pdf, docx, py, sh, sql, js, ts, tsx",
    //                 "title_case": false,
    //                 "type": "file",
    //                 "_input_type": "FileInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from pathlib import Path\n\nfrom langflow.base.data.utils import TEXT_FILE_TYPES, parse_text_file_to_data\nfrom langflow.custom import Component\nfrom langflow.io import BoolInput, FileInput, Output\nfrom langflow.schema import Data\n\n\nclass FileComponent(Component):\n    display_name = \"File\"\n    description = \"A generic file loader.\"\n    icon = \"file-text\"\n    name = \"File\"\n\n    inputs = [\n        FileInput(\n            name=\"path\",\n            display_name=\"Path\",\n            file_types=TEXT_FILE_TYPES,\n            info=f\"Supported file types: {', '.join(TEXT_FILE_TYPES)}\",\n        ),\n        BoolInput(\n            name=\"silent_errors\",\n            display_name=\"Silent Errors\",\n            advanced=True,\n            info=\"If true, errors will not raise an exception.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"load_file\"),\n    ]\n\n    def load_file(self) -> Data:\n        if not self.path:\n            msg = \"Please, upload a file to use this component.\"\n            raise ValueError(msg)\n        resolved_path = self.resolve_path(self.path)\n        silent_errors = self.silent_errors\n\n        extension = Path(resolved_path).suffix[1:].lower()\n\n        if extension == \"doc\":\n            msg = \"doc files are not supported. Please save as .docx\"\n            raise ValueError(msg)\n        if extension not in TEXT_FILE_TYPES:\n            msg = f\"Unsupported file type: {extension}\"\n            raise ValueError(msg)\n\n        data = parse_text_file_to_data(resolved_path, silent_errors=silent_errors)\n        self.status = data or \"No data\"\n        return data or Data()\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "silent_errors": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "silent_errors",
    //                 "value": false,
    //                 "display_name": "Silent Errors",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "If true, errors will not raise an exception.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "A generic file loader.",
    //         "icon": "file-text",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "File",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "display_name": "Data",
    //                 "method": "load_file",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "path",
    //             "silent_errors"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "GmailLoaderComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import base64\nimport json\nimport re\nfrom collections.abc import Iterator\nfrom json.decoder import JSONDecodeError\nfrom typing import Any\n\nfrom google.auth.exceptions import RefreshError\nfrom google.oauth2.credentials import Credentials\nfrom googleapiclient.discovery import build\nfrom langchain_core.chat_sessions import ChatSession\nfrom langchain_core.messages import HumanMessage\nfrom langchain_google_community.gmail.loader import GMailLoader\nfrom loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.inputs import MessageTextInput\nfrom langflow.io import SecretStrInput\nfrom langflow.schema import Data\nfrom langflow.template import Output\n\n\nclass GmailLoaderComponent(Component):\n    display_name = \"Gmail Loader\"\n    description = \"Loads emails from Gmail using provided credentials.\"\n    icon = \"Google\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"json_string\",\n            display_name=\"JSON String of the Service Account Token\",\n            info=\"JSON string containing OAuth 2.0 access token information for service account access\",\n            required=True,\n            value=\"\"\"{\n                \"account\": \"\",\n                \"client_id\": \"\",\n                \"client_secret\": \"\",\n                \"expiry\": \"\",\n                \"refresh_token\": \"\",\n                \"scopes\": [\n                    \"https://www.googleapis.com/auth/gmail.readonly\",\n                ],\n                \"token\": \"\",\n                \"token_uri\": \"https://oauth2.googleapis.com/token\",\n                \"universe_domain\": \"googleapis.com\"\n            }\"\"\",\n        ),\n        MessageTextInput(\n            name=\"label_ids\",\n            display_name=\"Label IDs\",\n            info=\"Comma-separated list of label IDs to filter emails.\",\n            required=True,\n            value=\"INBOX,SENT,UNREAD,IMPORTANT\",\n        ),\n        MessageTextInput(\n            name=\"max_results\",\n            display_name=\"Max Results\",\n            info=\"Maximum number of emails to load.\",\n            required=True,\n            value=\"10\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"load_emails\"),\n    ]\n\n    def load_emails(self) -> Data:\n        class CustomGMailLoader(GMailLoader):\n            def __init__(\n                self, creds: Any, *, n: int = 100, label_ids: list[str] | None = None, raise_error: bool = False\n            ) -> None:\n                super().__init__(creds, n, raise_error)\n                self.label_ids = label_ids if label_ids is not None else [\"SENT\"]\n\n            def clean_message_content(self, message):\n                # Remove URLs\n                message = re.sub(r\"http\\S+|www\\S+|https\\S+\", \"\", message, flags=re.MULTILINE)\n\n                # Remove email addresses\n                message = re.sub(r\"\\S+@\\S+\", \"\", message)\n\n                # Remove special characters and excessive whitespace\n                message = re.sub(r\"[^A-Za-z0-9\\s]+\", \" \", message)\n                message = re.sub(r\"\\s{2,}\", \" \", message)\n\n                # Trim leading and trailing whitespace\n                return message.strip()\n\n            def _extract_email_content(self, msg: Any) -> HumanMessage:\n                from_email = None\n                for values in msg[\"payload\"][\"headers\"]:\n                    name = values[\"name\"]\n                    if name == \"From\":\n                        from_email = values[\"value\"]\n                if from_email is None:\n                    msg = \"From email not found.\"\n                    raise ValueError(msg)\n\n                parts = msg[\"payload\"][\"parts\"] if \"parts\" in msg[\"payload\"] else [msg[\"payload\"]]\n\n                for part in parts:\n                    if part[\"mimeType\"] == \"text/plain\":\n                        data = part[\"body\"][\"data\"]\n                        data = base64.urlsafe_b64decode(data).decode(\"utf-8\")\n                        pattern = re.compile(r\"\\r\\nOn .+(\\r\\n)*wrote:\\r\\n\")\n                        newest_response = re.split(pattern, data)[0]\n                        return HumanMessage(\n                            content=self.clean_message_content(newest_response),\n                            additional_kwargs={\"sender\": from_email},\n                        )\n                msg = \"No plain text part found in the email.\"\n                raise ValueError(msg)\n\n            def _get_message_data(self, service: Any, message: Any) -> ChatSession:\n                msg = service.users().messages().get(userId=\"me\", id=message[\"id\"]).execute()\n                message_content = self._extract_email_content(msg)\n\n                in_reply_to = None\n                email_data = msg[\"payload\"][\"headers\"]\n                for values in email_data:\n                    name = values[\"name\"]\n                    if name == \"In-Reply-To\":\n                        in_reply_to = values[\"value\"]\n\n                thread_id = msg[\"threadId\"]\n\n                if in_reply_to:\n                    thread = service.users().threads().get(userId=\"me\", id=thread_id).execute()\n                    messages = thread[\"messages\"]\n\n                    response_email = None\n                    for _message in messages:\n                        email_data = _message[\"payload\"][\"headers\"]\n                        for values in email_data:\n                            if values[\"name\"] == \"Message-ID\":\n                                message_id = values[\"value\"]\n                                if message_id == in_reply_to:\n                                    response_email = _message\n                    if response_email is None:\n                        msg = \"Response email not found in the thread.\"\n                        raise ValueError(msg)\n                    starter_content = self._extract_email_content(response_email)\n                    return ChatSession(messages=[starter_content, message_content])\n                return ChatSession(messages=[message_content])\n\n            def lazy_load(self) -> Iterator[ChatSession]:\n                service = build(\"gmail\", \"v1\", credentials=self.creds)\n                results = (\n                    service.users().messages().list(userId=\"me\", labelIds=self.label_ids, maxResults=self.n).execute()\n                )\n                messages = results.get(\"messages\", [])\n                if not messages:\n                    logger.warning(\"No messages found with the specified labels.\")\n                for message in messages:\n                    try:\n                        yield self._get_message_data(service, message)\n                    except Exception:\n                        if self.raise_error:\n                            raise\n                        else:\n                            logger.exception(f\"Error processing message {message['id']}\")\n\n        json_string = self.json_string\n        label_ids = self.label_ids.split(\",\") if self.label_ids else [\"INBOX\"]\n        max_results = int(self.max_results) if self.max_results else 100\n\n        # Load the token information from the JSON string\n        try:\n            token_info = json.loads(json_string)\n        except JSONDecodeError as e:\n            msg = \"Invalid JSON string\"\n            raise ValueError(msg) from e\n\n        creds = Credentials.from_authorized_user_info(token_info)\n\n        # Initialize the custom loader with the provided credentials\n        loader = CustomGMailLoader(creds=creds, n=max_results, label_ids=label_ids)\n\n        try:\n            docs = loader.load()\n        except RefreshError as e:\n            msg = \"Authentication error: Unable to refresh authentication token. Please try to reauthenticate.\"\n            raise ValueError(msg) from e\n        except Exception as e:\n            msg = f\"Error loading documents: {e}\"\n            raise ValueError(msg) from e\n\n        # Return the loaded documents\n        self.status = docs\n        return Data(data={\"text\": docs})\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "json_string": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "json_string",
    //                 "value": "{\n                \"account\": \"\",\n                \"client_id\": \"\",\n                \"client_secret\": \"\",\n                \"expiry\": \"\",\n                \"refresh_token\": \"\",\n                \"scopes\": [\n                    \"https://www.googleapis.com/auth/gmail.readonly\",\n                ],\n                \"token\": \"\",\n                \"token_uri\": \"https://oauth2.googleapis.com/token\",\n                \"universe_domain\": \"googleapis.com\"\n            }",
    //                 "display_name": "JSON String of the Service Account Token",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "JSON string containing OAuth 2.0 access token information for service account access",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "label_ids": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "label_ids",
    //                 "value": "INBOX,SENT,UNREAD,IMPORTANT",
    //                 "display_name": "Label IDs",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Comma-separated list of label IDs to filter emails.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "max_results": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_results",
    //                 "value": "10",
    //                 "display_name": "Max Results",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Maximum number of emails to load.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Loads emails from Gmail using provided credentials.",
    //         "icon": "Google",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Gmail Loader",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "display_name": "Data",
    //                 "method": "load_emails",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "json_string",
    //             "label_ids",
    //             "max_results"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "Directory": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.base.data.utils import TEXT_FILE_TYPES, parallel_load_data, parse_text_file_to_data, retrieve_file_paths\nfrom langflow.custom import Component\nfrom langflow.io import BoolInput, IntInput, MessageTextInput\nfrom langflow.schema import Data\nfrom langflow.template import Output\n\n\nclass DirectoryComponent(Component):\n    display_name = \"Directory\"\n    description = \"Recursively load files from a directory.\"\n    icon = \"folder\"\n    name = \"Directory\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"path\",\n            display_name=\"Path\",\n            info=\"Path to the directory to load files from.\",\n        ),\n        MessageTextInput(\n            name=\"types\",\n            display_name=\"Types\",\n            info=\"File types to load. Leave empty to load all default supported types.\",\n            is_list=True,\n        ),\n        IntInput(\n            name=\"depth\",\n            display_name=\"Depth\",\n            info=\"Depth to search for files.\",\n            value=0,\n        ),\n        IntInput(\n            name=\"max_concurrency\",\n            display_name=\"Max Concurrency\",\n            advanced=True,\n            info=\"Maximum concurrency for loading files.\",\n            value=2,\n        ),\n        BoolInput(\n            name=\"load_hidden\",\n            display_name=\"Load Hidden\",\n            advanced=True,\n            info=\"If true, hidden files will be loaded.\",\n        ),\n        BoolInput(\n            name=\"recursive\",\n            display_name=\"Recursive\",\n            advanced=True,\n            info=\"If true, the search will be recursive.\",\n        ),\n        BoolInput(\n            name=\"silent_errors\",\n            display_name=\"Silent Errors\",\n            advanced=True,\n            info=\"If true, errors will not raise an exception.\",\n        ),\n        BoolInput(\n            name=\"use_multithreading\",\n            display_name=\"Use Multithreading\",\n            advanced=True,\n            info=\"If true, multithreading will be used.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"load_directory\"),\n    ]\n\n    def load_directory(self) -> list[Data]:\n        path = self.path\n        types = (\n            self.types if self.types and self.types != [\"\"] else TEXT_FILE_TYPES\n        )  # self.types is already a list due to is_list=True\n        depth = self.depth\n        max_concurrency = self.max_concurrency\n        load_hidden = self.load_hidden\n        recursive = self.recursive\n        silent_errors = self.silent_errors\n        use_multithreading = self.use_multithreading\n\n        resolved_path = self.resolve_path(path)\n        file_paths = retrieve_file_paths(\n            resolved_path, load_hidden=load_hidden, recursive=recursive, depth=depth, types=types\n        )\n\n        if types:\n            file_paths = [fp for fp in file_paths if any(fp.endswith(ext) for ext in types)]\n\n        loaded_data = []\n\n        if use_multithreading:\n            loaded_data = parallel_load_data(file_paths, silent_errors=silent_errors, max_concurrency=max_concurrency)\n        else:\n            loaded_data = [parse_text_file_to_data(file_path, silent_errors=silent_errors) for file_path in file_paths]\n        loaded_data = list(filter(None, loaded_data))\n        self.status = loaded_data\n        return loaded_data  # type: ignore[return-value]\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "depth": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "depth",
    //                 "value": 0,
    //                 "display_name": "Depth",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Depth to search for files.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "load_hidden": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "load_hidden",
    //                 "value": false,
    //                 "display_name": "Load Hidden",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "If true, hidden files will be loaded.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "max_concurrency": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "max_concurrency",
    //                 "value": 2,
    //                 "display_name": "Max Concurrency",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Maximum concurrency for loading files.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "path": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "path",
    //                 "value": "",
    //                 "display_name": "Path",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Path to the directory to load files from.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "recursive": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "recursive",
    //                 "value": false,
    //                 "display_name": "Recursive",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "If true, the search will be recursive.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "silent_errors": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "silent_errors",
    //                 "value": false,
    //                 "display_name": "Silent Errors",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "If true, errors will not raise an exception.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "types": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "types",
    //                 "value": "",
    //                 "display_name": "Types",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "File types to load. Leave empty to load all default supported types.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "use_multithreading": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "use_multithreading",
    //                 "value": false,
    //                 "display_name": "Use Multithreading",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "If true, multithreading will be used.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Recursively load files from a directory.",
    //         "icon": "folder",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Directory",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "display_name": "Data",
    //                 "method": "load_directory",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "path",
    //             "types",
    //             "depth",
    //             "max_concurrency",
    //             "load_hidden",
    //             "recursive",
    //             "silent_errors",
    //             "use_multithreading"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "GoogleDriveComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import json\nfrom json.decoder import JSONDecodeError\n\nfrom google.auth.exceptions import RefreshError\nfrom google.oauth2.credentials import Credentials\nfrom langchain_google_community import GoogleDriveLoader\n\nfrom langflow.custom import Component\nfrom langflow.helpers.data import docs_to_data\nfrom langflow.inputs import MessageTextInput\nfrom langflow.io import SecretStrInput\nfrom langflow.schema import Data\nfrom langflow.template import Output\n\n\nclass GoogleDriveComponent(Component):\n    display_name = \"Google Drive Loader\"\n    description = \"Loads documents from Google Drive using provided credentials.\"\n    icon = \"Google\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"json_string\",\n            display_name=\"JSON String of the Service Account Token\",\n            info=\"JSON string containing OAuth 2.0 access token information for service account access\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"document_id\", display_name=\"Document ID\", info=\"Single Google Drive document ID\", required=True\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Loaded Documents\", name=\"docs\", method=\"load_documents\"),\n    ]\n\n    def load_documents(self) -> Data:\n        class CustomGoogleDriveLoader(GoogleDriveLoader):\n            creds: Credentials | None = None\n            \"\"\"Credentials object to be passed directly.\"\"\"\n\n            def _load_credentials(self):\n                \"\"\"Load credentials from the provided creds attribute or fallback to the original method.\"\"\"\n                if self.creds:\n                    return self.creds\n                msg = \"No credentials provided.\"\n                raise ValueError(msg)\n\n            class Config:\n                arbitrary_types_allowed = True\n\n        json_string = self.json_string\n\n        document_ids = [self.document_id]\n        if len(document_ids) != 1:\n            msg = \"Expected a single document ID\"\n            raise ValueError(msg)\n\n        # TODO: Add validation to check if the document ID is valid\n\n        # Load the token information from the JSON string\n        try:\n            token_info = json.loads(json_string)\n        except JSONDecodeError as e:\n            msg = \"Invalid JSON string\"\n            raise ValueError(msg) from e\n\n        # Initialize the custom loader with the provided credentials and document IDs\n        loader = CustomGoogleDriveLoader(\n            creds=Credentials.from_authorized_user_info(token_info), document_ids=document_ids\n        )\n\n        # Load the documents\n        try:\n            docs = loader.load()\n        # catch google.auth.exceptions.RefreshError\n        except RefreshError as e:\n            msg = \"Authentication error: Unable to refresh authentication token. Please try to reauthenticate.\"\n            raise ValueError(msg) from e\n        except Exception as e:\n            msg = f\"Error loading documents: {e}\"\n            raise ValueError(msg) from e\n\n        if len(docs) != 1:\n            msg = \"Expected a single document to be loaded.\"\n            raise ValueError(msg)\n\n        data = docs_to_data(docs)\n        # Return the loaded documents\n        self.status = data\n        return Data(data={\"text\": data})\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "document_id": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "document_id",
    //                 "value": "",
    //                 "display_name": "Document ID",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Single Google Drive document ID",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "json_string": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "json_string",
    //                 "value": "",
    //                 "display_name": "JSON String of the Service Account Token",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "JSON string containing OAuth 2.0 access token information for service account access",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             }
    //         },
    //         "description": "Loads documents from Google Drive using provided credentials.",
    //         "icon": "Google",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Google Drive Loader",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "docs",
    //                 "display_name": "Loaded Documents",
    //                 "method": "load_documents",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "json_string",
    //             "document_id"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "outputs": {
    //     "ChatOutput": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import DropdownInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_NAME_AI, MESSAGE_SENDER_USER\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"ChatOutput\"\n    name = \"ChatOutput\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    def message_response(self) -> Message:\n        message = Message(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n        )\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = self.store_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "data_template": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "data_template",
    //                 "value": "{text}",
    //                 "display_name": "Data Template",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Text",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Message to be passed as output.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "sender": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Machine",
    //                     "User"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "sender",
    //                 "value": "Machine",
    //                 "display_name": "Sender Type",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Type of sender.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "sender_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "sender_name",
    //                 "value": "AI",
    //                 "display_name": "Sender Name",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Name of the sender.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "session_id": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "session_id",
    //                 "value": "",
    //                 "display_name": "Session ID",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "should_store_message": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "should_store_message",
    //                 "value": true,
    //                 "display_name": "Store Messages",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Store the message in the history.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Display a chat message in the Playground.",
    //         "icon": "ChatOutput",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Chat Output",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "message",
    //                 "display_name": "Message",
    //                 "method": "message_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "should_store_message",
    //             "sender",
    //             "sender_name",
    //             "session_id",
    //             "data_template"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "TextOutput": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextOutputComponent(TextComponent):\n    display_name = \"Text Output\"\n    description = \"Display a text output in the Playground.\"\n    icon = \"type\"\n    name = \"TextOutput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as output.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Text\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        message = Message(\n            text=self.input_value,\n        )\n        self.status = self.input_value\n        return message\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Text",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Text to be passed as output.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Display a text output in the Playground.",
    //         "icon": "type",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Text Output",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text",
    //                 "display_name": "Text",
    //                 "method": "text_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "input_value"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "helpers": {
    //     "StructuredOutputComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "llm": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "llm",
    //                 "value": "",
    //                 "display_name": "Language Model",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "LanguageModel"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The language model to use to generate the structured output.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import cast\n\nfrom pydantic import BaseModel, Field, create_model\n\nfrom langflow.base.models.chat_result import get_chat_result\nfrom langflow.custom import Component\nfrom langflow.field_typing.constants import LanguageModel\nfrom langflow.helpers.base_model import build_model_from_schema\nfrom langflow.io import BoolInput, HandleInput, MessageTextInput, Output, StrInput, TableInput\nfrom langflow.schema.data import Data\n\n\nclass StructuredOutputComponent(Component):\n    display_name = \"Structured Output\"\n    description = (\n        \"Transforms LLM responses into **structured data formats**. Ideal for extracting specific information \"\n        \"or creating consistent outputs.\"\n    )\n    inputs = [\n        HandleInput(\n            name=\"llm\",\n            display_name=\"Language Model\",\n            info=\"The language model to use to generate the structured output.\",\n            input_types=[\"LanguageModel\"],\n        ),\n        MessageTextInput(name=\"input_value\", display_name=\"Input message\"),\n        StrInput(\n            name=\"schema_name\",\n            display_name=\"Schema Name\",\n            info=\"Provide a name for the output data schema.\",\n        ),\n        TableInput(\n            name=\"output_schema\",\n            display_name=\"Output Schema\",\n            info=\"Define the structure and data types for the model's output.\",\n            table_schema=[\n                {\n                    \"name\": \"name\",\n                    \"display_name\": \"Name\",\n                    \"type\": \"str\",\n                    \"description\": \"Specify the name of the output field.\",\n                },\n                {\n                    \"name\": \"description\",\n                    \"display_name\": \"Description\",\n                    \"type\": \"str\",\n                    \"description\": \"Describe the purpose of the output field.\",\n                },\n                {\n                    \"name\": \"type\",\n                    \"display_name\": \"Type\",\n                    \"type\": \"str\",\n                    \"description\": (\n                        \"Indicate the data type of the output field \" \"(e.g., str, int, float, bool, list, dict).\"\n                    ),\n                    \"default\": \"text\",\n                },\n                {\n                    \"name\": \"multiple\",\n                    \"display_name\": \"Multiple\",\n                    \"type\": \"boolean\",\n                    \"description\": \"Set to True if this output field should be a list of the specified type.\",\n                    \"default\": \"False\",\n                },\n            ],\n        ),\n        BoolInput(\n            name=\"multiple\",\n            display_name=\"Generate Multiple\",\n            info=\"Set to True if the model should generate a list of outputs instead of a single output.\",\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"structured_output\", display_name=\"Structured Output\", method=\"build_structured_output\"),\n    ]\n\n    def build_structured_output(self) -> Data:\n        if not hasattr(self.llm, \"with_structured_output\"):\n            msg = \"Language model does not support structured output.\"\n            raise TypeError(msg)\n        if not self.output_schema:\n            msg = \"Output schema cannot be empty\"\n            raise ValueError(msg)\n\n        _output_model = build_model_from_schema(self.output_schema)\n        if self.multiple:\n            output_model = create_model(\n                self.schema_name,\n                objects=(list[_output_model], Field(description=f\"A list of {self.schema_name}.\")),  # type: ignore[valid-type]\n            )\n        else:\n            output_model = _output_model\n        try:\n            llm_with_structured_output = cast(LanguageModel, self.llm).with_structured_output(schema=output_model)  # type: ignore[valid-type, attr-defined]\n\n        except NotImplementedError as exc:\n            msg = f\"{self.llm.__class__.__name__} does not support structured output.\"\n            raise TypeError(msg) from exc\n        config_dict = {\n            \"run_name\": self.display_name,\n            \"project_name\": self.get_project_name(),\n            \"callbacks\": self.get_langchain_callbacks(),\n        }\n        output = get_chat_result(runnable=llm_with_structured_output, input_value=self.input_value, config=config_dict)\n        if isinstance(output, BaseModel):\n            output_dict = output.model_dump()\n        else:\n            msg = f\"Output should be a Pydantic BaseModel, got {type(output)} ({output})\"\n            raise TypeError(msg)\n        return Data(data=output_dict)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input message",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "multiple": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "multiple",
    //                 "value": false,
    //                 "display_name": "Generate Multiple",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Set to True if the model should generate a list of outputs instead of a single output.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "output_schema": {
    //                 "is_list": true,
    //                 "table_schema": {
    //                     "columns": [
    //                         {
    //                             "name": "name",
    //                             "display_name": "Name",
    //                             "sortable": true,
    //                             "filterable": true,
    //                             "type": "text",
    //                             "description": "Specify the name of the output field."
    //                         },
    //                         {
    //                             "name": "description",
    //                             "display_name": "Description",
    //                             "sortable": true,
    //                             "filterable": true,
    //                             "type": "text",
    //                             "description": "Describe the purpose of the output field."
    //                         },
    //                         {
    //                             "name": "type",
    //                             "display_name": "Type",
    //                             "sortable": true,
    //                             "filterable": true,
    //                             "type": "text",
    //                             "description": "Indicate the data type of the output field (e.g., str, int, float, bool, list, dict).",
    //                             "default": "text"
    //                         },
    //                         {
    //                             "name": "multiple",
    //                             "display_name": "Multiple",
    //                             "sortable": true,
    //                             "filterable": true,
    //                             "type": "boolean",
    //                             "description": "Set to True if this output field should be a list of the specified type.",
    //                             "default": "False"
    //                         }
    //                     ]
    //                 },
    //                 "trace_as_metadata": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "output_schema",
    //                 "value": "",
    //                 "display_name": "Output Schema",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Define the structure and data types for the model's output.",
    //                 "title_case": false,
    //                 "type": "table",
    //                 "_input_type": "TableInput"
    //             },
    //             "schema_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "schema_name",
    //                 "value": "",
    //                 "display_name": "Schema Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Provide a name for the output data schema.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Transforms LLM responses into **structured data formats**. Ideal for extracting specific information or creating consistent outputs.",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Structured Output",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "structured_output",
    //                 "display_name": "Structured Output",
    //                 "method": "build_structured_output",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "llm",
    //             "input_value",
    //             "schema_name",
    //             "output_schema",
    //             "multiple"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "SequentialTaskComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "agent": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "agent",
    //                 "value": "",
    //                 "display_name": "Agent",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Agent"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "CrewAI Agent that will perform the task",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "task": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "task",
    //                 "value": "",
    //                 "display_name": "Task",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "SequentialTask"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "CrewAI Task that will perform the task",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "tools": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tools",
    //                 "value": "",
    //                 "display_name": "Tools",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Tool"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "List of tools/resources limited for task execution. Uses the Agent tools by default.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "async_execution": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "async_execution",
    //                 "value": true,
    //                 "display_name": "Async Execution",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Boolean flag indicating asynchronous task execution.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.base.agents.crewai.tasks import SequentialTask\nfrom langflow.custom import Component\nfrom langflow.io import BoolInput, HandleInput, MultilineInput, Output\n\n\nclass SequentialTaskComponent(Component):\n    display_name: str = \"Sequential Task\"\n    description: str = \"Each task must have a description, an expected output and an agent responsible for execution.\"\n    icon = \"CrewAI\"\n    inputs = [\n        MultilineInput(\n            name=\"task_description\",\n            display_name=\"Description\",\n            info=\"Descriptive text detailing task's purpose and execution.\",\n        ),\n        MultilineInput(\n            name=\"expected_output\",\n            display_name=\"Expected Output\",\n            info=\"Clear definition of expected task outcome.\",\n        ),\n        HandleInput(\n            name=\"tools\",\n            display_name=\"Tools\",\n            input_types=[\"Tool\"],\n            is_list=True,\n            info=\"List of tools/resources limited for task execution. Uses the Agent tools by default.\",\n            required=False,\n            advanced=True,\n        ),\n        HandleInput(\n            name=\"agent\",\n            display_name=\"Agent\",\n            input_types=[\"Agent\"],\n            info=\"CrewAI Agent that will perform the task\",\n            required=True,\n        ),\n        HandleInput(\n            name=\"task\",\n            display_name=\"Task\",\n            input_types=[\"SequentialTask\"],\n            info=\"CrewAI Task that will perform the task\",\n        ),\n        BoolInput(\n            name=\"async_execution\",\n            display_name=\"Async Execution\",\n            value=True,\n            advanced=True,\n            info=\"Boolean flag indicating asynchronous task execution.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Task\", name=\"task_output\", method=\"build_task\"),\n    ]\n\n    def build_task(self) -> list[SequentialTask]:\n        tasks: list[SequentialTask] = []\n        task = SequentialTask(\n            description=self.task_description,\n            expected_output=self.expected_output,\n            tools=self.agent.tools,\n            async_execution=False,\n            agent=self.agent,\n        )\n        tasks.append(task)\n        self.status = task\n        if self.task:\n            if isinstance(self.task, list) and all(isinstance(task, SequentialTask) for task in self.task):\n                tasks = self.task + tasks\n            elif isinstance(self.task, SequentialTask):\n                tasks = [self.task, *tasks]\n        return tasks\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "expected_output": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "expected_output",
    //                 "value": "",
    //                 "display_name": "Expected Output",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Clear definition of expected task outcome.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "task_description": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "task_description",
    //                 "value": "",
    //                 "display_name": "Description",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Descriptive text detailing task's purpose and execution.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Each task must have a description, an expected output and an agent responsible for execution.",
    //         "icon": "CrewAI",
    //         "base_classes": [
    //             "SequentialTask"
    //         ],
    //         "display_name": "Sequential Task",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "SequentialTask"
    //                 ],
    //                 "selected": "SequentialTask",
    //                 "name": "task_output",
    //                 "display_name": "Task",
    //                 "method": "build_task",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "task_description",
    //             "expected_output",
    //             "tools",
    //             "agent",
    //             "task",
    //             "async_execution"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "IDGenerator": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import uuid\nfrom typing import Any\n\nfrom typing_extensions import override\n\nfrom langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema import dotdict\nfrom langflow.schema.message import Message\n\n\nclass IDGeneratorComponent(Component):\n    display_name = \"ID Generator\"\n    description = \"Generates a unique ID.\"\n    icon = \"fingerprint\"\n    name = \"IDGenerator\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"unique_id\",\n            display_name=\"Value\",\n            info=\"The generated unique ID.\",\n            refresh_button=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"ID\", name=\"id\", method=\"generate_id\"),\n    ]\n\n    @override\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"unique_id\":\n            build_config[field_name][\"value\"] = str(uuid.uuid4())\n        return build_config\n\n    def generate_id(self) -> Message:\n        unique_id = self.unique_id or str(uuid.uuid4())\n        self.status = f\"Generated ID: {unique_id}\"\n        return Message(text=unique_id)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "unique_id": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "unique_id",
    //                 "value": "",
    //                 "display_name": "Value",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The generated unique ID.",
    //                 "refresh_button": true,
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Generates a unique ID.",
    //         "icon": "fingerprint",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "ID Generator",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "id",
    //                 "display_name": "ID",
    //                 "method": "generate_id",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "unique_id"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "CreateList": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.custom import Component\nfrom langflow.inputs import StrInput\nfrom langflow.schema import Data\nfrom langflow.template import Output\n\n\nclass CreateListComponent(Component):\n    display_name = \"Create List\"\n    description = \"Creates a list of texts.\"\n    icon = \"list\"\n    name = \"CreateList\"\n\n    inputs = [\n        StrInput(\n            name=\"texts\",\n            display_name=\"Texts\",\n            info=\"Enter one or more texts.\",\n            is_list=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data List\", name=\"list\", method=\"create_list\"),\n    ]\n\n    def create_list(self) -> list[Data]:\n        data = [Data(text=text) for text in self.texts]\n        self.status = data\n        return data\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "texts": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "texts",
    //                 "value": "",
    //                 "display_name": "Texts",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Enter one or more texts.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Creates a list of texts.",
    //         "icon": "list",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Create List",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "list",
    //                 "display_name": "Data List",
    //                 "method": "create_list",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "texts"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "CombineText": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema.message import Message\n\n\nclass CombineTextComponent(Component):\n    display_name = \"Combine Text\"\n    description = \"Concatenate two text sources into a single text chunk using a specified delimiter.\"\n    icon = \"merge\"\n    name = \"CombineText\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"text1\",\n            display_name=\"First Text\",\n            info=\"The first text input to concatenate.\",\n        ),\n        MessageTextInput(\n            name=\"text2\",\n            display_name=\"Second Text\",\n            info=\"The second text input to concatenate.\",\n        ),\n        MessageTextInput(\n            name=\"delimiter\",\n            display_name=\"Delimiter\",\n            info=\"A string used to separate the two text inputs. Defaults to a whitespace.\",\n            value=\" \",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Combined Text\", name=\"combined_text\", method=\"combine_texts\"),\n    ]\n\n    def combine_texts(self) -> Message:\n        combined = self.delimiter.join([self.text1, self.text2])\n        self.status = combined\n        return Message(text=combined)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "delimiter": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "delimiter",
    //                 "value": " ",
    //                 "display_name": "Delimiter",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "A string used to separate the two text inputs. Defaults to a whitespace.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "text1": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "text1",
    //                 "value": "",
    //                 "display_name": "First Text",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The first text input to concatenate.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "text2": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "text2",
    //                 "value": "",
    //                 "display_name": "Second Text",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The second text input to concatenate.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Concatenate two text sources into a single text chunk using a specified delimiter.",
    //         "icon": "merge",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Combine Text",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "combined_text",
    //                 "display_name": "Combined Text",
    //                 "method": "combine_texts",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "text1",
    //             "text2",
    //             "delimiter"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "Memory": {
    //         "template": {
    //             "_type": "Component",
    //             "memory": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "memory",
    //                 "value": "",
    //                 "display_name": "External Memory",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "BaseChatMessageHistory"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Retrieve messages from an external memory. If empty, it will use the Langflow tables.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain.memory import ConversationBufferMemory\n\nfrom langflow.custom import Component\nfrom langflow.field_typing import BaseChatMemory\nfrom langflow.helpers.data import data_to_text\nfrom langflow.inputs import HandleInput\nfrom langflow.io import DropdownInput, IntInput, MessageTextInput, MultilineInput, Output\nfrom langflow.memory import LCBuiltinChatMemory, get_messages\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_USER\n\n\nclass MemoryComponent(Component):\n    display_name = \"Chat Memory\"\n    description = \"Retrieves stored chat messages from Langflow tables or an external memory.\"\n    icon = \"message-square-more\"\n    name = \"Memory\"\n\n    inputs = [\n        HandleInput(\n            name=\"memory\",\n            display_name=\"External Memory\",\n            input_types=[\"BaseChatMessageHistory\"],\n            info=\"Retrieve messages from an external memory. If empty, it will use the Langflow tables.\",\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER, \"Machine and User\"],\n            value=\"Machine and User\",\n            info=\"Filter by sender type.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Filter by sender name.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"n_messages\",\n            display_name=\"Number of Messages\",\n            value=100,\n            info=\"Number of messages to retrieve.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"order\",\n            display_name=\"Order\",\n            options=[\"Ascending\", \"Descending\"],\n            value=\"Ascending\",\n            info=\"Order of the messages.\",\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. \"\n            \"It can contain the keys {text}, {sender} or any other key in the message data.\",\n            value=\"{sender_name}: {text}\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Messages (Data)\", name=\"messages\", method=\"retrieve_messages\"),\n        Output(display_name=\"Messages (Text)\", name=\"messages_text\", method=\"retrieve_messages_as_text\"),\n        Output(display_name=\"Memory\", name=\"lc_memory\", method=\"build_lc_memory\"),\n    ]\n\n    def retrieve_messages(self) -> Data:\n        sender = self.sender\n        sender_name = self.sender_name\n        session_id = self.session_id\n        n_messages = self.n_messages\n        order = \"DESC\" if self.order == \"Descending\" else \"ASC\"\n\n        if sender == \"Machine and User\":\n            sender = None\n\n        if self.memory:\n            # override session_id\n            self.memory.session_id = session_id\n\n            stored = self.memory.messages\n            # langchain memories are supposed to return messages in ascending order\n            if order == \"DESC\":\n                stored = stored[::-1]\n            if n_messages:\n                stored = stored[:n_messages]\n            stored = [Message.from_lc_message(m) for m in stored]\n            if sender:\n                expected_type = MESSAGE_SENDER_AI if sender == MESSAGE_SENDER_AI else MESSAGE_SENDER_USER\n                stored = [m for m in stored if m.type == expected_type]\n        else:\n            stored = get_messages(\n                sender=sender,\n                sender_name=sender_name,\n                session_id=session_id,\n                limit=n_messages,\n                order=order,\n            )\n        self.status = stored\n        return stored\n\n    def retrieve_messages_as_text(self) -> Message:\n        stored_text = data_to_text(self.template, self.retrieve_messages())\n        self.status = stored_text\n        return Message(text=stored_text)\n\n    def build_lc_memory(self) -> BaseChatMemory:\n        chat_memory = self.memory or LCBuiltinChatMemory(flow_id=self.flow_id, session_id=self.session_id)\n        return ConversationBufferMemory(chat_memory=chat_memory)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "n_messages": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "n_messages",
    //                 "value": 100,
    //                 "display_name": "Number of Messages",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Number of messages to retrieve.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "order": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Ascending",
    //                     "Descending"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "order",
    //                 "value": "Ascending",
    //                 "display_name": "Order",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Order of the messages.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "sender": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Machine",
    //                     "User",
    //                     "Machine and User"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "sender",
    //                 "value": "Machine and User",
    //                 "display_name": "Sender Type",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Filter by sender type.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "sender_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "sender_name",
    //                 "value": "",
    //                 "display_name": "Sender Name",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Filter by sender name.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "session_id": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "session_id",
    //                 "value": "",
    //                 "display_name": "Session ID",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "template": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "template",
    //                 "value": "{sender_name}: {text}",
    //                 "display_name": "Template",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The template to use for formatting the data. It can contain the keys {text}, {sender} or any other key in the message data.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Retrieves stored chat messages from Langflow tables or an external memory.",
    //         "icon": "message-square-more",
    //         "base_classes": [
    //             "BaseChatMemory",
    //             "Data",
    //             "Message"
    //         ],
    //         "display_name": "Chat Memory",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "messages",
    //                 "display_name": "Messages (Data)",
    //                 "method": "retrieve_messages",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             },
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "messages_text",
    //                 "display_name": "Messages (Text)",
    //                 "method": "retrieve_messages_as_text",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             },
    //             {
    //                 "types": [
    //                     "BaseChatMemory"
    //                 ],
    //                 "selected": "BaseChatMemory",
    //                 "name": "lc_memory",
    //                 "display_name": "Memory",
    //                 "method": "build_lc_memory",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "memory",
    //             "sender",
    //             "sender_name",
    //             "n_messages",
    //             "session_id",
    //             "order",
    //             "template"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "DataConditionalRouter": {
    //         "template": {
    //             "_type": "Component",
    //             "data_input": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "data_input",
    //                 "value": "",
    //                 "display_name": "Data Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The Data object or list of Data objects to process",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import DataInput, DropdownInput, MessageTextInput, Output\nfrom langflow.schema import Data, dotdict\n\n\nclass DataConditionalRouterComponent(Component):\n    display_name = \"Data Conditional Router\"\n    description = \"Route Data object(s) based on a condition applied to a specified key, including boolean validation.\"\n    icon = \"split\"\n    beta = True\n    name = \"DataConditionalRouter\"\n\n    inputs = [\n        DataInput(\n            name=\"data_input\",\n            display_name=\"Data Input\",\n            info=\"The Data object or list of Data objects to process\",\n            is_list=True,\n        ),\n        MessageTextInput(\n            name=\"key_name\",\n            display_name=\"Key Name\",\n            info=\"The name of the key in the Data object(s) to check\",\n        ),\n        DropdownInput(\n            name=\"operator\",\n            display_name=\"Comparison Operator\",\n            options=[\"equals\", \"not equals\", \"contains\", \"starts with\", \"ends with\", \"boolean validator\"],\n            info=\"The operator to apply for comparing the values. 'boolean validator' treats the value as a boolean.\",\n            value=\"equals\",\n        ),\n        MessageTextInput(\n            name=\"compare_value\",\n            display_name=\"Compare Value\",\n            info=\"The value to compare against (not used for boolean validator)\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"True Output\", name=\"true_output\", method=\"process_data\"),\n        Output(display_name=\"False Output\", name=\"false_output\", method=\"process_data\"),\n    ]\n\n    def compare_values(self, item_value: str, compare_value: str, operator: str) -> bool:\n        if operator == \"equals\":\n            return item_value == compare_value\n        if operator == \"not equals\":\n            return item_value != compare_value\n        if operator == \"contains\":\n            return compare_value in item_value\n        if operator == \"starts with\":\n            return item_value.startswith(compare_value)\n        if operator == \"ends with\":\n            return item_value.endswith(compare_value)\n        if operator == \"boolean validator\":\n            return self.parse_boolean(item_value)\n        return False\n\n    def parse_boolean(self, value):\n        if isinstance(value, bool):\n            return value\n        if isinstance(value, str):\n            return value.lower() in {\"true\", \"1\", \"yes\", \"y\", \"on\"}\n        return bool(value)\n\n    def validate_input(self, data_item: Data) -> bool:\n        if not isinstance(data_item, Data):\n            self.status = \"Input is not a Data object\"\n            return False\n        if self.key_name not in data_item.data:\n            self.status = f\"Key '{self.key_name}' not found in Data\"\n            return False\n        return True\n\n    def process_data(self) -> Data | list[Data]:\n        if isinstance(self.data_input, list):\n            true_output = []\n            false_output = []\n            for item in self.data_input:\n                if self.validate_input(item):\n                    result = self.process_single_data(item)\n                    if result:\n                        true_output.append(item)\n                    else:\n                        false_output.append(item)\n            self.stop(\"false_output\" if true_output else \"true_output\")\n            return true_output or false_output\n        if not self.validate_input(self.data_input):\n            return Data(data={\"error\": self.status})\n        result = self.process_single_data(self.data_input)\n        self.stop(\"false_output\" if result else \"true_output\")\n        return self.data_input\n\n    def process_single_data(self, data_item: Data) -> bool:\n        item_value = data_item.data[self.key_name]\n        operator = self.operator\n\n        if operator == \"boolean validator\":\n            condition_met = self.parse_boolean(item_value)\n            condition_description = f\"Boolean validation of '{self.key_name}'\"\n        else:\n            compare_value = self.compare_value\n            condition_met = self.compare_values(str(item_value), compare_value, operator)\n            condition_description = f\"{self.key_name} {operator} {compare_value}\"\n\n        if condition_met:\n            self.status = f\"Condition met: {condition_description}\"\n            return True\n        self.status = f\"Condition not met: {condition_description}\"\n        return False\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"operator\":\n            if field_value == \"boolean validator\":\n                build_config[\"compare_value\"][\"show\"] = False\n                build_config[\"compare_value\"][\"advanced\"] = True\n                build_config[\"compare_value\"][\"value\"] = None\n            else:\n                build_config[\"compare_value\"][\"show\"] = True\n                build_config[\"compare_value\"][\"advanced\"] = False\n\n        return build_config\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "compare_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "compare_value",
    //                 "value": "",
    //                 "display_name": "Compare Value",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The value to compare against (not used for boolean validator)",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "key_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "key_name",
    //                 "value": "",
    //                 "display_name": "Key Name",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The name of the key in the Data object(s) to check",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "operator": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "equals",
    //                     "not equals",
    //                     "contains",
    //                     "starts with",
    //                     "ends with",
    //                     "boolean validator"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "operator",
    //                 "value": "equals",
    //                 "display_name": "Comparison Operator",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The operator to apply for comparing the values. 'boolean validator' treats the value as a boolean.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             }
    //         },
    //         "description": "Route Data object(s) based on a condition applied to a specified key, including boolean validation.",
    //         "icon": "split",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Data Conditional Router",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "true_output",
    //                 "display_name": "True Output",
    //                 "method": "process_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             },
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "false_output",
    //                 "display_name": "False Output",
    //                 "method": "process_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "data_input",
    //             "key_name",
    //             "operator",
    //             "compare_value"
    //         ],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "JSONtoData": {
    //         "template": {
    //             "_type": "Component",
    //             "json_file": {
    //                 "trace_as_metadata": true,
    //                 "file_path": "",
    //                 "fileTypes": [
    //                     "json"
    //                 ],
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "json_file",
    //                 "value": "",
    //                 "display_name": "JSON File",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Upload a JSON file to convert to a Data object or list of Data objects",
    //                 "title_case": false,
    //                 "type": "file",
    //                 "_input_type": "FileInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import json\nfrom pathlib import Path\n\nfrom json_repair import repair_json\n\nfrom langflow.custom import Component\nfrom langflow.io import FileInput, MessageTextInput, MultilineInput, Output\nfrom langflow.schema import Data\n\n\nclass JSONToDataComponent(Component):\n    display_name = \"JSON to Data\"\n    description = (\n        \"Convert a JSON file, JSON from a file path, or a JSON string to a Data object or a list of Data objects\"\n    )\n    icon = \"braces\"\n    beta = True\n    name = \"JSONtoData\"\n\n    inputs = [\n        FileInput(\n            name=\"json_file\",\n            display_name=\"JSON File\",\n            file_types=[\"json\"],\n            info=\"Upload a JSON file to convert to a Data object or list of Data objects\",\n        ),\n        MessageTextInput(\n            name=\"json_path\",\n            display_name=\"JSON File Path\",\n            info=\"Provide the path to the JSON file as pure text\",\n        ),\n        MultilineInput(\n            name=\"json_string\",\n            display_name=\"JSON String\",\n            info=\"Enter a valid JSON string (object or array) to convert to a Data object or list of Data objects\",\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"data\", display_name=\"Data\", method=\"convert_json_to_data\"),\n    ]\n\n    def convert_json_to_data(self) -> Data | list[Data]:\n        if sum(bool(field) for field in [self.json_file, self.json_path, self.json_string]) != 1:\n            msg = \"Please provide exactly one of: JSON file, file path, or JSON string.\"\n            self.status = msg\n            raise ValueError(msg)\n\n        json_data = None\n\n        try:\n            if self.json_file:\n                resolved_path = self.resolve_path(self.json_file)\n                file_path = Path(resolved_path)\n                if file_path.suffix.lower() != \".json\":\n                    self.status = \"The provided file must be a JSON file.\"\n                else:\n                    json_data = file_path.read_text(encoding=\"utf-8\")\n\n            elif self.json_path:\n                file_path = Path(self.json_path)\n                if file_path.suffix.lower() != \".json\":\n                    self.status = \"The provided file must be a JSON file.\"\n                else:\n                    json_data = file_path.read_text(encoding=\"utf-8\")\n\n            else:\n                json_data = self.json_string\n\n            if json_data:\n                # Try to parse the JSON string\n                try:\n                    parsed_data = json.loads(json_data)\n                except json.JSONDecodeError:\n                    # If JSON parsing fails, try to repair the JSON string\n                    repaired_json_string = repair_json(json_data)\n                    parsed_data = json.loads(repaired_json_string)\n\n                # Check if the parsed data is a list\n                if isinstance(parsed_data, list):\n                    result = [Data(data=item) for item in parsed_data]\n                else:\n                    result = Data(data=parsed_data)\n                self.status = result\n                return result\n\n        except (json.JSONDecodeError, SyntaxError, ValueError) as e:\n            error_message = f\"Invalid JSON or Python literal: {e}\"\n            self.status = error_message\n            raise ValueError(error_message) from e\n\n        except Exception as e:\n            error_message = f\"An error occurred: {e}\"\n            self.status = error_message\n            raise ValueError(error_message) from e\n\n        # An error occurred\n        raise ValueError(self.status)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "json_path": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "json_path",
    //                 "value": "",
    //                 "display_name": "JSON File Path",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Provide the path to the JSON file as pure text",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "json_string": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "json_string",
    //                 "value": "",
    //                 "display_name": "JSON String",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Enter a valid JSON string (object or array) to convert to a Data object or list of Data objects",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Convert a JSON file, JSON from a file path, or a JSON string to a Data object or a list of Data objects",
    //         "icon": "braces",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "JSON to Data",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "display_name": "Data",
    //                 "method": "convert_json_to_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "json_file",
    //             "json_path",
    //             "json_string"
    //         ],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "ParseJSONData": {
    //         "template": {
    //             "_type": "Component",
    //             "input_value": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message",
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Data object to filter.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import json\nfrom json import JSONDecodeError\n\nimport jq\nfrom json_repair import repair_json\nfrom loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.inputs import HandleInput, MessageTextInput\nfrom langflow.io import Output\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\n\n\nclass ParseJSONDataComponent(Component):\n    display_name = \"Parse JSON\"\n    description = \"Convert and extract JSON fields.\"\n    icon = \"braces\"\n    name = \"ParseJSONData\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n            info=\"Data object to filter.\",\n            required=True,\n            input_types=[\"Message\", \"Data\"],\n        ),\n        MessageTextInput(\n            name=\"query\",\n            display_name=\"JQ Query\",\n            info=\"JQ Query to filter the data. The input is always a JSON list.\",\n            required=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Filtered Data\", name=\"filtered_data\", method=\"filter_data\"),\n    ]\n\n    def _parse_data(self, input_value) -> str:\n        if isinstance(input_value, Message) and isinstance(input_value.text, str):\n            return input_value.text\n        if isinstance(input_value, Data):\n            return json.dumps(input_value.data)\n        return str(input_value)\n\n    def filter_data(self) -> list[Data]:\n        to_filter = self.input_value\n        if not to_filter:\n            return []\n        if isinstance(to_filter, list):\n            to_filter = [self._parse_data(f) for f in to_filter]\n        else:\n            to_filter = [self._parse_data(to_filter)]\n\n        to_filter = [repair_json(f) for f in to_filter]\n        to_filter_as_dict = []\n        for f in to_filter:\n            try:\n                to_filter_as_dict.append(json.loads(f))\n            except JSONDecodeError:\n                try:\n                    to_filter_as_dict.append(json.loads(repair_json(f)))\n                except JSONDecodeError as e:\n                    msg = f\"Invalid JSON: {e}\"\n                    raise ValueError(msg) from e\n\n        full_filter_str = json.dumps(to_filter_as_dict)\n\n        logger.info(\"to_filter: \", to_filter)\n\n        results = jq.compile(self.query).input_text(full_filter_str).all()\n        logger.info(\"results: \", results)\n        return [Data(data=value) if isinstance(value, dict) else Data(text=str(value)) for value in results]\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "query": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "query",
    //                 "value": "",
    //                 "display_name": "JQ Query",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "JQ Query to filter the data. The input is always a JSON list.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Convert and extract JSON fields.",
    //         "icon": "braces",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Parse JSON",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "filtered_data",
    //                 "display_name": "Filtered Data",
    //                 "method": "filter_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "query"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "StoreMessage": {
    //         "template": {
    //             "_type": "Component",
    //             "memory": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "memory",
    //                 "value": "",
    //                 "display_name": "External Memory",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "BaseChatMessageHistory"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The external memory to store the message. If empty, it will use the Langflow tables.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.custom import Component\nfrom langflow.inputs import HandleInput, MessageInput\nfrom langflow.inputs.inputs import MessageTextInput\nfrom langflow.memory import get_messages, store_message\nfrom langflow.schema.message import Message\nfrom langflow.template import Output\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_NAME_AI\n\n\nclass StoreMessageComponent(Component):\n    display_name = \"Store Message\"\n    description = \"Stores a chat message or text into Langflow tables or an external memory.\"\n    icon = \"save\"\n    name = \"StoreMessage\"\n\n    inputs = [\n        MessageInput(name=\"message\", display_name=\"Message\", info=\"The chat message to be stored.\", required=True),\n        HandleInput(\n            name=\"memory\",\n            display_name=\"External Memory\",\n            input_types=[\"BaseChatMessageHistory\"],\n            info=\"The external memory to store the message. If empty, it will use the Langflow tables.\",\n        ),\n        MessageTextInput(\n            name=\"sender\",\n            display_name=\"Sender\",\n            info=\"The sender of the message. Might be Machine or User. \"\n            \"If empty, the current sender parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"The name of the sender. Might be AI or User. If empty, the current sender parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            value=\"\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Stored Messages\", name=\"stored_messages\", method=\"store_message\"),\n    ]\n\n    def store_message(self) -> Message:\n        message = self.message\n\n        message.session_id = self.session_id or message.session_id\n        message.sender = self.sender or message.sender or MESSAGE_SENDER_AI\n        message.sender_name = self.sender_name or message.sender_name or MESSAGE_SENDER_NAME_AI\n\n        if self.memory:\n            # override session_id\n            self.memory.session_id = message.session_id\n            lc_message = message.to_lc_message()\n            self.memory.add_messages([lc_message])\n            stored = self.memory.messages\n            stored = [Message.from_lc_message(m) for m in stored]\n            if message.sender:\n                stored = [m for m in stored if m.sender == message.sender]\n        else:\n            store_message(message, flow_id=self.graph.flow_id)\n            stored = get_messages(session_id=message.session_id, sender_name=message.sender_name, sender=message.sender)\n        self.status = stored\n        return stored\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "message",
    //                 "value": "",
    //                 "display_name": "Message",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The chat message to be stored.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "sender": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "sender",
    //                 "value": "",
    //                 "display_name": "Sender",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The sender of the message. Might be Machine or User. If empty, the current sender parameter will be used.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "sender_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "sender_name",
    //                 "value": "",
    //                 "display_name": "Sender Name",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The name of the sender. Might be AI or User. If empty, the current sender parameter will be used.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "session_id": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "session_id",
    //                 "value": "",
    //                 "display_name": "Session ID",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Stores a chat message or text into Langflow tables or an external memory.",
    //         "icon": "save",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Store Message",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "stored_messages",
    //                 "display_name": "Stored Messages",
    //                 "method": "store_message",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "message",
    //             "memory",
    //             "sender",
    //             "sender_name",
    //             "session_id"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "SplitText": {
    //         "template": {
    //             "_type": "Component",
    //             "data_inputs": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "data_inputs",
    //                 "value": "",
    //                 "display_name": "Data Inputs",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The data to split.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "chunk_overlap": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chunk_overlap",
    //                 "value": 200,
    //                 "display_name": "Chunk Overlap",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Number of characters to overlap between chunks.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "chunk_size": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "chunk_size",
    //                 "value": 1000,
    //                 "display_name": "Chunk Size",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The maximum number of characters in each chunk.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langchain_text_splitters import CharacterTextSplitter\n\nfrom langflow.custom import Component\nfrom langflow.io import HandleInput, IntInput, MessageTextInput, Output\nfrom langflow.schema import Data\nfrom langflow.utils.util import unescape_string\n\n\nclass SplitTextComponent(Component):\n    display_name: str = \"Split Text\"\n    description: str = \"Split text into chunks based on specified criteria.\"\n    icon = \"scissors-line-dashed\"\n    name = \"SplitText\"\n\n    inputs = [\n        HandleInput(\n            name=\"data_inputs\",\n            display_name=\"Data Inputs\",\n            info=\"The data to split.\",\n            input_types=[\"Data\"],\n            is_list=True,\n        ),\n        IntInput(\n            name=\"chunk_overlap\",\n            display_name=\"Chunk Overlap\",\n            info=\"Number of characters to overlap between chunks.\",\n            value=200,\n        ),\n        IntInput(\n            name=\"chunk_size\",\n            display_name=\"Chunk Size\",\n            info=\"The maximum number of characters in each chunk.\",\n            value=1000,\n        ),\n        MessageTextInput(\n            name=\"separator\",\n            display_name=\"Separator\",\n            info=\"The character to split on. Defaults to newline.\",\n            value=\"\\n\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Chunks\", name=\"chunks\", method=\"split_text\"),\n    ]\n\n    def _docs_to_data(self, docs):\n        return [Data(text=doc.page_content, data=doc.metadata) for doc in docs]\n\n    def split_text(self) -> list[Data]:\n        separator = unescape_string(self.separator)\n\n        documents = [_input.to_lc_document() for _input in self.data_inputs if isinstance(_input, Data)]\n\n        splitter = CharacterTextSplitter(\n            chunk_overlap=self.chunk_overlap,\n            chunk_size=self.chunk_size,\n            separator=separator,\n        )\n        docs = splitter.split_documents(documents)\n        data = self._docs_to_data(docs)\n        self.status = data\n        return data\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "separator": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "separator",
    //                 "value": "\n",
    //                 "display_name": "Separator",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The character to split on. Defaults to newline.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Split text into chunks based on specified criteria.",
    //         "icon": "scissors-line-dashed",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Split Text",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "chunks",
    //                 "display_name": "Chunks",
    //                 "method": "split_text",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "data_inputs",
    //             "chunk_overlap",
    //             "chunk_size",
    //             "separator"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "MergeDataComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "data_inputs": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "data_inputs",
    //                 "value": "",
    //                 "display_name": "Data Inputs",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "A list of Data inputs objects to be merged.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.io import DataInput, Output\nfrom langflow.schema import Data\n\n\nclass MergeDataComponent(Component):\n    \"\"\"MergeDataComponent is responsible for combining multiple Data objects into a unified list of Data objects.\n\n    It ensures that all keys across the input Data objects are present in each merged Data object.\n    Missing keys are filled with empty strings to maintain consistency.\n    \"\"\"\n\n    display_name = \"Merge Data\"\n    description = (\n        \"Combines multiple Data objects into a unified list, ensuring all keys are present in each Data object.\"\n    )\n    icon = \"merge\"\n\n    inputs = [\n        DataInput(\n            name=\"data_inputs\",\n            display_name=\"Data Inputs\",\n            is_list=True,\n            info=\"A list of Data inputs objects to be merged.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Merged Data\",\n            name=\"merged_data\",\n            method=\"merge_data\",\n        ),\n    ]\n\n    def merge_data(self) -> list[Data]:\n        \"\"\"Merges multiple Data objects into a single list of Data objects.\n\n        Ensures that all keys from the input Data objects are present in each merged Data object.\n        Missing keys are filled with empty strings.\n\n        Returns:\n            List[Data]: A list of merged Data objects with consistent keys.\n        \"\"\"\n        logger.info(\"Initiating the data merging process.\")\n\n        data_inputs: list[Data] = self.data_inputs\n        logger.debug(f\"Received {len(data_inputs)} data input(s) for merging.\")\n\n        if not data_inputs:\n            logger.warning(\"No data inputs provided. Returning an empty list.\")\n            return []\n\n        # Collect all unique keys from all Data objects\n        all_keys: set[str] = set()\n        for idx, data_input in enumerate(data_inputs):\n            if not isinstance(data_input, Data):\n                error_message = f\"Data input at index {idx} is not of type Data.\"\n                logger.error(error_message)\n                type_error_message = (\n                    f\"All items in data_inputs must be of type Data. Item at index {idx} is {type(data_input)}\"\n                )\n                raise TypeError(type_error_message)\n            all_keys.update(data_input.data.keys())\n        logger.debug(f\"Collected {len(all_keys)} unique key(s) from input data.\")\n\n        try:\n            # Create new list of Data objects with missing keys filled with empty strings\n            merged_data_list = []\n            for idx, data_input in enumerate(data_inputs):\n                merged_data_dict = {}\n\n                for key in all_keys:\n                    # Use the existing value if the key exists, otherwise use an empty string\n                    value = data_input.data.get(key, \"\")\n                    if key not in data_input.data:\n                        log_message = f\"Key '{key}' missing in data input at index {idx}. \" \"Assigning empty string.\"\n                        logger.debug(log_message)\n                    merged_data_dict[key] = value\n\n                merged_data = Data(\n                    text_key=data_input.text_key, data=merged_data_dict, default_value=data_input.default_value\n                )\n                merged_data_list.append(merged_data)\n                logger.debug(\"Merged Data object created for input at index: \" + str(idx))\n\n        except Exception:\n            logger.exception(\"An error occurred during the data merging process.\")\n            raise\n\n        logger.info(\"Data merging process completed successfully.\")\n        return merged_data_list\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             }
    //         },
    //         "description": "Combines multiple Data objects into a unified list, ensuring all keys are present in each Data object.",
    //         "icon": "merge",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Merge Data",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "merged_data",
    //                 "display_name": "Merged Data",
    //                 "method": "merge_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "data_inputs"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "ExtractaKey": {
    //         "template": {
    //             "_type": "Component",
    //             "data_input": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "data_input",
    //                 "value": "",
    //                 "display_name": "Data Input",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The Data object or list of Data objects to extract the key from.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.custom import Component\nfrom langflow.io import DataInput, Output, StrInput\nfrom langflow.schema import Data\n\n\nclass ExtractDataKeyComponent(Component):\n    display_name = \"Extract Key\"\n    description = (\n        \"Extract a specific key from a Data object or a list of \"\n        \"Data objects and return the extracted value(s) as Data object(s).\"\n    )\n    icon = \"key\"\n    beta = True\n    name = \"ExtractaKey\"\n\n    inputs = [\n        DataInput(\n            name=\"data_input\",\n            display_name=\"Data Input\",\n            info=\"The Data object or list of Data objects to extract the key from.\",\n        ),\n        StrInput(\n            name=\"key\",\n            display_name=\"Key to Extract\",\n            info=\"The key in the Data object(s) to extract.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Extracted Data\", name=\"extracted_data\", method=\"extract_key\"),\n    ]\n\n    def extract_key(self) -> Data | list[Data]:\n        key = self.key\n\n        if isinstance(self.data_input, list):\n            result = []\n            for item in self.data_input:\n                if isinstance(item, Data) and key in item.data:\n                    extracted_value = item.data[key]\n                    result.append(Data(data={key: extracted_value}))\n            self.status = result\n            return result\n        if isinstance(self.data_input, Data):\n            if key in self.data_input.data:\n                extracted_value = self.data_input.data[key]\n                result = Data(data={key: extracted_value})\n                self.status = result\n                return result\n            self.status = f\"Key '{key}' not found in Data object.\"\n            return Data(data={\"error\": f\"Key '{key}' not found in Data object.\"})\n        self.status = \"Invalid input. Expected Data object or list of Data objects.\"\n        return Data(data={\"error\": \"Invalid input. Expected Data object or list of Data objects.\"})\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "key": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "key",
    //                 "value": "",
    //                 "display_name": "Key to Extract",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The key in the Data object(s) to extract.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             }
    //         },
    //         "description": "Extract a specific key from a Data object or a list of Data objects and return the extracted value(s) as Data object(s).",
    //         "icon": "key",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Extract Key",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "extracted_data",
    //                 "display_name": "Extracted Data",
    //                 "method": "extract_key",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "data_input",
    //             "key"
    //         ],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "FilterData": {
    //         "template": {
    //             "_type": "Component",
    //             "data": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "data",
    //                 "value": "",
    //                 "display_name": "Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Data object to filter.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.custom import Component\nfrom langflow.io import DataInput, MessageTextInput, Output\nfrom langflow.schema import Data\n\n\nclass FilterDataComponent(Component):\n    display_name = \"Filter Data\"\n    description = \"Filters a Data object based on a list of keys.\"\n    icon = \"filter\"\n    beta = True\n    name = \"FilterData\"\n\n    inputs = [\n        DataInput(\n            name=\"data\",\n            display_name=\"Data\",\n            info=\"Data object to filter.\",\n        ),\n        MessageTextInput(\n            name=\"filter_criteria\",\n            display_name=\"Filter Criteria\",\n            info=\"List of keys to filter by.\",\n            is_list=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Filtered Data\", name=\"filtered_data\", method=\"filter_data\"),\n    ]\n\n    def filter_data(self) -> Data:\n        filter_criteria: list[str] = self.filter_criteria\n        data = self.data.data if isinstance(self.data, Data) else {}\n\n        # Filter the data\n        filtered = {key: value for key, value in data.items() if key in filter_criteria}\n\n        # Create a new Data object with the filtered data\n        filtered_data = Data(data=filtered)\n        self.status = filtered_data\n        return filtered_data\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "filter_criteria": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "filter_criteria",
    //                 "value": "",
    //                 "display_name": "Filter Criteria",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "List of keys to filter by.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Filters a Data object based on a list of keys.",
    //         "icon": "filter",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Filter Data",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "filtered_data",
    //                 "display_name": "Filtered Data",
    //                 "method": "filter_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "data",
    //             "filter_criteria"
    //         ],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "CustomComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "# from langflow.field_typing import Data\nfrom langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema import Data\n\n\nclass CustomComponent(Component):\n    display_name = \"Custom Component\"\n    description = \"Use as a template to create your own component.\"\n    documentation: str = \"http://docs.langflow.org/components/custom\"\n    icon = \"custom_components\"\n    name = \"CustomComponent\"\n\n    inputs = [\n        MessageTextInput(name=\"input_value\", display_name=\"Input Value\", value=\"Hello, World!\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Output\", name=\"output\", method=\"build_output\"),\n    ]\n\n    def build_output(self) -> Data:\n        data = Data(value=self.input_value)\n        self.status = data\n        return data\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "Hello, World!",
    //                 "display_name": "Input Value",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Use as a template to create your own component.",
    //         "icon": "custom_components",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Custom Component",
    //         "documentation": "http://docs.langflow.org/components/custom",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "output",
    //                 "display_name": "Output",
    //                 "method": "build_output",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "input_value"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "HierarchicalTaskComponent": {
    //         "template": {
    //             "_type": "Component",
    //             "tools": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "tools",
    //                 "value": "",
    //                 "display_name": "Tools",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Tool"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "List of tools/resources limited for task execution. Uses the Agent tools by default.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "HandleInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.base.agents.crewai.tasks import HierarchicalTask\nfrom langflow.custom import Component\nfrom langflow.io import HandleInput, MultilineInput, Output\n\n\nclass HierarchicalTaskComponent(Component):\n    display_name: str = \"Hierarchical Task\"\n    description: str = \"Each task must have a description, an expected output and an agent responsible for execution.\"\n    icon = \"CrewAI\"\n    inputs = [\n        MultilineInput(\n            name=\"task_description\",\n            display_name=\"Description\",\n            info=\"Descriptive text detailing task's purpose and execution.\",\n        ),\n        MultilineInput(\n            name=\"expected_output\",\n            display_name=\"Expected Output\",\n            info=\"Clear definition of expected task outcome.\",\n        ),\n        HandleInput(\n            name=\"tools\",\n            display_name=\"Tools\",\n            input_types=[\"Tool\"],\n            is_list=True,\n            info=\"List of tools/resources limited for task execution. Uses the Agent tools by default.\",\n            required=False,\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Task\", name=\"task_output\", method=\"build_task\"),\n    ]\n\n    def build_task(self) -> HierarchicalTask:\n        task = HierarchicalTask(\n            description=self.task_description,\n            expected_output=self.expected_output,\n            tools=self.tools or [],\n        )\n        self.status = task\n        return task\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "expected_output": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "expected_output",
    //                 "value": "",
    //                 "display_name": "Expected Output",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Clear definition of expected task outcome.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "task_description": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "task_description",
    //                 "value": "",
    //                 "display_name": "Description",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Descriptive text detailing task's purpose and execution.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Each task must have a description, an expected output and an agent responsible for execution.",
    //         "icon": "CrewAI",
    //         "base_classes": [
    //             "HierarchicalTask"
    //         ],
    //         "display_name": "Hierarchical Task",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "HierarchicalTask"
    //                 ],
    //                 "selected": "HierarchicalTask",
    //                 "name": "task_output",
    //                 "display_name": "Task",
    //                 "method": "build_task",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "task_description",
    //             "expected_output",
    //             "tools"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "ParseData": {
    //         "template": {
    //             "_type": "Component",
    //             "data": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "data",
    //                 "value": "",
    //                 "display_name": "Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The data to convert to text.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.custom import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import DataInput, MultilineInput, Output, StrInput\nfrom langflow.schema.message import Message\n\n\nclass ParseDataComponent(Component):\n    display_name = \"Parse Data\"\n    description = \"Convert Data into plain text following a specified template.\"\n    icon = \"braces\"\n    name = \"ParseData\"\n\n    inputs = [\n        DataInput(name=\"data\", display_name=\"Data\", info=\"The data to convert to text.\"),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. \"\n            \"It can contain the keys {text}, {data} or any other key in the Data.\",\n            value=\"{text}\",\n        ),\n        StrInput(name=\"sep\", display_name=\"Separator\", advanced=True, value=\"\\n\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Text\", name=\"text\", method=\"parse_data\"),\n    ]\n\n    def parse_data(self) -> Message:\n        data = self.data if isinstance(self.data, list) else [self.data]\n        template = self.template\n\n        result_string = data_to_text(template, data, sep=self.sep)\n        self.status = result_string\n        return Message(text=result_string)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "sep": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "sep",
    //                 "value": "\n",
    //                 "display_name": "Separator",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "template": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "template",
    //                 "value": "{text}",
    //                 "display_name": "Template",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Convert Data into plain text following a specified template.",
    //         "icon": "braces",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Parse Data",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text",
    //                 "display_name": "Text",
    //                 "method": "parse_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "data",
    //             "template",
    //             "sep"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "CSVtoData": {
    //         "template": {
    //             "_type": "Component",
    //             "csv_file": {
    //                 "trace_as_metadata": true,
    //                 "file_path": "",
    //                 "fileTypes": [
    //                     "csv"
    //                 ],
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "csv_file",
    //                 "value": "",
    //                 "display_name": "CSV File",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Upload a CSV file to convert to a list of Data objects",
    //                 "title_case": false,
    //                 "type": "file",
    //                 "_input_type": "FileInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import csv\nimport io\nfrom pathlib import Path\n\nfrom langflow.custom import Component\nfrom langflow.io import FileInput, MessageTextInput, MultilineInput, Output\nfrom langflow.schema import Data\n\n\nclass CSVToDataComponent(Component):\n    display_name = \"CSV to Data List\"\n    description = \"Load a CSV file, CSV from a file path, or a valid CSV string and convert it to a list of Data\"\n    icon = \"file-spreadsheet\"\n    beta = True\n    name = \"CSVtoData\"\n\n    inputs = [\n        FileInput(\n            name=\"csv_file\",\n            display_name=\"CSV File\",\n            file_types=[\"csv\"],\n            info=\"Upload a CSV file to convert to a list of Data objects\",\n        ),\n        MessageTextInput(\n            name=\"csv_path\",\n            display_name=\"CSV File Path\",\n            info=\"Provide the path to the CSV file as pure text\",\n        ),\n        MultilineInput(\n            name=\"csv_string\",\n            display_name=\"CSV String\",\n            info=\"Paste a CSV string directly to convert to a list of Data objects\",\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"data_list\", display_name=\"Data List\", method=\"load_csv_to_data\"),\n    ]\n\n    def load_csv_to_data(self) -> list[Data]:\n        if sum(bool(field) for field in [self.csv_file, self.csv_path, self.csv_string]) != 1:\n            msg = \"Please provide exactly one of: CSV file, file path, or CSV string.\"\n            raise ValueError(msg)\n\n        csv_data = None\n        try:\n            if self.csv_file:\n                resolved_path = self.resolve_path(self.csv_file)\n                file_path = Path(resolved_path)\n                if file_path.suffix.lower() != \".csv\":\n                    self.status = \"The provided file must be a CSV file.\"\n                else:\n                    with file_path.open(newline=\"\", encoding=\"utf-8\") as csvfile:\n                        csv_data = csvfile.read()\n\n            elif self.csv_path:\n                file_path = Path(self.csv_path)\n                if file_path.suffix.lower() != \".csv\":\n                    self.status = \"The provided file must be a CSV file.\"\n                else:\n                    with file_path.open(newline=\"\", encoding=\"utf-8\") as csvfile:\n                        csv_data = csvfile.read()\n\n            else:\n                csv_data = self.csv_string\n\n            if csv_data:\n                csv_reader = csv.DictReader(io.StringIO(csv_data))\n                result = [Data(data=row) for row in csv_reader]\n\n                if not result:\n                    self.status = \"The CSV data is empty.\"\n                    return []\n\n                self.status = result\n                return result\n\n        except csv.Error as e:\n            error_message = f\"CSV parsing error: {e}\"\n            self.status = error_message\n            raise ValueError(error_message) from e\n\n        except Exception as e:\n            error_message = f\"An error occurred: {e}\"\n            self.status = error_message\n            raise ValueError(error_message) from e\n\n        # An error occurred\n        raise ValueError(self.status)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "csv_path": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "csv_path",
    //                 "value": "",
    //                 "display_name": "CSV File Path",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Provide the path to the CSV file as pure text",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "csv_string": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "csv_string",
    //                 "value": "",
    //                 "display_name": "CSV String",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Paste a CSV string directly to convert to a list of Data objects",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Load a CSV file, CSV from a file path, or a valid CSV string and convert it to a list of Data",
    //         "icon": "file-spreadsheet",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "CSV to Data List",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data_list",
    //                 "display_name": "Data List",
    //                 "method": "load_csv_to_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "csv_file",
    //             "csv_path",
    //             "csv_string"
    //         ],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "CurrentDate": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from datetime import datetime\nfrom zoneinfo import ZoneInfo\n\nfrom loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.io import DropdownInput, Output\nfrom langflow.schema.message import Message\n\n\nclass CurrentDateComponent(Component):\n    display_name = \"Current Date\"\n    description = \"Returns the current date and time in the selected timezone.\"\n    icon = \"clock\"\n    beta = True\n    name = \"CurrentDate\"\n\n    inputs = [\n        DropdownInput(\n            name=\"timezone\",\n            display_name=\"Timezone\",\n            options=[\n                \"UTC\",\n                \"US/Eastern\",\n                \"US/Central\",\n                \"US/Mountain\",\n                \"US/Pacific\",\n                \"Europe/London\",\n                \"Europe/Paris\",\n                \"Europe/Berlin\",\n                \"Europe/Moscow\",\n                \"Asia/Tokyo\",\n                \"Asia/Shanghai\",\n                \"Asia/Singapore\",\n                \"Asia/Dubai\",\n                \"Australia/Sydney\",\n                \"Australia/Melbourne\",\n                \"Pacific/Auckland\",\n                \"America/Sao_Paulo\",\n                \"America/Mexico_City\",\n                \"America/Toronto\",\n                \"America/Vancouver\",\n                \"Africa/Cairo\",\n                \"Africa/Johannesburg\",\n                \"Atlantic/Reykjavik\",\n                \"Indian/Maldives\",\n                \"America/Bogota\",\n                \"America/Lima\",\n                \"America/Santiago\",\n                \"America/Buenos_Aires\",\n                \"America/Caracas\",\n                \"America/La_Paz\",\n                \"America/Montevideo\",\n                \"America/Asuncion\",\n                \"America/Cuiaba\",\n            ],\n            value=\"UTC\",\n            info=\"Select the timezone for the current date and time.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Current Date\", name=\"current_date\", method=\"get_current_date\"),\n    ]\n\n    def get_current_date(self) -> Message:\n        try:\n            tz = ZoneInfo(self.timezone)\n            current_date = datetime.now(tz).strftime(\"%Y-%m-%d %H:%M:%S %Z\")\n            result = f\"Current date and time in {self.timezone}: {current_date}\"\n            self.status = result\n            return Message(text=result)\n        except Exception as e:  # noqa: BLE001\n            logger.opt(exception=True).debug(\"Error getting current date\")\n            error_message = f\"Error: {e}\"\n            self.status = error_message\n            return Message(text=error_message)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "timezone": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "UTC",
    //                     "US/Eastern",
    //                     "US/Central",
    //                     "US/Mountain",
    //                     "US/Pacific",
    //                     "Europe/London",
    //                     "Europe/Paris",
    //                     "Europe/Berlin",
    //                     "Europe/Moscow",
    //                     "Asia/Tokyo",
    //                     "Asia/Shanghai",
    //                     "Asia/Singapore",
    //                     "Asia/Dubai",
    //                     "Australia/Sydney",
    //                     "Australia/Melbourne",
    //                     "Pacific/Auckland",
    //                     "America/Sao_Paulo",
    //                     "America/Mexico_City",
    //                     "America/Toronto",
    //                     "America/Vancouver",
    //                     "Africa/Cairo",
    //                     "Africa/Johannesburg",
    //                     "Atlantic/Reykjavik",
    //                     "Indian/Maldives",
    //                     "America/Bogota",
    //                     "America/Lima",
    //                     "America/Santiago",
    //                     "America/Buenos_Aires",
    //                     "America/Caracas",
    //                     "America/La_Paz",
    //                     "America/Montevideo",
    //                     "America/Asuncion",
    //                     "America/Cuiaba"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "timezone",
    //                 "value": "UTC",
    //                 "display_name": "Timezone",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Select the timezone for the current date and time.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             }
    //         },
    //         "description": "Returns the current date and time in the selected timezone.",
    //         "icon": "clock",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Current Date",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "current_date",
    //                 "display_name": "Current Date",
    //                 "method": "get_current_date",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "timezone"
    //         ],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "MessagetoData": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.io import MessageInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\n\n\nclass MessageToDataComponent(Component):\n    display_name = \"Message to Data\"\n    description = \"Convert a Message object to a Data object\"\n    icon = \"message-square-share\"\n    beta = True\n    name = \"MessagetoData\"\n\n    inputs = [\n        MessageInput(\n            name=\"message\",\n            display_name=\"Message\",\n            info=\"The Message object to convert to a Data object\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"convert_message_to_data\"),\n    ]\n\n    def convert_message_to_data(self) -> Data:\n        if isinstance(self.message, Message):\n            # Convert Message to Data\n            data = Data(data=self.message.data)\n\n            self.status = \"Successfully converted Message to Data\"\n            return data\n\n        msg = \"Error converting Message to Data: Input must be a Message object\"\n        logger.opt(exception=True).debug(msg)\n        self.status = msg\n        return Data(data={\"error\": msg})\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "message": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "message",
    //                 "value": "",
    //                 "display_name": "Message",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The Message object to convert to a Data object",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             }
    //         },
    //         "description": "Convert a Message object to a Data object",
    //         "icon": "message-square-share",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Message to Data",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "data",
    //                 "display_name": "Data",
    //                 "method": "convert_message_to_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "message"
    //         ],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "FilterDataValues": {
    //         "template": {
    //             "_type": "Component",
    //             "input_data": {
    //                 "trace_as_metadata": true,
    //                 "list": true,
    //                 "trace_as_input": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_data",
    //                 "value": "",
    //                 "display_name": "Input Data",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Data"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The list of data items to filter.",
    //                 "title_case": false,
    //                 "type": "other",
    //                 "_input_type": "DataInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import DataInput, DropdownInput, MessageInput, Output\nfrom langflow.schema import Data\n\n\nclass DataFilterComponent(Component):\n    display_name = \"Filter Data Values\"\n    description = (\n        \"Filter a list of data items based on a specified key, filter value,\"\n        \" and comparison operator. Check advanced options to select match comparision.\"\n    )\n    icon = \"filter\"\n    beta = True\n    name = \"FilterDataValues\"\n\n    inputs = [\n        DataInput(name=\"input_data\", display_name=\"Input Data\", info=\"The list of data items to filter.\", is_list=True),\n        MessageInput(\n            name=\"filter_key\", display_name=\"Filter Key\", info=\"The key to filter on (e.g., 'route').\", value=\"route\"\n        ),\n        MessageInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter by (e.g., 'CMIP').\",\n            value=\"CMIP\",\n        ),\n        DropdownInput(\n            name=\"operator\",\n            display_name=\"Comparison Operator\",\n            options=[\"equals\", \"not equals\", \"contains\", \"starts with\", \"ends with\"],\n            info=\"The operator to apply for comparing the values.\",\n            value=\"equals\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Filtered Data\", name=\"filtered_data\", method=\"filter_data\"),\n    ]\n\n    def compare_values(self, item_value: Any, filter_value: str, operator: str) -> bool:\n        if operator == \"equals\":\n            return str(item_value) == filter_value\n        if operator == \"not equals\":\n            return str(item_value) != filter_value\n        if operator == \"contains\":\n            return filter_value in str(item_value)\n        if operator == \"starts with\":\n            return str(item_value).startswith(filter_value)\n        if operator == \"ends with\":\n            return str(item_value).endswith(filter_value)\n        return False\n\n    def filter_data(self) -> list[Data]:\n        # Extract inputs\n        input_data: list[Data] = self.input_data\n        filter_key: str = self.filter_key.text\n        filter_value: str = self.filter_value.text\n        operator: str = self.operator\n\n        # Validate inputs\n        if not input_data:\n            self.status = \"Input data is empty.\"\n            return []\n\n        if not filter_key or not filter_value:\n            self.status = \"Filter key or value is missing.\"\n            return input_data\n\n        # Filter the data\n        filtered_data = []\n        for item in input_data:\n            if isinstance(item.data, dict) and filter_key in item.data:\n                if self.compare_values(item.data[filter_key], filter_value, operator):\n                    filtered_data.append(item)\n            else:\n                self.status = f\"Warning: Some items don't have the key '{filter_key}' or are not dictionaries.\"\n\n        self.status = filtered_data\n        return filtered_data\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "filter_key": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "filter_key",
    //                 "value": {
    //                     "text_key": "text",
    //                     "data": {
    //                         "text": "route",
    //                         "files": [],
    //                         "timestamp": "2024-10-27 09:41:20"
    //                     },
    //                     "default_value": "",
    //                     "text": "route",
    //                     "files": [],
    //                     "session_id": "",
    //                     "timestamp": "2024-10-27T04:11:20+00:00",
    //                     "error": false,
    //                     "edit": false
    //                 },
    //                 "display_name": "Filter Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The key to filter on (e.g., 'route').",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "filter_value": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "filter_value",
    //                 "value": {
    //                     "text_key": "text",
    //                     "data": {
    //                         "text": "CMIP",
    //                         "files": [],
    //                         "timestamp": "2024-10-27 09:41:20"
    //                     },
    //                     "default_value": "",
    //                     "text": "CMIP",
    //                     "files": [],
    //                     "session_id": "",
    //                     "timestamp": "2024-10-27T04:11:20+00:00",
    //                     "error": false,
    //                     "edit": false
    //                 },
    //                 "display_name": "Filter Value",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The value to filter by (e.g., 'CMIP').",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageInput"
    //             },
    //             "operator": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "equals",
    //                     "not equals",
    //                     "contains",
    //                     "starts with",
    //                     "ends with"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "operator",
    //                 "value": "equals",
    //                 "display_name": "Comparison Operator",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "The operator to apply for comparing the values.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             }
    //         },
    //         "description": "Filter a list of data items based on a specified key, filter value, and comparison operator. Check advanced options to select match comparision.",
    //         "icon": "filter",
    //         "base_classes": [
    //             "Data"
    //         ],
    //         "display_name": "Filter Data Values",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Data"
    //                 ],
    //                 "selected": "Data",
    //                 "name": "filtered_data",
    //                 "display_name": "Filtered Data",
    //                 "method": "filter_data",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "input_data",
    //             "filter_key",
    //             "filter_value",
    //             "operator"
    //         ],
    //         "beta": true,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "memories": {
    //     "CassandraChatMemory": {
    //         "template": {
    //             "_type": "Component",
    //             "cluster_kwargs": {
    //                 "trace_as_input": true,
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "cluster_kwargs",
    //                 "value": {},
    //                 "display_name": "Cluster arguments",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional dictionary of additional keyword arguments for the Cassandra cluster.",
    //                 "title_case": false,
    //                 "type": "dict",
    //                 "_input_type": "DictInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.base.memory.model import LCChatMemoryComponent\nfrom langflow.field_typing import BaseChatMessageHistory\nfrom langflow.inputs import DictInput, MessageTextInput, SecretStrInput\n\n\nclass CassandraChatMemory(LCChatMemoryComponent):\n    display_name = \"Cassandra Chat Memory\"\n    description = \"Retrieves and store chat messages from Apache Cassandra.\"\n    name = \"CassandraChatMemory\"\n    icon = \"Cassandra\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"database_ref\",\n            display_name=\"Contact Points / Astra Database ID\",\n            info=\"Contact points for the database (or AstraDB database ID)\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"username\", display_name=\"Username\", info=\"Username for the database (leave empty for AstraDB).\"\n        ),\n        SecretStrInput(\n            name=\"token\",\n            display_name=\"Password / AstraDB Token\",\n            info=\"User password for the database (or AstraDB token).\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"keyspace\",\n            display_name=\"Keyspace\",\n            info=\"Table Keyspace (or AstraDB namespace).\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"table_name\",\n            display_name=\"Table Name\",\n            info=\"The name of the table (or AstraDB collection) where vectors will be stored.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\", display_name=\"Session ID\", info=\"Session ID for the message.\", advanced=True\n        ),\n        DictInput(\n            name=\"cluster_kwargs\",\n            display_name=\"Cluster arguments\",\n            info=\"Optional dictionary of additional keyword arguments for the Cassandra cluster.\",\n            advanced=True,\n            is_list=True,\n        ),\n    ]\n\n    def build_message_history(self) -> BaseChatMessageHistory:\n        from langchain_community.chat_message_histories import CassandraChatMessageHistory\n\n        try:\n            import cassio\n        except ImportError as e:\n            msg = \"Could not import cassio integration package. Please install it with `pip install cassio`.\"\n            raise ImportError(msg) from e\n\n        from uuid import UUID\n\n        database_ref = self.database_ref\n\n        try:\n            UUID(self.database_ref)\n            is_astra = True\n        except ValueError:\n            is_astra = False\n            if \",\" in self.database_ref:\n                # use a copy because we can't change the type of the parameter\n                database_ref = self.database_ref.split(\",\")\n\n        if is_astra:\n            cassio.init(\n                database_id=database_ref,\n                token=self.token,\n                cluster_kwargs=self.cluster_kwargs,\n            )\n        else:\n            cassio.init(\n                contact_points=database_ref,\n                username=self.username,\n                password=self.token,\n                cluster_kwargs=self.cluster_kwargs,\n            )\n\n        return CassandraChatMessageHistory(\n            session_id=self.session_id,\n            table_name=self.table_name,\n            keyspace=self.keyspace,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "database_ref": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "database_ref",
    //                 "value": "",
    //                 "display_name": "Contact Points / Astra Database ID",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Contact points for the database (or AstraDB database ID)",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "keyspace": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "keyspace",
    //                 "value": "",
    //                 "display_name": "Keyspace",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Table Keyspace (or AstraDB namespace).",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "session_id": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "session_id",
    //                 "value": "",
    //                 "display_name": "Session ID",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Session ID for the message.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "table_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "table_name",
    //                 "value": "",
    //                 "display_name": "Table Name",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The name of the table (or AstraDB collection) where vectors will be stored.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "token": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "token",
    //                 "value": "",
    //                 "display_name": "Password / AstraDB Token",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "User password for the database (or AstraDB token).",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "username": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "username",
    //                 "value": "",
    //                 "display_name": "Username",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Username for the database (leave empty for AstraDB).",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Retrieves and store chat messages from Apache Cassandra.",
    //         "icon": "Cassandra",
    //         "base_classes": [
    //             "BaseChatMessageHistory"
    //         ],
    //         "display_name": "Cassandra Chat Memory",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "BaseChatMessageHistory"
    //                 ],
    //                 "selected": "BaseChatMessageHistory",
    //                 "name": "memory",
    //                 "display_name": "Memory",
    //                 "method": "build_message_history",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "cluster_kwargs",
    //                     "database_ref",
    //                     "keyspace",
    //                     "session_id",
    //                     "table_name",
    //                     "token",
    //                     "username"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "database_ref",
    //             "username",
    //             "token",
    //             "keyspace",
    //             "table_name",
    //             "session_id",
    //             "cluster_kwargs"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "AstraDBChatMemory": {
    //         "template": {
    //             "_type": "Component",
    //             "api_endpoint": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_endpoint",
    //                 "value": "ASTRA_DB_API_ENDPOINT",
    //                 "display_name": "API Endpoint",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "API endpoint URL for the Astra DB service.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "import os\n\nfrom astrapy.admin import parse_api_endpoint\n\nfrom langflow.base.memory.model import LCChatMemoryComponent\nfrom langflow.field_typing import BaseChatMessageHistory\nfrom langflow.inputs import MessageTextInput, SecretStrInput, StrInput\n\n\nclass AstraDBChatMemory(LCChatMemoryComponent):\n    display_name = \"Astra DB Chat Memory\"\n    description = \"Retrieves and store chat messages from Astra DB.\"\n    name = \"AstraDBChatMemory\"\n    icon: str = \"AstraDB\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"token\",\n            display_name=\"Astra DB Application Token\",\n            info=\"Authentication token for accessing Astra DB.\",\n            value=\"ASTRA_DB_APPLICATION_TOKEN\",\n            required=True,\n            advanced=os.getenv(\"ASTRA_ENHANCED\", \"false\").lower() == \"true\",\n        ),\n        SecretStrInput(\n            name=\"api_endpoint\",\n            display_name=\"API Endpoint\",\n            info=\"API endpoint URL for the Astra DB service.\",\n            value=\"ASTRA_DB_API_ENDPOINT\",\n            required=True,\n        ),\n        StrInput(\n            name=\"collection_name\",\n            display_name=\"Collection Name\",\n            info=\"The name of the collection within Astra DB where the vectors will be stored.\",\n            required=True,\n        ),\n        StrInput(\n            name=\"namespace\",\n            display_name=\"Namespace\",\n            info=\"Optional namespace within Astra DB to use for the collection.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n    ]\n\n    def build_message_history(self) -> BaseChatMessageHistory:\n        try:\n            from langchain_astradb.chat_message_histories import AstraDBChatMessageHistory\n        except ImportError as e:\n            msg = (\n                \"Could not import langchain Astra DB integration package. \"\n                \"Please install it with `pip install langchain-astradb`.\"\n            )\n            raise ImportError(msg) from e\n\n        return AstraDBChatMessageHistory(\n            session_id=self.session_id,\n            collection_name=self.collection_name,\n            token=self.token,\n            api_endpoint=self.api_endpoint,\n            namespace=self.namespace or None,\n            environment=parse_api_endpoint(self.api_endpoint).environment,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "collection_name": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "collection_name",
    //                 "value": "",
    //                 "display_name": "Collection Name",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "The name of the collection within Astra DB where the vectors will be stored.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "namespace": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "namespace",
    //                 "value": "",
    //                 "display_name": "Namespace",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Optional namespace within Astra DB to use for the collection.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "session_id": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "session_id",
    //                 "value": "",
    //                 "display_name": "Session ID",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "token": {
    //                 "load_from_db": true,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "token",
    //                 "value": "ASTRA_DB_APPLICATION_TOKEN",
    //                 "display_name": "Astra DB Application Token",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Authentication token for accessing Astra DB.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             }
    //         },
    //         "description": "Retrieves and store chat messages from Astra DB.",
    //         "icon": "AstraDB",
    //         "base_classes": [
    //             "BaseChatMessageHistory"
    //         ],
    //         "display_name": "Astra DB Chat Memory",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "BaseChatMessageHistory"
    //                 ],
    //                 "selected": "BaseChatMessageHistory",
    //                 "name": "memory",
    //                 "display_name": "Memory",
    //                 "method": "build_message_history",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_endpoint",
    //                     "collection_name",
    //                     "namespace",
    //                     "session_id",
    //                     "token"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "token",
    //             "api_endpoint",
    //             "collection_name",
    //             "namespace",
    //             "session_id"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "ZepChatMemory": {
    //         "template": {
    //             "_type": "Component",
    //             "api_base_path": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "api/v1",
    //                     "api/v2"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_base_path",
    //                 "value": "api/v1",
    //                 "display_name": "API Base Path",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "api_key": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "api_key",
    //                 "value": "",
    //                 "display_name": "API Key",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "API Key for the Zep instance.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.base.memory.model import LCChatMemoryComponent\nfrom langflow.field_typing import BaseChatMessageHistory\nfrom langflow.inputs import DropdownInput, MessageTextInput, SecretStrInput\n\n\nclass ZepChatMemory(LCChatMemoryComponent):\n    display_name = \"Zep Chat Memory\"\n    description = \"Retrieves and store chat messages from Zep.\"\n    name = \"ZepChatMemory\"\n\n    inputs = [\n        MessageTextInput(name=\"url\", display_name=\"Zep URL\", info=\"URL of the Zep instance.\"),\n        SecretStrInput(name=\"api_key\", display_name=\"API Key\", info=\"API Key for the Zep instance.\"),\n        DropdownInput(\n            name=\"api_base_path\",\n            display_name=\"API Base Path\",\n            options=[\"api/v1\", \"api/v2\"],\n            value=\"api/v1\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\", display_name=\"Session ID\", info=\"Session ID for the message.\", advanced=True\n        ),\n    ]\n\n    def build_message_history(self) -> BaseChatMessageHistory:\n        try:\n            # Monkeypatch API_BASE_PATH to\n            # avoid 404\n            # This is a workaround for the local Zep instance\n            # cloud Zep works with v2\n            import zep_python.zep_client\n            from zep_python import ZepClient\n            from zep_python.langchain import ZepChatMessageHistory\n\n            zep_python.zep_client.API_BASE_PATH = self.api_base_path\n        except ImportError as e:\n            msg = \"Could not import zep-python package. Please install it with `pip install zep-python`.\"\n            raise ImportError(msg) from e\n\n        zep_client = ZepClient(api_url=self.url, api_key=self.api_key)\n        return ZepChatMessageHistory(session_id=self.session_id, zep_client=zep_client)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "session_id": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "session_id",
    //                 "value": "",
    //                 "display_name": "Session ID",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Session ID for the message.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "url": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "url",
    //                 "value": "",
    //                 "display_name": "Zep URL",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "URL of the Zep instance.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Retrieves and store chat messages from Zep.",
    //         "base_classes": [
    //             "BaseChatMessageHistory"
    //         ],
    //         "display_name": "Zep Chat Memory",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "BaseChatMessageHistory"
    //                 ],
    //                 "selected": "BaseChatMessageHistory",
    //                 "name": "memory",
    //                 "display_name": "Memory",
    //                 "method": "build_message_history",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "api_base_path",
    //                     "api_key",
    //                     "session_id",
    //                     "url"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "url",
    //             "api_key",
    //             "api_base_path",
    //             "session_id"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "RedisChatMemory": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from urllib import parse\n\nfrom langchain_community.chat_message_histories.redis import RedisChatMessageHistory\n\nfrom langflow.base.memory.model import LCChatMemoryComponent\nfrom langflow.field_typing import BaseChatMessageHistory\nfrom langflow.inputs import IntInput, MessageTextInput, SecretStrInput, StrInput\n\n\nclass RedisIndexChatMemory(LCChatMemoryComponent):\n    display_name = \"Redis Chat Memory\"\n    description = \"Retrieves and store chat messages from Redis.\"\n    name = \"RedisChatMemory\"\n    icon = \"Redis\"\n\n    inputs = [\n        StrInput(\n            name=\"host\", display_name=\"hostname\", required=True, value=\"localhost\", info=\"IP address or hostname.\"\n        ),\n        IntInput(name=\"port\", display_name=\"port\", required=True, value=6379, info=\"Redis Port Number.\"),\n        StrInput(name=\"database\", display_name=\"database\", required=True, value=\"0\", info=\"Redis database.\"),\n        MessageTextInput(\n            name=\"username\", display_name=\"Username\", value=\"\", info=\"The Redis user name.\", advanced=True\n        ),\n        SecretStrInput(\n            name=\"password\", display_name=\"Password\", value=\"\", info=\"The password for username.\", advanced=True\n        ),\n        StrInput(name=\"key_prefix\", display_name=\"Key prefix\", info=\"Key prefix.\", advanced=True),\n        MessageTextInput(\n            name=\"session_id\", display_name=\"Session ID\", info=\"Session ID for the message.\", advanced=True\n        ),\n    ]\n\n    def build_message_history(self) -> BaseChatMessageHistory:\n        kwargs = {}\n        password: str | None = self.password\n        if self.key_prefix:\n            kwargs[\"key_prefix\"] = self.key_prefix\n        if password:\n            password = parse.quote_plus(password)\n\n        url = f\"redis://{self.username}:{self.password}@{self.host}:{self.port}/{self.database}\"\n        return RedisChatMessageHistory(session_id=self.session_id, url=url, **kwargs)\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "database": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "database",
    //                 "value": "0",
    //                 "display_name": "database",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Redis database.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "host": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "host",
    //                 "value": "localhost",
    //                 "display_name": "hostname",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "IP address or hostname.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "key_prefix": {
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "key_prefix",
    //                 "value": "",
    //                 "display_name": "Key prefix",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Key prefix.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "StrInput"
    //             },
    //             "password": {
    //                 "load_from_db": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "password",
    //                 "value": "",
    //                 "display_name": "Password",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The password for username.",
    //                 "title_case": false,
    //                 "password": true,
    //                 "type": "str",
    //                 "_input_type": "SecretStrInput"
    //             },
    //             "port": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": true,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "port",
    //                 "value": 6379,
    //                 "display_name": "port",
    //                 "advanced": false,
    //                 "dynamic": false,
    //                 "info": "Redis Port Number.",
    //                 "title_case": false,
    //                 "type": "int",
    //                 "_input_type": "IntInput"
    //             },
    //             "session_id": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "session_id",
    //                 "value": "",
    //                 "display_name": "Session ID",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Session ID for the message.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "username": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "username",
    //                 "value": "",
    //                 "display_name": "Username",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The Redis user name.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             }
    //         },
    //         "description": "Retrieves and store chat messages from Redis.",
    //         "icon": "Redis",
    //         "base_classes": [
    //             "BaseChatMessageHistory"
    //         ],
    //         "display_name": "Redis Chat Memory",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "BaseChatMessageHistory"
    //                 ],
    //                 "selected": "BaseChatMessageHistory",
    //                 "name": "memory",
    //                 "display_name": "Memory",
    //                 "method": "build_message_history",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true,
    //                 "required_inputs": [
    //                     "database",
    //                     "host",
    //                     "key_prefix",
    //                     "password",
    //                     "port",
    //                     "session_id",
    //                     "username"
    //                 ]
    //             }
    //         ],
    //         "field_order": [
    //             "host",
    //             "port",
    //             "database",
    //             "username",
    //             "password",
    //             "key_prefix",
    //             "session_id"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    // "inputs": {
    //     "ChatInput": {
    //         "template": {
    //             "_type": "Component",
    //             "files": {
    //                 "trace_as_metadata": true,
    //                 "file_path": "",
    //                 "fileTypes": [
    //                     "txt",
    //                     "md",
    //                     "mdx",
    //                     "csv",
    //                     "json",
    //                     "yaml",
    //                     "yml",
    //                     "xml",
    //                     "html",
    //                     "htm",
    //                     "pdf",
    //                     "docx",
    //                     "py",
    //                     "sh",
    //                     "sql",
    //                     "js",
    //                     "ts",
    //                     "tsx",
    //                     "jpg",
    //                     "jpeg",
    //                     "png",
    //                     "bmp",
    //                     "image"
    //                 ],
    //                 "list": true,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "files",
    //                 "value": "",
    //                 "display_name": "Files",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Files to be sent with the message.",
    //                 "title_case": false,
    //                 "type": "file",
    //                 "_input_type": "FileInput"
    //             },
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import DropdownInput, FileInput, MessageTextInput, MultilineInput, Output\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_NAME_USER, MESSAGE_SENDER_USER\n\n\nclass ChatInput(ChatComponent):\n    display_name = \"Chat Input\"\n    description = \"Get chat inputs from the Playground.\"\n    icon = \"ChatInput\"\n    name = \"ChatInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            value=\"\",\n            info=\"Message to be passed as input.\",\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_USER,\n            info=\"Type of sender.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_USER,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"Files\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"Files to be sent with the message.\",\n            advanced=True,\n            is_list=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    def message_response(self) -> Message:\n        message = Message(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n            files=self.files,\n        )\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = self.store_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Text",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Message to be passed as input.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             },
    //             "sender": {
    //                 "trace_as_metadata": true,
    //                 "options": [
    //                     "Machine",
    //                     "User"
    //                 ],
    //                 "combobox": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "sender",
    //                 "value": "User",
    //                 "display_name": "Sender Type",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Type of sender.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "DropdownInput"
    //             },
    //             "sender_name": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "sender_name",
    //                 "value": "User",
    //                 "display_name": "Sender Name",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Name of the sender.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "session_id": {
    //                 "trace_as_input": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "session_id",
    //                 "value": "",
    //                 "display_name": "Session ID",
    //                 "advanced": true,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MessageTextInput"
    //             },
    //             "should_store_message": {
    //                 "trace_as_metadata": true,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "should_store_message",
    //                 "value": true,
    //                 "display_name": "Store Messages",
    //                 "advanced": true,
    //                 "dynamic": false,
    //                 "info": "Store the message in the history.",
    //                 "title_case": false,
    //                 "type": "bool",
    //                 "_input_type": "BoolInput"
    //             }
    //         },
    //         "description": "Get chat inputs from the Playground.",
    //         "icon": "ChatInput",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Chat Input",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "message",
    //                 "display_name": "Message",
    //                 "method": "message_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "input_value",
    //             "should_store_message",
    //             "sender",
    //             "sender_name",
    //             "session_id",
    //             "files"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     },
    //     "TextInput": {
    //         "template": {
    //             "_type": "Component",
    //             "code": {
    //                 "type": "code",
    //                 "required": true,
    //                 "placeholder": "",
    //                 "list": false,
    //                 "show": true,
    //                 "multiline": true,
    //                 "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextInputComponent(TextComponent):\n    display_name = \"Text Input\"\n    description = \"Get text inputs from the Playground.\"\n    icon = \"type\"\n    name = \"TextInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as input.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Text\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        return Message(\n            text=self.input_value,\n        )\n",
    //                 "fileTypes": [],
    //                 "file_path": "",
    //                 "password": false,
    //                 "name": "code",
    //                 "advanced": true,
    //                 "dynamic": true,
    //                 "info": "",
    //                 "load_from_db": false,
    //                 "title_case": false
    //             },
    //             "input_value": {
    //                 "trace_as_input": true,
    //                 "multiline": true,
    //                 "trace_as_metadata": true,
    //                 "load_from_db": false,
    //                 "list": false,
    //                 "required": false,
    //                 "placeholder": "",
    //                 "show": true,
    //                 "name": "input_value",
    //                 "value": "",
    //                 "display_name": "Text",
    //                 "advanced": false,
    //                 "input_types": [
    //                     "Message"
    //                 ],
    //                 "dynamic": false,
    //                 "info": "Text to be passed as input.",
    //                 "title_case": false,
    //                 "type": "str",
    //                 "_input_type": "MultilineInput"
    //             }
    //         },
    //         "description": "Get text inputs from the Playground.",
    //         "icon": "type",
    //         "base_classes": [
    //             "Message"
    //         ],
    //         "display_name": "Text Input",
    //         "documentation": "",
    //         "custom_fields": {},
    //         "output_types": [],
    //         "pinned": false,
    //         "conditional_paths": [],
    //         "frozen": false,
    //         "outputs": [
    //             {
    //                 "types": [
    //                     "Message"
    //                 ],
    //                 "selected": "Message",
    //                 "name": "text",
    //                 "display_name": "Text",
    //                 "method": "text_response",
    //                 "value": "__UNDEFINED__",
    //                 "cache": true
    //             }
    //         ],
    //         "field_order": [
    //             "input_value"
    //         ],
    //         "beta": false,
    //         "edited": false,
    //         "metadata": {}
    //     }
    // },
    "coprocessors": {
        "Brevis": {
            "template": {
                "_type": "Component",
                "memory": {
                    "trace_as_metadata": true,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "memory",
                    "value": "",
                    "display_name": "Data",
                    "advanced": false,
                    "input_types": [
                        "BaseChatMessageHistory"
                    ],
                    "dynamic": false,
                    "info": "Data for which proof needs to be generated",
                    "title_case": false,
                    "type": "other",
                    "_input_type": "HandleInput"
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from langchain.memory import ConversationBufferMemory\n\nfrom langflow.custom import Component\nfrom langflow.field_typing import BaseChatMemory\nfrom langflow.helpers.data import data_to_text\nfrom langflow.inputs import HandleInput\nfrom langflow.io import DropdownInput, IntInput, MessageTextInput, MultilineInput, Output\nfrom langflow.memory import LCBuiltinChatMemory, get_messages\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_USER\n\n\nclass MemoryComponent(Component):\n    display_name = \"Chat Memory\"\n    description = \"Retrieves stored chat messages from Langflow tables or an external memory.\"\n    icon = \"message-square-more\"\n    name = \"Memory\"\n\n    inputs = [\n        HandleInput(\n            name=\"memory\",\n            display_name=\"External Memory\",\n            input_types=[\"BaseChatMessageHistory\"],\n            info=\"Retrieve messages from an external memory. If empty, it will use the Langflow tables.\",\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER, \"Machine and User\"],\n            value=\"Machine and User\",\n            info=\"Filter by sender type.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Filter by sender name.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"n_messages\",\n            display_name=\"Number of Messages\",\n            value=100,\n            info=\"Number of messages to retrieve.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"order\",\n            display_name=\"Order\",\n            options=[\"Ascending\", \"Descending\"],\n            value=\"Ascending\",\n            info=\"Order of the messages.\",\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. \"\n            \"It can contain the keys {text}, {sender} or any other key in the message data.\",\n            value=\"{sender_name}: {text}\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Messages (Data)\", name=\"messages\", method=\"retrieve_messages\"),\n        Output(display_name=\"Messages (Text)\", name=\"messages_text\", method=\"retrieve_messages_as_text\"),\n        Output(display_name=\"Memory\", name=\"lc_memory\", method=\"build_lc_memory\"),\n    ]\n\n    def retrieve_messages(self) -> Data:\n        sender = self.sender\n        sender_name = self.sender_name\n        session_id = self.session_id\n        n_messages = self.n_messages\n        order = \"DESC\" if self.order == \"Descending\" else \"ASC\"\n\n        if sender == \"Machine and User\":\n            sender = None\n\n        if self.memory:\n            # override session_id\n            self.memory.session_id = session_id\n\n            stored = self.memory.messages\n            # langchain memories are supposed to return messages in ascending order\n            if order == \"DESC\":\n                stored = stored[::-1]\n            if n_messages:\n                stored = stored[:n_messages]\n            stored = [Message.from_lc_message(m) for m in stored]\n            if sender:\n                expected_type = MESSAGE_SENDER_AI if sender == MESSAGE_SENDER_AI else MESSAGE_SENDER_USER\n                stored = [m for m in stored if m.type == expected_type]\n        else:\n            stored = get_messages(\n                sender=sender,\n                sender_name=sender_name,\n                session_id=session_id,\n                limit=n_messages,\n                order=order,\n            )\n        self.status = stored\n        return stored\n\n    def retrieve_messages_as_text(self) -> Message:\n        stored_text = data_to_text(self.template, self.retrieve_messages())\n        self.status = stored_text\n        return Message(text=stored_text)\n\n    def build_lc_memory(self) -> BaseChatMemory:\n        chat_memory = self.memory or LCBuiltinChatMemory(flow_id=self.flow_id, session_id=self.session_id)\n        return ConversationBufferMemory(chat_memory=chat_memory)\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "n_messages": {
                    "trace_as_metadata": true,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "n_messages",
                    "value": 100,
                    "display_name": "Number of Messages",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Number of messages to retrieve.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "order": {
                    "trace_as_metadata": true,
                    "options": [
                        "Ascending",
                        "Descending"
                    ],
                    "combobox": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "order",
                    "value": "Ascending",
                    "display_name": "Order",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Order of the messages.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "sender": {
                    "trace_as_metadata": true,
                    "options": [
                        "Machine",
                        "User",
                        "Machine and User"
                    ],
                    "combobox": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "sender",
                    "value": "Machine and User",
                    "display_name": "Sender Type",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Filter by sender type.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "sender_name": {
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "sender_name",
                    "value": "",
                    "display_name": "Sender Name",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Filter by sender name.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "session_id": {
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "session_id",
                    "value": "",
                    "display_name": "Session ID",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "template": {
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "template",
                    "value": "{sender_name}: {text}",
                    "display_name": "Template",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The template to use for formatting the data. It can contain the keys {text}, {sender} or any other key in the message data.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                }
            },
            "description": "Retrieves stored chat messages from Langflow tables or an external memory.",
            "icon": "message-square-more",
            "base_classes": [
                "BaseChatMemory",
                "Data",
                "Message"
            ],
            "display_name": "Brevis Coprocessor",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "messages",
                    "display_name": "ZK Proof",
                    "method": "retrieve_messages",
                    "value": "__UNDEFINED__",
                    "cache": true
                }
            ],
            "field_order": [
                "memory",
                "sender",
                "sender_name",
                "n_messages",
                "session_id",
                "order",
                "template"
            ],
            "beta": false,
            "edited": false,
            "metadata": {}
        },
        "Automata": {
            "template": {
                "_type": "Component",
                "memory": {
                    "trace_as_metadata": true,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "memory",
                    "value": "",
                    "display_name": "Data",
                    "advanced": false,
                    "input_types": [
                        "BaseChatMessageHistory"
                    ],
                    "dynamic": false,
                    "info": "Data for which proof needs to be generated",
                    "title_case": false,
                    "type": "other",
                    "_input_type": "HandleInput"
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from langchain.memory import ConversationBufferMemory\n\nfrom langflow.custom import Component\nfrom langflow.field_typing import BaseChatMemory\nfrom langflow.helpers.data import data_to_text\nfrom langflow.inputs import HandleInput\nfrom langflow.io import DropdownInput, IntInput, MessageTextInput, MultilineInput, Output\nfrom langflow.memory import LCBuiltinChatMemory, get_messages\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_USER\n\n\nclass MemoryComponent(Component):\n    display_name = \"Chat Memory\"\n    description = \"Retrieves stored chat messages from Langflow tables or an external memory.\"\n    icon = \"message-square-more\"\n    name = \"Memory\"\n\n    inputs = [\n        HandleInput(\n            name=\"memory\",\n            display_name=\"External Memory\",\n            input_types=[\"BaseChatMessageHistory\"],\n            info=\"Retrieve messages from an external memory. If empty, it will use the Langflow tables.\",\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER, \"Machine and User\"],\n            value=\"Machine and User\",\n            info=\"Filter by sender type.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Filter by sender name.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"n_messages\",\n            display_name=\"Number of Messages\",\n            value=100,\n            info=\"Number of messages to retrieve.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"order\",\n            display_name=\"Order\",\n            options=[\"Ascending\", \"Descending\"],\n            value=\"Ascending\",\n            info=\"Order of the messages.\",\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. \"\n            \"It can contain the keys {text}, {sender} or any other key in the message data.\",\n            value=\"{sender_name}: {text}\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Messages (Data)\", name=\"messages\", method=\"retrieve_messages\"),\n        Output(display_name=\"Messages (Text)\", name=\"messages_text\", method=\"retrieve_messages_as_text\"),\n        Output(display_name=\"Memory\", name=\"lc_memory\", method=\"build_lc_memory\"),\n    ]\n\n    def retrieve_messages(self) -> Data:\n        sender = self.sender\n        sender_name = self.sender_name\n        session_id = self.session_id\n        n_messages = self.n_messages\n        order = \"DESC\" if self.order == \"Descending\" else \"ASC\"\n\n        if sender == \"Machine and User\":\n            sender = None\n\n        if self.memory:\n            # override session_id\n            self.memory.session_id = session_id\n\n            stored = self.memory.messages\n            # langchain memories are supposed to return messages in ascending order\n            if order == \"DESC\":\n                stored = stored[::-1]\n            if n_messages:\n                stored = stored[:n_messages]\n            stored = [Message.from_lc_message(m) for m in stored]\n            if sender:\n                expected_type = MESSAGE_SENDER_AI if sender == MESSAGE_SENDER_AI else MESSAGE_SENDER_USER\n                stored = [m for m in stored if m.type == expected_type]\n        else:\n            stored = get_messages(\n                sender=sender,\n                sender_name=sender_name,\n                session_id=session_id,\n                limit=n_messages,\n                order=order,\n            )\n        self.status = stored\n        return stored\n\n    def retrieve_messages_as_text(self) -> Message:\n        stored_text = data_to_text(self.template, self.retrieve_messages())\n        self.status = stored_text\n        return Message(text=stored_text)\n\n    def build_lc_memory(self) -> BaseChatMemory:\n        chat_memory = self.memory or LCBuiltinChatMemory(flow_id=self.flow_id, session_id=self.session_id)\n        return ConversationBufferMemory(chat_memory=chat_memory)\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "n_messages": {
                    "trace_as_metadata": true,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "n_messages",
                    "value": 100,
                    "display_name": "Number of Messages",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Number of messages to retrieve.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "order": {
                    "trace_as_metadata": true,
                    "options": [
                        "Ascending",
                        "Descending"
                    ],
                    "combobox": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "order",
                    "value": "Ascending",
                    "display_name": "Order",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Order of the messages.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "sender": {
                    "trace_as_metadata": true,
                    "options": [
                        "Machine",
                        "User",
                        "Machine and User"
                    ],
                    "combobox": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "sender",
                    "value": "Machine and User",
                    "display_name": "Sender Type",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Filter by sender type.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "sender_name": {
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "sender_name",
                    "value": "",
                    "display_name": "Sender Name",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Filter by sender name.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "session_id": {
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "session_id",
                    "value": "",
                    "display_name": "Session ID",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "template": {
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "template",
                    "value": "{sender_name}: {text}",
                    "display_name": "Template",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The template to use for formatting the data. It can contain the keys {text}, {sender} or any other key in the message data.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                }
            },
            "description": "Retrieves stored chat messages from Langflow tables or an external memory.",
            "icon": "message-square-more",
            "base_classes": [
                "BaseChatMemory",
                "Data",
                "Message"
            ],
            "display_name": "Automata Coprocessor",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "messages",
                    "display_name": "ZK Proof",
                    "method": "retrieve_messages",
                    "value": "__UNDEFINED__",
                    "cache": true
                }
            ],
            "field_order": [
                "memory",
                "sender",
                "sender_name",
                "n_messages",
                "session_id",
                "order",
                "template"
            ],
            "beta": false,
            "edited": false,
            "metadata": {}
        },
        "CustomComponent": {
            "template": {
                "_type": "Component",
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "# from langflow.field_typing import Data\nfrom langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema import Data\n\n\nclass CustomComponent(Component):\n    display_name = \"Custom Component\"\n    description = \"Use as a template to create your own component.\"\n    documentation: str = \"http://docs.langflow.org/components/custom\"\n    icon = \"custom_components\"\n    name = \"CustomComponent\"\n\n    inputs = [\n        MessageTextInput(name=\"input_value\", display_name=\"Input Value\", value=\"Hello, World!\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Output\", name=\"output\", method=\"build_output\"),\n    ]\n\n    def build_output(self) -> Data:\n        data = Data(value=self.input_value)\n        self.status = data\n        return data\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "input_value": {
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "input_value",
                    "value": "Hello, World!",
                    "display_name": "Input Value",
                    "advanced": false,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                }
            },
            "description": "Use as a template to create your own component.",
            "icon": "custom_components",
            "base_classes": [
                "Data"
            ],
            "display_name": "Custom Component",
            "documentation": "http://docs.langflow.org/components/custom",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "output",
                    "display_name": "Output",
                    "method": "build_output",
                    "value": "__UNDEFINED__",
                    "cache": true
                }
            ],
            "field_order": [
                "input_value"
            ],
            "beta": false,
            "edited": false,
            "metadata": {}
        },
    },
    "dataAvailability": {
        "EigenDA": {
            "template": {
                "_type": "Component",
                "memory": {
                    "trace_as_metadata": true,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "memory",
                    "value": "",
                    "display_name": "External Memory",
                    "advanced": false,
                    "input_types": [
                        "BaseChatMessageHistory"
                    ],
                    "dynamic": false,
                    "info": "Retrieve messages from an external memory. If empty, it will use the Langflow tables.",
                    "title_case": false,
                    "type": "other",
                    "_input_type": "HandleInput"
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from langchain.memory import ConversationBufferMemory\n\nfrom langflow.custom import Component\nfrom langflow.field_typing import BaseChatMemory\nfrom langflow.helpers.data import data_to_text\nfrom langflow.inputs import HandleInput\nfrom langflow.io import DropdownInput, IntInput, MessageTextInput, MultilineInput, Output\nfrom langflow.memory import LCBuiltinChatMemory, get_messages\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_USER\n\n\nclass MemoryComponent(Component):\n    display_name = \"Chat Memory\"\n    description = \"Retrieves stored chat messages from Langflow tables or an external memory.\"\n    icon = \"message-square-more\"\n    name = \"Memory\"\n\n    inputs = [\n        HandleInput(\n            name=\"memory\",\n            display_name=\"External Memory\",\n            input_types=[\"BaseChatMessageHistory\"],\n            info=\"Retrieve messages from an external memory. If empty, it will use the Langflow tables.\",\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER, \"Machine and User\"],\n            value=\"Machine and User\",\n            info=\"Filter by sender type.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Filter by sender name.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"n_messages\",\n            display_name=\"Number of Messages\",\n            value=100,\n            info=\"Number of messages to retrieve.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"order\",\n            display_name=\"Order\",\n            options=[\"Ascending\", \"Descending\"],\n            value=\"Ascending\",\n            info=\"Order of the messages.\",\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. \"\n            \"It can contain the keys {text}, {sender} or any other key in the message data.\",\n            value=\"{sender_name}: {text}\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Messages (Data)\", name=\"messages\", method=\"retrieve_messages\"),\n        Output(display_name=\"Messages (Text)\", name=\"messages_text\", method=\"retrieve_messages_as_text\"),\n        Output(display_name=\"Memory\", name=\"lc_memory\", method=\"build_lc_memory\"),\n    ]\n\n    def retrieve_messages(self) -> Data:\n        sender = self.sender\n        sender_name = self.sender_name\n        session_id = self.session_id\n        n_messages = self.n_messages\n        order = \"DESC\" if self.order == \"Descending\" else \"ASC\"\n\n        if sender == \"Machine and User\":\n            sender = None\n\n        if self.memory:\n            # override session_id\n            self.memory.session_id = session_id\n\n            stored = self.memory.messages\n            # langchain memories are supposed to return messages in ascending order\n            if order == \"DESC\":\n                stored = stored[::-1]\n            if n_messages:\n                stored = stored[:n_messages]\n            stored = [Message.from_lc_message(m) for m in stored]\n            if sender:\n                expected_type = MESSAGE_SENDER_AI if sender == MESSAGE_SENDER_AI else MESSAGE_SENDER_USER\n                stored = [m for m in stored if m.type == expected_type]\n        else:\n            stored = get_messages(\n                sender=sender,\n                sender_name=sender_name,\n                session_id=session_id,\n                limit=n_messages,\n                order=order,\n            )\n        self.status = stored\n        return stored\n\n    def retrieve_messages_as_text(self) -> Message:\n        stored_text = data_to_text(self.template, self.retrieve_messages())\n        self.status = stored_text\n        return Message(text=stored_text)\n\n    def build_lc_memory(self) -> BaseChatMemory:\n        chat_memory = self.memory or LCBuiltinChatMemory(flow_id=self.flow_id, session_id=self.session_id)\n        return ConversationBufferMemory(chat_memory=chat_memory)\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "n_messages": {
                    "trace_as_metadata": true,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "n_messages",
                    "value": 100,
                    "display_name": "Number of Messages",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Number of messages to retrieve.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "order": {
                    "trace_as_metadata": true,
                    "options": [
                        "Ascending",
                        "Descending"
                    ],
                    "combobox": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "order",
                    "value": "Ascending",
                    "display_name": "Order",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Order of the messages.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "sender": {
                    "trace_as_metadata": true,
                    "options": [
                        "Machine",
                        "User",
                        "Machine and User"
                    ],
                    "combobox": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "sender",
                    "value": "Machine and User",
                    "display_name": "Sender Type",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Filter by sender type.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "sender_name": {
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "sender_name",
                    "value": "",
                    "display_name": "Sender Name",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Filter by sender name.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "session_id": {
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "session_id",
                    "value": "",
                    "display_name": "Session ID",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "template": {
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "template",
                    "value": "{sender_name}: {text}",
                    "display_name": "Template",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The template to use for formatting the data. It can contain the keys {text}, {sender} or any other key in the message data.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                }
            },
            "description": "Retrieves stored chat messages from Langflow tables or an external memory.",
            "icon": "message-square-more",
            "base_classes": [
                "BaseChatMemory",
                "Data",
                "Message"
            ],
            "display_name": "EigenDA",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "messages",
                    "display_name": "Messages (Data)",
                    "method": "retrieve_messages",
                    "value": "__UNDEFINED__",
                    "cache": true
                },
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "messages_text",
                    "display_name": "Messages (Text)",
                    "method": "retrieve_messages_as_text",
                    "value": "__UNDEFINED__",
                    "cache": true
                },
                {
                    "types": [
                        "BaseChatMemory"
                    ],
                    "selected": "BaseChatMemory",
                    "name": "lc_memory",
                    "display_name": "Memory",
                    "method": "build_lc_memory",
                    "value": "__UNDEFINED__",
                    "cache": true
                }
            ],
            "field_order": [
                "memory",
                "sender",
                "sender_name",
                "n_messages",
                "session_id",
                "order",
                "template"
            ],
            "beta": false,
            "edited": false,
            "metadata": {}
        },
        "NearDA": {
            "template": {
                "_type": "Component",
                "memory": {
                    "trace_as_metadata": true,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "memory",
                    "value": "",
                    "display_name": "External Memory",
                    "advanced": false,
                    "input_types": [
                        "BaseChatMessageHistory"
                    ],
                    "dynamic": false,
                    "info": "Retrieve messages from an external memory. If empty, it will use the Langflow tables.",
                    "title_case": false,
                    "type": "other",
                    "_input_type": "HandleInput"
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from langchain.memory import ConversationBufferMemory\n\nfrom langflow.custom import Component\nfrom langflow.field_typing import BaseChatMemory\nfrom langflow.helpers.data import data_to_text\nfrom langflow.inputs import HandleInput\nfrom langflow.io import DropdownInput, IntInput, MessageTextInput, MultilineInput, Output\nfrom langflow.memory import LCBuiltinChatMemory, get_messages\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_USER\n\n\nclass MemoryComponent(Component):\n    display_name = \"Chat Memory\"\n    description = \"Retrieves stored chat messages from Langflow tables or an external memory.\"\n    icon = \"message-square-more\"\n    name = \"Memory\"\n\n    inputs = [\n        HandleInput(\n            name=\"memory\",\n            display_name=\"External Memory\",\n            input_types=[\"BaseChatMessageHistory\"],\n            info=\"Retrieve messages from an external memory. If empty, it will use the Langflow tables.\",\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER, \"Machine and User\"],\n            value=\"Machine and User\",\n            info=\"Filter by sender type.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Filter by sender name.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"n_messages\",\n            display_name=\"Number of Messages\",\n            value=100,\n            info=\"Number of messages to retrieve.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"order\",\n            display_name=\"Order\",\n            options=[\"Ascending\", \"Descending\"],\n            value=\"Ascending\",\n            info=\"Order of the messages.\",\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. \"\n            \"It can contain the keys {text}, {sender} or any other key in the message data.\",\n            value=\"{sender_name}: {text}\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Messages (Data)\", name=\"messages\", method=\"retrieve_messages\"),\n        Output(display_name=\"Messages (Text)\", name=\"messages_text\", method=\"retrieve_messages_as_text\"),\n        Output(display_name=\"Memory\", name=\"lc_memory\", method=\"build_lc_memory\"),\n    ]\n\n    def retrieve_messages(self) -> Data:\n        sender = self.sender\n        sender_name = self.sender_name\n        session_id = self.session_id\n        n_messages = self.n_messages\n        order = \"DESC\" if self.order == \"Descending\" else \"ASC\"\n\n        if sender == \"Machine and User\":\n            sender = None\n\n        if self.memory:\n            # override session_id\n            self.memory.session_id = session_id\n\n            stored = self.memory.messages\n            # langchain memories are supposed to return messages in ascending order\n            if order == \"DESC\":\n                stored = stored[::-1]\n            if n_messages:\n                stored = stored[:n_messages]\n            stored = [Message.from_lc_message(m) for m in stored]\n            if sender:\n                expected_type = MESSAGE_SENDER_AI if sender == MESSAGE_SENDER_AI else MESSAGE_SENDER_USER\n                stored = [m for m in stored if m.type == expected_type]\n        else:\n            stored = get_messages(\n                sender=sender,\n                sender_name=sender_name,\n                session_id=session_id,\n                limit=n_messages,\n                order=order,\n            )\n        self.status = stored\n        return stored\n\n    def retrieve_messages_as_text(self) -> Message:\n        stored_text = data_to_text(self.template, self.retrieve_messages())\n        self.status = stored_text\n        return Message(text=stored_text)\n\n    def build_lc_memory(self) -> BaseChatMemory:\n        chat_memory = self.memory or LCBuiltinChatMemory(flow_id=self.flow_id, session_id=self.session_id)\n        return ConversationBufferMemory(chat_memory=chat_memory)\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "n_messages": {
                    "trace_as_metadata": true,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "n_messages",
                    "value": 100,
                    "display_name": "Number of Messages",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Number of messages to retrieve.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "order": {
                    "trace_as_metadata": true,
                    "options": [
                        "Ascending",
                        "Descending"
                    ],
                    "combobox": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "order",
                    "value": "Ascending",
                    "display_name": "Order",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Order of the messages.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "sender": {
                    "trace_as_metadata": true,
                    "options": [
                        "Machine",
                        "User",
                        "Machine and User"
                    ],
                    "combobox": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "sender",
                    "value": "Machine and User",
                    "display_name": "Sender Type",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Filter by sender type.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "sender_name": {
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "sender_name",
                    "value": "",
                    "display_name": "Sender Name",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Filter by sender name.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "session_id": {
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "session_id",
                    "value": "",
                    "display_name": "Session ID",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "template": {
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "template",
                    "value": "{sender_name}: {text}",
                    "display_name": "Template",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The template to use for formatting the data. It can contain the keys {text}, {sender} or any other key in the message data.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                }
            },
            "description": "Retrieves stored chat messages from Langflow tables or an external memory.",
            "icon": "message-square-more",
            "base_classes": [
                "BaseChatMemory",
                "Data",
                "Message"
            ],
            "display_name": "NearDA",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "messages",
                    "display_name": "Messages (Data)",
                    "method": "retrieve_messages",
                    "value": "__UNDEFINED__",
                    "cache": true
                },
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "messages_text",
                    "display_name": "Messages (Text)",
                    "method": "retrieve_messages_as_text",
                    "value": "__UNDEFINED__",
                    "cache": true
                },
                {
                    "types": [
                        "BaseChatMemory"
                    ],
                    "selected": "BaseChatMemory",
                    "name": "lc_memory",
                    "display_name": "Memory",
                    "method": "build_lc_memory",
                    "value": "__UNDEFINED__",
                    "cache": true
                }
            ],
            "field_order": [
                "memory",
                "sender",
                "sender_name",
                "n_messages",
                "session_id",
                "order",
                "template"
            ],
            "beta": false,
            "edited": false,
            "metadata": {}
        },
        "Celestia": {
            "template": {
                "_type": "Component",
                "memory": {
                    "trace_as_metadata": true,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "memory",
                    "value": "",
                    "display_name": "External Memory",
                    "advanced": false,
                    "input_types": [
                        "BaseChatMessageHistory"
                    ],
                    "dynamic": false,
                    "info": "Retrieve messages from an external memory. If empty, it will use the Langflow tables.",
                    "title_case": false,
                    "type": "other",
                    "_input_type": "HandleInput"
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from langchain.memory import ConversationBufferMemory\n\nfrom langflow.custom import Component\nfrom langflow.field_typing import BaseChatMemory\nfrom langflow.helpers.data import data_to_text\nfrom langflow.inputs import HandleInput\nfrom langflow.io import DropdownInput, IntInput, MessageTextInput, MultilineInput, Output\nfrom langflow.memory import LCBuiltinChatMemory, get_messages\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_USER\n\n\nclass MemoryComponent(Component):\n    display_name = \"Chat Memory\"\n    description = \"Retrieves stored chat messages from Langflow tables or an external memory.\"\n    icon = \"message-square-more\"\n    name = \"Memory\"\n\n    inputs = [\n        HandleInput(\n            name=\"memory\",\n            display_name=\"External Memory\",\n            input_types=[\"BaseChatMessageHistory\"],\n            info=\"Retrieve messages from an external memory. If empty, it will use the Langflow tables.\",\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER, \"Machine and User\"],\n            value=\"Machine and User\",\n            info=\"Filter by sender type.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Filter by sender name.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"n_messages\",\n            display_name=\"Number of Messages\",\n            value=100,\n            info=\"Number of messages to retrieve.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"order\",\n            display_name=\"Order\",\n            options=[\"Ascending\", \"Descending\"],\n            value=\"Ascending\",\n            info=\"Order of the messages.\",\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. \"\n            \"It can contain the keys {text}, {sender} or any other key in the message data.\",\n            value=\"{sender_name}: {text}\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Messages (Data)\", name=\"messages\", method=\"retrieve_messages\"),\n        Output(display_name=\"Messages (Text)\", name=\"messages_text\", method=\"retrieve_messages_as_text\"),\n        Output(display_name=\"Memory\", name=\"lc_memory\", method=\"build_lc_memory\"),\n    ]\n\n    def retrieve_messages(self) -> Data:\n        sender = self.sender\n        sender_name = self.sender_name\n        session_id = self.session_id\n        n_messages = self.n_messages\n        order = \"DESC\" if self.order == \"Descending\" else \"ASC\"\n\n        if sender == \"Machine and User\":\n            sender = None\n\n        if self.memory:\n            # override session_id\n            self.memory.session_id = session_id\n\n            stored = self.memory.messages\n            # langchain memories are supposed to return messages in ascending order\n            if order == \"DESC\":\n                stored = stored[::-1]\n            if n_messages:\n                stored = stored[:n_messages]\n            stored = [Message.from_lc_message(m) for m in stored]\n            if sender:\n                expected_type = MESSAGE_SENDER_AI if sender == MESSAGE_SENDER_AI else MESSAGE_SENDER_USER\n                stored = [m for m in stored if m.type == expected_type]\n        else:\n            stored = get_messages(\n                sender=sender,\n                sender_name=sender_name,\n                session_id=session_id,\n                limit=n_messages,\n                order=order,\n            )\n        self.status = stored\n        return stored\n\n    def retrieve_messages_as_text(self) -> Message:\n        stored_text = data_to_text(self.template, self.retrieve_messages())\n        self.status = stored_text\n        return Message(text=stored_text)\n\n    def build_lc_memory(self) -> BaseChatMemory:\n        chat_memory = self.memory or LCBuiltinChatMemory(flow_id=self.flow_id, session_id=self.session_id)\n        return ConversationBufferMemory(chat_memory=chat_memory)\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "n_messages": {
                    "trace_as_metadata": true,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "n_messages",
                    "value": 100,
                    "display_name": "Number of Messages",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Number of messages to retrieve.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "order": {
                    "trace_as_metadata": true,
                    "options": [
                        "Ascending",
                        "Descending"
                    ],
                    "combobox": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "order",
                    "value": "Ascending",
                    "display_name": "Order",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Order of the messages.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "sender": {
                    "trace_as_metadata": true,
                    "options": [
                        "Machine",
                        "User",
                        "Machine and User"
                    ],
                    "combobox": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "sender",
                    "value": "Machine and User",
                    "display_name": "Sender Type",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Filter by sender type.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "sender_name": {
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "sender_name",
                    "value": "",
                    "display_name": "Sender Name",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Filter by sender name.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "session_id": {
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "session_id",
                    "value": "",
                    "display_name": "Session ID",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "template": {
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "template",
                    "value": "{sender_name}: {text}",
                    "display_name": "Template",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The template to use for formatting the data. It can contain the keys {text}, {sender} or any other key in the message data.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                }
            },
            "description": "Retrieves stored chat messages from Langflow tables or an external memory.",
            "icon": "message-square-more",
            "base_classes": [
                "BaseChatMemory",
                "Data",
                "Message"
            ],
            "display_name": "Celestia",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "messages",
                    "display_name": "Messages (Data)",
                    "method": "retrieve_messages",
                    "value": "__UNDEFINED__",
                    "cache": true
                },
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "messages_text",
                    "display_name": "Messages (Text)",
                    "method": "retrieve_messages_as_text",
                    "value": "__UNDEFINED__",
                    "cache": true
                },
                {
                    "types": [
                        "BaseChatMemory"
                    ],
                    "selected": "BaseChatMemory",
                    "name": "lc_memory",
                    "display_name": "Memory",
                    "method": "build_lc_memory",
                    "value": "__UNDEFINED__",
                    "cache": true
                }
            ],
            "field_order": [
                "memory",
                "sender",
                "sender_name",
                "n_messages",
                "session_id",
                "order",
                "template"
            ],
            "beta": false,
            "edited": false,
            "metadata": {}
        },
        "Avail": {
            "template": {
                "_type": "Component",
                "memory": {
                    "trace_as_metadata": true,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "memory",
                    "value": "",
                    "display_name": "External Memory",
                    "advanced": false,
                    "input_types": [
                        "BaseChatMessageHistory"
                    ],
                    "dynamic": false,
                    "info": "Retrieve messages from an external memory. If empty, it will use the Langflow tables.",
                    "title_case": false,
                    "type": "other",
                    "_input_type": "HandleInput"
                },
                "code": {
                    "type": "code",
                    "required": true,
                    "placeholder": "",
                    "list": false,
                    "show": true,
                    "multiline": true,
                    "value": "from langchain.memory import ConversationBufferMemory\n\nfrom langflow.custom import Component\nfrom langflow.field_typing import BaseChatMemory\nfrom langflow.helpers.data import data_to_text\nfrom langflow.inputs import HandleInput\nfrom langflow.io import DropdownInput, IntInput, MessageTextInput, MultilineInput, Output\nfrom langflow.memory import LCBuiltinChatMemory, get_messages\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_USER\n\n\nclass MemoryComponent(Component):\n    display_name = \"Chat Memory\"\n    description = \"Retrieves stored chat messages from Langflow tables or an external memory.\"\n    icon = \"message-square-more\"\n    name = \"Memory\"\n\n    inputs = [\n        HandleInput(\n            name=\"memory\",\n            display_name=\"External Memory\",\n            input_types=[\"BaseChatMessageHistory\"],\n            info=\"Retrieve messages from an external memory. If empty, it will use the Langflow tables.\",\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER, \"Machine and User\"],\n            value=\"Machine and User\",\n            info=\"Filter by sender type.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Filter by sender name.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"n_messages\",\n            display_name=\"Number of Messages\",\n            value=100,\n            info=\"Number of messages to retrieve.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"order\",\n            display_name=\"Order\",\n            options=[\"Ascending\", \"Descending\"],\n            value=\"Ascending\",\n            info=\"Order of the messages.\",\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. \"\n            \"It can contain the keys {text}, {sender} or any other key in the message data.\",\n            value=\"{sender_name}: {text}\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Messages (Data)\", name=\"messages\", method=\"retrieve_messages\"),\n        Output(display_name=\"Messages (Text)\", name=\"messages_text\", method=\"retrieve_messages_as_text\"),\n        Output(display_name=\"Memory\", name=\"lc_memory\", method=\"build_lc_memory\"),\n    ]\n\n    def retrieve_messages(self) -> Data:\n        sender = self.sender\n        sender_name = self.sender_name\n        session_id = self.session_id\n        n_messages = self.n_messages\n        order = \"DESC\" if self.order == \"Descending\" else \"ASC\"\n\n        if sender == \"Machine and User\":\n            sender = None\n\n        if self.memory:\n            # override session_id\n            self.memory.session_id = session_id\n\n            stored = self.memory.messages\n            # langchain memories are supposed to return messages in ascending order\n            if order == \"DESC\":\n                stored = stored[::-1]\n            if n_messages:\n                stored = stored[:n_messages]\n            stored = [Message.from_lc_message(m) for m in stored]\n            if sender:\n                expected_type = MESSAGE_SENDER_AI if sender == MESSAGE_SENDER_AI else MESSAGE_SENDER_USER\n                stored = [m for m in stored if m.type == expected_type]\n        else:\n            stored = get_messages(\n                sender=sender,\n                sender_name=sender_name,\n                session_id=session_id,\n                limit=n_messages,\n                order=order,\n            )\n        self.status = stored\n        return stored\n\n    def retrieve_messages_as_text(self) -> Message:\n        stored_text = data_to_text(self.template, self.retrieve_messages())\n        self.status = stored_text\n        return Message(text=stored_text)\n\n    def build_lc_memory(self) -> BaseChatMemory:\n        chat_memory = self.memory or LCBuiltinChatMemory(flow_id=self.flow_id, session_id=self.session_id)\n        return ConversationBufferMemory(chat_memory=chat_memory)\n",
                    "fileTypes": [],
                    "file_path": "",
                    "password": false,
                    "name": "code",
                    "advanced": true,
                    "dynamic": true,
                    "info": "",
                    "load_from_db": false,
                    "title_case": false
                },
                "n_messages": {
                    "trace_as_metadata": true,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "n_messages",
                    "value": 100,
                    "display_name": "Number of Messages",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Number of messages to retrieve.",
                    "title_case": false,
                    "type": "int",
                    "_input_type": "IntInput"
                },
                "order": {
                    "trace_as_metadata": true,
                    "options": [
                        "Ascending",
                        "Descending"
                    ],
                    "combobox": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "order",
                    "value": "Ascending",
                    "display_name": "Order",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Order of the messages.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "sender": {
                    "trace_as_metadata": true,
                    "options": [
                        "Machine",
                        "User",
                        "Machine and User"
                    ],
                    "combobox": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "sender",
                    "value": "Machine and User",
                    "display_name": "Sender Type",
                    "advanced": true,
                    "dynamic": false,
                    "info": "Filter by sender type.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "DropdownInput"
                },
                "sender_name": {
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "sender_name",
                    "value": "",
                    "display_name": "Sender Name",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "Filter by sender name.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "session_id": {
                    "trace_as_input": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "session_id",
                    "value": "",
                    "display_name": "Session ID",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MessageTextInput"
                },
                "template": {
                    "trace_as_input": true,
                    "multiline": true,
                    "trace_as_metadata": true,
                    "load_from_db": false,
                    "list": false,
                    "required": false,
                    "placeholder": "",
                    "show": true,
                    "name": "template",
                    "value": "{sender_name}: {text}",
                    "display_name": "Template",
                    "advanced": true,
                    "input_types": [
                        "Message"
                    ],
                    "dynamic": false,
                    "info": "The template to use for formatting the data. It can contain the keys {text}, {sender} or any other key in the message data.",
                    "title_case": false,
                    "type": "str",
                    "_input_type": "MultilineInput"
                }
            },
            "description": "Retrieves stored chat messages from Langflow tables or an external memory.",
            "icon": "message-square-more",
            "base_classes": [
                "BaseChatMemory",
                "Data",
                "Message"
            ],
            "display_name": "Avail",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
                {
                    "types": [
                        "Data"
                    ],
                    "selected": "Data",
                    "name": "messages",
                    "display_name": "Messages (Data)",
                    "method": "retrieve_messages",
                    "value": "__UNDEFINED__",
                    "cache": true
                },
                {
                    "types": [
                        "Message"
                    ],
                    "selected": "Message",
                    "name": "messages_text",
                    "display_name": "Messages (Text)",
                    "method": "retrieve_messages_as_text",
                    "value": "__UNDEFINED__",
                    "cache": true
                },
                {
                    "types": [
                        "BaseChatMemory"
                    ],
                    "selected": "BaseChatMemory",
                    "name": "lc_memory",
                    "display_name": "Memory",
                    "method": "build_lc_memory",
                    "value": "__UNDEFINED__",
                    "cache": true
                }
            ],
            "field_order": [
                "memory",
                "sender",
                "sender_name",
                "n_messages",
                "session_id",
                "order",
                "template"
            ],
            "beta": false,
            "edited": false,
            "metadata": {}
        },
    },
};