import type { AllNodeType, GenericNodeType } from "@/types/flow";
import { getEffectiveAliasFromAnyNode } from "@/types/flow";

/**
 * Utility functions for managing component aliases with hybrid approach:
 * - Auto-generated aliases renumber with gap-filling when components are removed
 * - User-defined aliases remain stable to preserve semantic meaning
 *
 * CRITICAL SAFETY RULES:
 * 1. NEVER modify user-defined aliases (detected by pattern)
 * 2. NEVER change existing valid aliases during migration unless duplicates exist
 * 3. ONLY reassign auto-generated aliases or components without aliases
 * 4. ALWAYS preserve user semantic meaning in custom aliases
 */

/**
 * Check if an alias has a number suffix (making it protected from modification)
 * All aliases are auto-generated, but those with #number are protected
 */
export function hasNumberSuffix(alias: string): boolean {
  // Pattern: any text + # + number (e.g., "OpenAI#1", "Language Model#3")
  return /^.+#\d+$/.test(alias);
}

/**
 * Safety check: Verify if it's safe to modify a component's alias
 * Can only modify aliases that don't have a number suffix
 */
export function isSafeToModifyAlias(node: GenericNodeType): boolean {
  const alias = node.data.node.alias;

  if (!alias) return true; // No alias, safe to add one

  // Can only modify if it doesn't have a number suffix
  return !hasNumberSuffix(alias);
}

/**
 * Generate auto-alias with gap-filling for components of the same display_name
 */
export function generateAutoAlias(
  displayName: string,
  existingNodes: AllNodeType[],
): string {
  const sameTypeNodes = getNodesByDisplayName(existingNodes, displayName);
  const autoGenerated = sameTypeNodes.filter(
    (n) =>
      n.type === "genericNode" &&
      n.data.node.alias &&
      hasNumberSuffix(n.data.node.alias),
  );

  // Find the lowest available number
  let counter = 1;
  const usedNumbers = new Set<number>();

  // Collect used numbers from auto-generated aliases only
  autoGenerated.forEach((node) => {
    if (node.type === "genericNode" && node.data.node.alias) {
      const match = node.data.node.alias.match(/^.+#(\d+)$/);
      if (match) usedNumbers.add(parseInt(match[1]));
    }
  });

  // Find first available slot
  while (usedNumbers.has(counter)) {
    counter++;
  }

  return `${displayName}#${counter}`;
}

/**
 * Renumber auto-generated aliases when component is removed (hybrid approach)
 */
export function renumberAutoGeneratedAliases(
  nodes: AllNodeType[],
  removedDisplayName: string,
): AllNodeType[] {
  const sameTypeNodes = getNodesByDisplayName(nodes, removedDisplayName)
    .filter((n) => {
      if (n.type !== "genericNode" || !n.data.node.alias) return false;

      // Only include numbered aliases that match the old display name pattern
      // This ensures we only renumber aliases that were auto-generated for this display name
      const alias = n.data.node.alias;
      const oldPattern = new RegExp(
        `^${removedDisplayName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}#\\d+$`,
      );
      return oldPattern.test(alias);
    })
    .sort((a, b) => {
      const numA = extractNumber(
        a.type === "genericNode" ? a.data.node.alias : null,
      );
      const numB = extractNumber(
        b.type === "genericNode" ? b.data.node.alias : null,
      );
      return numA - numB;
    });

  // Renumber to fill gaps: #1, #2, #3, etc.
  // Note: For renumbering, we DO want to modify numbered aliases (that's the point)
  sameTypeNodes.forEach((node, index) => {
    if (node.type === "genericNode") {
      const newAlias = `${removedDisplayName}#${index + 1}`;
      node.data.node.alias = newAlias;
    }
  });

  return nodes;
}

/**
 * Assign aliases when adding a new component to workspace
 */
export function assignAliasToNewComponent(
  newNode: AllNodeType,
  existingNodes: AllNodeType[],
): void {
  if (newNode.type !== "genericNode") return;

  const displayName = newNode.data.node.display_name;
  const sameTypeNodes = existingNodes.filter(
    (n) => n.type === "genericNode" && n.data.node.display_name === displayName,
  );

  if (sameTypeNodes.length === 0) {
    // First of its type - no alias needed initially
    newNode.data.node.alias = undefined;
  } else if (sameTypeNodes.length === 1 && !sameTypeNodes[0].data.node.alias) {
    // Second of its type - assign aliases to both
    const firstNode = sameTypeNodes[0] as GenericNodeType;
    firstNode.data.node.alias = `${displayName}#1`;

    newNode.data.node.alias = `${displayName}#2`;
  } else {
    // Multiple exist - generate next available auto-alias
    newNode.data.node.alias = generateAutoAlias(displayName, existingNodes);
  }
}

/**
 * Update aliases when display name changes
 */
export function updateAliasesForDisplayNameChange(
  nodeId: string,
  oldDisplayName: string,
  newDisplayName: string,
  allNodes: AllNodeType[],
): AllNodeType[] {
  const targetNode = allNodes.find((n) => n.id === nodeId);
  if (!targetNode || targetNode.type !== "genericNode") return allNodes;

  // For display name changes, we always update the alias to match the new name
  // This is different from other operations where we protect numbered aliases

  // Update auto-generated alias to use new display name
  const sameNewTypeNodes = allNodes.filter(
    (n) =>
      n.type === "genericNode" &&
      n.data.node.display_name === newDisplayName &&
      n.id !== nodeId,
  );

  if (sameNewTypeNodes.length === 0) {
    // Only component with this display name - remove alias
    targetNode.data.node.alias = undefined;
  } else {
    // Generate new alias based on new display name
    targetNode.data.node.alias = generateAutoAlias(newDisplayName, allNodes);
  }

  // Renumber any remaining components with the old display name
  renumberAutoGeneratedAliases(allNodes, oldDisplayName);

  return allNodes;
}

/**
 * Set user-defined alias
 */
export function setUserDefinedAlias(
  nodeId: string,
  customAlias: string,
  allNodes: AllNodeType[],
): void {
  const node = allNodes.find((n) => n.id === nodeId);
  if (!node || node.type !== "genericNode") return;

  const previousAlias = node.data.node.alias;
  const displayName = node.data.node.display_name;
  const wasNumbered = previousAlias ? hasNumberSuffix(previousAlias) : false;

  // Set custom alias
  node.data.node.alias = customAlias;

  // Trigger renumbering of remaining auto-generated aliases if needed
  if (previousAlias && !wasNumbered) {
    renumberAutoGeneratedAliases(allNodes, node.data.node.display_name);
  }
}

/**
 * Clear user-defined alias (revert to auto-generated)
 */
export function clearUserDefinedAlias(
  nodeId: string,
  allNodes: AllNodeType[],
): void {
  const node = allNodes.find((n) => n.id === nodeId);
  if (!node || node.type !== "genericNode") return;

  const currentAlias = node.data.node.alias;
  const displayName = node.data.node.display_name;

  // SAFETY CHECK: Only clear if it's actually user-defined
  if (!currentAlias) {
    console.warn(
      `Cannot clear user-defined alias for node ${nodeId}: already auto-generated or no alias`,
    );
    return;
  }

  if (hasNumberSuffix(currentAlias)) {
    console.warn(
      `Cannot clear user-defined alias for node ${nodeId}: already auto-generated or no alias`,
    );
    return;
  }

  // Generate new auto-alias based on existing nodes
  node.data.node.alias = generateAutoAlias(displayName, allNodes);
}

/**
 * Migrate existing flows to assign aliases to duplicate components
 * This ensures backward compatibility for flows created before alias implementation
 */
export function migrateExistingFlow(nodes: AllNodeType[]): AllNodeType[] {
  // Group nodes by display_name
  const nodesByDisplayName = new Map<string, GenericNodeType[]>();

  nodes.forEach((node) => {
    if (node.type === "genericNode" && node.data?.node?.display_name) {
      const displayName = node.data.node.display_name;
      if (!nodesByDisplayName.has(displayName)) {
        nodesByDisplayName.set(displayName, []);
      }
      nodesByDisplayName.get(displayName)!.push(node);
    }
  });

  // Assign aliases to groups with multiple components
  nodesByDisplayName.forEach((sameTypeNodes, displayName) => {
    if (sameTypeNodes.length > 1) {
      // Separate user-defined from auto-generated aliases
      const userDefinedNodes: GenericNodeType[] = [];
      const autoGeneratedNodes: GenericNodeType[] = [];
      const usedNumbers = new Set<number>();

      // First pass: preserve valid aliases (both user-defined and valid auto-generated) and collect used numbers
      sameTypeNodes.forEach((node) => {
        const currentAlias = node.data.node.alias;
        const hasNumber = currentAlias ? hasNumberSuffix(currentAlias) : false;

        if (currentAlias) {
          // Check if alias is valid format for this display name
          const match = currentAlias.match(
            new RegExp(
              `^${displayName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}#(\\d+)$`,
            ),
          );

          if (!hasNumber) {
            // Aliases without numbers - preserve them but don't reserve numbers
            userDefinedNodes.push(node);
          } else if (match) {
            // Valid auto-generated alias - preserve it too
            usedNumbers.add(parseInt(match[1]));
          } else {
            // Invalid auto-generated alias - needs reassignment
            autoGeneratedNodes.push(node);
          }
        } else {
          // No alias - needs one
          autoGeneratedNodes.push(node);
        }
      });

      // Second pass: reassign all auto-generated aliases to fill gaps
      let counter = 1;
      autoGeneratedNodes.forEach((node) => {
        // SAFETY CHECK: Only modify if safe
        if (!isSafeToModifyAlias(node)) {
          console.warn(
            `Attempted to modify protected alias for node ${node.id}. Skipping.`,
          );
          return;
        }

        // Find next available number
        while (usedNumbers.has(counter)) {
          counter++;
        }

        node.data.node.alias = `${displayName}#${counter}`;
        usedNumbers.add(counter);
        counter++;
      });
    } else {
      // Single component - ensure no alias if it's auto-generated
      const node = sameTypeNodes[0];
      if (node.data.node.alias && isSafeToModifyAlias(node)) {
        node.data.node.alias = undefined;
      }
    }
  });

  return nodes;
}

/**
 * Check if a flow needs migration (has duplicate components without proper aliases)
 */
export function needsMigration(nodes: AllNodeType[]): boolean {
  // Simple approach: check for any duplicate display names without proper aliases
  const displayNameGroups: { [displayName: string]: AllNodeType[] } = {};

  // Group by display name
  for (const node of nodes) {
    if (node.type === "genericNode" && node.data?.node?.display_name) {
      const displayName = node.data.node.display_name;
      if (!displayNameGroups[displayName]) {
        displayNameGroups[displayName] = [];
      }
      displayNameGroups[displayName].push(node);
    }
  }

  // Check each group
  for (const [_displayName, groupNodes] of Object.entries(displayNameGroups)) {
    if (groupNodes.length > 1) {
      // Multiple components - check if they need aliases
      const aliases: string[] = [];

      for (const node of groupNodes) {
        if (node.type === "genericNode") {
          const alias = node.data.node.alias;

          // Missing alias = needs migration
          if (!alias) {
            return true;
          }

          // Duplicate alias = needs migration
          if (aliases.includes(alias)) {
            return true;
          }

          aliases.push(alias);
        }
      }
    }
  }

  return false;
}

// Helper functions
function extractNumber(alias: string | undefined): number {
  if (!alias) return 0;
  const match = alias.match(/^.+#(\d+)$/);
  return match ? parseInt(match[1]) : 0;
}

/**
 * Converts UUID-based tweak keys to human-readable alias keys for API code generation
 */
export function convertTweaksToAliases(tweaks: any, nodes?: any[]): any {
  if (!nodes || !tweaks) return tweaks;

  const aliasedTweaks: any = {};

  for (const [nodeId, tweakValues] of Object.entries(tweaks)) {
    const node = nodes.find((n) => n.id === nodeId);
    if (node) {
      const alias = getEffectiveAliasFromAnyNode(node);
      aliasedTweaks[alias] = tweakValues;
    } else {
      // Fallback to original nodeId if node not found
      aliasedTweaks[nodeId] = tweakValues;
    }
  }

  return aliasedTweaks;
}

function getNodesByDisplayName(
  nodes: AllNodeType[],
  displayName: string,
): AllNodeType[] {
  return nodes.filter(
    (n) => n.type === "genericNode" && n.data.node.display_name === displayName,
  );
}
