/**
 * Unit tests for pattern-based alias utility functions
 */

import type { AllNodeType, GenericNodeType } from "@/types/flow";
import {
  assignAliasToNewComponent,
  clearUserDefinedAlias,
  convertTweaksToAliases,
  generateAutoAlias,
  hasNumberSuffix,
  isSafeToModifyAlias,
  migrateExistingFlow,
  needsMigration,
  renumberAutoGeneratedAliases,
  setUserDefinedAlias,
  updateAliasesForDisplayNameChange,
} from "../aliasUtils";

// Helper function to create mock generic nodes
function createMockNode(
  id: string,
  displayName: string,
  alias?: string,
): GenericNodeType {
  return {
    id,
    type: "genericNode",
    position: { x: 0, y: 0 },
    data: {
      showNode: true,
      type: "generic",
      id,
      node: {
        display_name: displayName,
        alias,
        description: "",
        template: {},
        documentation: "",
      },
    },
  };
}

describe("Pattern-Based Alias Utility Functions", () => {
  describe("Pattern Detection", () => {
    it("should detect numbered aliases (protected)", () => {
      expect(hasNumberSuffix("OpenAI#1")).toBe(true);
      expect(hasNumberSuffix("Language Model#5")).toBe(true);
      expect(hasNumberSuffix("测试组件#2")).toBe(true);
      expect(hasNumberSuffix("MyModel#123")).toBe(true); // Even if user typed it
    });

    it("should detect non-numbered aliases (modifiable)", () => {
      expect(hasNumberSuffix("MyCustomLLM")).toBe(false);
      expect(hasNumberSuffix("ProductionModel")).toBe(false);
      expect(hasNumberSuffix("OpenAI-Custom")).toBe(false);
    });

    it("should handle edge cases", () => {
      expect(hasNumberSuffix("OpenAI#")).toBe(false); // No number
      expect(hasNumberSuffix("OpenAI#abc")).toBe(false); // Non-numeric
      expect(hasNumberSuffix("Model")).toBe(false); // No # at all
    });
  });

  describe("isSafeToModifyAlias", () => {
    it("should return true for non-numbered aliases (modifiable)", () => {
      const node = createMockNode("1", "OpenAI", "MyCustomLLM");
      expect(isSafeToModifyAlias(node)).toBe(true); // Non-numbered = can modify
    });

    it("should return false for numbered aliases (protected)", () => {
      const node = createMockNode("1", "OpenAI", "OpenAI#1");
      expect(isSafeToModifyAlias(node)).toBe(false); // Numbered = protected
    });

    it("should return true for nodes without aliases", () => {
      const node = createMockNode("1", "OpenAI");
      expect(isSafeToModifyAlias(node)).toBe(true);
    });
  });

  describe("generateAutoAlias", () => {
    it("should generate first alias correctly", () => {
      const existingNodes: AllNodeType[] = [];
      const result = generateAutoAlias("OpenAI", existingNodes);
      expect(result).toBe("OpenAI#1");
    });

    it("should generate next available alias number", () => {
      const existingNodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"),
        createMockNode("2", "OpenAI", "OpenAI#2"),
      ];
      const result = generateAutoAlias("OpenAI", existingNodes);
      expect(result).toBe("OpenAI#3");
    });

    it("should fill gaps in numbering", () => {
      const existingNodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"),
        createMockNode("3", "OpenAI", "OpenAI#4"), // Gap at #2 and #3
      ];
      const result = generateAutoAlias("OpenAI", existingNodes);
      expect(result).toBe("OpenAI#2");
    });

    it("should ignore user-defined aliases when calculating numbers", () => {
      const existingNodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"),
        createMockNode("2", "OpenAI", "MyCustomLLM"), // User-defined, should be ignored
        createMockNode("3", "OpenAI", "OpenAI#2"),
      ];
      const result = generateAutoAlias("OpenAI", existingNodes);
      expect(result).toBe("OpenAI#3");
    });
  });

  describe("assignAliasToNewComponent", () => {
    it("should not assign alias to first component of a type", () => {
      const newNode = createMockNode("1", "OpenAI");
      const existingNodes: AllNodeType[] = [];

      assignAliasToNewComponent(newNode, existingNodes);

      expect(newNode.data.node.alias).toBeUndefined();
    });

    it("should assign aliases to both components when adding second", () => {
      const existingNode = createMockNode("1", "OpenAI");
      const newNode = createMockNode("2", "OpenAI");
      const existingNodes: AllNodeType[] = [existingNode];

      assignAliasToNewComponent(newNode, existingNodes);

      // First node should get alias
      expect(existingNode.data.node.alias).toBe("OpenAI#1");

      // New node should get alias
      expect(newNode.data.node.alias).toBe("OpenAI#2");
    });

    it("should generate next available alias for third component", () => {
      const newNode = createMockNode("3", "OpenAI");
      const existingNodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"),
        createMockNode("2", "OpenAI", "OpenAI#2"),
      ];

      assignAliasToNewComponent(newNode, existingNodes);

      expect(newNode.data.node.alias).toBe("OpenAI#3");
    });
  });

  describe("migrateExistingFlow", () => {
    it("should assign aliases to duplicate components without aliases", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI"),
        createMockNode("2", "OpenAI"),
        createMockNode("3", "OpenAI"),
      ];

      const result = migrateExistingFlow(nodes);

      expect(result[0].data.node.alias).toBe("OpenAI#1");
      expect(result[1].data.node.alias).toBe("OpenAI#2");
      expect(result[2].data.node.alias).toBe("OpenAI#3");
    });

    it("should preserve user-defined aliases", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "MyCustomLLM"), // User-defined (doesn't match pattern)
        createMockNode("2", "OpenAI"), // No alias
        createMockNode("3", "OpenAI"), // No alias
      ];

      const result = migrateExistingFlow(nodes);

      expect(result[0].data.node.alias).toBe("MyCustomLLM"); // Preserved
      expect(result[1].data.node.alias).toBe("OpenAI#1"); // New
      expect(result[2].data.node.alias).toBe("OpenAI#2"); // New
    });

    it("should preserve valid auto-generated aliases", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"), // Valid auto-generated
        createMockNode("2", "OpenAI"), // No alias
        createMockNode("3", "OpenAI"), // No alias
      ];

      const result = migrateExistingFlow(nodes);

      expect(result[0].data.node.alias).toBe("OpenAI#1"); // Preserved
      expect(result[1].data.node.alias).toBe("OpenAI#2"); // New
      expect(result[2].data.node.alias).toBe("OpenAI#3"); // New
    });
  });

  describe("needsMigration", () => {
    it("should return false for single components", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI"),
        createMockNode("2", "Wikipedia"),
      ];

      expect(needsMigration(nodes)).toBe(false);
    });

    it("should return false for properly aliased duplicates", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"),
        createMockNode("2", "OpenAI", "OpenAI#2"),
        createMockNode("3", "OpenAI", "MyCustomLLM"), // User-defined
      ];

      expect(needsMigration(nodes)).toBe(false);
    });

    it("should return true for duplicates without aliases", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI"),
        createMockNode("2", "OpenAI"),
      ];

      // Debug: Let's manually check what needsMigration should see
      const groups = new Map();
      for (const node of nodes) {
        if (node.type === "genericNode" && node.data?.node?.display_name) {
          const displayName = node.data.node.display_name;
          if (!groups.has(displayName)) {
            groups.set(displayName, []);
          }
          groups.get(displayName).push(node);
        }
      }

      // Should have 1 group with 2 nodes
      expect(groups.size).toBe(1);
      expect(groups.get("OpenAI")?.length).toBe(2);

      // Both nodes should have no alias
      const openAINodes = groups.get("OpenAI");
      expect(openAINodes?.[0].data.node.alias).toBeUndefined();
      expect(openAINodes?.[1].data.node.alias).toBeUndefined();

      // Now test the actual function
      expect(needsMigration(nodes)).toBe(true);
    });

    it("should return true for duplicate aliases", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"),
        createMockNode("2", "OpenAI", "OpenAI#1"), // Duplicate!
      ];

      expect(needsMigration(nodes)).toBe(true);
    });
  });

  describe("renumberAutoGeneratedAliases", () => {
    it("should renumber auto-generated aliases to fill gaps", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"),
        createMockNode("3", "OpenAI", "OpenAI#4"), // Gap between 1 and 4
      ];

      const result = renumberAutoGeneratedAliases(nodes, "OpenAI");

      const openAINodes = result.filter(
        (n) =>
          n.type === "genericNode" && n.data.node.display_name === "OpenAI",
      );
      expect(openAINodes[0].data.node.alias).toBe("OpenAI#1");
      expect(openAINodes[1].data.node.alias).toBe("OpenAI#2"); // Renumbered from #4 to #2
    });

    it("should preserve user-defined aliases during renumbering", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "MyCustomLLM"), // User-defined, should be preserved
        createMockNode("2", "OpenAI", "OpenAI#3"), // Auto-generated, will renumber
        createMockNode("3", "OpenAI", "OpenAI#5"), // Auto-generated, will renumber
      ];

      const result = renumberAutoGeneratedAliases(nodes, "OpenAI");

      // Find nodes by their original IDs to check transformation
      const node1 = result.find((n) => n.id === "1")!;
      const node2 = result.find((n) => n.id === "2")!;
      const node3 = result.find((n) => n.id === "3")!;

      expect(node1.data.node.alias).toBe("MyCustomLLM"); // Preserved
      expect(node2.data.node.alias).toBe("OpenAI#1"); // Renumbered
      expect(node3.data.node.alias).toBe("OpenAI#2"); // Renumbered
    });
  });

  describe("setUserDefinedAlias", () => {
    it("should set custom alias", () => {
      const node = createMockNode("1", "OpenAI", "OpenAI#1");
      const nodes: AllNodeType[] = [node];

      setUserDefinedAlias("1", "MyProductionLLM", nodes);

      expect(node.data.node.alias).toBe("MyProductionLLM");
    });

    it("should handle node not found gracefully", () => {
      const nodes: AllNodeType[] = [createMockNode("1", "OpenAI", "OpenAI#1")];

      // Should not throw error
      expect(() => {
        setUserDefinedAlias("nonexistent", "CustomAlias", nodes);
      }).not.toThrow();
    });
  });

  describe("clearUserDefinedAlias", () => {
    it("should revert user-defined alias to auto-generated", () => {
      const node = createMockNode("1", "OpenAI", "MyCustomLLM"); // User-defined
      const nodes: AllNodeType[] = [
        node,
        createMockNode("2", "OpenAI", "OpenAI#2"),
      ];

      clearUserDefinedAlias("1", nodes);

      expect(node.data.node.alias).toBe("OpenAI#1"); // Generated new auto-alias
    });

    it("should not clear already auto-generated aliases", () => {
      const node = createMockNode("1", "OpenAI", "OpenAI#1"); // Auto-generated
      const nodes: AllNodeType[] = [node];

      // Mock console.warn to capture warning
      const consoleSpy = jest.spyOn(console, "warn").mockImplementation();

      clearUserDefinedAlias("1", nodes);

      expect(consoleSpy).toHaveBeenCalledWith(
        "Cannot clear user-defined alias for node 1: already auto-generated or no alias",
      );
      expect(node.data.node.alias).toBe("OpenAI#1"); // Unchanged

      consoleSpy.mockRestore();
    });
  });

  describe("updateAliasesForDisplayNameChange", () => {
    it("should update numbered alias when display name changes", () => {
      const targetNode = createMockNode("1", "OpenAI", "OpenAI#1");
      const nodes: AllNodeType[] = [targetNode];

      const result = updateAliasesForDisplayNameChange(
        "1",
        "OpenAI",
        "ResponseGenerator",
        nodes,
      );

      const updatedNode = result.find((n) => n.id === "1")!;
      // Since it's a single component, the system removes the alias (no numbering needed)
      expect(updatedNode.data.node.alias).toBeUndefined();
    });

    it("should update non-numbered aliases when display name changes", () => {
      const targetNode = createMockNode("1", "OpenAI", "MyCustomLLM"); // Non-numbered
      const nodes: AllNodeType[] = [targetNode];

      const result = updateAliasesForDisplayNameChange(
        "1",
        "OpenAI",
        "ResponseGenerator",
        nodes,
      );

      const updatedNode = result.find((n) => n.id === "1")!;
      // Single component, alias should be removed since no numbering needed
      expect(updatedNode.data.node.alias).toBeUndefined();
    });
  });

  describe("convertTweaksToAliases", () => {
    it("should convert UUID-based tweaks to alias-based tweaks", () => {
      const nodes = [
        createMockNode("node-uuid-1", "OpenAI", "OpenAI#1"),
        createMockNode("node-uuid-2", "OpenAI", "MyCustomLLM"),
      ];

      const tweaks = {
        "node-uuid-1": { temperature: 0.7 },
        "node-uuid-2": { temperature: 0.3 },
      };

      const result = convertTweaksToAliases(tweaks, nodes);

      expect(result).toEqual({
        "OpenAI#1": { temperature: 0.7 },
        MyCustomLLM: { temperature: 0.3 },
      });
    });

    it("should fallback to node ID if node not found", () => {
      const nodes = [createMockNode("known-node", "OpenAI", "OpenAI#1")];

      const tweaks = {
        "known-node": { temperature: 0.7 },
        "unknown-node": { temperature: 0.3 },
      };

      const result = convertTweaksToAliases(tweaks, nodes);

      expect(result).toEqual({
        "OpenAI#1": { temperature: 0.7 },
        "unknown-node": { temperature: 0.3 }, // Fallback to original ID
      });
    });

    it("should handle empty tweaks gracefully", () => {
      const nodes = [createMockNode("1", "OpenAI", "OpenAI#1")];
      const tweaks = {};

      const result = convertTweaksToAliases(tweaks, nodes);

      expect(result).toEqual({});
    });
  });

  describe("Safety and Backward Compatibility", () => {
    it("should handle mixed alias scenarios", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"), // Auto-generated
        createMockNode("2", "OpenAI", "MyProductionLLM"), // User-defined
        createMockNode("3", "OpenAI"), // No alias
      ];

      const result = migrateExistingFlow(nodes);

      // Auto-generated preserved
      expect(result[0].data.node.alias).toBe("OpenAI#1");

      // User-defined preserved
      expect(result[1].data.node.alias).toBe("MyProductionLLM");

      // New alias assigned
      expect(result[2].data.node.alias).toBe("OpenAI#2");
    });

    it("should maintain alias uniqueness", () => {
      let nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI"),
        createMockNode("2", "OpenAI"),
        createMockNode("3", "Wikipedia"),
        createMockNode("4", "Wikipedia"),
      ];

      // Migrate
      nodes = migrateExistingFlow(nodes);

      // Add more components
      const newOpenAI = createMockNode("5", "OpenAI");
      const newWikipedia = createMockNode("6", "Wikipedia");

      assignAliasToNewComponent(newOpenAI, nodes);
      assignAliasToNewComponent(newWikipedia, nodes);

      nodes.push(newOpenAI, newWikipedia);

      // Collect all aliases
      const allAliases = nodes
        .filter((n) => n.type === "genericNode" && n.data.node.alias)
        .map((n) => n.data.node.alias);

      // All aliases should be unique
      expect(new Set(allAliases).size).toBe(allAliases.length);

      // Should have proper numbering
      const openAIAliases = allAliases.filter((alias) =>
        alias?.startsWith("OpenAI#"),
      );
      const wikipediaAliases = allAliases.filter((alias) =>
        alias?.startsWith("Wikipedia#"),
      );

      expect(openAIAliases.sort()).toEqual([
        "OpenAI#1",
        "OpenAI#2",
        "OpenAI#3",
      ]);
      expect(wikipediaAliases.sort()).toEqual([
        "Wikipedia#1",
        "Wikipedia#2",
        "Wikipedia#3",
      ]);
    });
  });
});
