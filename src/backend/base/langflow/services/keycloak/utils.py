"""Keycloak Authentication Utilities.

This module provides utility functions for Keycloak/OpenID Connect authentication integration
with Langflow. It handles token processing, user creation/update from Keycloak data.
"""

from __future__ import annotations

import secrets
from datetime import datetime, timezone
from typing import TYPE_CHECKING

from fastapi import HTTPException, Response, status
from loguru import logger

from langflow.api.v1.login import create_and_set_user_tokens
from langflow.services.auth.constants import COOKIE_KEYCLOAK_REFRESH_TOKEN
from langflow.services.auth.utils import get_password_hash
from langflow.services.database.models.user.crud import get_user_by_username, update_user
from langflow.services.database.models.user.model import User, UserUpdate

if TYPE_CHECKING:
    from sqlmodel.ext.asyncio.session import AsyncSession

    from langflow.services.keycloak.service import KeycloakService


async def process_keycloak_login(
    code: str,
    client_nonce: str,
    redirect_uri: str,
    response: Response,
    db: AsyncSession,
    keycloak_service: KeycloakService,
) -> dict:
    """Process Keycloak OAuth callback and create Langflow authentication tokens.

    This function handles the entire authentication flow after receiving the authorization code
    from Keycloak. It exchanges the code for tokens, extracts user information, creates or
    updates the user in the database, and generates Langflow-specific tokens.

    Args:
        code: Authorization code received from Keycloak callback
        client_nonce: Nonce generated by the client for security checks
        redirect_uri: URI to which Keycloak redirected after authentication
        response: FastAPI Response object for setting cookies
        db: Database session for accessing and modifying user data
        keycloak_service: Keycloak Authentication Service, injected by FastAPI

    Returns:
        dict: Token response containing access_token and token_type

    Raises:
        HTTPException: If token retrieval fails, user information is invalid, or user
                    creation is disabled but user does not exist
    """
    # Check if Keycloak is enabled (extra safety check)
    if not keycloak_service.is_enabled:
        logger.error("Cannot process Keycloak login: Keycloak is not enabled")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Keycloak is disabled",
        )

    settings_service = keycloak_service.settings_service
    auth_settings = settings_service.auth_settings

    # Get token from authorization code
    try:
        token_response = await keycloak_service.get_token(code, redirect_uri)
    except Exception as e:
        logger.error(f"Error getting token from Keycloak: {e!s}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"Failed to get token from Keycloak: {e!s}",
        ) from e

    if not token_response:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Failed to get token from Keycloak: Empty response",
        )

    # Decode token to get user info
    access_token = token_response.get("access_token")

    if not access_token:
        logger.error("No access token found in token response")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="No access token found in Keycloak response",
        )

    try:
        decoded_token = await keycloak_service.decode_token(access_token)
    except Exception as e:
        logger.error(f"Error decoding token: {e!s}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"Failed to decode token: {e!s}",
        ) from e

    # Validate nonce
    if not decoded_token.get("nonce") or decoded_token.get("nonce") != client_nonce:
        logger.error("Nonce mismatch: token nonce does not match client nonce")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Nonce mismatch",
        )

    # Retrieve or create user
    user = await get_or_create_user(db, decoded_token, keycloak_service)

    # Create Langflow JWT tokens
    tokens = await create_and_set_user_tokens(response, db, auth_settings, user)

    # Store Keycloak tokens for future use
    response.set_cookie(
        COOKIE_KEYCLOAK_REFRESH_TOKEN,
        token_response.get("refresh_token", ""),
        httponly=True,
        samesite=auth_settings.REFRESH_SAME_SITE,
        secure=auth_settings.REFRESH_SECURE,
        expires=auth_settings.REFRESH_TOKEN_EXPIRE_SECONDS,
        domain=auth_settings.COOKIE_DOMAIN,
    )

    return tokens


async def get_or_create_user(db: AsyncSession, decoded_token: dict, keycloak_service) -> User:
    """Retrieve or create a user from Keycloak authentication data.

    Args:
        db: Database session
        decoded_token: User token decoded
        keycloak_service: Keycloak Authentication Service

    Returns:
        User: The user either retrieved or created
    """
    # Extract user data from Keycloak token
    preferred_username = decoded_token.get("preferred_username")
    email = decoded_token.get("email")
    given_name = decoded_token.get("given_name")
    family_name = decoded_token.get("family_name")

    # Construct a username - prioritize preferred_username, then email, or generate one if neither exists
    username = preferred_username or email
    if not username:
        # If neither preferred_username nor email are available, construct from name or generate random
        if given_name and family_name:
            username = f"{given_name.lower()}.{family_name.lower()}"
        else:
            # Generate a random username as last resort
            import uuid

            username = f"user_{uuid.uuid4().hex[:8]}"

    # Get user roles from Keycloak
    roles = keycloak_service.extract_roles(decoded_token)
    # Check if user has the admin role using the property from keycloak_service
    is_admin = keycloak_service.admin_role in roles

    # Try to find existing user by username
    user = await get_user_by_username(db, username, include_deleted=True)

    if user:
        # If user exists but is deleted, stop the process
        if user.is_deleted:
            logger.info(f"Soft-deleted user: {username}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User was removed",
            )

        # Update existing user with latest information from Keycloak
        logger.info(f"Updating existing user: {username}")
        user_update = UserUpdate(
            is_keycloak_user=True,
            is_active=True,
            email=email,
            is_superuser=is_admin if is_admin is not None else user.is_superuser,
        )
        await update_user(user, user_update, db)
    else:
        # Create new user with information from Keycloak using the auto_create_users property
        logger.info(f"Creating new user from Keycloak: {username}")
        user = await create_keycloak_user(db, username, email, is_admin)

    return user


async def create_keycloak_user(
    db: AsyncSession, username: str, email: str | None = None, is_admin: bool = False
) -> User:
    """Create a new user in the database from Keycloak information.

    This function creates a new user based on Keycloak authentication data.
    Since the user will always authenticate via Keycloak, it generates a random
    password that will never be used for actual authentication.

    Args:
        db: Database session
        username: Username from Keycloak (or derived from email/name)
        email: User's email address from Keycloak (optional)
        is_admin: Whether the user should have admin privileges

    Returns:
        User: The newly created user

    Raises:
        Exception: If user creation fails even with minimal fields
    """
    # Generate a secure random password that won't be used (user will authenticate via Keycloak)
    # We still need a password field as it's required by the User model
    password = secrets.token_urlsafe(32)
    hashed_password = get_password_hash(password)

    # Get current UTC timestamp for created/updated fields
    now = datetime.now(timezone.utc)

    # Create the user with full Keycloak authentication information
    try:
        user = User(
            username=username,
            email=email,
            password=hashed_password,
            is_superuser=is_admin,
            is_active=True,
            is_keycloak_user=True,
            is_deleted=False,
            create_at=now,
            updated_at=now,
        )
    except Exception as e:
        logger.error(f"Failed to create user in database: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create user in database",
        ) from e

    # Add the user to the database
    return await create_new_user(db, user)


async def create_new_user(db: AsyncSession, user: User) -> User:
    """Create a new user in the database.

    A utility function to add a user object to the database and commit the changes.

    Args:
        db: Database session
        user: User object to create

    Returns:
        User: The created user with updated database fields
    """
    # Add user to the database session
    db.add(user)

    # Commit the changes to the database
    await db.commit()

    # Refresh the user object with values from the database (e.g., auto-generated ids)
    await db.refresh(user)

    return user
