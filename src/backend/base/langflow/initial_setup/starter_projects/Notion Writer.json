{
  "data": {
    "edges": [
      {
        "animated": false,
        "data": {
          "sourceHandle": {
            "dataType": "ChatInput",
            "id": "ChatInput-UH4Nn",
            "name": "message",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "Agent-ZUTcs",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-ChatInput-UH4Nn{œdataTypeœ:œChatInputœ,œidœ:œChatInput-UH4Nnœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}-Agent-ZUTcs{œfieldNameœ:œinput_valueœ,œidœ:œAgent-ZUTcsœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ChatInput-UH4Nn",
        "sourceHandle": "{œdataTypeœ: œChatInputœ, œidœ: œChatInput-UH4Nnœ, œnameœ: œmessageœ, œoutput_typesœ: [œMessageœ]}",
        "target": "Agent-ZUTcs",
        "targetHandle": "{œfieldNameœ: œinput_valueœ, œidœ: œAgent-ZUTcsœ, œinputTypesœ: [œMessageœ], œtypeœ: œstrœ}"
      },
      {
        "animated": false,
        "data": {
          "sourceHandle": {
            "dataType": "Agent",
            "id": "Agent-F6VMP",
            "name": "component_as_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-ZUTcs",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-Agent-F6VMP{œdataTypeœ:œAgentœ,œidœ:œAgent-F6VMPœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}-Agent-ZUTcs{œfieldNameœ:œtoolsœ,œidœ:œAgent-ZUTcsœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "Agent-F6VMP",
        "sourceHandle": "{œdataTypeœ: œAgentœ, œidœ: œAgent-F6VMPœ, œnameœ: œcomponent_as_toolœ, œoutput_typesœ: [œToolœ]}",
        "target": "Agent-ZUTcs",
        "targetHandle": "{œfieldNameœ: œtoolsœ, œidœ: œAgent-ZUTcsœ, œinputTypesœ: [œToolœ], œtypeœ: œotherœ}"
      },
      {
        "animated": false,
        "data": {
          "sourceHandle": {
            "dataType": "Agent",
            "id": "Agent-ZUTcs",
            "name": "response",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-3KyuV",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-Agent-ZUTcs{œdataTypeœ:œAgentœ,œidœ:œAgent-ZUTcsœ,œnameœ:œresponseœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-3KyuV{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-3KyuVœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "Agent-ZUTcs",
        "sourceHandle": "{œdataTypeœ: œAgentœ, œidœ: œAgent-ZUTcsœ, œnameœ: œresponseœ, œoutput_typesœ: [œMessageœ]}",
        "target": "ChatOutput-3KyuV",
        "targetHandle": "{œfieldNameœ: œinput_valueœ, œidœ: œChatOutput-3KyuVœ, œinputTypesœ: [œDataœ, œDataFrameœ, œMessageœ], œtypeœ: œotherœ}"
      },
      {
        "animated": false,
        "data": {
          "sourceHandle": {
            "dataType": "AddContentToPage",
            "id": "AddContentToPage-kR0Yb",
            "name": "component_as_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-ZUTcs",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-AddContentToPage-kR0Yb{œdataTypeœ:œAddContentToPageœ,œidœ:œAddContentToPage-kR0Ybœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}-Agent-ZUTcs{œfieldNameœ:œtoolsœ,œidœ:œAgent-ZUTcsœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "AddContentToPage-kR0Yb",
        "sourceHandle": "{œdataTypeœ: œAddContentToPageœ, œidœ: œAddContentToPage-kR0Ybœ, œnameœ: œcomponent_as_toolœ, œoutput_typesœ: [œToolœ]}",
        "target": "Agent-ZUTcs",
        "targetHandle": "{œfieldNameœ: œtoolsœ, œidœ: œAgent-ZUTcsœ, œinputTypesœ: [œToolœ], œtypeœ: œotherœ}"
      }
    ],
    "nodes": [
      {
        "data": {
          "id": "Agent-ZUTcs",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "agents",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Define the agent's instructions, then enter a task to complete using tools.",
            "display_name": "Orchestrator",
            "documentation": "",
            "edited": false,
            "field_order": [
              "agent_llm",
              "max_tokens",
              "model_kwargs",
              "json_mode",
              "model_name",
              "openai_api_base",
              "api_key",
              "temperature",
              "seed",
              "max_retries",
              "timeout",
              "system_prompt",
              "tools",
              "input_value",
              "handle_parsing_errors",
              "verbose",
              "max_iterations",
              "agent_description",
              "memory",
              "sender",
              "sender_name",
              "n_messages",
              "session_id",
              "order",
              "template",
              "add_current_date_tool"
            ],
            "frozen": false,
            "icon": "bot",
            "key": "Agent",
            "legacy": false,
            "lf_version": "1.2.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Response",
                "method": "message_response",
                "name": "response",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 1.1732828199964098e-19,
            "template": {
              "_type": "Component",
              "add_current_date_tool": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Current Date",
                "dynamic": false,
                "info": "If true, will add a tool to the agent that returns the current date.",
                "list": false,
                "list_add_label": "Add More",
                "name": "add_current_date_tool",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "agent_description": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "display_name": "Agent Description [Deprecated]",
                "dynamic": false,
                "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "agent_description",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "A helpful assistant with access to the following tools:"
              },
              "agent_llm": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Model Provider",
                "dynamic": false,
                "info": "The provider of the language model that the agent will use to generate responses.",
                "input_types": [],
                "name": "agent_llm",
                "options": [
                  "Amazon Bedrock",
                  "Anthropic",
                  "Azure OpenAI",
                  "Google Generative AI",
                  "Groq",
                  "NVIDIA",
                  "OpenAI",
                  "SambaNova",
                  "Custom"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "OpenAI"
              },
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "OpenAI API Key",
                "dynamic": false,
                "info": "The OpenAI API Key to use for the OpenAI model.",
                "input_types": [
                  "Message"
                ],
                "load_from_db": false,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langchain_core.tools import StructuredTool\n\nfrom langflow.base.agents.agent import LCToolsAgentComponent\nfrom langflow.base.agents.events import ExceptionWithMessageError\nfrom langflow.base.models.model_input_constants import (\n    ALL_PROVIDER_FIELDS,\n    MODEL_DYNAMIC_UPDATE_FIELDS,\n    MODEL_PROVIDERS_DICT,\n    MODELS_METADATA,\n)\nfrom langflow.base.models.model_utils import get_model_name\nfrom langflow.components.helpers import CurrentDateComponent\nfrom langflow.components.helpers.memory import MemoryComponent\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\nfrom langflow.custom.custom_component.component import _get_component_toolkit\nfrom langflow.custom.utils import update_component_build_config\nfrom langflow.field_typing import Tool\nfrom langflow.io import BoolInput, DropdownInput, MultilineInput, Output\nfrom langflow.logging import logger\nfrom langflow.schema.dotdict import dotdict\nfrom langflow.schema.message import Message\n\n\ndef set_advanced_true(component_input):\n    component_input.advanced = True\n    return component_input\n\n\nclass AgentComponent(ToolCallingAgentComponent):\n    display_name: str = \"Agent\"\n    description: str = \"Define the agent's instructions, then enter a task to complete using tools.\"\n    icon = \"bot\"\n    beta = False\n    name = \"Agent\"\n\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\n\n    inputs = [\n        DropdownInput(\n            name=\"agent_llm\",\n            display_name=\"Model Provider\",\n            info=\"The provider of the language model that the agent will use to generate responses.\",\n            options=[*sorted(MODEL_PROVIDERS_DICT.keys()), \"Custom\"],\n            value=\"OpenAI\",\n            real_time_refresh=True,\n            input_types=[],\n            options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())] + [{\"icon\": \"brain\"}],\n        ),\n        *MODEL_PROVIDERS_DICT[\"OpenAI\"][\"inputs\"],\n        MultilineInput(\n            name=\"system_prompt\",\n            display_name=\"Agent Instructions\",\n            info=\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\",\n            value=\"You are a helpful assistant that can use tools to answer questions and perform tasks.\",\n            advanced=False,\n        ),\n        *LCToolsAgentComponent._base_inputs,\n        *memory_inputs,\n        BoolInput(\n            name=\"add_current_date_tool\",\n            display_name=\"Current Date\",\n            advanced=True,\n            info=\"If true, will add a tool to the agent that returns the current date.\",\n            value=True,\n        ),\n    ]\n    outputs = [Output(name=\"response\", display_name=\"Response\", method=\"message_response\")]\n\n    async def message_response(self) -> Message:\n        try:\n            # Get LLM model and validate\n            llm_model, display_name = self.get_llm()\n            if llm_model is None:\n                msg = \"No language model selected. Please choose a model to proceed.\"\n                raise ValueError(msg)\n            self.model_name = get_model_name(llm_model, display_name=display_name)\n\n            # Get memory data\n            self.chat_history = await self.get_memory_data()\n\n            # Add current date tool if enabled\n            if self.add_current_date_tool:\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\n                    self.tools = []\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\n                if not isinstance(current_date_tool, StructuredTool):\n                    msg = \"CurrentDateComponent must be converted to a StructuredTool\"\n                    raise TypeError(msg)\n                self.tools.append(current_date_tool)\n\n            # Validate tools\n            if not self.tools:\n                msg = \"Tools are required to run the agent. Please add at least one tool.\"\n                raise ValueError(msg)\n\n            # Set up and run agent\n            self.set(\n                llm=llm_model,\n                tools=self.tools,\n                chat_history=self.chat_history,\n                input_value=self.input_value,\n                system_prompt=self.system_prompt,\n            )\n            agent = self.create_agent_runnable()\n            return await self.run_agent(agent)\n\n        except (ValueError, TypeError, KeyError) as e:\n            logger.error(f\"{type(e).__name__}: {e!s}\")\n            raise\n        except ExceptionWithMessageError as e:\n            logger.error(f\"ExceptionWithMessageError occurred: {e}\")\n            raise\n        except Exception as e:\n            logger.error(f\"Unexpected error: {e!s}\")\n            raise\n\n    async def get_memory_data(self):\n        memory_kwargs = {\n            component_input.name: getattr(self, f\"{component_input.name}\") for component_input in self.memory_inputs\n        }\n        # filter out empty values\n        memory_kwargs = {k: v for k, v in memory_kwargs.items() if v}\n\n        return await MemoryComponent(**self.get_base_args()).set(**memory_kwargs).retrieve_messages()\n\n    def get_llm(self):\n        if not isinstance(self.agent_llm, str):\n            return self.agent_llm, None\n\n        try:\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n            if not provider_info:\n                msg = f\"Invalid model provider: {self.agent_llm}\"\n                raise ValueError(msg)\n\n            component_class = provider_info.get(\"component_class\")\n            display_name = component_class.display_name\n            inputs = provider_info.get(\"inputs\")\n            prefix = provider_info.get(\"prefix\", \"\")\n\n            return self._build_llm_model(component_class, inputs, prefix), display_name\n\n        except Exception as e:\n            logger.error(f\"Error building {self.agent_llm} language model: {e!s}\")\n            msg = f\"Failed to initialize language model: {e!s}\"\n            raise ValueError(msg) from e\n\n    def _build_llm_model(self, component, inputs, prefix=\"\"):\n        model_kwargs = {input_.name: getattr(self, f\"{prefix}{input_.name}\") for input_ in inputs}\n        return component.set(**model_kwargs).build_model()\n\n    def set_component_params(self, component):\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n        if provider_info:\n            inputs = provider_info.get(\"inputs\")\n            prefix = provider_info.get(\"prefix\")\n            model_kwargs = {input_.name: getattr(self, f\"{prefix}{input_.name}\") for input_ in inputs}\n\n            return component.set(**model_kwargs)\n        return component\n\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\n        \"\"\"Delete specified fields from build_config.\"\"\"\n        for field in fields:\n            build_config.pop(field, None)\n\n    def update_input_types(self, build_config: dotdict) -> dotdict:\n        \"\"\"Update input types for all fields in build_config.\"\"\"\n        for key, value in build_config.items():\n            if isinstance(value, dict):\n                if value.get(\"input_types\") is None:\n                    build_config[key][\"input_types\"] = []\n            elif hasattr(value, \"input_types\") and value.input_types is None:\n                value.input_types = []\n        return build_config\n\n    async def update_build_config(\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\n    ) -> dotdict:\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\n        # Existing logic for updating build_config\n        if field_name in (\"agent_llm\",):\n            build_config[\"agent_llm\"][\"value\"] = field_value\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\n            if provider_info:\n                component_class = provider_info.get(\"component_class\")\n                if component_class and hasattr(component_class, \"update_build_config\"):\n                    # Call the component class's update_build_config method\n                    build_config = await update_component_build_config(\n                        component_class, build_config, field_value, \"model_name\"\n                    )\n\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\n                provider: (\n                    MODEL_PROVIDERS_DICT[provider][\"fields\"],\n                    [\n                        MODEL_PROVIDERS_DICT[other_provider][\"fields\"]\n                        for other_provider in MODEL_PROVIDERS_DICT\n                        if other_provider != provider\n                    ],\n                )\n                for provider in MODEL_PROVIDERS_DICT\n            }\n            if field_value in provider_configs:\n                fields_to_add, fields_to_delete = provider_configs[field_value]\n\n                # Delete fields from other providers\n                for fields in fields_to_delete:\n                    self.delete_fields(build_config, fields)\n\n                # Add provider-specific fields\n                if field_value == \"OpenAI\" and not any(field in build_config for field in fields_to_add):\n                    build_config.update(fields_to_add)\n                else:\n                    build_config.update(fields_to_add)\n                # Reset input types for agent_llm\n                build_config[\"agent_llm\"][\"input_types\"] = []\n            elif field_value == \"Custom\":\n                # Delete all provider fields\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\n                # Update with custom component\n                custom_component = DropdownInput(\n                    name=\"agent_llm\",\n                    display_name=\"Language Model\",\n                    options=[*sorted(MODEL_PROVIDERS_DICT.keys()), \"Custom\"],\n                    value=\"Custom\",\n                    real_time_refresh=True,\n                    input_types=[\"LanguageModel\"],\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\n                    + [{\"icon\": \"brain\"}],\n                )\n                build_config.update({\"agent_llm\": custom_component.to_dict()})\n            # Update input types for all fields\n            build_config = self.update_input_types(build_config)\n\n            # Validate required keys\n            default_keys = [\n                \"code\",\n                \"_type\",\n                \"agent_llm\",\n                \"tools\",\n                \"input_value\",\n                \"add_current_date_tool\",\n                \"system_prompt\",\n                \"agent_description\",\n                \"max_iterations\",\n                \"handle_parsing_errors\",\n                \"verbose\",\n            ]\n            missing_keys = [key for key in default_keys if key not in build_config]\n            if missing_keys:\n                msg = f\"Missing required keys in build_config: {missing_keys}\"\n                raise ValueError(msg)\n        if (\n            isinstance(self.agent_llm, str)\n            and self.agent_llm in MODEL_PROVIDERS_DICT\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\n        ):\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n            if provider_info:\n                component_class = provider_info.get(\"component_class\")\n                component_class = self.set_component_params(component_class)\n                prefix = provider_info.get(\"prefix\")\n                if component_class and hasattr(component_class, \"update_build_config\"):\n                    # Call each component class's update_build_config method\n                    # remove the prefix from the field_name\n                    if isinstance(field_name, str) and isinstance(prefix, str):\n                        field_name = field_name.replace(prefix, \"\")\n                    build_config = await update_component_build_config(\n                        component_class, build_config, field_value, \"model_name\"\n                    )\n        return dotdict({k: v.to_dict() if hasattr(v, \"to_dict\") else v for k, v in build_config.items()})\n\n    async def to_toolkit(self) -> list[Tool]:\n        component_toolkit = _get_component_toolkit()\n        tools_names = self._build_tools_names()\n        agent_description = self.get_tool_description()\n        # TODO: Agent Description Depreciated Feature to be removed\n        description = f\"{agent_description}{tools_names}\"\n        tools = component_toolkit(component=self).get_tools(\n            tool_name=self.get_tool_name(), tool_description=description, callbacks=self.get_langchain_callbacks()\n        )\n        if hasattr(self, \"tools_metadata\"):\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\n        return tools\n"
              },
              "handle_parsing_errors": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Handle Parse Errors",
                "dynamic": false,
                "info": "Should the Agent fix errors when reading user input for better processing?",
                "list": false,
                "list_add_label": "Add More",
                "name": "handle_parsing_errors",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "input_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "The input provided by the user for the agent to process.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "json_mode": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "JSON Mode",
                "dynamic": false,
                "info": "If True, it will output JSON regardless of passing a schema.",
                "list": false,
                "list_add_label": "Add More",
                "name": "json_mode",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "max_iterations": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Iterations",
                "dynamic": false,
                "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_iterations",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 15
              },
              "max_retries": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Retries",
                "dynamic": false,
                "info": "The maximum number of retries to make when generating.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_retries",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 5
              },
              "max_tokens": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Tokens",
                "dynamic": false,
                "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_tokens",
                "placeholder": "",
                "range_spec": {
                  "max": 128000,
                  "min": 0,
                  "step": 0.1,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "memory": {
                "_input_type": "HandleInput",
                "advanced": true,
                "display_name": "External Memory",
                "dynamic": false,
                "info": "Retrieve messages from an external memory. If empty, it will use the Langflow tables.",
                "input_types": [
                  "Memory"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "memory",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "model_kwargs": {
                "_input_type": "DictInput",
                "advanced": true,
                "display_name": "Model Kwargs",
                "dynamic": false,
                "info": "Additional keyword arguments to pass to the model.",
                "list": false,
                "list_add_label": "Add More",
                "name": "model_kwargs",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "dict",
                "value": {}
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Model Name",
                "dynamic": false,
                "info": "To see the model names, first choose a provider. Then, enter your API key and click the refresh button next to the model name.",
                "name": "model_name",
                "options": [
                  "gpt-4o-mini",
                  "gpt-4o",
                  "gpt-4.5-preview",
                  "gpt-4-turbo",
                  "gpt-4-turbo-preview",
                  "gpt-4",
                  "gpt-3.5-turbo"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": false,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "gpt-4o-mini"
              },
              "n_messages": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Messages",
                "dynamic": false,
                "info": "Number of messages to retrieve.",
                "list": false,
                "list_add_label": "Add More",
                "name": "n_messages",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 100
              },
              "openai_api_base": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "OpenAI API Base",
                "dynamic": false,
                "info": "The base URL of the OpenAI API. Defaults to https://api.openai.com/v1. You can change this to use other APIs like JinaChat, LocalAI and Prem.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "openai_api_base",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "order": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Order",
                "dynamic": false,
                "info": "Order of the messages.",
                "name": "order",
                "options": [
                  "Ascending",
                  "Descending"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Ascending"
              },
              "seed": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Seed",
                "dynamic": false,
                "info": "The seed controls the reproducibility of the job.",
                "list": false,
                "list_add_label": "Add More",
                "name": "seed",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Filter by sender type.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User",
                  "Machine and User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine and User"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Filter by sender name.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "system_prompt": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "display_name": "Agent Instructions",
                "dynamic": false,
                "info": "System Prompt: Initial instructions and context provided to guide the agent's behavior.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_prompt",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "# Notion Markdown Orchestrator\n\nYou are an orchestrator agent that coordinates the creation of well-formatted Markdown content for Notion pages. You work with a specialized Planning agent to generate content and then add it to Notion using the AddContentToPage-add_content_to_page tool.\n\n## Your Workflow\n\n1. Receive a content request from the user\n2. Pass this request to the Planning agent to receive a structured outline\n3. Fill in the content for each section of the outline, replacing all [CONTENT: description] placeholders with high-quality content\n4. Call the AddContentToPage-add_content_to_page tool to add the completed markdown to Notion\n\n## Working with the Planning Agent\n\n- The Planning agent will provide a structured markdown outline\n- The outline will contain [CONTENT: description] placeholders\n- Your job is to replace these placeholders with appropriate, detailed content\n- Maintain the structure and headings exactly as provided by the Planning agent\n\n## Content Creation Guidelines\n\nWhen filling in content:\n\n1. Create comprehensive, informative content for each section\n2. Maintain a consistent tone and style throughout the document\n3. Include relevant examples, explanations, and details\n4. Fill in any table data that was outlined in the structure\n5. Ensure all content is factually accurate and helpful\n6. Keep content concise but thorough\n\n## Using the Notion Tool\n\nAfter completing the content, use the tool as follows:\n\n1. Call the \"AddContentToPage-add_content_to_page\" tool \n2. Pass your completed markdown as the \"markdown_text\" parameter\n\n## Example Workflow\n\n1. User requests: \"Create a guide to cryptocurrency investing\"\n\n2. You send this request to the Planning agent and receive a structure like:\n   ```markdown\n   # Cryptocurrency Investing Guide\n   \n   ## Introduction\n   [CONTENT: Brief overview of cryptocurrency and investing basics]\n   \n   ## Types of Cryptocurrencies\n   [CONTENT: List of major cryptocurrencies and their characteristics]\n   ```\n\n3. You fill in the content:\n   ```markdown\n   # Cryptocurrency Investing Guide\n   \n   ## Introduction\n   Cryptocurrency investing involves allocating capital to digital assets that use cryptography for security. Unlike traditional investments, cryptocurrencies operate on decentralized networks based on blockchain technology. This guide will help you understand the fundamentals of cryptocurrency investing and provide strategies for getting started in this volatile but potentially rewarding market.\n   \n   ## Types of Cryptocurrencies\n   The cryptocurrency market includes thousands of digital assets, each with different purposes and technologies:\n   \n   - **Bitcoin (BTC)**: The first and most valuable cryptocurrency, often viewed as digital gold and a store of value\n   - **Ethereum (ETH)**: A platform for decentralized applications and smart contracts, enabling programmable money\n   - **Binance Coin (BNB)**: The native token of the Binance exchange ecosystem, used for trading fee discounts and more\n   - **Solana (SOL)**: Known for high transaction speeds and low costs, popular for DeFi and NFT applications\n   - **Cardano (ADA)**: Focuses on sustainability, scalability, and transparency with a research-driven approach\n   ```\n\n4. You call the AddContentToPage-add_content_to_page tool with the completed markdown\n\n5. You confirm to the user that the content has been added to their Notion page\n\nRemember, your value comes from transforming structured outlines into detailed, helpful content and then seamlessly adding it to Notion."
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": true,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "",
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 1,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.1
              },
              "template": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "display_name": "Template",
                "dynamic": false,
                "info": "The template to use for formatting the data. It can contain the keys {text}, {sender} or any other key in the message data.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{sender_name}: {text}"
              },
              "timeout": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Timeout",
                "dynamic": false,
                "info": "The timeout for requests to OpenAI completion API.",
                "list": false,
                "list_add_label": "Add More",
                "name": "timeout",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 700
              },
              "tools": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Tools",
                "dynamic": false,
                "info": "These are the tools that the agent can use to help with tasks.",
                "input_types": [
                  "Tool"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "tools",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "verbose": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Verbose",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "verbose",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Agent"
        },
        "id": "Agent-ZUTcs",
        "measured": {
          "height": 618,
          "width": 320
        },
        "position": {
          "x": 2622.9307418094477,
          "y": 740.2122748339816
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatInput-UH4Nn",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "inputs",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Get chat inputs from the Playground.",
            "display_name": "Chat Input",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "files",
              "background_color",
              "chat_icon",
              "text_color"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "key": "ChatInput",
            "legacy": false,
            "lf_version": "1.2.0",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.0020353564437605998,
            "template": {
              "_type": "Component",
              "background_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Background Color",
                "dynamic": false,
                "info": "The background color of the icon.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "background_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "chat_icon": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Icon",
                "dynamic": false,
                "info": "The icon of the message.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_icon",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import (\n    DropdownInput,\n    FileInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n)\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_USER,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatInput(ChatComponent):\n    display_name = \"Chat Input\"\n    description = \"Get chat inputs from the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatInput\"\n    minimized = True\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            value=\"\",\n            info=\"Message to be passed as input.\",\n            input_types=[],\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_USER,\n            info=\"Type of sender.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_USER,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"Files\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"Files to be sent with the message.\",\n            advanced=True,\n            is_list=True,\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    async def message_response(self) -> Message:\n        background_color = self.background_color\n        text_color = self.text_color\n        icon = self.chat_icon\n\n        message = await Message.create(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n            files=self.files,\n            properties={\n                \"background_color\": background_color,\n                \"text_color\": text_color,\n                \"icon\": icon,\n            },\n        )\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n"
              },
              "files": {
                "_input_type": "FileInput",
                "advanced": true,
                "display_name": "Files",
                "dynamic": false,
                "fileTypes": [
                  "txt",
                  "md",
                  "mdx",
                  "csv",
                  "json",
                  "yaml",
                  "yml",
                  "xml",
                  "html",
                  "htm",
                  "pdf",
                  "docx",
                  "py",
                  "sh",
                  "sql",
                  "js",
                  "ts",
                  "tsx",
                  "jpg",
                  "jpeg",
                  "png",
                  "bmp",
                  "image"
                ],
                "file_path": "",
                "info": "Files to be sent with the message.",
                "list": true,
                "list_add_label": "Add More",
                "name": "files",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "file",
                "value": ""
              },
              "input_value": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "display_name": "Text",
                "dynamic": false,
                "info": "Message to be passed as input.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Create a guide about time management techniques"
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "text_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Color",
                "dynamic": false,
                "info": "The text color of the name",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ChatInput"
        },
        "id": "ChatInput-UH4Nn",
        "measured": {
          "height": 227,
          "width": 320
        },
        "position": {
          "x": 1657.7548155939426,
          "y": 1253.7759019656758
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Agent-F6VMP",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "agents",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Define the agent's instructions, then enter a task to complete using tools.",
            "display_name": "Markdown Planner",
            "documentation": "",
            "edited": false,
            "field_order": [
              "agent_llm",
              "max_tokens",
              "model_kwargs",
              "json_mode",
              "model_name",
              "openai_api_base",
              "api_key",
              "temperature",
              "seed",
              "max_retries",
              "timeout",
              "system_prompt",
              "tools",
              "input_value",
              "handle_parsing_errors",
              "verbose",
              "max_iterations",
              "agent_description",
              "memory",
              "sender",
              "sender_name",
              "n_messages",
              "session_id",
              "order",
              "template",
              "add_current_date_tool"
            ],
            "frozen": false,
            "icon": "bot",
            "key": "Agent",
            "legacy": false,
            "lf_version": "1.2.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Toolset",
                "hidden": null,
                "method": "to_toolkit",
                "name": "component_as_tool",
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 1.1732828199964098e-19,
            "template": {
              "_type": "Component",
              "add_current_date_tool": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Current Date",
                "dynamic": false,
                "info": "If true, will add a tool to the agent that returns the current date.",
                "list": false,
                "list_add_label": "Add More",
                "name": "add_current_date_tool",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "agent_description": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "display_name": "Agent Description [Deprecated]",
                "dynamic": false,
                "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "agent_description",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "A helpful assistant with access to the following tools:"
              },
              "agent_llm": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Model Provider",
                "dynamic": false,
                "info": "The provider of the language model that the agent will use to generate responses.",
                "input_types": [],
                "name": "agent_llm",
                "options": [
                  "Amazon Bedrock",
                  "Anthropic",
                  "Azure OpenAI",
                  "Google Generative AI",
                  "Groq",
                  "NVIDIA",
                  "OpenAI",
                  "SambaNova",
                  "Custom"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "OpenAI"
              },
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "OpenAI API Key",
                "dynamic": false,
                "info": "The OpenAI API Key to use for the OpenAI model.",
                "input_types": [
                  "Message"
                ],
                "load_from_db": false,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langchain_core.tools import StructuredTool\n\nfrom langflow.base.agents.agent import LCToolsAgentComponent\nfrom langflow.base.agents.events import ExceptionWithMessageError\nfrom langflow.base.models.model_input_constants import (\n    ALL_PROVIDER_FIELDS,\n    MODEL_DYNAMIC_UPDATE_FIELDS,\n    MODEL_PROVIDERS_DICT,\n)\nfrom langflow.base.models.model_utils import get_model_name\nfrom langflow.components.helpers import CurrentDateComponent\nfrom langflow.components.helpers.memory import MemoryComponent\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\nfrom langflow.custom.custom_component.component import _get_component_toolkit\nfrom langflow.custom.utils import update_component_build_config\nfrom langflow.field_typing import Tool\nfrom langflow.io import BoolInput, DropdownInput, MultilineInput, Output\nfrom langflow.logging import logger\nfrom langflow.schema.dotdict import dotdict\nfrom langflow.schema.message import Message\n\n\ndef set_advanced_true(component_input):\n    component_input.advanced = True\n    return component_input\n\n\nclass AgentComponent(ToolCallingAgentComponent):\n    display_name: str = \"Agent\"\n    description: str = \"Define the agent's instructions, then enter a task to complete using tools.\"\n    icon = \"bot\"\n    beta = False\n    name = \"Agent\"\n\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\n\n    inputs = [\n        DropdownInput(\n            name=\"agent_llm\",\n            display_name=\"Model Provider\",\n            info=\"The provider of the language model that the agent will use to generate responses.\",\n            options=[*sorted(MODEL_PROVIDERS_DICT.keys()), \"Custom\"],\n            value=\"OpenAI\",\n            real_time_refresh=True,\n            input_types=[],\n        ),\n        *MODEL_PROVIDERS_DICT[\"OpenAI\"][\"inputs\"],\n        MultilineInput(\n            name=\"system_prompt\",\n            display_name=\"Agent Instructions\",\n            info=\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\",\n            value=\"You are a helpful assistant that can use tools to answer questions and perform tasks.\",\n            advanced=False,\n        ),\n        *LCToolsAgentComponent._base_inputs,\n        *memory_inputs,\n        BoolInput(\n            name=\"add_current_date_tool\",\n            display_name=\"Current Date\",\n            advanced=True,\n            info=\"If true, will add a tool to the agent that returns the current date.\",\n            value=True,\n        ),\n    ]\n    outputs = [Output(name=\"response\", display_name=\"Response\", method=\"message_response\")]\n\n    async def message_response(self) -> Message:\n        try:\n            # Get LLM model and validate\n            llm_model, display_name = self.get_llm()\n            if llm_model is None:\n                msg = \"No language model selected. Please choose a model to proceed.\"\n                raise ValueError(msg)\n            self.model_name = get_model_name(llm_model, display_name=display_name)\n\n            # Get memory data\n            self.chat_history = await self.get_memory_data()\n\n            # Add current date tool if enabled\n            if self.add_current_date_tool:\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\n                    self.tools = []\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\n                if not isinstance(current_date_tool, StructuredTool):\n                    msg = \"CurrentDateComponent must be converted to a StructuredTool\"\n                    raise TypeError(msg)\n                self.tools.append(current_date_tool)\n\n            # Validate tools\n            if not self.tools:\n                msg = \"Tools are required to run the agent. Please add at least one tool.\"\n                raise ValueError(msg)\n\n            # Set up and run agent\n            self.set(\n                llm=llm_model,\n                tools=self.tools,\n                chat_history=self.chat_history,\n                input_value=self.input_value,\n                system_prompt=self.system_prompt,\n            )\n            agent = self.create_agent_runnable()\n            return await self.run_agent(agent)\n\n        except (ValueError, TypeError, KeyError) as e:\n            logger.error(f\"{type(e).__name__}: {e!s}\")\n            raise\n        except ExceptionWithMessageError as e:\n            logger.error(f\"ExceptionWithMessageError occurred: {e}\")\n            raise\n        except Exception as e:\n            logger.error(f\"Unexpected error: {e!s}\")\n            raise\n\n    async def get_memory_data(self):\n        memory_kwargs = {\n            component_input.name: getattr(self, f\"{component_input.name}\") for component_input in self.memory_inputs\n        }\n        # filter out empty values\n        memory_kwargs = {k: v for k, v in memory_kwargs.items() if v}\n\n        return await MemoryComponent(**self.get_base_args()).set(**memory_kwargs).retrieve_messages()\n\n    def get_llm(self):\n        if not isinstance(self.agent_llm, str):\n            return self.agent_llm, None\n\n        try:\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n            if not provider_info:\n                msg = f\"Invalid model provider: {self.agent_llm}\"\n                raise ValueError(msg)\n\n            component_class = provider_info.get(\"component_class\")\n            display_name = component_class.display_name\n            inputs = provider_info.get(\"inputs\")\n            prefix = provider_info.get(\"prefix\", \"\")\n\n            return self._build_llm_model(component_class, inputs, prefix), display_name\n\n        except Exception as e:\n            logger.error(f\"Error building {self.agent_llm} language model: {e!s}\")\n            msg = f\"Failed to initialize language model: {e!s}\"\n            raise ValueError(msg) from e\n\n    def _build_llm_model(self, component, inputs, prefix=\"\"):\n        model_kwargs = {input_.name: getattr(self, f\"{prefix}{input_.name}\") for input_ in inputs}\n        return component.set(**model_kwargs).build_model()\n\n    def set_component_params(self, component):\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n        if provider_info:\n            inputs = provider_info.get(\"inputs\")\n            prefix = provider_info.get(\"prefix\")\n            model_kwargs = {input_.name: getattr(self, f\"{prefix}{input_.name}\") for input_ in inputs}\n\n            return component.set(**model_kwargs)\n        return component\n\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\n        \"\"\"Delete specified fields from build_config.\"\"\"\n        for field in fields:\n            build_config.pop(field, None)\n\n    def update_input_types(self, build_config: dotdict) -> dotdict:\n        \"\"\"Update input types for all fields in build_config.\"\"\"\n        for key, value in build_config.items():\n            if isinstance(value, dict):\n                if value.get(\"input_types\") is None:\n                    build_config[key][\"input_types\"] = []\n            elif hasattr(value, \"input_types\") and value.input_types is None:\n                value.input_types = []\n        return build_config\n\n    async def update_build_config(\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\n    ) -> dotdict:\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\n        # Existing logic for updating build_config\n        if field_name in (\"agent_llm\",):\n            build_config[\"agent_llm\"][\"value\"] = field_value\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\n            if provider_info:\n                component_class = provider_info.get(\"component_class\")\n                if component_class and hasattr(component_class, \"update_build_config\"):\n                    # Call the component class's update_build_config method\n                    build_config = await update_component_build_config(\n                        component_class, build_config, field_value, \"model_name\"\n                    )\n\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\n                provider: (\n                    MODEL_PROVIDERS_DICT[provider][\"fields\"],\n                    [\n                        MODEL_PROVIDERS_DICT[other_provider][\"fields\"]\n                        for other_provider in MODEL_PROVIDERS_DICT\n                        if other_provider != provider\n                    ],\n                )\n                for provider in MODEL_PROVIDERS_DICT\n            }\n            if field_value in provider_configs:\n                fields_to_add, fields_to_delete = provider_configs[field_value]\n\n                # Delete fields from other providers\n                for fields in fields_to_delete:\n                    self.delete_fields(build_config, fields)\n\n                # Add provider-specific fields\n                if field_value == \"OpenAI\" and not any(field in build_config for field in fields_to_add):\n                    build_config.update(fields_to_add)\n                else:\n                    build_config.update(fields_to_add)\n                # Reset input types for agent_llm\n                build_config[\"agent_llm\"][\"input_types\"] = []\n            elif field_value == \"Custom\":\n                # Delete all provider fields\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\n                # Update with custom component\n                custom_component = DropdownInput(\n                    name=\"agent_llm\",\n                    display_name=\"Language Model\",\n                    options=[*sorted(MODEL_PROVIDERS_DICT.keys()), \"Custom\"],\n                    value=\"Custom\",\n                    real_time_refresh=True,\n                    input_types=[\"LanguageModel\"],\n                )\n                build_config.update({\"agent_llm\": custom_component.to_dict()})\n            # Update input types for all fields\n            build_config = self.update_input_types(build_config)\n\n            # Validate required keys\n            default_keys = [\n                \"code\",\n                \"_type\",\n                \"agent_llm\",\n                \"tools\",\n                \"input_value\",\n                \"add_current_date_tool\",\n                \"system_prompt\",\n                \"agent_description\",\n                \"max_iterations\",\n                \"handle_parsing_errors\",\n                \"verbose\",\n            ]\n            missing_keys = [key for key in default_keys if key not in build_config]\n            if missing_keys:\n                msg = f\"Missing required keys in build_config: {missing_keys}\"\n                raise ValueError(msg)\n        if (\n            isinstance(self.agent_llm, str)\n            and self.agent_llm in MODEL_PROVIDERS_DICT\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\n        ):\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n            if provider_info:\n                component_class = provider_info.get(\"component_class\")\n                component_class = self.set_component_params(component_class)\n                prefix = provider_info.get(\"prefix\")\n                if component_class and hasattr(component_class, \"update_build_config\"):\n                    # Call each component class's update_build_config method\n                    # remove the prefix from the field_name\n                    if isinstance(field_name, str) and isinstance(prefix, str):\n                        field_name = field_name.replace(prefix, \"\")\n                    build_config = await update_component_build_config(\n                        component_class, build_config, field_value, \"model_name\"\n                    )\n        return dotdict({k: v.to_dict() if hasattr(v, \"to_dict\") else v for k, v in build_config.items()})\n\n    async def to_toolkit(self) -> list[Tool]:\n        component_toolkit = _get_component_toolkit()\n        tools_names = self._build_tools_names()\n        agent_description = self.get_tool_description()\n        # TODO: Agent Description Depreciated Feature to be removed\n        description = f\"{agent_description}{tools_names}\"\n        tools = component_toolkit(component=self).get_tools(\n            tool_name=self.get_tool_name(), tool_description=description, callbacks=self.get_langchain_callbacks()\n        )\n        if hasattr(self, \"tools_metadata\"):\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\n        return tools\n"
              },
              "handle_parsing_errors": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Handle Parse Errors",
                "dynamic": false,
                "info": "Should the Agent fix errors when reading user input for better processing?",
                "list": false,
                "list_add_label": "Add More",
                "name": "handle_parsing_errors",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "input_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "The input provided by the user for the agent to process.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "json_mode": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "JSON Mode",
                "dynamic": false,
                "info": "If True, it will output JSON regardless of passing a schema.",
                "list": false,
                "list_add_label": "Add More",
                "name": "json_mode",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "max_iterations": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Iterations",
                "dynamic": false,
                "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_iterations",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 15
              },
              "max_retries": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Retries",
                "dynamic": false,
                "info": "The maximum number of retries to make when generating.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_retries",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 5
              },
              "max_tokens": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Tokens",
                "dynamic": false,
                "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_tokens",
                "placeholder": "",
                "range_spec": {
                  "max": 128000,
                  "min": 0,
                  "step": 0.1,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "memory": {
                "_input_type": "HandleInput",
                "advanced": true,
                "display_name": "External Memory",
                "dynamic": false,
                "info": "Retrieve messages from an external memory. If empty, it will use the Langflow tables.",
                "input_types": [
                  "Memory"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "memory",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "model_kwargs": {
                "_input_type": "DictInput",
                "advanced": true,
                "display_name": "Model Kwargs",
                "dynamic": false,
                "info": "Additional keyword arguments to pass to the model.",
                "list": false,
                "list_add_label": "Add More",
                "name": "model_kwargs",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "dict",
                "value": {}
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Model Name",
                "dynamic": false,
                "info": "To see the model names, first choose a provider. Then, enter your API key and click the refresh button next to the model name.",
                "name": "model_name",
                "options": [
                  "gpt-4o-mini",
                  "gpt-4o",
                  "gpt-4-turbo",
                  "gpt-4-turbo-preview",
                  "gpt-4",
                  "gpt-3.5-turbo",
                  "gpt-3.5-turbo-0125"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": false,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "gpt-4o-mini"
              },
              "n_messages": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Messages",
                "dynamic": false,
                "info": "Number of messages to retrieve.",
                "list": false,
                "list_add_label": "Add More",
                "name": "n_messages",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 100
              },
              "openai_api_base": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "OpenAI API Base",
                "dynamic": false,
                "info": "The base URL of the OpenAI API. Defaults to https://api.openai.com/v1. You can change this to use other APIs like JinaChat, LocalAI and Prem.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "openai_api_base",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "order": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Order",
                "dynamic": false,
                "info": "Order of the messages.",
                "name": "order",
                "options": [
                  "Ascending",
                  "Descending"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Ascending"
              },
              "seed": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Seed",
                "dynamic": false,
                "info": "The seed controls the reproducibility of the job.",
                "list": false,
                "list_add_label": "Add More",
                "name": "seed",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Filter by sender type.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User",
                  "Machine and User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine and User"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Filter by sender name.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "system_prompt": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "display_name": "Agent Instructions",
                "dynamic": false,
                "info": "System Prompt: Initial instructions and context provided to guide the agent's behavior.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_prompt",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "You are a specialized agent that creates structured outlines for Notion pages. Your role is to generate a skeleton/framework for content that will later be filled in by another agent.\n\n## Your Task\n\nWhen a user provides a topic or request, your job is to:\n\n1. Analyze the topic to determine the most logical structure\n2. Create a markdown outline with appropriate headings and placeholder sections\n3. Include guidance notes for what content should go in each section\n4. Return only the structured markdown outline without generating the actual content\n\n## Guidelines for Creating Structure\n\nCreate well-organized structures following these principles:\n\n### 1. Hierarchical Organization\n- Use heading levels appropriately (# for main title, ## for major sections, ### for subsections)\n- Organize content in a logical flow from general to specific\n\n### 2. Content Placeholders\n- Use `[CONTENT: description]` tags to indicate where specific content should be added\n- Be specific about what type of content belongs in each section\n\n### 3. Common Section Types\n- Introduction/Overview sections\n- Main content sections with logical grouping\n- Comparison tables where appropriate\n- Conclusion/Summary sections\n- Action items or next steps where relevant\n\n### 4. Structure Examples for Different Content Types\n\n**For a how-to guide:**\n```markdown\n# How to [Topic]\n\n## Overview\n[CONTENT: Brief introduction explaining what this guide covers and why it's important]\n\n## Prerequisites\n[CONTENT: List of requirements or knowledge needed before starting]\n\n## Step 1: [First Step]\n[CONTENT: Detailed explanation of the first step]\n\n## Step 2: [Second Step]\n[CONTENT: Detailed explanation of the second step]\n\n## Common Issues and Solutions\n[CONTENT: Table of common problems and their solutions]\n\n## Summary\n[CONTENT: Recap of what was learned]\n```\n\n**For a concept explanation:**\n```markdown\n# Understanding [Concept]\n\n## Definition\n[CONTENT: Clear definition of the concept]\n\n## Key Components\n[CONTENT: List of the main elements that make up this concept]\n\n## Practical Applications\n[CONTENT: Examples of how this concept is applied in real scenarios]\n\n## Related Concepts\n[CONTENT: Brief mentions of connected ideas with explanations of relationships]\n```\n\n## Example Response\n\nIf a user asks for \"a guide to personal finance management\":\n\n```markdown\n# Personal Finance Management Guide\n\n## Introduction\n[CONTENT: Brief overview of what personal finance management means and why it's important]\n\n## Assessing Your Current Financial Situation\n[CONTENT: Steps for evaluating current financial status, including income, expenses, assets, and debts]\n\n## Setting Financial Goals\n[CONTENT: Framework for establishing SMART financial goals with examples]\n\n## Creating a Budget\n[CONTENT: Detailed explanation of budgeting methods and tools]\n\n## Debt Management Strategies\n[CONTENT: Approaches to reducing and managing different types of debt]\n\n## Saving and Investing\n[CONTENT: Comparison of different saving and investment options]\n| Option | Risk Level | Typical Returns | Liquidity |\n|--------|------------|----------------|-----------|\n| [CONTENT: Saving/investment vehicle] | [CONTENT: Risk assessment] | [CONTENT: Expected returns] | [CONTENT: Liquidity rating] |\n\n## Emergency Fund Planning\n[CONTENT: Guidelines for establishing and maintaining emergency funds]\n\n## Next Steps\n[CONTENT: Actionable items to begin implementing this financial plan]\n```\n\nRemember, your role is strictly to create the structure, not the content. Be thorough in your outlines but leave the actual content creation to the orchestrator agent."
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": true,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "",
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 1,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.1
              },
              "template": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "display_name": "Template",
                "dynamic": false,
                "info": "The template to use for formatting the data. It can contain the keys {text}, {sender} or any other key in the message data.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{sender_name}: {text}"
              },
              "timeout": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Timeout",
                "dynamic": false,
                "info": "The timeout for requests to OpenAI completion API.",
                "list": false,
                "list_add_label": "Add More",
                "name": "timeout",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 700
              },
              "tools": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Tools",
                "dynamic": false,
                "info": "These are the tools that the agent can use to help with tasks.",
                "input_types": [
                  "Tool"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "tools",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "tools_metadata": {
                "_input_type": "TableInput",
                "advanced": false,
                "display_name": "Edit tools",
                "dynamic": false,
                "info": "",
                "is_list": true,
                "list_add_label": "Add More",
                "name": "tools_metadata",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "table_icon": "Hammer",
                "table_options": {
                  "block_add": true,
                  "block_delete": true,
                  "block_edit": true,
                  "block_filter": true,
                  "block_hide": true,
                  "block_select": true,
                  "block_sort": true,
                  "description": "Modify tool names and descriptions to help agents understand when to use each tool.",
                  "field_parsers": {
                    "commands": "commands",
                    "name": [
                      "snake_case",
                      "no_blank"
                    ]
                  },
                  "hide_options": true
                },
                "table_schema": {
                  "columns": [
                    {
                      "default": "None",
                      "description": "Specify the name of the tool.",
                      "disable_edit": false,
                      "display_name": "Tool Name",
                      "edit_mode": "inline",
                      "filterable": false,
                      "formatter": "text",
                      "hidden": false,
                      "name": "name",
                      "sortable": false,
                      "type": "str"
                    },
                    {
                      "default": "None",
                      "description": "Describe the purpose of the tool.",
                      "disable_edit": false,
                      "display_name": "Tool Description",
                      "edit_mode": "popover",
                      "filterable": false,
                      "formatter": "text",
                      "hidden": false,
                      "name": "description",
                      "sortable": false,
                      "type": "str"
                    },
                    {
                      "default": "None",
                      "description": "The default identifiers for the tools and cannot be changed.",
                      "disable_edit": true,
                      "display_name": "Tool Identifiers",
                      "edit_mode": "inline",
                      "filterable": false,
                      "formatter": "text",
                      "hidden": true,
                      "name": "tags",
                      "sortable": false,
                      "type": "str"
                    }
                  ]
                },
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "trigger_icon": "Hammer",
                "trigger_text": "",
                "type": "table",
                "value": [
                  {
                    "description": "A helpful assistant with access to the following tools:",
                    "name": "Agent",
                    "tags": [
                      "Agent"
                    ]
                  }
                ]
              },
              "verbose": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Verbose",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "verbose",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": true
          },
          "showNode": true,
          "type": "Agent"
        },
        "id": "Agent-F6VMP",
        "measured": {
          "height": 702,
          "width": 320
        },
        "position": {
          "x": 1647.8282819190622,
          "y": 225
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatOutput-3KyuV",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "outputs",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template",
              "background_color",
              "chat_icon",
              "text_color",
              "clean_data"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "key": "ChatOutput",
            "legacy": false,
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.003169567463043492,
            "template": {
              "_type": "Component",
              "background_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Background Color",
                "dynamic": false,
                "info": "The background color of the icon.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "background_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "chat_icon": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Icon",
                "dynamic": false,
                "info": "The icon of the message.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_icon",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Basic Clean Data",
                "dynamic": false,
                "info": "Whether to clean the data",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from collections.abc import Generator\nfrom typing import Any\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import DropdownInput, MessageTextInput, Output\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Basic Clean Data\",\n            value=True,\n            info=\"Whether to clean the data\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                if data.get_text() is None:\n                    msg = \"Empty Data object\"\n                    raise ValueError(msg)\n                return data.get_text()\n            if isinstance(data, DataFrame):\n                if self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n\n                # Replace pipe characters to avoid markdown table issues\n                processed_data = data.replace(r\"\\|\", r\"\\\\|\", regex=True)\n\n                processed_data = processed_data.map(\n                    lambda x: str(x).replace(\"\\n\", \"<br/>\") if isinstance(x, str) else x\n                )\n\n                return processed_data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            return \"\\n\".join([self._safe_convert(item) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return self._safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Text",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "text_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Color",
                "dynamic": false,
                "info": "The text color of the name",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatOutput"
        },
        "id": "ChatOutput-3KyuV",
        "measured": {
          "height": 65,
          "width": 192
        },
        "position": {
          "x": 3379.5811142064063,
          "y": 1273.5206495559323
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "note-HQn0o",
          "node": {
            "description": "# 📑 Create Notion Pages\n\nThis component creates new pages in your Notion databases with custom properties.\n\n## How to Use\n1. Add your **Notion Secret** token\n2. Select a **Database** from the dropdown\n3. Set the **Number of Properties** you want to add\n4. For each property, select its **Name** and enter the **Value**\n\n## Property Types Quick Guide\n- **Text/Title**: Simple text\n- **Select/Status**: Match option name exactly\n- **Multi-select**: Comma-separated option names\n- **Date**: YYYY-MM-DD or use \"to\" for ranges\n- **Number/Checkbox**: Standard formats\n- **People/Relation**: Comma-separated Notion IDs\n\n## Tips\n- Notion integration must have access to your databases\n- System properties (formula, rollup, timestamps) can't be set manually\n- The component returns a DataFrame with page details and properties",
            "display_name": "",
            "documentation": "",
            "template": {
              "backgroundColor": "neutral"
            }
          },
          "type": "note"
        },
        "dragging": false,
        "id": "note-HQn0o",
        "measured": {
          "height": 1035,
          "width": 324
        },
        "position": {
          "x": 1122.7334151607847,
          "y": 65.93415939871556
        },
        "selected": false,
        "type": "noteNode"
      },
      {
        "data": {
          "id": "note-UD1od",
          "node": {
            "description": "# Notion Content Orchestration\n\nThis flow automatically creates well-structured content and adds it directly to Notion pages using a two-agent architecture. The Markdown Planner creates a logical outline, and the Orchestrator fills in the details and posts to Notion.\n\n## Prerequisites\n- **Notion integration token** with access to your workspace\n- **OpenAI API key** for both agent components\n\n## Quickstart\n\n1. Add your **OpenAI API key** to both agent components\n2. Add your **Notion integration token** to the \"Add Content to Page\" component\n3. Select the destination **Notion page** from the dropdown\n4. Open the **Playground** and request content by describing what you need\n\n## How It Works\n\n1. Your request goes to the **Markdown Planner** agent, which:\n   - Analyzes the topic and creates a logical structure\n   - Adds placeholders where content should go\n   - Returns a skeleton markdown outline\n\n2. The **Orchestrator** agent then:\n   - Takes the structured outline\n   - Fills in all placeholders with detailed content\n   - Maintains the exact structure of the outline\n   - Sends the completed markdown to Notion\n\n3. The **Add Content to Page** component:\n   - Converts markdown to Notion blocks\n   - Adds them to your selected page\n   - Returns confirmation with page details\n\n## Example Requests\n\n- \"Create a guide about time management techniques\"\n- \"Make a comparison of popular project management tools\"\n- \"Write a step-by-step guide for launching an e-commerce business\"\n- \"Create a content marketing strategy outline for a small business\"",
            "display_name": "",
            "documentation": "",
            "template": {}
          },
          "type": "note"
        },
        "dragging": false,
        "id": "note-UD1od",
        "measured": {
          "height": 1709,
          "width": 324
        },
        "position": {
          "x": 458.2871707943883,
          "y": -222.6849395576927
        },
        "selected": false,
        "type": "noteNode"
      },
      {
        "data": {
          "id": "AddContentToPage-kR0Yb",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "category": "Notion",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Convert markdown text to Notion blocks and append them after the selected block.",
            "display_name": "Add Content to Page",
            "documentation": "https://developers.notion.com/reference/patch-block-children",
            "edited": false,
            "field_order": [
              "markdown_text",
              "notion_secret",
              "page_id",
              "block_id"
            ],
            "frozen": false,
            "icon": "NotionDirectoryLoader",
            "key": "AddContentToPage",
            "legacy": false,
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Toolset",
                "hidden": null,
                "method": "to_toolkit",
                "name": "component_as_tool",
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.03162277660168379,
            "template": {
              "_type": "Component",
              "block_id": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Insert After Block",
                "dynamic": false,
                "info": "Content will be added after this block",
                "name": "block_id",
                "options": [
                  "Top of Page"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Top of Page"
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nfrom typing import Any\n\nimport requests\nfrom bs4 import BeautifulSoup\nfrom loguru import logger\nfrom markdown import markdown\n\nfrom langflow.custom import Component\nfrom langflow.inputs import DropdownInput, MultilineInput, SecretStrInput\nfrom langflow.schema import Data, dotdict\nfrom langflow.template import Output\n\nMIN_ROWS_IN_TABLE = 3\n\n\nclass AddContentToPage(Component):\n    \"\"\"A component that adds content to a Notion page by converting markdown to Notion blocks.\"\"\"\n\n    display_name: str = \"Add Content to Page\"\n    description: str = \"Convert markdown text to Notion blocks and append them after the selected block.\"\n    documentation: str = \"https://developers.notion.com/reference/patch-block-children\"\n    icon: str = \"NotionDirectoryLoader\"\n\n    inputs = [\n        MultilineInput(\n            name=\"markdown_text\",\n            display_name=\"Markdown Text\",\n            info=\"The markdown text to convert to Notion blocks.\",\n            tool_mode=True,\n        ),\n        SecretStrInput(\n            name=\"notion_secret\",\n            display_name=\"Notion Secret\",\n            info=\"The Notion integration token.\",\n            required=True,\n            real_time_refresh=True,\n        ),\n        DropdownInput(\n            name=\"page_id\",\n            display_name=\"Page\",\n            info=\"Select a page to add content to\",\n            options=[\"Loading pages...\"],\n            value=\"Loading pages...\",\n            real_time_refresh=True,\n            required=True,\n        ),\n        DropdownInput(\n            name=\"block_id\",\n            display_name=\"Insert After Block\",\n            info=\"Content will be added after this block\",\n            options=[\"Top of Page\"],\n            value=\"Top of Page\",\n            real_time_refresh=True,\n            required=True,\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"data\", display_name=\"Response Data\", method=\"add_content_to_page\"),\n    ]\n\n    def search_pages(self) -> list[dict[str, Any]]:\n        \"\"\"Search Notion pages shared with the integration.\"\"\"\n        url = \"https://api.notion.com/v1/search\"\n        headers = {\n            \"Authorization\": f\"Bearer {self.notion_secret}\",\n            \"Content-Type\": \"application/json\",\n            \"Notion-Version\": \"2022-06-28\",\n        }\n        data = {\n            \"filter\": {\"value\": \"page\", \"property\": \"object\"},\n            \"sort\": {\"direction\": \"descending\", \"timestamp\": \"last_edited_time\"},\n        }\n\n        try:\n            self.log(\"Searching for pages...\")\n            response = requests.post(url, headers=headers, json=data, timeout=10)\n            response.raise_for_status()\n\n            results = response.json().get(\"results\", [])\n            self.log(f\"Found {len(results)} pages\")\n\n            pages = []\n            for result in results:\n                # Extract page title\n                title = \"Untitled\"\n                if \"properties\" in result:\n                    for prop in result[\"properties\"].values():\n                        if prop[\"type\"] == \"title\":\n                            title_array = prop.get(\"title\", [])\n                            if title_array:\n                                title = \"\".join(part.get(\"plain_text\", \"\") for part in title_array)\n                                break\n\n                pages.append(\n                    {\n                        \"id\": result[\"id\"],\n                        \"title\": title,\n                        \"url\": result.get(\"url\", \"\"),\n                    }\n                )\n\n        except requests.exceptions.RequestException as e:\n            self.log(f\"Error searching pages: {e}\")\n            return []\n        else:\n            return sorted(pages, key=lambda x: x[\"title\"].lower())\n\n    def get_block_children(self, block_id: str) -> list[dict[str, Any]]:\n        \"\"\"Get children blocks of a given block ID.\"\"\"\n        if not block_id:\n            return []\n\n        url = f\"https://api.notion.com/v1/blocks/{block_id}/children\"\n        headers = {\n            \"Authorization\": f\"Bearer {self.notion_secret}\",\n            \"Notion-Version\": \"2022-06-28\",\n        }\n\n        try:\n            self.log(f\"Fetching children for block: {block_id}\")\n            response = requests.get(url, headers=headers, params={\"page_size\": 100}, timeout=10)\n            response.raise_for_status()\n\n            results = response.json().get(\"results\", [])\n            self.log(f\"Found {len(results)} child blocks\")\n\n            blocks = []\n            for block in results:\n                block_type = block.get(\"type\", \"unknown\")\n                content = self.get_block_content(block)\n\n                blocks.append(\n                    {\n                        \"id\": block[\"id\"],\n                        \"type\": block_type,\n                        \"content\": content,\n                        \"has_children\": block.get(\"has_children\", False),\n                    }\n                )\n\n        except requests.exceptions.RequestException as e:\n            self.log(f\"Error fetching block children: {e}\")\n            return []\n        else:\n            return blocks\n\n    def get_block_content(self, block: dict[str, Any]) -> str:\n        \"\"\"Extract readable content from a block.\"\"\"\n        block_type = block.get(\"type\", \"\")\n        if not block_type or block_type == \"unsupported\":\n            return f\"{block_type}\"\n\n        block_data = block.get(block_type, {})\n\n        # Handle text-based blocks\n        if \"rich_text\" in block_data:\n            rich_text = block_data.get(\"rich_text\", [])\n            return \"\".join(rt.get(\"plain_text\", \"\") for rt in rich_text)\n\n        # Handle specific block types\n        if block_type == \"child_page\":\n            return f\"Page: {block_data.get('title', 'Untitled')}\"\n\n        if block_type == \"child_database\":\n            return f\"Database: {block_data.get('title', 'Untitled')}\"\n\n        # Default for any other block types\n        return f\"{block_type}\"\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None) -> dotdict:\n        \"\"\"Update the component build configuration.\"\"\"\n        try:\n            # When notion_secret changes or component initializes\n            if field_name is None or field_name == \"notion_secret\":\n                pages = self.search_pages()\n\n                # Build options list and create a lookup dict for page IDs\n                page_options = []\n                page_tooltips = {}\n\n                for page in pages:\n                    title = page[\"title\"]\n                    page_id = page[\"id\"]\n                    page_options.append(title)\n                    page_tooltips[title] = page_id\n\n                # Update the page dropdown\n                build_config[\"page_id\"][\"options\"] = page_options if page_options else [\"Loading pages...\"]\n                if page_options:\n                    build_config[\"page_id\"][\"value\"] = page_options[0]\n\n                # Store the page ID mapping in tooltips\n                build_config[\"page_id\"][\"tooltips\"] = page_tooltips\n\n                # Reset block dropdown\n                build_config[\"block_id\"][\"options\"] = [\"Top of Page\"]\n                build_config[\"block_id\"][\"value\"] = \"Top of Page\"\n\n            # When page_id changes\n            elif field_name == \"page_id\" and field_value != \"Loading pages...\":\n                # Get the actual page ID from tooltips\n                page_id = build_config[\"page_id\"][\"tooltips\"].get(field_value)\n\n                if page_id:\n                    self.log(f\"Selected page: {field_value} (ID: {page_id})\")\n\n                    # Fetch blocks for this page\n                    blocks = self.get_block_children(page_id)\n\n                    # Build options and tooltips for blocks\n                    block_options = []\n                    block_tooltips = {}\n\n                    for block in blocks:\n                        display_text = (\n                            f\"{block['type']}: {block['content'][:50]}...\" if block[\"content\"] else block[\"type\"]\n                        )\n                        block_options.append(display_text)\n                        block_tooltips[display_text] = block[\"id\"]\n\n                    # Update the block dropdown\n                    build_config[\"block_id\"][\"options\"] = [\"Top of Page\", *block_options]\n                    build_config[\"block_id\"][\"value\"] = \"Top of Page\"\n                    build_config[\"block_id\"][\"tooltips\"] = block_tooltips\n\n                    self.log(f\"Updated block options: {len(block_options)} blocks\")\n                else:\n                    self.log(f\"Could not find page ID for: {field_value}\")\n\n        except requests.exceptions.RequestException as e:\n            self.log(f\"Error updating build config: {e}\")\n\n        return build_config\n\n    def add_content_to_page(self) -> Data:\n        \"\"\"Convert markdown text to Notion blocks and append them after the selected block.\"\"\"\n        page_title = self.page_id\n        page_id = \"\"\n\n        try:\n            # Use the tooltips to get the page ID and URL\n            pages = self.search_pages()\n            page_url = \"\"\n            for page in pages:\n                if page[\"title\"] == page_title:\n                    page_id = page[\"id\"]\n                    page_url = page[\"url\"]\n                    break\n\n            if not page_id:\n                return Data(data={\"error\": \"Could not find page ID for the selected page\"})\n\n            # Get block ID if not \"Top of Page\"\n            after_id = \"\"\n            if self.block_id != \"Top of Page\":\n                blocks = self.get_block_children(page_id)\n                for block in blocks:\n                    display_text = f\"{block['type']}: {block['content'][:50]}...\" if block[\"content\"] else block[\"type\"]\n                    if display_text == self.block_id:\n                        after_id = block[\"id\"]\n                        break\n\n            # Convert markdown to blocks\n            html_text = markdown(self.markdown_text)\n            soup = BeautifulSoup(html_text, \"html.parser\")\n            blocks = self.process_node(soup)\n\n            # Prepare request to add content\n            url = f\"https://api.notion.com/v1/blocks/{page_id}/children\"\n            headers = {\n                \"Authorization\": f\"Bearer {self.notion_secret}\",\n                \"Content-Type\": \"application/json\",\n                \"Notion-Version\": \"2022-06-28\",\n            }\n\n            # Explicitly type data as a dictionary to resolve linter error\n            data: dict[str, Any] = {\"children\": blocks}\n            if after_id:\n                data[\"after\"] = after_id\n\n            # Make the request\n            response = requests.patch(url, headers=headers, json=data, timeout=10)\n            response.raise_for_status()\n\n            # Return the response data\n            result = response.json()\n            result[\"page_id\"] = page_id\n            result[\"page_url\"] = page_url\n            if after_id:\n                result[\"after_block\"] = after_id\n\n            return Data(data=result)\n\n        except requests.exceptions.RequestException as e:\n            error_message = f\"Error adding content to Notion: {e}\"\n            if hasattr(e, \"response\") and e.response:\n                error_message += f\" Status: {e.response.status_code}, Response: {e.response.text}\"\n            return Data(data={\"error\": error_message})\n        except json.JSONDecodeError as e:\n            logger.opt(exception=True).debug(\"Error decoding JSON response from Notion\")\n            return Data(data={\"error\": f\"An error occurred while decoding the JSON response: {e}\"})\n\n    def process_node(self, node):\n        \"\"\"Process a BeautifulSoup node and convert it to Notion blocks.\"\"\"\n        blocks = []\n        if isinstance(node, str):\n            text = node.strip()\n            if text:\n                if text.startswith(\"#\"):\n                    heading_level = min(text.count(\"#\", 0, 6), 3)\n                    heading_text = text[heading_level:].strip()\n                    blocks.append(self.create_block(f\"heading_{heading_level}\", heading_text))\n                else:\n                    blocks.append(self.create_block(\"paragraph\", text))\n        elif node.name == \"h1\":\n            blocks.append(self.create_block(\"heading_1\", node.get_text(strip=True)))\n        elif node.name == \"h2\":\n            blocks.append(self.create_block(\"heading_2\", node.get_text(strip=True)))\n        elif node.name == \"h3\":\n            blocks.append(self.create_block(\"heading_3\", node.get_text(strip=True)))\n        elif node.name == \"p\":\n            code_node = node.find(\"code\")\n            if code_node:\n                code_text = code_node.get_text()\n                language, code = self.extract_language_and_code(code_text)\n                blocks.append(self.create_block(\"code\", code, language=language))\n            elif self.is_table(str(node)):\n                blocks.extend(self.process_table(node))\n            else:\n                blocks.append(self.create_block(\"paragraph\", node.get_text(strip=True)))\n        elif node.name == \"ul\":\n            blocks.extend(self.process_list(node, \"bulleted_list_item\"))\n        elif node.name == \"ol\":\n            blocks.extend(self.process_list(node, \"numbered_list_item\"))\n        elif node.name == \"blockquote\":\n            blocks.append(self.create_block(\"quote\", node.get_text(strip=True)))\n        elif node.name == \"hr\":\n            blocks.append(self.create_block(\"divider\", \"\"))\n        elif node.name == \"img\":\n            blocks.append(self.create_block(\"image\", \"\", image_url=node.get(\"src\")))\n        elif node.name == \"a\":\n            blocks.append(self.create_block(\"bookmark\", node.get_text(strip=True), link_url=node.get(\"href\")))\n        elif node.name == \"table\":\n            blocks.extend(self.process_table(node))\n\n        for child in node.children:\n            if isinstance(child, str):\n                continue\n            blocks.extend(self.process_node(child))\n\n        return blocks\n\n    def extract_language_and_code(self, code_text):\n        \"\"\"Extract language and code from a code block.\"\"\"\n        lines = code_text.split(\"\\n\")\n        language = lines[0].strip()\n        code = \"\\n\".join(lines[1:]).strip()\n        return language, code\n\n    def is_table(self, text):\n        \"\"\"Check if text represents a markdown table.\"\"\"\n        rows = text.split(\"\\n\")\n        if len(rows) < MIN_ROWS_IN_TABLE:\n            return False\n\n        has_separator = False\n        for i, row in enumerate(rows):\n            if \"|\" in row:\n                cells = [cell.strip() for cell in row.split(\"|\")]\n                cells = [cell for cell in cells if cell]  # Remove empty cells\n                if i == 1 and all(set(cell) <= set(\"-|\") for cell in cells):\n                    has_separator = True\n                elif not cells:\n                    return False\n\n        return has_separator\n\n    def process_list(self, node, list_type):\n        \"\"\"Process list nodes and convert them to Notion list blocks.\"\"\"\n        blocks = []\n        for item in node.find_all(\"li\", recursive=False):  # Only direct children\n            item_text = item.get_text(strip=True)\n            checked = item_text.startswith(\"[x]\")\n            is_checklist = item_text.startswith(\"[ ]\") or checked\n\n            if is_checklist:\n                item_text = item_text.replace(\"[x]\", \"\").replace(\"[ ]\", \"\").strip()\n                blocks.append(self.create_block(\"to_do\", item_text, checked=checked))\n            else:\n                blocks.append(self.create_block(list_type, item_text))\n\n            # Process nested lists if any\n            nested_ul = item.find(\"ul\")\n            if nested_ul:\n                blocks.extend(self.process_list(nested_ul, \"bulleted_list_item\"))\n            nested_ol = item.find(\"ol\")\n            if nested_ol:\n                blocks.extend(self.process_list(nested_ol, \"numbered_list_item\"))\n\n        return blocks\n\n    def process_table(self, node):\n        \"\"\"Process table nodes and convert them to Notion table blocks.\"\"\"\n        blocks = []\n        header_row = node.find(\"thead\").find(\"tr\") if node.find(\"thead\") else None\n        body_rows = node.find(\"tbody\").find_all(\"tr\") if node.find(\"tbody\") else []\n\n        if not body_rows and not header_row:\n            all_rows = node.find_all(\"tr\")\n            if len(all_rows) > 1:\n                header_row = all_rows[0]\n                body_rows = all_rows[1:]\n\n        if header_row or body_rows:\n            table_width = max(\n                len(header_row.find_all([\"th\", \"td\"])) if header_row else 0,\n                *(len(row.find_all([\"th\", \"td\"])) for row in body_rows),\n            )\n\n            table_block = self.create_block(\"table\", \"\", table_width=table_width, has_column_header=bool(header_row))\n            blocks.append(table_block)\n\n            if header_row:\n                header_cells = [cell.get_text(strip=True) for cell in header_row.find_all([\"th\", \"td\"])]\n                header_row_block = self.create_block(\"table_row\", header_cells)\n                blocks.append(header_row_block)\n\n            for row in body_rows:\n                cells = [cell.get_text(strip=True) for cell in row.find_all([\"th\", \"td\"])]\n                row_block = self.create_block(\"table_row\", cells)\n                blocks.append(row_block)\n\n        return blocks\n\n    def create_block(self, block_type: str, content: str, **kwargs) -> dict[str, Any]:\n        \"\"\"Create a Notion block with the specified type and content.\"\"\"\n        block: dict[str, Any] = {\n            \"object\": \"block\",\n            \"type\": block_type,\n            block_type: {},\n        }\n\n        if block_type in {\n            \"paragraph\",\n            \"heading_1\",\n            \"heading_2\",\n            \"heading_3\",\n            \"bulleted_list_item\",\n            \"numbered_list_item\",\n            \"quote\",\n        }:\n            block[block_type][\"rich_text\"] = [\n                {\n                    \"type\": \"text\",\n                    \"text\": {\"content\": content},\n                }\n            ]\n        elif block_type == \"to_do\":\n            block[block_type][\"rich_text\"] = [\n                {\n                    \"type\": \"text\",\n                    \"text\": {\"content\": content},\n                }\n            ]\n            block[block_type][\"checked\"] = kwargs.get(\"checked\", False)\n        elif block_type == \"code\":\n            block[block_type][\"rich_text\"] = [\n                {\n                    \"type\": \"text\",\n                    \"text\": {\"content\": content},\n                }\n            ]\n            block[block_type][\"language\"] = kwargs.get(\"language\", \"plain text\")\n        elif block_type == \"image\":\n            block[block_type] = {\"type\": \"external\", \"external\": {\"url\": kwargs.get(\"image_url\", \"\")}}\n        elif block_type == \"divider\":\n            pass\n        elif block_type == \"bookmark\":\n            block[block_type][\"url\"] = kwargs.get(\"link_url\", \"\")\n        elif block_type == \"table\":\n            block[block_type][\"table_width\"] = kwargs.get(\"table_width\", 0)\n            block[block_type][\"has_column_header\"] = kwargs.get(\"has_column_header\", False)\n            block[block_type][\"has_row_header\"] = kwargs.get(\"has_row_header\", False)\n        elif block_type == \"table_row\":\n            block[block_type][\"cells\"] = [[{\"type\": \"text\", \"text\": {\"content\": cell}} for cell in content]]\n\n        return block\n"
              },
              "markdown_text": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "display_name": "Markdown Text",
                "dynamic": false,
                "info": "The markdown text to convert to Notion blocks.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "markdown_text",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "notion_secret": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Notion Secret",
                "dynamic": false,
                "info": "The Notion integration token.",
                "input_types": [
                  "Message"
                ],
                "load_from_db": false,
                "name": "notion_secret",
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "page_id": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Page",
                "dynamic": false,
                "info": "Select a page to add content to",
                "name": "page_id",
                "options": [
                  "Loading pages..."
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "tooltips": {},
                "trace_as_metadata": true,
                "type": "str",
                "value": "Loading pages..."
              },
              "tools_metadata": {
                "_input_type": "TableInput",
                "advanced": false,
                "display_name": "Edit tools",
                "dynamic": false,
                "info": "",
                "is_list": true,
                "list_add_label": "Add More",
                "name": "tools_metadata",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "table_icon": "Hammer",
                "table_options": {
                  "block_add": true,
                  "block_delete": true,
                  "block_edit": true,
                  "block_filter": true,
                  "block_hide": true,
                  "block_select": true,
                  "block_sort": true,
                  "description": "Modify tool names and descriptions to help agents understand when to use each tool.",
                  "field_parsers": {
                    "commands": "commands",
                    "name": [
                      "snake_case",
                      "no_blank"
                    ]
                  },
                  "hide_options": true
                },
                "table_schema": {
                  "columns": [
                    {
                      "default": "None",
                      "description": "Specify the name of the tool.",
                      "disable_edit": false,
                      "display_name": "Tool Name",
                      "edit_mode": "inline",
                      "filterable": false,
                      "formatter": "text",
                      "hidden": false,
                      "name": "name",
                      "sortable": false,
                      "type": "str"
                    },
                    {
                      "default": "None",
                      "description": "Describe the purpose of the tool.",
                      "disable_edit": false,
                      "display_name": "Tool Description",
                      "edit_mode": "popover",
                      "filterable": false,
                      "formatter": "text",
                      "hidden": false,
                      "name": "description",
                      "sortable": false,
                      "type": "str"
                    },
                    {
                      "default": "None",
                      "description": "The default identifiers for the tools and cannot be changed.",
                      "disable_edit": true,
                      "display_name": "Tool Identifiers",
                      "edit_mode": "inline",
                      "filterable": false,
                      "formatter": "text",
                      "hidden": true,
                      "name": "tags",
                      "sortable": false,
                      "type": "str"
                    }
                  ]
                },
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "trigger_icon": "Hammer",
                "trigger_text": "",
                "type": "table",
                "value": [
                  {
                    "description": "add_content_to_page(block_id: FieldTypes.TEXT, notion_secret: Message, page_id: FieldTypes.TEXT) - Convert markdown text to Notion blocks and append them after the selected block.",
                    "name": "AddContentToPage-add_content_to_page",
                    "tags": [
                      "AddContentToPage-add_content_to_page"
                    ]
                  }
                ]
              }
            },
            "tool_mode": true
          },
          "showNode": true,
          "type": "AddContentToPage"
        },
        "id": "AddContentToPage-kR0Yb",
        "measured": {
          "height": 576,
          "width": 320
        },
        "position": {
          "x": 2112.5472877517177,
          "y": 367.8662218083805
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "NotionPageCreator-7NNuh",
          "node": {
            "base_classes": [
              "DataFrame"
            ],
            "beta": false,
            "category": "Notion",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Create a new page in a Notion database with dynamic property selection and values.",
            "display_name": "Create Page",
            "documentation": "https://docs.langflow.org/integrations/notion/page-create",
            "edited": false,
            "field_order": [
              "notion_secret",
              "database_id",
              "number_of_properties"
            ],
            "frozen": false,
            "icon": "NotionDirectoryLoader",
            "key": "NotionPageCreator",
            "legacy": false,
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Page Data",
                "method": "create_page_as_dataframe",
                "name": "dataframe",
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.08849264769357712,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nfrom typing import Any\n\nimport pandas as pd\nimport requests\n\nfrom langflow.custom import Component\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import DropdownInput, IntInput, MessageTextInput, SecretStrInput\nfrom langflow.io import Output\nfrom langflow.schema import DataFrame, dotdict\n\n\nclass NotionPageCreator(Component):\n    \"\"\"A component that creates pages in Notion databases with dynamic properties.\"\"\"\n\n    display_name: str = \"Create Page\"\n    description: str = \"Create a new page in a Notion database with dynamic property selection and values.\"\n    documentation: str = \"https://docs.langflow.org/integrations/notion/page-create\"\n    icon: str = \"NotionDirectoryLoader\"\n\n    # Maximum number of allowed properties\n    MAX_PROPERTIES = 10\n\n    # Store database properties globally\n    _database_properties: dict[str, Any] = {}\n\n    inputs = [\n        SecretStrInput(\n            name=\"notion_secret\",\n            display_name=\"Notion Secret\",\n            info=\"The Notion integration token.\",\n            required=True,\n            real_time_refresh=True,\n        ),\n        DropdownInput(\n            name=\"database_id\",\n            display_name=\"Database Name\",\n            info=\"Select a database by name\",\n            options=[\"Loading databases...\"],\n            value=\"Loading databases...\",\n            real_time_refresh=True,\n            required=True,\n        ),\n        IntInput(\n            name=\"number_of_properties\",\n            display_name=\"Number of Properties\",\n            info=\"Number of properties to add to the page\",\n            value=0,\n            real_time_refresh=True,\n            range_spec=RangeSpec(min=0, max=MAX_PROPERTIES, step=1, step_type=\"int\"),\n            advanced=True,  # Start as hidden\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"dataframe\", display_name=\"Page Data\", method=\"create_page_as_dataframe\"),\n    ]\n\n    def fetch_databases(self) -> list[dict[str, Any]]:\n        \"\"\"Fetch available databases from Notion API.\"\"\"\n        headers = {\n            \"Authorization\": f\"Bearer {self.notion_secret}\",\n            \"Content-Type\": \"application/json\",\n            \"Notion-Version\": \"2022-06-28\",\n        }\n\n        try:\n            response = requests.post(\n                \"https://api.notion.com/v1/search\",\n                headers=headers,\n                json={\"filter\": {\"value\": \"database\", \"property\": \"object\"}},\n                timeout=10,\n            )\n            response.raise_for_status()\n            return response.json().get(\"results\", [])\n        except requests.exceptions.RequestException as e:\n            self.log(f\"Error fetching databases: {e!s}\")\n            return []\n\n    def fetch_database_properties(self, database_id: str) -> dict[str, Any]:\n        \"\"\"Fetch properties of a specific database.\"\"\"\n        # Extract the pure ID if it's in the format \"Name (ID)\"\n        if \"(\" in database_id and database_id.endswith(\")\"):\n            database_id = database_id.split(\"(\")[-1].rstrip(\")\")\n\n        if not database_id or database_id == \"Loading databases...\":\n            return {}\n\n        headers = {\n            \"Authorization\": f\"Bearer {self.notion_secret}\",\n            \"Notion-Version\": \"2022-06-28\",\n        }\n\n        try:\n            response = requests.get(f\"https://api.notion.com/v1/databases/{database_id}\", headers=headers, timeout=10)\n            response.raise_for_status()\n            return response.json().get(\"properties\", {})\n        except requests.exceptions.RequestException as e:\n            self.log(f\"Error fetching database properties: {e!s}\")\n            return {}\n\n    def format_property_value(self, prop_name: str, prop_info: dict[str, Any], value: str) -> dict[str, Any]:\n        \"\"\"Format a property value based on its type in Notion.\"\"\"\n        prop_type = prop_info[\"type\"]\n\n        self.log(f\"Formatting property {prop_name} of type {prop_type} with value {value}\")\n\n        try:\n            if prop_type == \"title\":\n                return {\"title\": [{\"type\": \"text\", \"text\": {\"content\": str(value)}}]}\n\n            if prop_type == \"rich_text\":\n                return {\"rich_text\": [{\"type\": \"text\", \"text\": {\"content\": str(value)}}]}\n\n            if prop_type == \"select\":\n                if not value:\n                    return {\"select\": None}\n                return {\"select\": {\"name\": str(value)}}\n\n            if prop_type == \"multi_select\":\n                values = [v.strip() for v in str(value).split(\",\")]\n                return {\"multi_select\": [{\"name\": v} for v in values if v]}\n\n            if prop_type == \"date\":\n                if not value:\n                    return {\"date\": None}\n                if \" to \" in value:\n                    start, end = value.split(\" to \")\n                    return {\"date\": {\"start\": start.strip(), \"end\": end.strip()}}\n                return {\"date\": {\"start\": str(value)}}\n\n            if prop_type == \"number\":\n                if not value:\n                    return {\"number\": None}\n                try:\n                    return {\"number\": float(value)}\n                except ValueError:\n                    return {\"number\": 0}\n\n            elif prop_type == \"checkbox\":\n                return {\"checkbox\": str(value).lower() in (\"true\", \"1\", \"yes\", \"y\", \"on\")}\n\n            elif prop_type == \"url\":\n                return {\"url\": str(value) if value else None}\n\n            elif prop_type == \"email\":\n                return {\"email\": str(value) if value else None}\n\n            elif prop_type == \"phone_number\":\n                return {\"phone_number\": str(value) if value else None}\n\n            elif prop_type == \"files\":\n                if not value:\n                    return {\"files\": []}\n                if value.startswith((\"http://\", \"https://\")):\n                    return {\"files\": [{\"name\": value.split(\"/\")[-1], \"type\": \"external\", \"external\": {\"url\": value}}]}\n                return {\"files\": []}\n\n            elif prop_type == \"relation\":\n                import re\n\n                uuid_regex = re.compile(\n                    r\"^[0-9a-fA-F]{8}-\"\n                    r\"[0-9a-fA-F]{4}-\"\n                    r\"[0-9a-fA-F]{4}-\"\n                    r\"[0-9a-fA-F]{4}-\"\n                    r\"[0-9a-fA-F]{12}$\"\n                )\n                relation_values = [v.strip() for v in str(value).split(\",\") if v.strip()]\n                relation_ids = [v for v in relation_values if uuid_regex.match(v)]\n                if relation_values and not relation_ids:\n                    error_message = f\"Invalid relation id(s) provided for property {prop_name}: {value}\"\n                    raise ValueError(error_message)\n                return {\"relation\": [{\"id\": rid} for rid in relation_ids]}\n\n            elif prop_type == \"status\":\n                if not value:\n                    return {\"status\": None}\n                return {\"status\": {\"name\": str(value)}}\n\n            elif prop_type == \"people\":\n                # Handle people type - this requires user IDs\n                import re\n\n                uuid_regex = re.compile(\n                    r\"^[0-9a-fA-F]{8}-\"\n                    r\"[0-9a-fA-F]{4}-\"\n                    r\"[0-9a-fA-F]{4}-\"\n                    r\"[0-9a-fA-F]{4}-\"\n                    r\"[0-9a-fA-F]{12}$\"\n                )\n                # Check if value looks like UUID\n                if not value:\n                    return {\"people\": []}\n\n                people_values = [v.strip() for v in str(value).split(\",\") if v.strip()]\n                # Use a differently named variable to avoid redefinition issues\n                people_id_objects: list[dict[str, str]] = []\n\n                for person_value in people_values:\n                    if uuid_regex.match(person_value):\n                        # It's a user ID - create a dictionary with the ID\n                        people_id_objects.append({\"id\": person_value})\n                    else:\n                        # For non-UUID values, log a warning\n                        self.log(\n                            f\"Warning: '{person_value}' doesn't appear to be a valid user ID. \"\n                            f\"People properties require Notion user IDs, not names.\"\n                        )\n\n                return {\"people\": people_id_objects}\n\n            elif prop_type == \"formula\":\n                # Formula properties are calculated by Notion and cannot be set\n                self.log(f\"Skipping formula property {prop_name} as it cannot be set manually\")\n                return {}  # Return empty dict instead of None\n\n            elif prop_type == \"rollup\":\n                # Rollup properties are calculated by Notion and cannot be set\n                self.log(f\"Skipping rollup property {prop_name} as it cannot be set manually\")\n                return {}  # Return empty dict instead of None\n\n            elif prop_type in {\"created_by\", \"last_edited_by\", \"created_time\", \"last_edited_time\"}:\n                # These are system properties and cannot be set\n                self.log(f\"Skipping system property {prop_name} as it cannot be set manually\")\n                return {}  # Return empty dict instead of None\n\n            else:\n                # Log unknown property type\n                self.log(\n                    f\"Unknown property type '{prop_type}' for property '{prop_name}'. \"\n                    f\"Please check your Notion database schema.\"\n                )\n                return {}  # Return empty dict instead of None\n\n        except (ValueError, TypeError) as e:\n            self.log(f\"Error formatting property {prop_name}: {e!s}\")\n            # Returns empty value or None based on type\n            empty_values: dict[str, dict[str, Any]] = {\n                \"title\": {\"title\": []},\n                \"rich_text\": {\"rich_text\": []},\n                \"select\": {\"select\": None},\n                \"multi_select\": {\"multi_select\": []},\n                \"date\": {\"date\": None},\n                \"number\": {\"number\": None},\n                \"checkbox\": {\"checkbox\": False},\n                \"url\": {\"url\": None},\n                \"email\": {\"email\": None},\n                \"phone_number\": {\"phone_number\": None},\n                \"files\": {\"files\": []},\n                \"status\": {\"status\": None},\n                \"people\": {\"people\": []},\n                \"relation\": {\"relation\": []},\n            }\n            return empty_values.get(prop_type, {}) if prop_type in empty_values else {\"value\": None}\n\n    def create_page_as_dataframe(self) -> DataFrame:\n        \"\"\"Create a new page in a Notion database and return as DataFrame.\"\"\"\n        page_response = self._create_notion_page()\n\n        # If error, return DataFrame with error information\n        if \"error\" in page_response:\n            error_df = pd.DataFrame({\"error\": [page_response[\"error\"]]})\n            return DataFrame(error_df)\n\n        # Extract the important information from the page response\n        page_data = {\n            \"page_id\": [page_response.get(\"id\", \"\")],\n            \"url\": [page_response.get(\"url\", \"\")],\n            \"created_time\": [page_response.get(\"created_time\", \"\")],\n            \"last_edited_time\": [page_response.get(\"last_edited_time\", \"\")],\n        }\n\n        # Extract property values in a user-friendly format\n        properties = page_response.get(\"properties\", {})\n        for prop_name, prop_content in properties.items():\n            prop_type = next(iter(prop_content)) if prop_content else \"\"\n\n            # Format the property based on its type\n            if prop_type == \"title\" and prop_content.get(\"title\"):\n                text_content = []\n                text_content = [\n                    item[\"text\"][\"content\"]\n                    for item in prop_content.get(\"title\", [])\n                    if item.get(\"type\") == \"text\" and item.get(\"text\", {}).get(\"content\")\n                ]\n                page_data[f\"{prop_name}\"] = [\" \".join(text_content) if text_content else \"\"]\n\n            elif prop_type == \"rich_text\" and prop_content.get(\"rich_text\"):\n                text_content = []\n                text_content = [\n                    item[\"text\"][\"content\"]\n                    for item in prop_content.get(\"rich_text\", [])\n                    if item.get(\"type\") == \"text\" and \"text\" in item and \"content\" in item[\"text\"]\n                ]\n                page_data[f\"{prop_name}\"] = [\" \".join(text_content) if text_content else \"\"]\n\n            elif prop_type == \"select\" and prop_content.get(\"select\"):\n                page_data[f\"{prop_name}\"] = [prop_content[\"select\"].get(\"name\", \"\")]\n\n            elif prop_type == \"multi_select\" and prop_content.get(\"multi_select\"):\n                multi_select_values = [item.get(\"name\", \"\") for item in prop_content.get(\"multi_select\", [])]\n                page_data[f\"{prop_name}\"] = [\", \".join(multi_select_values)]\n\n            elif prop_type == \"date\" and prop_content.get(\"date\"):\n                date_info = prop_content[\"date\"]\n                date_value = date_info.get(\"start\", \"\")\n                if date_info.get(\"end\"):\n                    date_value += f\" to {date_info['end']}\"\n                page_data[f\"{prop_name}\"] = [date_value]\n\n            elif prop_type == \"checkbox\":\n                page_data[f\"{prop_name}\"] = [str(prop_content.get(\"checkbox\", False))]\n\n            elif prop_type in [\"number\", \"url\", \"email\", \"phone_number\"]:\n                page_data[f\"{prop_name}\"] = [str(prop_content.get(prop_type, \"\"))]\n\n            elif prop_type == \"status\" and prop_content.get(\"status\"):\n                page_data[f\"{prop_name}\"] = [prop_content[\"status\"].get(\"name\", \"\")]\n\n            elif prop_type == \"relation\":\n                relation_ids = [item.get(\"id\", \"\") for item in prop_content.get(\"relation\", [])]\n                page_data[f\"{prop_name}\"] = [\", \".join(relation_ids)]\n\n            # Add other property types as needed\n\n        # Add database info and additional metadata\n        page_data[\"database_id\"] = [page_response.get(\"parent\", {}).get(\"database_id\", \"\")]\n        page_data[\"database_name\"] = [self.database_id.split(\" (\")[0] if \"(\" in self.database_id else self.database_id]\n        page_data[\"created_by\"] = [page_response.get(\"created_by\", {}).get(\"id\", \"\")]\n        page_data[\"last_edited_by\"] = [page_response.get(\"last_edited_by\", {}).get(\"id\", \"\")]\n\n        # Add the full JSON response as a column for debugging/advanced use\n        page_data[\"api_response\"] = [json.dumps(page_response)]\n\n        # Create DataFrame\n        result_df = pd.DataFrame(page_data)\n\n        # Order columns: metadata first, then properties\n        metadata_cols = [\n            \"page_id\",\n            \"database_id\",\n            \"database_name\",\n            \"url\",\n            \"created_time\",\n            \"last_edited_time\",\n            \"created_by\",\n            \"last_edited_by\",\n        ]\n        property_cols = [col for col in result_df.columns if col not in metadata_cols and col != \"api_response\"]\n\n        # Put api_response at the end\n        ordered_cols = metadata_cols + sorted(property_cols) + [\"api_response\"]\n\n        # Filter out columns that don't exist in the dataframe\n        existing_cols = [col for col in ordered_cols if col in result_df.columns]\n\n        return DataFrame(result_df[existing_cols])\n\n    def _create_notion_page(self) -> dict[str, Any]:\n        \"\"\"Internal method to create the Notion page and return the API response.\"\"\"\n        if not self.database_id or self.database_id == \"Loading databases...\":\n            return {\"error\": \"Please select a valid database first.\"}\n\n        # Debug logs\n        self.log(f\"Creating page in database: {self.database_id}\")\n        self.log(f\"Available properties: {self._database_properties}\")\n\n        # Ensure we have database properties\n        if not self._database_properties:\n            self._database_properties = self.fetch_database_properties(self.database_id)\n            self.log(f\"Fetched properties: {self._database_properties}\")\n\n        headers = {\n            \"Authorization\": f\"Bearer {self.notion_secret}\",\n            \"Content-Type\": \"application/json\",\n            \"Notion-Version\": \"2022-06-28\",\n        }\n\n        # Find title property\n        title_property = None\n        for prop_name, prop_info in self._database_properties.items():\n            if prop_info[\"type\"] == \"title\":\n                title_property = prop_name\n                self.log(f\"Found title property: {title_property}\")\n                break\n\n        properties: dict[str, Any] = {}\n        num_properties = getattr(self, \"number_of_properties\", 0)\n        self.log(f\"Processing {num_properties} properties\")\n\n        for i in range(1, num_properties + 1):\n            property_name = getattr(self, f\"property_{i}_name\", None)\n            property_value = getattr(self, f\"property_{i}_value\", None)\n\n            self.log(f\"Processing property {i}:\")\n            self.log(f\"Name: {property_name}\")\n            self.log(f\"Value: {property_value}\")\n\n            # Skip if no property name\n            if not property_name:\n                self.log(\"No property name provided, skipping\")\n                continue\n\n            # Get property info\n            prop_info = self._database_properties.get(property_name)\n            if not prop_info:\n                self.log(f\"Property {property_name} not found in database properties\")\n                continue\n\n            self.log(f\"Property info: {prop_info}\")\n\n            # Get detailed info about this property type\n            prop_type = prop_info[\"type\"]\n            self.log(f\"Property type: {prop_type}\")\n\n            # Skip system properties that can't be set\n            if prop_type in [\"formula\", \"rollup\", \"created_by\", \"last_edited_by\", \"created_time\", \"last_edited_time\"]:\n                self.log(f\"Skipping system/computed property {property_name} of type {prop_type}\")\n                continue\n\n            # Format the value\n            formatted_value = self.format_property_value(\n                property_name, prop_info, property_value if property_value else \"\"\n            )\n\n            self.log(f\"Formatted value: {formatted_value}\")\n\n            # Add to properties if we got a valid formatted value\n            if formatted_value is not None:\n                properties[property_name] = formatted_value\n                self.log(f\"Added property {property_name}\")\n\n            # Check if this is the title property\n            if prop_type == \"title\":\n                title_property = None  # We already have a title set\n\n        # Add default title if needed\n        if title_property:\n            self.log(\"Adding default title property\")\n            properties[title_property] = {\"title\": [{\"type\": \"text\", \"text\": {\"content\": \"New Page\"}}]}\n\n        # Final check\n        if not properties:\n            self.log(\"No properties were created!\")\n            return {\"error\": \"No valid properties defined. Please check the logs for details.\"}\n\n        # Create page data\n        # Extract the pure database ID before sending to the API\n        clean_db_id = self.database_id.split(\"(\")[-1].rstrip(\")\") if \"(\" in self.database_id else self.database_id\n        data = {\"parent\": {\"database_id\": clean_db_id}, \"properties\": properties}\n\n        self.log(f\"Final request data: {json.dumps(data, indent=2)}\")\n\n        # Send request\n        try:\n            response = requests.post(\"https://api.notion.com/v1/pages\", headers=headers, json=data, timeout=10)\n\n            self.log(f\"Response status: {response.status_code}\")\n            self.log(f\"Response body: {response.text}\")\n\n            if not response.ok:\n                error_msg = (\n                    f\"Notion API error: {response.status_code}\\n\"\n                    f\"Response: {response.text}\\n\"\n                    f\"Request data: {json.dumps(data, indent=2)}\"\n                )\n                self.log(error_msg)\n                return {\"error\": error_msg}\n\n            response.raise_for_status()\n            return response.json()\n        except requests.exceptions.RequestException as e:\n            error_msg = f\"Error creating page: {e!s}\"\n            self.log(error_msg)\n            return {\"error\": error_msg}\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None) -> dotdict:\n        \"\"\"Update build configuration based on field updates.\"\"\"\n        try:\n            # When notion_secret is updated or initially loaded\n            if field_name is None or field_name == \"notion_secret\":\n                databases = self.fetch_databases()\n                # Format options as \"Name (ID)\"\n                formatted_dbs: list[str] = []\n                for db in databases:\n                    db_name = db.get(\"title\", [{}])[0].get(\"text\", {}).get(\"content\", \"Untitled\")\n                    db_id = db[\"id\"]\n                    formatted_name = f\"{db_name} ({db_id})\"\n                    formatted_dbs.append(formatted_name)\n\n                build_config[\"database_id\"][\"options\"] = formatted_dbs\n                if databases:\n                    build_config[\"database_id\"][\"value\"] = formatted_dbs[0]\n\n                # Skip setting tooltips to avoid any type errors\n\n            # When database_id changes\n            if field_name == \"database_id\":\n                # Only show number_of_properties and enable it if a valid database is selected\n                if field_value and field_value != \"Loading databases...\":\n                    build_config[\"number_of_properties\"][\"advanced\"] = False\n                    # Reset number of properties to 0 when database changes\n                    build_config[\"number_of_properties\"][\"value\"] = 0\n                    # Store database properties globally\n                    self._database_properties = self.fetch_database_properties(field_value)\n                else:\n                    build_config[\"number_of_properties\"][\"advanced\"] = True\n                    build_config[\"number_of_properties\"][\"value\"] = 0\n                    self._database_properties = {}\n\n            # When number_of_properties changes\n            if field_name == \"number_of_properties\":\n                try:\n                    num_properties = int(field_value)\n                except ValueError:\n                    self.log(\"Invalid number of properties\")\n                    return build_config\n\n                # Validate number of properties\n                if num_properties > self.MAX_PROPERTIES:\n                    num_properties = self.MAX_PROPERTIES\n                    build_config[\"number_of_properties\"][\"value\"] = self.MAX_PROPERTIES\n\n                # Default keys that should not be removed\n                default_keys = {\"code\", \"_type\", \"notion_secret\", \"database_id\", \"number_of_properties\"}\n\n                # Clear existing property fields\n                for key in list(build_config.keys()):\n                    if key not in default_keys:\n                        build_config.pop(key)\n\n                # Get properties from database\n                if not self._database_properties:\n                    self._database_properties = self.fetch_database_properties(self.database_id)\n\n                property_options = list(self._database_properties.keys())\n\n                if not property_options:\n                    property_options = [\"No properties available\"]\n\n                # Create fields for each property\n                for i in range(1, num_properties + 1):\n                    name_key = f\"property_{i}_name\"\n                    value_key = f\"property_{i}_value\"\n\n                    # Add the property name dropdown\n                    build_config[name_key] = DropdownInput(\n                        name=name_key,\n                        display_name=f\"Property {i} - Name\",\n                        info=\"Select the property name\",\n                        options=property_options,\n                        value=property_options[0] if property_options else \"\",\n                    ).to_dict()\n\n                    # Get property type info\n                    prop_type = \"text\"\n                    info_text = \"Enter the value for this property\"\n\n                    if property_options and property_options[0] != \"No properties available\":\n                        first_prop = self._database_properties[property_options[0]]\n                        prop_type = first_prop[\"type\"]\n                        info_text = f\"Enter the value for this property (type: {prop_type})\"\n\n                        if prop_type in [\"select\", \"multi_select\", \"status\"]:\n                            options = first_prop.get(prop_type, {}).get(\"options\", [])\n                            option_names = [opt[\"name\"] for opt in options]\n                            info_text += f\"\\nValid options: {', '.join(option_names)}\"\n                            if prop_type == \"multi_select\":\n                                info_text += \"\\nFor multiple values, separate with commas\"\n\n                        elif prop_type == \"people\":\n                            info_text = (\n                                \"Enter Notion user IDs (not names) for people. Separate multiple IDs with commas.\"\n                            )\n\n                        elif prop_type == \"relation\":\n                            info_text = \"Enter page IDs to link to. Separate multiple IDs with commas.\"\n\n                        elif prop_type in [\n                            \"formula\",\n                            \"rollup\",\n                            \"created_by\",\n                            \"last_edited_by\",\n                            \"created_time\",\n                            \"last_edited_time\",\n                        ]:\n                            info_text = \"This property is computed by Notion and cannot be set manually.\"\n\n                    # Add the value input field\n                    build_config[value_key] = MessageTextInput(\n                        name=value_key,\n                        display_name=f\"Property {i} - Value\",\n                        info=info_text,\n                        placeholder=f\"Enter {prop_type} value...\",\n                    ).to_dict()\n\n                build_config[\"number_of_properties\"][\"value\"] = num_properties\n\n        except (ValueError, KeyError) as e:\n            self.log(f\"Error updating build config: {e!s}\")\n\n            build_config[\"database_id\"][\"options\"] = [\"Error loading databases\"]\n            build_config[\"database_id\"][\"value\"] = \"Error loading databases\"\n            build_config[\"number_of_properties\"][\"advanced\"] = True\n            build_config[\"number_of_properties\"][\"value\"] = 0\n\n        return build_config\n"
              },
              "database_id": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Database Name",
                "dynamic": false,
                "info": "Select a database by name",
                "name": "database_id",
                "options": [
                  "Loading databases..."
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Loading databases..."
              },
              "notion_secret": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Notion Secret",
                "dynamic": false,
                "info": "The Notion integration token.",
                "input_types": [
                  "Message"
                ],
                "load_from_db": false,
                "name": "notion_secret",
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "number_of_properties": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Properties",
                "dynamic": false,
                "info": "Number of properties to add to the page",
                "list": false,
                "list_add_label": "Add More",
                "name": "number_of_properties",
                "placeholder": "",
                "range_spec": {
                  "max": 10,
                  "min": 0,
                  "step": 1,
                  "step_type": "int"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 0
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "NotionPageCreator"
        },
        "dragging": false,
        "id": "NotionPageCreator-7NNuh",
        "measured": {
          "height": 329,
          "width": 320
        },
        "position": {
          "x": 1129.792754507032,
          "y": 1146.4528503004688
        },
        "selected": false,
        "type": "genericNode"
      }
    ],
    "viewport": {
      "x": 232.01833417311275,
      "y": 174.37551097546992,
      "zoom": 0.24999999999999992
    }
  },
  "description": "The Notion Content Orchestration flow creates well-structured markdown content and automatically adds it to Notion pages using a two-agent system.",
  "endpoint_name": null,
  "icon": "Notion",
  "id": "b3c45e9b-3781-495a-a4b2-c1d56f7890ab",
  "is_component": false,
  "last_tested_version": "1.2.0",
  "name": "Notion Content Orchestrator",
  "tags": [
    "agents",
    "assistants"
  ]
}