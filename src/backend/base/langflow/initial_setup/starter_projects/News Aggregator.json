{
  "data": {
    "edges": [
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "AgentQL",
            "id": "AgentQL-064NO",
            "name": "component_as_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-ZH2Rd",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-AgentQL-064NO{Å“dataTypeÅ“:Å“AgentQLÅ“,Å“idÅ“:Å“AgentQL-064NOÅ“,Å“nameÅ“:Å“component_as_toolÅ“,Å“output_typesÅ“:[Å“ToolÅ“]}-Agent-ZH2Rd{Å“fieldNameÅ“:Å“toolsÅ“,Å“idÅ“:Å“Agent-ZH2RdÅ“,Å“inputTypesÅ“:[Å“ToolÅ“],Å“typeÅ“:Å“otherÅ“}",
        "selected": false,
        "source": "AgentQL-064NO",
        "sourceHandle": "{Å“dataTypeÅ“: Å“AgentQLÅ“, Å“idÅ“: Å“AgentQL-064NOÅ“, Å“nameÅ“: Å“component_as_toolÅ“, Å“output_typesÅ“: [Å“ToolÅ“]}",
        "target": "Agent-ZH2Rd",
        "targetHandle": "{Å“fieldNameÅ“: Å“toolsÅ“, Å“idÅ“: Å“Agent-ZH2RdÅ“, Å“inputTypesÅ“: [Å“ToolÅ“], Å“typeÅ“: Å“otherÅ“}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ChatInput",
            "id": "ChatInput-S2wgk",
            "name": "message",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "Agent-ZH2Rd",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-ChatInput-S2wgk{Å“dataTypeÅ“:Å“ChatInputÅ“,Å“idÅ“:Å“ChatInput-S2wgkÅ“,Å“nameÅ“:Å“messageÅ“,Å“output_typesÅ“:[Å“MessageÅ“]}-Agent-ZH2Rd{Å“fieldNameÅ“:Å“input_valueÅ“,Å“idÅ“:Å“Agent-ZH2RdÅ“,Å“inputTypesÅ“:[Å“MessageÅ“],Å“typeÅ“:Å“strÅ“}",
        "selected": false,
        "source": "ChatInput-S2wgk",
        "sourceHandle": "{Å“dataTypeÅ“: Å“ChatInputÅ“, Å“idÅ“: Å“ChatInput-S2wgkÅ“, Å“nameÅ“: Å“messageÅ“, Å“output_typesÅ“: [Å“MessageÅ“]}",
        "target": "Agent-ZH2Rd",
        "targetHandle": "{Å“fieldNameÅ“: Å“input_valueÅ“, Å“idÅ“: Å“Agent-ZH2RdÅ“, Å“inputTypesÅ“: [Å“MessageÅ“], Å“typeÅ“: Å“strÅ“}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Agent",
            "id": "Agent-ZH2Rd",
            "name": "response",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-jNfAw",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-Agent-ZH2Rd{Å“dataTypeÅ“:Å“AgentÅ“,Å“idÅ“:Å“Agent-ZH2RdÅ“,Å“nameÅ“:Å“responseÅ“,Å“output_typesÅ“:[Å“MessageÅ“]}-ChatOutput-jNfAw{Å“fieldNameÅ“:Å“input_valueÅ“,Å“idÅ“:Å“ChatOutput-jNfAwÅ“,Å“inputTypesÅ“:[Å“DataÅ“,Å“DataFrameÅ“,Å“MessageÅ“],Å“typeÅ“:Å“otherÅ“}",
        "selected": false,
        "source": "Agent-ZH2Rd",
        "sourceHandle": "{Å“dataTypeÅ“: Å“AgentÅ“, Å“idÅ“: Å“Agent-ZH2RdÅ“, Å“nameÅ“: Å“responseÅ“, Å“output_typesÅ“: [Å“MessageÅ“]}",
        "target": "ChatOutput-jNfAw",
        "targetHandle": "{Å“fieldNameÅ“: Å“input_valueÅ“, Å“idÅ“: Å“ChatOutput-jNfAwÅ“, Å“inputTypesÅ“: [Å“DataÅ“, Å“DataFrameÅ“, Å“MessageÅ“], Å“typeÅ“: Å“otherÅ“}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ChatOutput",
            "id": "ChatOutput-jNfAw",
            "name": "message",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input",
            "id": "SaveToFile-VVVVb",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__ChatOutput-jNfAw{Å“dataTypeÅ“:Å“ChatOutputÅ“,Å“idÅ“:Å“ChatOutput-jNfAwÅ“,Å“nameÅ“:Å“messageÅ“,Å“output_typesÅ“:[Å“MessageÅ“]}-SaveToFile-VVVVb{Å“fieldNameÅ“:Å“inputÅ“,Å“idÅ“:Å“SaveToFile-VVVVbÅ“,Å“inputTypesÅ“:[Å“DataÅ“,Å“DataFrameÅ“,Å“MessageÅ“],Å“typeÅ“:Å“otherÅ“}",
        "selected": false,
        "source": "ChatOutput-jNfAw",
        "sourceHandle": "{Å“dataTypeÅ“: Å“ChatOutputÅ“, Å“idÅ“: Å“ChatOutput-jNfAwÅ“, Å“nameÅ“: Å“messageÅ“, Å“output_typesÅ“: [Å“MessageÅ“]}",
        "target": "SaveToFile-VVVVb",
        "targetHandle": "{Å“fieldNameÅ“: Å“inputÅ“, Å“idÅ“: Å“SaveToFile-VVVVbÅ“, Å“inputTypesÅ“: [Å“DataÅ“, Å“DataFrameÅ“, Å“MessageÅ“], Å“typeÅ“: Å“otherÅ“}"
      }
    ],
    "nodes": [
      {
        "data": {
          "id": "note-40ntb",
          "node": {
            "description": "### ðŸ’¡ Add your OpenAI API key here",
            "display_name": "",
            "documentation": "",
            "template": {
              "backgroundColor": "transparent"
            }
          },
          "type": "note"
        },
        "dragging": false,
        "id": "note-40ntb",
        "measured": {
          "height": 324,
          "width": 324
        },
        "position": {
          "x": 1173.6948654399118,
          "y": 140.3910247692671
        },
        "selected": false,
        "type": "noteNode"
      },
      {
        "data": {
          "id": "note-UXZI9",
          "node": {
            "description": "### ðŸ’¡ Add your AgentQL API key here",
            "display_name": "",
            "documentation": "",
            "template": {
              "backgroundColor": "transparent"
            }
          },
          "type": "note"
        },
        "dragging": false,
        "height": 346,
        "id": "note-UXZI9",
        "measured": {
          "height": 346,
          "width": 324
        },
        "position": {
          "x": 754.0235442608289,
          "y": 35.586746852834835
        },
        "selected": false,
        "type": "noteNode"
      },
      {
        "data": {
          "description": "Uses AgentQL API to extract structured data from a given URL.",
          "display_name": "AgentQL Query Data",
          "id": "AgentQL-064NO",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extracts structured data from a web page using an AgentQL query or a Natural Language description.",
            "display_name": "Extract Web Data",
            "documentation": "https://docs.agentql.com/rest-api/api-reference",
            "edited": false,
            "field_order": [
              "api_key",
              "url",
              "query",
              "prompt",
              "is_stealth_mode_enabled",
              "timeout",
              "mode",
              "wait_for",
              "is_scroll_to_bottom_enabled",
              "is_screenshot_enabled"
            ],
            "frozen": false,
            "icon": "AgentQL",
            "last_updated": "2025-09-30T16:16:12.099Z",
            "legacy": false,
            "lf_version": "1.4.3",
            "metadata": {
              "code_hash": "37de3210aed9",
              "dependencies": {
                "dependencies": [
                  {
                    "name": "httpx",
                    "version": "0.28.1"
                  },
                  {
                    "name": "lfx",
                    "version": null
                  }
                ],
                "total_dependencies": 2
              },
              "module": "lfx.components.agentql.agentql_api.AgentQL"
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Toolset",
                "group_outputs": false,
                "hidden": null,
                "method": "to_toolkit",
                "name": "component_as_tool",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "AgentQL API Key",
                "dynamic": false,
                "info": "Your AgentQL API key from dev.agentql.com",
                "input_types": [],
                "load_from_db": true,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": "AGENTQL_API_KEY"
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import httpx\n\nfrom lfx.custom.custom_component.component import Component\nfrom lfx.field_typing.range_spec import RangeSpec\nfrom lfx.io import BoolInput, DropdownInput, IntInput, MessageTextInput, MultilineInput, Output, SecretStrInput\nfrom lfx.log.logger import logger\nfrom lfx.schema.data import Data\n\n\nclass AgentQL(Component):\n    display_name = \"Extract Web Data\"\n    description = \"Extracts structured data from a web page using an AgentQL query or a Natural Language description.\"\n    documentation: str = \"https://docs.agentql.com/rest-api/api-reference\"\n    icon = \"AgentQL\"\n    name = \"AgentQL\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"AgentQL API Key\",\n            required=True,\n            password=True,\n            info=\"Your AgentQL API key from dev.agentql.com\",\n        ),\n        MessageTextInput(\n            name=\"url\",\n            display_name=\"URL\",\n            required=True,\n            info=\"The URL of the public web page you want to extract data from.\",\n            tool_mode=True,\n        ),\n        MultilineInput(\n            name=\"query\",\n            display_name=\"AgentQL Query\",\n            required=False,\n            info=\"The AgentQL query to execute. Learn more at https://docs.agentql.com/agentql-query or use a prompt.\",\n            tool_mode=True,\n        ),\n        MultilineInput(\n            name=\"prompt\",\n            display_name=\"Prompt\",\n            required=False,\n            info=\"A Natural Language description of the data to extract from the page. Alternative to AgentQL query.\",\n            tool_mode=True,\n        ),\n        BoolInput(\n            name=\"is_stealth_mode_enabled\",\n            display_name=\"Enable Stealth Mode (Beta)\",\n            info=\"Enable experimental anti-bot evasion strategies. May not work for all websites at all times.\",\n            value=False,\n            advanced=True,\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            info=\"Seconds to wait for a request.\",\n            value=900,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"mode\",\n            display_name=\"Request Mode\",\n            info=\"'standard' uses deep data analysis, while 'fast' trades some depth of analysis for speed.\",\n            options=[\"fast\", \"standard\"],\n            value=\"fast\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"wait_for\",\n            display_name=\"Wait For\",\n            info=\"Seconds to wait for the page to load before extracting data.\",\n            value=0,\n            range_spec=RangeSpec(min=0, max=10, step_type=\"int\"),\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"is_scroll_to_bottom_enabled\",\n            display_name=\"Enable scroll to bottom\",\n            info=\"Scroll to bottom of the page before extracting data.\",\n            value=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"is_screenshot_enabled\",\n            display_name=\"Enable screenshot\",\n            info=\"Take a screenshot before extracting data. Returned in 'metadata' as a Base64 string.\",\n            value=False,\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"build_output\"),\n    ]\n\n    def build_output(self) -> Data:\n        endpoint = \"https://api.agentql.com/v1/query-data\"\n        headers = {\n            \"X-API-Key\": self.api_key,\n            \"Content-Type\": \"application/json\",\n            \"X-TF-Request-Origin\": \"langflow\",\n        }\n\n        payload = {\n            \"url\": self.url,\n            \"query\": self.query,\n            \"prompt\": self.prompt,\n            \"params\": {\n                \"mode\": self.mode,\n                \"wait_for\": self.wait_for,\n                \"is_scroll_to_bottom_enabled\": self.is_scroll_to_bottom_enabled,\n                \"is_screenshot_enabled\": self.is_screenshot_enabled,\n            },\n            \"metadata\": {\n                \"experimental_stealth_mode_enabled\": self.is_stealth_mode_enabled,\n            },\n        }\n\n        if not self.prompt and not self.query:\n            self.status = \"Either Query or Prompt must be provided.\"\n            raise ValueError(self.status)\n        if self.prompt and self.query:\n            self.status = \"Both Query and Prompt can't be provided at the same time.\"\n            raise ValueError(self.status)\n\n        try:\n            response = httpx.post(endpoint, headers=headers, json=payload, timeout=self.timeout)\n            response.raise_for_status()\n\n            json = response.json()\n            data = Data(result=json[\"data\"], metadata=json[\"metadata\"])\n\n        except httpx.HTTPStatusError as e:\n            response = e.response\n            if response.status_code == httpx.codes.UNAUTHORIZED:\n                self.status = \"Please, provide a valid API Key. You can create one at https://dev.agentql.com.\"\n            else:\n                try:\n                    error_json = response.json()\n                    logger.error(\n                        f\"Failure response: '{response.status_code} {response.reason_phrase}' with body: {error_json}\"\n                    )\n                    msg = error_json[\"error_info\"] if \"error_info\" in error_json else error_json[\"detail\"]\n                except (ValueError, TypeError):\n                    msg = f\"HTTP {e}.\"\n                self.status = msg\n            raise ValueError(self.status) from e\n\n        else:\n            self.status = data\n            return data\n"
              },
              "is_screenshot_enabled": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Enable screenshot",
                "dynamic": false,
                "info": "Take a screenshot before extracting data. Returned in 'metadata' as a Base64 string.",
                "list": false,
                "list_add_label": "Add More",
                "name": "is_screenshot_enabled",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "is_scroll_to_bottom_enabled": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Enable scroll to bottom",
                "dynamic": false,
                "info": "Scroll to bottom of the page before extracting data.",
                "list": false,
                "list_add_label": "Add More",
                "name": "is_scroll_to_bottom_enabled",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "is_stealth_mode_enabled": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Enable Stealth Mode (Beta)",
                "dynamic": false,
                "info": "Enable experimental anti-bot evasion strategies. May not work for all websites at all times.",
                "list": false,
                "list_add_label": "Add More",
                "name": "is_stealth_mode_enabled",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "mode": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Request Mode",
                "dynamic": false,
                "info": "'standard' uses deep data analysis, while 'fast' trades some depth of analysis for speed.",
                "name": "mode",
                "options": [
                  "fast",
                  "standard"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "fast"
              },
              "prompt": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Prompt",
                "dynamic": false,
                "info": "A Natural Language description of the data to extract from the page. Alternative to AgentQL query.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "prompt",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "query": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "AgentQL Query",
                "dynamic": false,
                "info": "The AgentQL query to execute. Learn more at https://docs.agentql.com/agentql-query or use a prompt.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "query",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "timeout": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Timeout",
                "dynamic": false,
                "info": "Seconds to wait for a request.",
                "list": false,
                "list_add_label": "Add More",
                "name": "timeout",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 900
              },
              "tools_metadata": {
                "_input_type": "ToolsInput",
                "advanced": false,
                "display_name": "Actions",
                "dynamic": false,
                "info": "Modify tool names and descriptions to help agents understand when to use each tool.",
                "is_list": true,
                "list_add_label": "Add More",
                "name": "tools_metadata",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tools",
                "value": [
                  {
                    "args": {
                      "prompt": {
                        "default": "",
                        "description": "A Natural Language description of the data to extract from the page. Alternative to AgentQL query.",
                        "title": "Prompt",
                        "type": "string"
                      },
                      "query": {
                        "default": "",
                        "description": "The AgentQL query to execute. Learn more at https://docs.agentql.com/agentql-query or use a prompt.",
                        "title": "Query",
                        "type": "string"
                      },
                      "url": {
                        "description": "The URL of the public web page you want to extract data from.",
                        "title": "Url",
                        "type": "string"
                      }
                    },
                    "description": "AgentQL. build_output - Extracts structured data from a web page using an AgentQL query or a Natural Language description.",
                    "display_description": "AgentQL. build_output - Extracts structured data from a web page using an AgentQL query or a Natural Language description.",
                    "display_name": "build_output",
                    "name": "build_output",
                    "readonly": false,
                    "status": true,
                    "tags": [
                      "build_output"
                    ]
                  }
                ]
              },
              "url": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "URL",
                "dynamic": false,
                "info": "The URL of the public web page you want to extract data from.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "url",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "wait_for": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Wait For",
                "dynamic": false,
                "info": "Seconds to wait for the page to load before extracting data.",
                "list": false,
                "list_add_label": "Add More",
                "name": "wait_for",
                "placeholder": "",
                "range_spec": {
                  "max": 10,
                  "min": 0,
                  "step": 0.1,
                  "step_type": "int"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 0
              }
            },
            "tool_mode": true
          },
          "selected_output": "component_as_tool",
          "showNode": true,
          "type": "AgentQL"
        },
        "dragging": false,
        "id": "AgentQL-064NO",
        "measured": {
          "height": 316,
          "width": 320
        },
        "position": {
          "x": 754.0425636172196,
          "y": 87.23877481296148
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatInput-S2wgk",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "inputs",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Get chat inputs from the Playground.",
            "display_name": "Chat Input",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "files",
              "background_color",
              "chat_icon",
              "text_color"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "key": "ChatInput",
            "legacy": false,
            "lf_version": "1.4.3",
            "metadata": {
              "code_hash": "7a26c54d89ed",
              "dependencies": {
                "dependencies": [
                  {
                    "name": "lfx",
                    "version": null
                  }
                ],
                "total_dependencies": 1
              },
              "module": "lfx.components.input_output.chat.ChatInput"
            },
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Chat Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.0020353564437605998,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from lfx.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom lfx.base.io.chat import ChatComponent\nfrom lfx.inputs.inputs import BoolInput\nfrom lfx.io import (\n    DropdownInput,\n    FileInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n)\nfrom lfx.schema.message import Message\nfrom lfx.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_USER,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatInput(ChatComponent):\n    display_name = \"Chat Input\"\n    description = \"Get chat inputs from the Playground.\"\n    documentation: str = \"https://docs.langflow.org/chat-input-and-output\"\n    icon = \"MessagesSquare\"\n    name = \"ChatInput\"\n    minimized = True\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input Text\",\n            value=\"\",\n            info=\"Message to be passed as input.\",\n            input_types=[],\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_USER,\n            info=\"Type of sender.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_USER,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"context_id\",\n            display_name=\"Context ID\",\n            info=\"The context ID of the chat. Adds an extra layer to the local memory.\",\n            value=\"\",\n            advanced=True,\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"Files\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"Files to be sent with the message.\",\n            advanced=True,\n            is_list=True,\n            temp_file=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Chat Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    async def message_response(self) -> Message:\n        # Ensure files is a list and filter out empty/None values\n        files = self.files if self.files else []\n        if files and not isinstance(files, list):\n            files = [files]\n        # Filter out None/empty values\n        files = [f for f in files if f is not None and f != \"\"]\n\n        session_id = self.session_id or self.graph.session_id or \"\"\n        message = await Message.create(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=session_id,\n            context_id=self.context_id,\n            files=files,\n        )\n        if session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n"
              },
              "context_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Context ID",
                "dynamic": false,
                "info": "The context ID of the chat. Adds an extra layer to the local memory.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "context_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "files": {
                "_input_type": "FileInput",
                "advanced": true,
                "display_name": "Files",
                "dynamic": false,
                "fileTypes": [
                  "csv",
                  "json",
                  "pdf",
                  "txt",
                  "md",
                  "mdx",
                  "yaml",
                  "yml",
                  "xml",
                  "html",
                  "htm",
                  "docx",
                  "py",
                  "sh",
                  "sql",
                  "js",
                  "ts",
                  "tsx",
                  "jpg",
                  "jpeg",
                  "png",
                  "bmp",
                  "image"
                ],
                "file_path": "",
                "info": "Files to be sent with the message.",
                "list": true,
                "list_add_label": "Add More",
                "name": "files",
                "placeholder": "",
                "required": false,
                "show": true,
                "temp_file": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "file",
                "value": ""
              },
              "input_value": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "display_name": "Input Text",
                "dynamic": false,
                "info": "Message to be passed as input.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Write a JSON file of all job postings from the following career page: https://www.ycombinator.com/jobs Include columns for: Posted Date (in MM-DD-YYYY format) | Job Title | Company | Location | Job URL | Employment Type (Full-time, Part-time, Contract, etc.) | Remote Eligibility (Yes/No) | Suggested Outreach  In the Suggested Outreach column: Suggest a brief message our recruiters could send to a potential candidate.  At the end, summarize the most in-demand skills and trends based on the job descriptions in a paragraph for our internal hiring strategy report."
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "selected_output": "message",
          "showNode": false,
          "type": "ChatInput"
        },
        "dragging": false,
        "id": "ChatInput-S2wgk",
        "measured": {
          "height": 48,
          "width": 192
        },
        "position": {
          "x": 808.8830410213426,
          "y": 771.0150784240468
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "note-reU70",
          "node": {
            "description": "# News Aggregator\n\nThis flow extracts structured data from a URL and saves it into a JSON file.\n\n## Prerequisites\n\n* **[AgentQL API Key](https://dev.agentql.com/api-keys)**\n* **[OpenAI API Key](https://platform.openai.com/)**\n\n## Quick Start\n\n1. Add your [AgentQL API Key](https://dev.agentql.com/api-keys) to the **AgentQL** component.\n2. Add your [OpenAI API Key](https://platform.openai.com/) to the **Agent** component.\n3. Click **Playground** and enter a question.\n\nThe **Agent** component populates the **AgentQL** component's **URL** and **Query** fields, and returns a structured response to your question. Then the extracted data is saved into a JSON file `news-aggregated.json`, which can be found in your current project directory.",
            "display_name": "",
            "documentation": "",
            "template": {
              "backgroundColor": "amber"
            }
          },
          "type": "note"
        },
        "dragging": false,
        "id": "note-reU70",
        "measured": {
          "height": 696,
          "width": 575
        },
        "position": {
          "x": 135.77506751324216,
          "y": 54.23110716380944
        },
        "selected": false,
        "type": "noteNode"
      },
      {
        "data": {
          "id": "ChatOutput-jNfAw",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template",
              "background_color",
              "chat_icon",
              "text_color",
              "clean_data"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "legacy": false,
            "lf_version": "1.4.3",
            "metadata": {
              "code_hash": "8c87e536cca4",
              "dependencies": {
                "dependencies": [
                  {
                    "name": "orjson",
                    "version": "3.10.15"
                  },
                  {
                    "name": "fastapi",
                    "version": "0.128.0"
                  },
                  {
                    "name": "lfx",
                    "version": null
                  }
                ],
                "total_dependencies": 3
              },
              "module": "lfx.components.input_output.chat_output.ChatOutput"
            },
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Output Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Basic Clean Data",
                "dynamic": false,
                "info": "Whether to clean data before converting to string.",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from collections.abc import Generator\nfrom typing import Any\n\nimport orjson\nfrom fastapi.encoders import jsonable_encoder\n\nfrom lfx.base.io.chat import ChatComponent\nfrom lfx.helpers.data import safe_convert\nfrom lfx.inputs.inputs import BoolInput, DropdownInput, HandleInput, MessageTextInput\nfrom lfx.schema.data import Data\nfrom lfx.schema.dataframe import DataFrame\nfrom lfx.schema.message import Message\nfrom lfx.schema.properties import Source\nfrom lfx.template.field.base import Output\nfrom lfx.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    documentation: str = \"https://docs.langflow.org/chat-input-and-output\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Inputs\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"context_id\",\n            display_name=\"Context ID\",\n            info=\"The context ID of the chat. Adds an extra layer to the local memory.\",\n            value=\"\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Basic Clean Data\",\n            value=True,\n            advanced=True,\n            info=\"Whether to clean data before converting to string.\",\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Output Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n\n        # Get source properties\n        source, _, display_name, source_id = self.get_properties_from_source_component()\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message) and not self.is_connected_to_chat_input():\n            message = self.input_value\n            # Update message properties\n            message.text = text\n            # Preserve existing session_id from the incoming message if it exists\n            existing_session_id = message.session_id\n        else:\n            message = Message(text=text)\n            existing_session_id = None\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        # Preserve session_id from incoming message, or use component/graph session_id\n        message.session_id = (\n            self.session_id or existing_session_id or (self.graph.session_id if hasattr(self, \"graph\") else None) or \"\"\n        )\n        message.context_id = self.context_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n\n        # Store message if needed\n        if message.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _serialize_data(self, data: Data) -> str:\n        \"\"\"Serialize Data object to JSON string.\"\"\"\n        # Convert data.data to JSON-serializable format\n        serializable_data = jsonable_encoder(data.data)\n        # Serialize with orjson, enabling pretty printing with indentation\n        json_bytes = orjson.dumps(serializable_data, option=orjson.OPT_INDENT_2)\n        # Convert bytes to string and wrap in Markdown code blocks\n        return \"```json\\n\" + json_bytes.decode(\"utf-8\") + \"\\n```\"\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            clean_data: bool = getattr(self, \"clean_data\", False)\n            return \"\\n\".join([safe_convert(item, clean_data=clean_data) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return safe_convert(self.input_value)\n"
              },
              "context_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Context ID",
                "dynamic": false,
                "info": "The context ID of the chat. Adds an extra layer to the local memory.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "context_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Inputs",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "selected_output": "message",
          "showNode": false,
          "type": "ChatOutput"
        },
        "dragging": false,
        "id": "ChatOutput-jNfAw",
        "measured": {
          "height": 48,
          "width": 192
        },
        "position": {
          "x": 1550.6058181803635,
          "y": 480.66205042564377
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Agent-ZH2Rd",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Define the agent's instructions, then enter a task to complete using tools.",
            "display_name": "Agent",
            "documentation": "https://docs.langflow.org/agents",
            "edited": false,
            "field_order": [
              "model",
              "api_key",
              "system_prompt",
              "context_id",
              "n_messages",
              "format_instructions",
              "output_schema",
              "tools",
              "input_value",
              "handle_parsing_errors",
              "verbose",
              "max_iterations",
              "agent_description",
              "add_current_date_tool"
            ],
            "frozen": false,
            "icon": "bot",
            "last_updated": "2025-12-11T21:41:48.407Z",
            "legacy": false,
            "metadata": {
              "code_hash": "b60d28d2784f",
              "dependencies": {
                "dependencies": [
                  {
                    "name": "pydantic",
                    "version": "2.11.10"
                  },
                  {
                    "name": "lfx",
                    "version": null
                  },
                  {
                    "name": "langchain_core",
                    "version": "0.3.81"
                  }
                ],
                "total_dependencies": 3
              },
              "module": "lfx.components.models_and_agents.agent.AgentComponent"
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Response",
                "group_outputs": false,
                "method": "message_response",
                "name": "response",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "add_current_date_tool": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Current Date",
                "dynamic": false,
                "info": "If true, will add a tool to the agent that returns the current date.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "add_current_date_tool",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": true
              },
              "agent_description": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "ai_enabled": false,
                "copy_field": false,
                "display_name": "Agent Description [Deprecated]",
                "dynamic": false,
                "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "agent_description",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "A helpful assistant with access to the following tools:"
              },
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": true,
                "display_name": "API Key",
                "dynamic": false,
                "info": "Model Provider API key",
                "input_types": [],
                "load_from_db": true,
                "name": "api_key",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from __future__ import annotations\n\nimport json\nimport re\nfrom typing import TYPE_CHECKING\n\nfrom pydantic import ValidationError\n\nfrom lfx.components.models_and_agents.memory import MemoryComponent\n\nif TYPE_CHECKING:\n    from langchain_core.tools import Tool\n\nfrom lfx.base.agents.agent import LCToolsAgentComponent\nfrom lfx.base.agents.events import ExceptionWithMessageError\nfrom lfx.base.models.unified_models import (\n    get_language_model_options,\n    get_llm,\n    update_model_options_in_build_config,\n)\nfrom lfx.components.helpers import CurrentDateComponent\nfrom lfx.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\nfrom lfx.custom.custom_component.component import get_component_toolkit\nfrom lfx.helpers.base_model import build_model_from_schema\nfrom lfx.inputs.inputs import BoolInput, ModelInput\nfrom lfx.io import IntInput, MessageTextInput, MultilineInput, Output, SecretStrInput, TableInput\nfrom lfx.log.logger import logger\nfrom lfx.schema.data import Data\nfrom lfx.schema.dotdict import dotdict\nfrom lfx.schema.message import Message\nfrom lfx.schema.table import EditMode\n\n\ndef set_advanced_true(component_input):\n    component_input.advanced = True\n    return component_input\n\n\nclass AgentComponent(ToolCallingAgentComponent):\n    display_name: str = \"Agent\"\n    description: str = \"Define the agent's instructions, then enter a task to complete using tools.\"\n    documentation: str = \"https://docs.langflow.org/agents\"\n    icon = \"bot\"\n    beta = False\n    name = \"Agent\"\n\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\n\n    inputs = [\n        ModelInput(\n            name=\"model\",\n            display_name=\"Language Model\",\n            info=\"Select your model provider\",\n            real_time_refresh=True,\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"API Key\",\n            info=\"Model Provider API key\",\n            real_time_refresh=True,\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"system_prompt\",\n            display_name=\"Agent Instructions\",\n            info=\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\",\n            value=\"You are a helpful assistant that can use tools to answer questions and perform tasks.\",\n            advanced=False,\n        ),\n        MessageTextInput(\n            name=\"context_id\",\n            display_name=\"Context ID\",\n            info=\"The context ID of the chat. Adds an extra layer to the local memory.\",\n            value=\"\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"n_messages\",\n            display_name=\"Number of Chat History Messages\",\n            value=100,\n            info=\"Number of chat history messages to retrieve.\",\n            advanced=True,\n            show=True,\n        ),\n        MultilineInput(\n            name=\"format_instructions\",\n            display_name=\"Output Format Instructions\",\n            info=\"Generic Template for structured output formatting. Valid only with Structured response.\",\n            value=(\n                \"You are an AI that extracts structured JSON objects from unstructured text. \"\n                \"Use a predefined schema with expected types (str, int, float, bool, dict). \"\n                \"Extract ALL relevant instances that match the schema - if multiple patterns exist, capture them all. \"\n                \"Fill missing or ambiguous values with defaults: null for missing values. \"\n                \"Remove exact duplicates but keep variations that have different field values. \"\n                \"Always return valid JSON in the expected format, never throw errors. \"\n                \"If multiple objects can be extracted, return them all in the structured format.\"\n            ),\n            advanced=True,\n        ),\n        TableInput(\n            name=\"output_schema\",\n            display_name=\"Output Schema\",\n            info=(\n                \"Schema Validation: Define the structure and data types for structured output. \"\n                \"No validation if no output schema.\"\n            ),\n            advanced=True,\n            required=False,\n            value=[],\n            table_schema=[\n                {\n                    \"name\": \"name\",\n                    \"display_name\": \"Name\",\n                    \"type\": \"str\",\n                    \"description\": \"Specify the name of the output field.\",\n                    \"default\": \"field\",\n                    \"edit_mode\": EditMode.INLINE,\n                },\n                {\n                    \"name\": \"description\",\n                    \"display_name\": \"Description\",\n                    \"type\": \"str\",\n                    \"description\": \"Describe the purpose of the output field.\",\n                    \"default\": \"description of field\",\n                    \"edit_mode\": EditMode.POPOVER,\n                },\n                {\n                    \"name\": \"type\",\n                    \"display_name\": \"Type\",\n                    \"type\": \"str\",\n                    \"edit_mode\": EditMode.INLINE,\n                    \"description\": (\"Indicate the data type of the output field (e.g., str, int, float, bool, dict).\"),\n                    \"options\": [\"str\", \"int\", \"float\", \"bool\", \"dict\"],\n                    \"default\": \"str\",\n                },\n                {\n                    \"name\": \"multiple\",\n                    \"display_name\": \"As List\",\n                    \"type\": \"boolean\",\n                    \"description\": \"Set to True if this output field should be a list of the specified type.\",\n                    \"default\": \"False\",\n                    \"edit_mode\": EditMode.INLINE,\n                },\n            ],\n        ),\n        *LCToolsAgentComponent.get_base_inputs(),\n        # removed memory inputs from agent component\n        # *memory_inputs,\n        BoolInput(\n            name=\"add_current_date_tool\",\n            display_name=\"Current Date\",\n            advanced=True,\n            info=\"If true, will add a tool to the agent that returns the current date.\",\n            value=True,\n        ),\n    ]\n    outputs = [\n        Output(name=\"response\", display_name=\"Response\", method=\"message_response\"),\n    ]\n\n    async def get_agent_requirements(self):\n        \"\"\"Get the agent requirements for the agent.\"\"\"\n        from langchain_core.tools import StructuredTool\n\n        llm_model = get_llm(\n            model=self.model,\n            user_id=self.user_id,\n            api_key=self.api_key,\n        )\n        if llm_model is None:\n            msg = \"No language model selected. Please choose a model to proceed.\"\n            raise ValueError(msg)\n\n        # Get memory data\n        self.chat_history = await self.get_memory_data()\n        await logger.adebug(f\"Retrieved {len(self.chat_history)} chat history messages\")\n        if isinstance(self.chat_history, Message):\n            self.chat_history = [self.chat_history]\n\n        # Add current date tool if enabled\n        if self.add_current_date_tool:\n            if not isinstance(self.tools, list):  # type: ignore[has-type]\n                self.tools = []\n            current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\n\n            if not isinstance(current_date_tool, StructuredTool):\n                msg = \"CurrentDateComponent must be converted to a StructuredTool\"\n                raise TypeError(msg)\n            self.tools.append(current_date_tool)\n\n        # Set shared callbacks for tracing the tools used by the agent\n        self.set_tools_callbacks(self.tools, self._get_shared_callbacks())\n\n        return llm_model, self.chat_history, self.tools\n\n    async def message_response(self) -> Message:\n        try:\n            llm_model, self.chat_history, self.tools = await self.get_agent_requirements()\n            # Set up and run agent\n            self.set(\n                llm=llm_model,\n                tools=self.tools or [],\n                chat_history=self.chat_history,\n                input_value=self.input_value,\n                system_prompt=self.system_prompt,\n            )\n            agent = self.create_agent_runnable()\n            result = await self.run_agent(agent)\n\n            # Store result for potential JSON output\n            self._agent_result = result\n\n        except (ValueError, TypeError, KeyError) as e:\n            await logger.aerror(f\"{type(e).__name__}: {e!s}\")\n            raise\n        except ExceptionWithMessageError as e:\n            await logger.aerror(f\"ExceptionWithMessageError occurred: {e}\")\n            raise\n        # Avoid catching blind Exception; let truly unexpected exceptions propagate\n        except Exception as e:\n            await logger.aerror(f\"Unexpected error: {e!s}\")\n            raise\n        else:\n            return result\n\n    def _preprocess_schema(self, schema):\n        \"\"\"Preprocess schema to ensure correct data types for build_model_from_schema.\"\"\"\n        processed_schema = []\n        for field in schema:\n            processed_field = {\n                \"name\": str(field.get(\"name\", \"field\")),\n                \"type\": str(field.get(\"type\", \"str\")),\n                \"description\": str(field.get(\"description\", \"\")),\n                \"multiple\": field.get(\"multiple\", False),\n            }\n            # Ensure multiple is handled correctly\n            if isinstance(processed_field[\"multiple\"], str):\n                processed_field[\"multiple\"] = processed_field[\"multiple\"].lower() in [\n                    \"true\",\n                    \"1\",\n                    \"t\",\n                    \"y\",\n                    \"yes\",\n                ]\n            processed_schema.append(processed_field)\n        return processed_schema\n\n    async def build_structured_output_base(self, content: str):\n        \"\"\"Build structured output with optional BaseModel validation.\"\"\"\n        json_pattern = r\"\\{.*\\}\"\n        schema_error_msg = \"Try setting an output schema\"\n\n        # Try to parse content as JSON first\n        json_data = None\n        try:\n            json_data = json.loads(content)\n        except json.JSONDecodeError:\n            json_match = re.search(json_pattern, content, re.DOTALL)\n            if json_match:\n                try:\n                    json_data = json.loads(json_match.group())\n                except json.JSONDecodeError:\n                    return {\"content\": content, \"error\": schema_error_msg}\n            else:\n                return {\"content\": content, \"error\": schema_error_msg}\n\n        # If no output schema provided, return parsed JSON without validation\n        if not hasattr(self, \"output_schema\") or not self.output_schema or len(self.output_schema) == 0:\n            return json_data\n\n        # Use BaseModel validation with schema\n        try:\n            processed_schema = self._preprocess_schema(self.output_schema)\n            output_model = build_model_from_schema(processed_schema)\n\n            # Validate against the schema\n            if isinstance(json_data, list):\n                # Multiple objects\n                validated_objects = []\n                for item in json_data:\n                    try:\n                        validated_obj = output_model.model_validate(item)\n                        validated_objects.append(validated_obj.model_dump())\n                    except ValidationError as e:\n                        await logger.aerror(f\"Validation error for item: {e}\")\n                        # Include invalid items with error info\n                        validated_objects.append({\"data\": item, \"validation_error\": str(e)})\n                return validated_objects\n\n            # Single object\n            try:\n                validated_obj = output_model.model_validate(json_data)\n                return [validated_obj.model_dump()]  # Return as list for consistency\n            except ValidationError as e:\n                await logger.aerror(f\"Validation error: {e}\")\n                return [{\"data\": json_data, \"validation_error\": str(e)}]\n\n        except (TypeError, ValueError) as e:\n            await logger.aerror(f\"Error building structured output: {e}\")\n            # Fallback to parsed JSON without validation\n            return json_data\n\n    async def json_response(self) -> Data:\n        \"\"\"Convert agent response to structured JSON Data output with schema validation.\"\"\"\n        # Always use structured chat agent for JSON response mode for better JSON formatting\n        try:\n            system_components = []\n\n            # 1. Agent Instructions (system_prompt)\n            agent_instructions = getattr(self, \"system_prompt\", \"\") or \"\"\n            if agent_instructions:\n                system_components.append(f\"{agent_instructions}\")\n\n            # 2. Format Instructions\n            format_instructions = getattr(self, \"format_instructions\", \"\") or \"\"\n            if format_instructions:\n                system_components.append(f\"Format instructions: {format_instructions}\")\n\n            # 3. Schema Information from BaseModel\n            if hasattr(self, \"output_schema\") and self.output_schema and len(self.output_schema) > 0:\n                try:\n                    processed_schema = self._preprocess_schema(self.output_schema)\n                    output_model = build_model_from_schema(processed_schema)\n                    schema_dict = output_model.model_json_schema()\n                    schema_info = (\n                        \"You are given some text that may include format instructions, \"\n                        \"explanations, or other content alongside a JSON schema.\\n\\n\"\n                        \"Your task:\\n\"\n                        \"- Extract only the JSON schema.\\n\"\n                        \"- Return it as valid JSON.\\n\"\n                        \"- Do not include format instructions, explanations, or extra text.\\n\\n\"\n                        \"Input:\\n\"\n                        f\"{json.dumps(schema_dict, indent=2)}\\n\\n\"\n                        \"Output (only JSON schema):\"\n                    )\n                    system_components.append(schema_info)\n                except (ValidationError, ValueError, TypeError, KeyError) as e:\n                    await logger.aerror(f\"Could not build schema for prompt: {e}\", exc_info=True)\n\n            # Combine all components\n            combined_instructions = \"\\n\\n\".join(system_components) if system_components else \"\"\n            llm_model, self.chat_history, self.tools = await self.get_agent_requirements()\n            self.set(\n                llm=llm_model,\n                tools=self.tools or [],\n                chat_history=self.chat_history,\n                input_value=self.input_value,\n                system_prompt=combined_instructions,\n            )\n\n            # Create and run structured chat agent\n            try:\n                structured_agent = self.create_agent_runnable()\n            except (NotImplementedError, ValueError, TypeError) as e:\n                await logger.aerror(f\"Error with structured chat agent: {e}\")\n                raise\n            try:\n                result = await self.run_agent(structured_agent)\n            except (\n                ExceptionWithMessageError,\n                ValueError,\n                TypeError,\n                RuntimeError,\n            ) as e:\n                await logger.aerror(f\"Error with structured agent result: {e}\")\n                raise\n            # Extract content from structured agent result\n            if hasattr(result, \"content\"):\n                content = result.content\n            elif hasattr(result, \"text\"):\n                content = result.text\n            else:\n                content = str(result)\n\n        except (\n            ExceptionWithMessageError,\n            ValueError,\n            TypeError,\n            NotImplementedError,\n            AttributeError,\n        ) as e:\n            await logger.aerror(f\"Error with structured chat agent: {e}\")\n            # Fallback to regular agent\n            content_str = \"No content returned from agent\"\n            return Data(data={\"content\": content_str, \"error\": str(e)})\n\n        # Process with structured output validation\n        try:\n            structured_output = await self.build_structured_output_base(content)\n\n            # Handle different output formats\n            if isinstance(structured_output, list) and structured_output:\n                if len(structured_output) == 1:\n                    return Data(data=structured_output[0])\n                return Data(data={\"results\": structured_output})\n            if isinstance(structured_output, dict):\n                return Data(data=structured_output)\n            return Data(data={\"content\": content})\n\n        except (ValueError, TypeError) as e:\n            await logger.aerror(f\"Error in structured output processing: {e}\")\n            return Data(data={\"content\": content, \"error\": str(e)})\n\n    async def get_memory_data(self):\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\n        messages = (\n            await MemoryComponent(**self.get_base_args())\n            .set(\n                session_id=self.graph.session_id,\n                context_id=self.context_id,\n                order=\"Ascending\",\n                n_messages=self.n_messages,\n            )\n            .retrieve_messages()\n        )\n        return [\n            message for message in messages if getattr(message, \"id\", None) != getattr(self.input_value, \"id\", None)\n        ]\n\n    def update_input_types(self, build_config: dotdict) -> dotdict:\n        \"\"\"Update input types for all fields in build_config.\"\"\"\n        for key, value in build_config.items():\n            if isinstance(value, dict):\n                if value.get(\"input_types\") is None:\n                    build_config[key][\"input_types\"] = []\n            elif hasattr(value, \"input_types\") and value.input_types is None:\n                value.input_types = []\n        return build_config\n\n    async def update_build_config(\n        self,\n        build_config: dotdict,\n        field_value: list[dict],\n        field_name: str | None = None,\n    ) -> dotdict:\n        # Update model options with caching (for all field changes)\n        # Agents require tool calling, so filter for only tool-calling capable models\n        def get_tool_calling_model_options(user_id=None):\n            return get_language_model_options(user_id=user_id, tool_calling=True)\n\n        build_config = update_model_options_in_build_config(\n            component=self,\n            build_config=dict(build_config),\n            cache_key_prefix=\"language_model_options_tool_calling\",\n            get_options_func=get_tool_calling_model_options,\n            field_name=field_name,\n            field_value=field_value,\n        )\n        build_config = dotdict(build_config)\n\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\n        if field_name == \"model\":\n            # Update input types for all fields\n            build_config = self.update_input_types(build_config)\n\n            # Validate required keys\n            default_keys = [\n                \"code\",\n                \"_type\",\n                \"model\",\n                \"tools\",\n                \"input_value\",\n                \"add_current_date_tool\",\n                \"system_prompt\",\n                \"agent_description\",\n                \"max_iterations\",\n                \"handle_parsing_errors\",\n                \"verbose\",\n            ]\n            missing_keys = [key for key in default_keys if key not in build_config]\n            if missing_keys:\n                msg = f\"Missing required keys in build_config: {missing_keys}\"\n                raise ValueError(msg)\n        return dotdict({k: v.to_dict() if hasattr(v, \"to_dict\") else v for k, v in build_config.items()})\n\n    async def _get_tools(self) -> list[Tool]:\n        component_toolkit = get_component_toolkit()\n        tools_names = self._build_tools_names()\n        agent_description = self.get_tool_description()\n        # TODO: Agent Description Depreciated Feature to be removed\n        description = f\"{agent_description}{tools_names}\"\n\n        tools = component_toolkit(component=self).get_tools(\n            tool_name=\"Call_Agent\",\n            tool_description=description,\n            # here we do not use the shared callbacks as we are exposing the agent as a tool\n            callbacks=self.get_langchain_callbacks(),\n        )\n        if hasattr(self, \"tools_metadata\"):\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\n\n        return tools\n"
              },
              "context_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Context ID",
                "dynamic": false,
                "info": "The context ID of the chat. Adds an extra layer to the local memory.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "context_id",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "format_instructions": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "ai_enabled": false,
                "copy_field": false,
                "display_name": "Output Format Instructions",
                "dynamic": false,
                "info": "Generic Template for structured output formatting. Valid only with Structured response.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "format_instructions",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "You are an AI that extracts structured JSON objects from unstructured text. Use a predefined schema with expected types (str, int, float, bool, dict). Extract ALL relevant instances that match the schema - if multiple patterns exist, capture them all. Fill missing or ambiguous values with defaults: null for missing values. Remove exact duplicates but keep variations that have different field values. Always return valid JSON in the expected format, never throw errors. If multiple objects can be extracted, return them all in the structured format."
              },
              "handle_parsing_errors": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Handle Parse Errors",
                "dynamic": false,
                "info": "Should the Agent fix errors when reading user input for better processing?",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "handle_parsing_errors",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": true
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "The input provided by the user for the agent to process.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "max_iterations": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Iterations",
                "dynamic": false,
                "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "max_iterations",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "int",
                "value": 15
              },
              "model": {
                "_input_type": "ModelInput",
                "advanced": false,
                "display_name": "Language Model",
                "dynamic": false,
                "external_options": {
                  "fields": {
                    "data": {
                      "node": {
                        "display_name": "Connect other models",
                        "icon": "CornerDownLeft",
                        "name": "connect_other_models"
                      }
                    }
                  }
                },
                "info": "Select your model provider",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "model_type": "language",
                "name": "model",
                "options": [],
                "override_skip": false,
                "placeholder": "Setup Provider",
                "real_time_refresh": true,
                "refresh_button": true,
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "track_in_telemetry": false,
                "type": "model",
                "value": []
              },
              "n_messages": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Chat History Messages",
                "dynamic": false,
                "info": "Number of chat history messages to retrieve.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "n_messages",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "int",
                "value": 100
              },
              "output_schema": {
                "_input_type": "TableInput",
                "advanced": true,
                "display_name": "Output Schema",
                "dynamic": false,
                "info": "Schema Validation: Define the structure and data types for structured output. No validation if no output schema.",
                "input_types": [],
                "is_list": true,
                "list_add_label": "Add More",
                "name": "output_schema",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "table_icon": "Table",
                "table_schema": [
                  {
                    "default": "field",
                    "description": "Specify the name of the output field.",
                    "display_name": "Name",
                    "edit_mode": "inline",
                    "name": "name",
                    "type": "str"
                  },
                  {
                    "default": "description of field",
                    "description": "Describe the purpose of the output field.",
                    "display_name": "Description",
                    "edit_mode": "popover",
                    "name": "description",
                    "type": "str"
                  },
                  {
                    "default": "str",
                    "description": "Indicate the data type of the output field (e.g., str, int, float, bool, dict).",
                    "display_name": "Type",
                    "edit_mode": "inline",
                    "name": "type",
                    "options": [
                      "str",
                      "int",
                      "float",
                      "bool",
                      "dict"
                    ],
                    "type": "str"
                  },
                  {
                    "default": "False",
                    "description": "Set to True if this output field should be a list of the specified type.",
                    "display_name": "As List",
                    "edit_mode": "inline",
                    "name": "multiple",
                    "type": "boolean"
                  }
                ],
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "trigger_icon": "Table",
                "trigger_text": "Open table",
                "type": "table",
                "value": []
              },
              "system_prompt": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "ai_enabled": false,
                "copy_field": false,
                "display_name": "Agent Instructions",
                "dynamic": false,
                "info": "System Prompt: Initial instructions and context provided to guide the agent's behavior.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_prompt",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "You are a helpful assistant that can use tools to answer questions and perform tasks."
              },
              "tools": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Tools",
                "dynamic": false,
                "info": "These are the tools that the agent can use to help with tasks.",
                "input_types": [
                  "Tool"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "tools",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "other",
                "value": ""
              },
              "verbose": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Verbose",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "verbose",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Agent"
        },
        "dragging": false,
        "id": "Agent-ZH2Rd",
        "measured": {
          "height": 594,
          "width": 320
        },
        "position": {
          "x": 1151.0943181682178,
          "y": 225.0272050437212
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "SaveToFile-VVVVb",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Save data to local file, AWS S3, or Google Drive in the selected format.",
            "display_name": "Write File",
            "documentation": "https://docs.langflow.org/components-processing#save-file",
            "edited": false,
            "field_order": [
              "storage_location",
              "input",
              "file_name",
              "local_format",
              "aws_format",
              "gdrive_format",
              "aws_access_key_id",
              "aws_secret_access_key",
              "bucket_name",
              "aws_region",
              "s3_prefix",
              "service_account_key",
              "folder_id"
            ],
            "frozen": false,
            "icon": "file-text",
            "last_updated": "2025-09-30T16:16:26.172Z",
            "legacy": false,
            "metadata": {
              "code_hash": "6657b458359b",
              "dependencies": {
                "dependencies": [
                  {
                    "name": "orjson",
                    "version": "3.10.15"
                  },
                  {
                    "name": "pandas",
                    "version": "2.2.3"
                  },
                  {
                    "name": "fastapi",
                    "version": "0.128.0"
                  },
                  {
                    "name": "lfx",
                    "version": null
                  },
                  {
                    "name": "langflow",
                    "version": null
                  },
                  {
                    "name": "boto3",
                    "version": "1.40.61"
                  },
                  {
                    "name": "googleapiclient",
                    "version": "2.154.0"
                  }
                ],
                "total_dependencies": 7
              },
              "module": "lfx.components.files_and_knowledge.save_file.SaveToFileComponent"
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "File Path",
                "group_outputs": false,
                "method": "save_to_file",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "append_mode": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Append",
                "dynamic": false,
                "info": "Append to file if it exists (only for Local storage with plain text formats). Not supported for cloud storage (AWS/Google Drive).",
                "list": false,
                "list_add_label": "Add More",
                "name": "append_mode",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": false
              },
              "aws_access_key_id": {
                "_input_type": "SecretStrInput",
                "advanced": true,
                "display_name": "AWS Access Key ID",
                "dynamic": false,
                "info": "AWS Access key ID.",
                "input_types": [],
                "load_from_db": false,
                "name": "aws_access_key_id",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": false,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "aws_format": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "File Format",
                "dynamic": false,
                "external_options": {},
                "info": "Select the file format for AWS S3 storage.",
                "name": "aws_format",
                "options": [
                  "txt",
                  "json",
                  "csv",
                  "xml",
                  "html",
                  "md",
                  "yaml",
                  "log",
                  "tsv",
                  "jsonl",
                  "parquet",
                  "xlsx",
                  "zip"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "txt"
              },
              "aws_region": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "AWS Region",
                "dynamic": false,
                "info": "AWS region (e.g., us-east-1, eu-west-1).",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "aws_region",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "aws_secret_access_key": {
                "_input_type": "SecretStrInput",
                "advanced": true,
                "display_name": "AWS Secret Key",
                "dynamic": false,
                "info": "AWS Secret Key.",
                "input_types": [],
                "load_from_db": false,
                "name": "aws_secret_access_key",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": false,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "bucket_name": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "S3 Bucket Name",
                "dynamic": false,
                "info": "Enter the name of the S3 bucket.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "bucket_name",
                "placeholder": "",
                "required": true,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nfrom collections.abc import AsyncIterator, Iterator\nfrom pathlib import Path\nfrom typing import Any\n\nimport orjson\nimport pandas as pd\nfrom fastapi import UploadFile\nfrom fastapi.encoders import jsonable_encoder\n\nfrom lfx.custom import Component\nfrom lfx.inputs import SortableListInput\nfrom lfx.io import BoolInput, DropdownInput, HandleInput, SecretStrInput, StrInput\nfrom lfx.schema import Data, DataFrame, Message\nfrom lfx.services.deps import get_settings_service, get_storage_service, session_scope\nfrom lfx.template.field.base import Output\nfrom lfx.utils.validate_cloud import is_astra_cloud_environment\n\n\ndef _get_storage_location_options():\n    \"\"\"Get storage location options, filtering out Local if in Astra cloud environment.\"\"\"\n    all_options = [{\"name\": \"AWS\", \"icon\": \"Amazon\"}, {\"name\": \"Google Drive\", \"icon\": \"google\"}]\n    if is_astra_cloud_environment():\n        return all_options\n    return [{\"name\": \"Local\", \"icon\": \"hard-drive\"}, *all_options]\n\n\nclass SaveToFileComponent(Component):\n    display_name = \"Write File\"\n    description = \"Save data to local file, AWS S3, or Google Drive in the selected format.\"\n    documentation: str = \"https://docs.langflow.org/write-file\"\n    icon = \"file-text\"\n    name = \"SaveToFile\"\n\n    # File format options for different storage types\n    LOCAL_DATA_FORMAT_CHOICES = [\"csv\", \"excel\", \"json\", \"markdown\"]\n    LOCAL_MESSAGE_FORMAT_CHOICES = [\"txt\", \"json\", \"markdown\"]\n    AWS_FORMAT_CHOICES = [\n        \"txt\",\n        \"json\",\n        \"csv\",\n        \"xml\",\n        \"html\",\n        \"md\",\n        \"yaml\",\n        \"log\",\n        \"tsv\",\n        \"jsonl\",\n        \"parquet\",\n        \"xlsx\",\n        \"zip\",\n    ]\n    GDRIVE_FORMAT_CHOICES = [\"txt\", \"json\", \"csv\", \"xlsx\", \"slides\", \"docs\", \"jpg\", \"mp3\"]\n\n    inputs = [\n        # Storage location selection\n        SortableListInput(\n            name=\"storage_location\",\n            display_name=\"Storage Location\",\n            placeholder=\"Select Location\",\n            info=\"Choose where to save the file.\",\n            options=_get_storage_location_options(),\n            real_time_refresh=True,\n            limit=1,\n        ),\n        # Common inputs\n        HandleInput(\n            name=\"input\",\n            display_name=\"File Content\",\n            info=\"The input to save.\",\n            dynamic=True,\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        StrInput(\n            name=\"file_name\",\n            display_name=\"File Name\",\n            info=\"Name file will be saved as (without extension).\",\n            required=True,\n            show=False,\n            tool_mode=True,\n        ),\n        BoolInput(\n            name=\"append_mode\",\n            display_name=\"Append\",\n            info=(\n                \"Append to file if it exists (only for Local storage with plain text formats). \"\n                \"Not supported for cloud storage (AWS/Google Drive).\"\n            ),\n            value=False,\n            show=False,\n        ),\n        # Format inputs (dynamic based on storage location)\n        DropdownInput(\n            name=\"local_format\",\n            display_name=\"File Format\",\n            options=list(dict.fromkeys(LOCAL_DATA_FORMAT_CHOICES + LOCAL_MESSAGE_FORMAT_CHOICES)),\n            info=\"Select the file format for local storage.\",\n            value=\"json\",\n            show=False,\n        ),\n        DropdownInput(\n            name=\"aws_format\",\n            display_name=\"File Format\",\n            options=AWS_FORMAT_CHOICES,\n            info=\"Select the file format for AWS S3 storage.\",\n            value=\"txt\",\n            show=False,\n        ),\n        DropdownInput(\n            name=\"gdrive_format\",\n            display_name=\"File Format\",\n            options=GDRIVE_FORMAT_CHOICES,\n            info=\"Select the file format for Google Drive storage.\",\n            value=\"txt\",\n            show=False,\n        ),\n        # AWS S3 specific inputs\n        SecretStrInput(\n            name=\"aws_access_key_id\",\n            display_name=\"AWS Access Key ID\",\n            info=\"AWS Access key ID.\",\n            show=False,\n            advanced=True,\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"aws_secret_access_key\",\n            display_name=\"AWS Secret Key\",\n            info=\"AWS Secret Key.\",\n            show=False,\n            advanced=True,\n            required=True,\n        ),\n        StrInput(\n            name=\"bucket_name\",\n            display_name=\"S3 Bucket Name\",\n            info=\"Enter the name of the S3 bucket.\",\n            show=False,\n            advanced=True,\n            required=True,\n        ),\n        StrInput(\n            name=\"aws_region\",\n            display_name=\"AWS Region\",\n            info=\"AWS region (e.g., us-east-1, eu-west-1).\",\n            show=False,\n            advanced=True,\n        ),\n        StrInput(\n            name=\"s3_prefix\",\n            display_name=\"S3 Prefix\",\n            info=\"Prefix for all files in S3.\",\n            show=False,\n            advanced=True,\n        ),\n        # Google Drive specific inputs\n        SecretStrInput(\n            name=\"service_account_key\",\n            display_name=\"GCP Credentials Secret Key\",\n            info=\"Your Google Cloud Platform service account JSON key as a secret string (complete JSON content).\",\n            show=False,\n            advanced=True,\n            required=True,\n        ),\n        StrInput(\n            name=\"folder_id\",\n            display_name=\"Google Drive Folder ID\",\n            info=(\n                \"The Google Drive folder ID where the file will be uploaded. \"\n                \"The folder must be shared with the service account email.\"\n            ),\n            required=True,\n            show=False,\n            advanced=True,\n        ),\n    ]\n\n    outputs = [Output(display_name=\"File Path\", name=\"message\", method=\"save_to_file\")]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Update build configuration to show/hide fields based on storage location selection.\"\"\"\n        # Update options dynamically based on cloud environment\n        # This ensures options are refreshed when build_config is updated\n        if \"storage_location\" in build_config:\n            updated_options = _get_storage_location_options()\n            build_config[\"storage_location\"][\"options\"] = updated_options\n\n        if field_name != \"storage_location\":\n            return build_config\n\n        # Extract selected storage location\n        selected = [location[\"name\"] for location in field_value] if isinstance(field_value, list) else []\n\n        # Hide all dynamic fields first\n        dynamic_fields = [\n            \"file_name\",  # Common fields (input is always visible)\n            \"append_mode\",\n            \"local_format\",\n            \"aws_format\",\n            \"gdrive_format\",\n            \"aws_access_key_id\",\n            \"aws_secret_access_key\",\n            \"bucket_name\",\n            \"aws_region\",\n            \"s3_prefix\",\n            \"service_account_key\",\n            \"folder_id\",\n        ]\n\n        for f_name in dynamic_fields:\n            if f_name in build_config:\n                build_config[f_name][\"show\"] = False\n\n        # Show fields based on selected storage location\n        if len(selected) == 1:\n            location = selected[0]\n\n            # Show file_name when any storage location is selected\n            if \"file_name\" in build_config:\n                build_config[\"file_name\"][\"show\"] = True\n\n            # Show append_mode only for Local storage (not supported for cloud storage)\n            if \"append_mode\" in build_config:\n                build_config[\"append_mode\"][\"show\"] = location == \"Local\"\n\n            if location == \"Local\":\n                if \"local_format\" in build_config:\n                    build_config[\"local_format\"][\"show\"] = True\n\n            elif location == \"AWS\":\n                aws_fields = [\n                    \"aws_format\",\n                    \"aws_access_key_id\",\n                    \"aws_secret_access_key\",\n                    \"bucket_name\",\n                    \"aws_region\",\n                    \"s3_prefix\",\n                ]\n                for f_name in aws_fields:\n                    if f_name in build_config:\n                        build_config[f_name][\"show\"] = True\n                        build_config[f_name][\"advanced\"] = False\n\n            elif location == \"Google Drive\":\n                gdrive_fields = [\"gdrive_format\", \"service_account_key\", \"folder_id\"]\n                for f_name in gdrive_fields:\n                    if f_name in build_config:\n                        build_config[f_name][\"show\"] = True\n                        build_config[f_name][\"advanced\"] = False\n\n        return build_config\n\n    async def save_to_file(self) -> Message:\n        \"\"\"Save the input to a file and upload it, returning a confirmation message.\"\"\"\n        # Validate inputs\n        if not self.file_name:\n            msg = \"File name must be provided.\"\n            raise ValueError(msg)\n        if not self._get_input_type():\n            msg = \"Input type is not set.\"\n            raise ValueError(msg)\n\n        # Get selected storage location\n        storage_location = self._get_selected_storage_location()\n        if not storage_location:\n            msg = \"Storage location must be selected.\"\n            raise ValueError(msg)\n\n        # Check if Local storage is disabled in cloud environment\n        if storage_location == \"Local\" and is_astra_cloud_environment():\n            msg = \"Local storage is not available in cloud environment. Please use AWS or Google Drive.\"\n            raise ValueError(msg)\n\n        # Route to appropriate save method based on storage location\n        if storage_location == \"Local\":\n            return await self._save_to_local()\n        if storage_location == \"AWS\":\n            return await self._save_to_aws()\n        if storage_location == \"Google Drive\":\n            return await self._save_to_google_drive()\n        msg = f\"Unsupported storage location: {storage_location}\"\n        raise ValueError(msg)\n\n    def _get_input_type(self) -> str:\n        \"\"\"Determine the input type based on the provided input.\"\"\"\n        # Use exact type checking (type() is) instead of isinstance() to avoid inheritance issues.\n        # Since Message inherits from Data, isinstance(message, Data) would return True for Message objects,\n        # causing Message inputs to be incorrectly identified as Data type.\n        if type(self.input) is DataFrame:\n            return \"DataFrame\"\n        if type(self.input) is Message:\n            return \"Message\"\n        if type(self.input) is Data:\n            return \"Data\"\n        msg = f\"Unsupported input type: {type(self.input)}\"\n        raise ValueError(msg)\n\n    def _get_default_format(self) -> str:\n        \"\"\"Return the default file format based on input type.\"\"\"\n        if self._get_input_type() == \"DataFrame\":\n            return \"csv\"\n        if self._get_input_type() == \"Data\":\n            return \"json\"\n        if self._get_input_type() == \"Message\":\n            return \"json\"\n        return \"json\"  # Fallback\n\n    def _adjust_file_path_with_format(self, path: Path, fmt: str) -> Path:\n        \"\"\"Adjust the file path to include the correct extension.\"\"\"\n        file_extension = path.suffix.lower().lstrip(\".\")\n        if fmt == \"excel\":\n            return Path(f\"{path}.xlsx\").expanduser() if file_extension not in [\"xlsx\", \"xls\"] else path\n        return Path(f\"{path}.{fmt}\").expanduser() if file_extension != fmt else path\n\n    def _is_plain_text_format(self, fmt: str) -> bool:\n        \"\"\"Check if a file format is plain text (supports appending).\"\"\"\n        plain_text_formats = [\"txt\", \"json\", \"markdown\", \"md\", \"csv\", \"xml\", \"html\", \"yaml\", \"log\", \"tsv\", \"jsonl\"]\n        return fmt.lower() in plain_text_formats\n\n    async def _upload_file(self, file_path: Path) -> None:\n        \"\"\"Upload the saved file using the upload_user_file service.\"\"\"\n        from langflow.api.v2.files import upload_user_file\n        from langflow.services.database.models.user.crud import get_user_by_id\n\n        # Ensure the file exists\n        if not file_path.exists():\n            msg = f\"File not found: {file_path}\"\n            raise FileNotFoundError(msg)\n\n        # Upload the file - always use append=False because the local file already contains\n        # the correct content (either new or appended locally)\n        with file_path.open(\"rb\") as f:\n            async with session_scope() as db:\n                if not self.user_id:\n                    msg = \"User ID is required for file saving.\"\n                    raise ValueError(msg)\n                current_user = await get_user_by_id(db, self.user_id)\n\n                await upload_user_file(\n                    file=UploadFile(filename=file_path.name, file=f, size=file_path.stat().st_size),\n                    session=db,\n                    current_user=current_user,\n                    storage_service=get_storage_service(),\n                    settings_service=get_settings_service(),\n                    append=False,\n                )\n\n    def _save_dataframe(self, dataframe: DataFrame, path: Path, fmt: str) -> str:\n        \"\"\"Save a DataFrame to the specified file format.\"\"\"\n        append_mode = getattr(self, \"append_mode\", False)\n        should_append = append_mode and path.exists() and self._is_plain_text_format(fmt)\n\n        if fmt == \"csv\":\n            dataframe.to_csv(path, index=False, mode=\"a\" if should_append else \"w\", header=not should_append)\n        elif fmt == \"excel\":\n            dataframe.to_excel(path, index=False, engine=\"openpyxl\")\n        elif fmt == \"json\":\n            if should_append:\n                # Read and parse existing JSON\n                existing_data = []\n                try:\n                    existing_content = path.read_text(encoding=\"utf-8\").strip()\n                    if existing_content:\n                        parsed = json.loads(existing_content)\n                        # Handle case where existing content is a single object\n                        if isinstance(parsed, dict):\n                            existing_data = [parsed]\n                        elif isinstance(parsed, list):\n                            existing_data = parsed\n                except (json.JSONDecodeError, FileNotFoundError):\n                    # Treat parse errors or missing file as empty array\n                    existing_data = []\n\n                # Append new data\n                new_records = json.loads(dataframe.to_json(orient=\"records\"))\n                existing_data.extend(new_records)\n\n                # Write back as a single JSON array\n                path.write_text(json.dumps(existing_data, indent=2), encoding=\"utf-8\")\n            else:\n                dataframe.to_json(path, orient=\"records\", indent=2)\n        elif fmt == \"markdown\":\n            content = dataframe.to_markdown(index=False)\n            if should_append:\n                path.write_text(path.read_text(encoding=\"utf-8\") + \"\\n\\n\" + content, encoding=\"utf-8\")\n            else:\n                path.write_text(content, encoding=\"utf-8\")\n        else:\n            msg = f\"Unsupported DataFrame format: {fmt}\"\n            raise ValueError(msg)\n        action = \"appended to\" if should_append else \"saved successfully as\"\n        return f\"DataFrame {action} '{path}'\"\n\n    def _save_data(self, data: Data, path: Path, fmt: str) -> str:\n        \"\"\"Save a Data object to the specified file format.\"\"\"\n        append_mode = getattr(self, \"append_mode\", False)\n        should_append = append_mode and path.exists() and self._is_plain_text_format(fmt)\n\n        if fmt == \"csv\":\n            pd.DataFrame(data.data).to_csv(\n                path,\n                index=False,\n                mode=\"a\" if should_append else \"w\",\n                header=not should_append,\n            )\n        elif fmt == \"excel\":\n            pd.DataFrame(data.data).to_excel(path, index=False, engine=\"openpyxl\")\n        elif fmt == \"json\":\n            new_data = jsonable_encoder(data.data)\n            if should_append:\n                # Read and parse existing JSON\n                existing_data = []\n                try:\n                    existing_content = path.read_text(encoding=\"utf-8\").strip()\n                    if existing_content:\n                        parsed = json.loads(existing_content)\n                        # Handle case where existing content is a single object\n                        if isinstance(parsed, dict):\n                            existing_data = [parsed]\n                        elif isinstance(parsed, list):\n                            existing_data = parsed\n                except (json.JSONDecodeError, FileNotFoundError):\n                    # Treat parse errors or missing file as empty array\n                    existing_data = []\n\n                # Append new data\n                if isinstance(new_data, list):\n                    existing_data.extend(new_data)\n                else:\n                    existing_data.append(new_data)\n\n                # Write back as a single JSON array\n                path.write_text(json.dumps(existing_data, indent=2), encoding=\"utf-8\")\n            else:\n                content = orjson.dumps(new_data, option=orjson.OPT_INDENT_2).decode(\"utf-8\")\n                path.write_text(content, encoding=\"utf-8\")\n        elif fmt == \"markdown\":\n            content = pd.DataFrame(data.data).to_markdown(index=False)\n            if should_append:\n                path.write_text(path.read_text(encoding=\"utf-8\") + \"\\n\\n\" + content, encoding=\"utf-8\")\n            else:\n                path.write_text(content, encoding=\"utf-8\")\n        else:\n            msg = f\"Unsupported Data format: {fmt}\"\n            raise ValueError(msg)\n        action = \"appended to\" if should_append else \"saved successfully as\"\n        return f\"Data {action} '{path}'\"\n\n    async def _save_message(self, message: Message, path: Path, fmt: str) -> str:\n        \"\"\"Save a Message to the specified file format, handling async iterators.\"\"\"\n        content = \"\"\n        if message.text is None:\n            content = \"\"\n        elif isinstance(message.text, AsyncIterator):\n            async for item in message.text:\n                content += str(item) + \" \"\n            content = content.strip()\n        elif isinstance(message.text, Iterator):\n            content = \" \".join(str(item) for item in message.text)\n        else:\n            content = str(message.text)\n\n        append_mode = getattr(self, \"append_mode\", False)\n        should_append = append_mode and path.exists() and self._is_plain_text_format(fmt)\n\n        if fmt == \"txt\":\n            if should_append:\n                path.write_text(path.read_text(encoding=\"utf-8\") + \"\\n\" + content, encoding=\"utf-8\")\n            else:\n                path.write_text(content, encoding=\"utf-8\")\n        elif fmt == \"json\":\n            new_message = {\"message\": content}\n            if should_append:\n                # Read and parse existing JSON\n                existing_data = []\n                try:\n                    existing_content = path.read_text(encoding=\"utf-8\").strip()\n                    if existing_content:\n                        parsed = json.loads(existing_content)\n                        # Handle case where existing content is a single object\n                        if isinstance(parsed, dict):\n                            existing_data = [parsed]\n                        elif isinstance(parsed, list):\n                            existing_data = parsed\n                except (json.JSONDecodeError, FileNotFoundError):\n                    # Treat parse errors or missing file as empty array\n                    existing_data = []\n\n                # Append new message\n                existing_data.append(new_message)\n\n                # Write back as a single JSON array\n                path.write_text(json.dumps(existing_data, indent=2), encoding=\"utf-8\")\n            else:\n                path.write_text(json.dumps(new_message, indent=2), encoding=\"utf-8\")\n        elif fmt == \"markdown\":\n            md_content = f\"**Message:**\\n\\n{content}\"\n            if should_append:\n                path.write_text(path.read_text(encoding=\"utf-8\") + \"\\n\\n\" + md_content, encoding=\"utf-8\")\n            else:\n                path.write_text(md_content, encoding=\"utf-8\")\n        else:\n            msg = f\"Unsupported Message format: {fmt}\"\n            raise ValueError(msg)\n        action = \"appended to\" if should_append else \"saved successfully as\"\n        return f\"Message {action} '{path}'\"\n\n    def _get_selected_storage_location(self) -> str:\n        \"\"\"Get the selected storage location from the SortableListInput.\"\"\"\n        if hasattr(self, \"storage_location\") and self.storage_location:\n            if isinstance(self.storage_location, list) and len(self.storage_location) > 0:\n                return self.storage_location[0].get(\"name\", \"\")\n            if isinstance(self.storage_location, dict):\n                return self.storage_location.get(\"name\", \"\")\n        return \"\"\n\n    def _get_file_format_for_location(self, location: str) -> str:\n        \"\"\"Get the appropriate file format based on storage location.\"\"\"\n        if location == \"Local\":\n            return getattr(self, \"local_format\", None) or self._get_default_format()\n        if location == \"AWS\":\n            return getattr(self, \"aws_format\", \"txt\")\n        if location == \"Google Drive\":\n            return getattr(self, \"gdrive_format\", \"txt\")\n        return self._get_default_format()\n\n    async def _save_to_local(self) -> Message:\n        \"\"\"Save file to local storage (original functionality).\"\"\"\n        file_format = self._get_file_format_for_location(\"Local\")\n\n        # Validate file format based on input type\n        allowed_formats = (\n            self.LOCAL_MESSAGE_FORMAT_CHOICES if self._get_input_type() == \"Message\" else self.LOCAL_DATA_FORMAT_CHOICES\n        )\n        if file_format not in allowed_formats:\n            msg = f\"Invalid file format '{file_format}' for {self._get_input_type()}. Allowed: {allowed_formats}\"\n            raise ValueError(msg)\n\n        # Prepare file path\n        file_path = Path(self.file_name).expanduser()\n        if not file_path.parent.exists():\n            file_path.parent.mkdir(parents=True, exist_ok=True)\n        file_path = self._adjust_file_path_with_format(file_path, file_format)\n\n        # Save the input to file based on type\n        if self._get_input_type() == \"DataFrame\":\n            confirmation = self._save_dataframe(self.input, file_path, file_format)\n        elif self._get_input_type() == \"Data\":\n            confirmation = self._save_data(self.input, file_path, file_format)\n        elif self._get_input_type() == \"Message\":\n            confirmation = await self._save_message(self.input, file_path, file_format)\n        else:\n            msg = f\"Unsupported input type: {self._get_input_type()}\"\n            raise ValueError(msg)\n\n        # Upload the saved file\n        await self._upload_file(file_path)\n\n        # Return the final file path and confirmation message\n        final_path = Path.cwd() / file_path if not file_path.is_absolute() else file_path\n        return Message(text=f\"{confirmation} at {final_path}\")\n\n    async def _save_to_aws(self) -> Message:\n        \"\"\"Save file to AWS S3 using S3 functionality.\"\"\"\n        import os\n\n        import boto3\n\n        from lfx.base.data.cloud_storage_utils import create_s3_client, validate_aws_credentials\n\n        # Get AWS credentials from component inputs or fall back to environment variables\n        aws_access_key_id = getattr(self, \"aws_access_key_id\", None)\n        if aws_access_key_id and hasattr(aws_access_key_id, \"get_secret_value\"):\n            aws_access_key_id = aws_access_key_id.get_secret_value()\n        if not aws_access_key_id:\n            aws_access_key_id = os.getenv(\"AWS_ACCESS_KEY_ID\")\n\n        aws_secret_access_key = getattr(self, \"aws_secret_access_key\", None)\n        if aws_secret_access_key and hasattr(aws_secret_access_key, \"get_secret_value\"):\n            aws_secret_access_key = aws_secret_access_key.get_secret_value()\n        if not aws_secret_access_key:\n            aws_secret_access_key = os.getenv(\"AWS_SECRET_ACCESS_KEY\")\n\n        bucket_name = getattr(self, \"bucket_name\", None)\n        if not bucket_name:\n            # Try to get from storage service settings\n            settings = get_settings_service().settings\n            bucket_name = settings.object_storage_bucket_name\n\n        # Validate AWS credentials\n        if not aws_access_key_id:\n            msg = (\n                \"AWS Access Key ID is required for S3 storage. Provide it as a component input \"\n                \"or set AWS_ACCESS_KEY_ID environment variable.\"\n            )\n            raise ValueError(msg)\n        if not aws_secret_access_key:\n            msg = (\n                \"AWS Secret Key is required for S3 storage. Provide it as a component input \"\n                \"or set AWS_SECRET_ACCESS_KEY environment variable.\"\n            )\n            raise ValueError(msg)\n        if not bucket_name:\n            msg = (\n                \"S3 Bucket Name is required for S3 storage. Provide it as a component input \"\n                \"or set LANGFLOW_OBJECT_STORAGE_BUCKET_NAME environment variable.\"\n            )\n            raise ValueError(msg)\n\n        # Validate AWS credentials\n        validate_aws_credentials(self)\n\n        # Create S3 client\n        s3_client = create_s3_client(self)\n        client_config: dict[str, Any] = {\n            \"aws_access_key_id\": str(aws_access_key_id),\n            \"aws_secret_access_key\": str(aws_secret_access_key),\n        }\n\n        # Get region from component input, environment variable, or settings\n        aws_region = getattr(self, \"aws_region\", None)\n        if not aws_region:\n            aws_region = os.getenv(\"AWS_DEFAULT_REGION\") or os.getenv(\"AWS_REGION\")\n        if aws_region:\n            client_config[\"region_name\"] = str(aws_region)\n\n        s3_client = boto3.client(\"s3\", **client_config)\n\n        # Extract content\n        content = self._extract_content_for_upload()\n        file_format = self._get_file_format_for_location(\"AWS\")\n\n        # Generate file path\n        file_path = f\"{self.file_name}.{file_format}\"\n        if hasattr(self, \"s3_prefix\") and self.s3_prefix:\n            file_path = f\"{self.s3_prefix.rstrip('/')}/{file_path}\"\n\n        # Create temporary file\n        import tempfile\n\n        with tempfile.NamedTemporaryFile(\n            mode=\"w\", encoding=\"utf-8\", suffix=f\".{file_format}\", delete=False\n        ) as temp_file:\n            temp_file.write(content)\n            temp_file_path = temp_file.name\n\n        try:\n            # Upload to S3\n            s3_client.upload_file(temp_file_path, bucket_name, file_path)\n            s3_url = f\"s3://{bucket_name}/{file_path}\"\n            return Message(text=f\"File successfully uploaded to {s3_url}\")\n        finally:\n            # Clean up temp file\n            if Path(temp_file_path).exists():\n                Path(temp_file_path).unlink()\n\n    async def _save_to_google_drive(self) -> Message:\n        \"\"\"Save file to Google Drive using Google Drive functionality.\"\"\"\n        import tempfile\n\n        from googleapiclient.http import MediaFileUpload\n\n        from lfx.base.data.cloud_storage_utils import create_google_drive_service\n\n        # Validate Google Drive credentials\n        if not getattr(self, \"service_account_key\", None):\n            msg = \"GCP Credentials Secret Key is required for Google Drive storage\"\n            raise ValueError(msg)\n        if not getattr(self, \"folder_id\", None):\n            msg = \"Google Drive Folder ID is required for Google Drive storage\"\n            raise ValueError(msg)\n\n        # Create Google Drive service with full drive scope (needed for folder operations)\n        drive_service, credentials = create_google_drive_service(\n            self.service_account_key, scopes=[\"https://www.googleapis.com/auth/drive\"], return_credentials=True\n        )\n\n        # Extract content and format\n        content = self._extract_content_for_upload()\n        file_format = self._get_file_format_for_location(\"Google Drive\")\n\n        # Handle special Google Drive formats\n        if file_format in [\"slides\", \"docs\"]:\n            return await self._save_to_google_apps(drive_service, credentials, content, file_format)\n\n        # Create temporary file\n        file_path = f\"{self.file_name}.{file_format}\"\n        with tempfile.NamedTemporaryFile(\n            mode=\"w\",\n            encoding=\"utf-8\",\n            suffix=f\".{file_format}\",\n            delete=False,\n        ) as temp_file:\n            temp_file.write(content)\n            temp_file_path = temp_file.name\n\n        try:\n            # Upload to Google Drive\n            # Note: We skip explicit folder verification since it requires broader permissions.\n            # If the folder doesn't exist or isn't accessible, the create() call will fail with a clear error.\n            file_metadata = {\"name\": file_path, \"parents\": [self.folder_id]}\n            media = MediaFileUpload(temp_file_path, resumable=True)\n\n            try:\n                uploaded_file = (\n                    drive_service.files().create(body=file_metadata, media_body=media, fields=\"id\").execute()\n                )\n            except Exception as e:\n                msg = (\n                    f\"Unable to upload file to Google Drive folder '{self.folder_id}'. \"\n                    f\"Error: {e!s}. \"\n                    \"Please ensure: 1) The folder ID is correct, 2) The folder exists, \"\n                    \"3) The service account has been granted access to this folder.\"\n                )\n                raise ValueError(msg) from e\n\n            file_id = uploaded_file.get(\"id\")\n            file_url = f\"https://drive.google.com/file/d/{file_id}/view\"\n            return Message(text=f\"File successfully uploaded to Google Drive: {file_url}\")\n        finally:\n            # Clean up temp file\n            if Path(temp_file_path).exists():\n                Path(temp_file_path).unlink()\n\n    async def _save_to_google_apps(self, drive_service, credentials, content: str, app_type: str) -> Message:\n        \"\"\"Save content to Google Apps (Slides or Docs).\"\"\"\n        import time\n\n        if app_type == \"slides\":\n            from googleapiclient.discovery import build\n\n            slides_service = build(\"slides\", \"v1\", credentials=credentials)\n\n            file_metadata = {\n                \"name\": self.file_name,\n                \"mimeType\": \"application/vnd.google-apps.presentation\",\n                \"parents\": [self.folder_id],\n            }\n\n            created_file = drive_service.files().create(body=file_metadata, fields=\"id\").execute()\n            presentation_id = created_file[\"id\"]\n\n            time.sleep(2)  # Wait for file to be available  # noqa: ASYNC251\n\n            presentation = slides_service.presentations().get(presentationId=presentation_id).execute()\n            slide_id = presentation[\"slides\"][0][\"objectId\"]\n\n            # Add content to slide\n            requests = [\n                {\n                    \"createShape\": {\n                        \"objectId\": \"TextBox_01\",\n                        \"shapeType\": \"TEXT_BOX\",\n                        \"elementProperties\": {\n                            \"pageObjectId\": slide_id,\n                            \"size\": {\n                                \"height\": {\"magnitude\": 3000000, \"unit\": \"EMU\"},\n                                \"width\": {\"magnitude\": 6000000, \"unit\": \"EMU\"},\n                            },\n                            \"transform\": {\n                                \"scaleX\": 1,\n                                \"scaleY\": 1,\n                                \"translateX\": 1000000,\n                                \"translateY\": 1000000,\n                                \"unit\": \"EMU\",\n                            },\n                        },\n                    }\n                },\n                {\"insertText\": {\"objectId\": \"TextBox_01\", \"insertionIndex\": 0, \"text\": content}},\n            ]\n\n            slides_service.presentations().batchUpdate(\n                presentationId=presentation_id, body={\"requests\": requests}\n            ).execute()\n            file_url = f\"https://docs.google.com/presentation/d/{presentation_id}/edit\"\n\n        elif app_type == \"docs\":\n            from googleapiclient.discovery import build\n\n            docs_service = build(\"docs\", \"v1\", credentials=credentials)\n\n            file_metadata = {\n                \"name\": self.file_name,\n                \"mimeType\": \"application/vnd.google-apps.document\",\n                \"parents\": [self.folder_id],\n            }\n\n            created_file = drive_service.files().create(body=file_metadata, fields=\"id\").execute()\n            document_id = created_file[\"id\"]\n\n            time.sleep(2)  # Wait for file to be available  # noqa: ASYNC251\n\n            # Add content to document\n            requests = [{\"insertText\": {\"location\": {\"index\": 1}, \"text\": content}}]\n            docs_service.documents().batchUpdate(documentId=document_id, body={\"requests\": requests}).execute()\n            file_url = f\"https://docs.google.com/document/d/{document_id}/edit\"\n\n        return Message(text=f\"File successfully created in Google {app_type.title()}: {file_url}\")\n\n    def _extract_content_for_upload(self) -> str:\n        \"\"\"Extract content from input for upload to cloud services.\"\"\"\n        if self._get_input_type() == \"DataFrame\":\n            return self.input.to_csv(index=False)\n        if self._get_input_type() == \"Data\":\n            if hasattr(self.input, \"data\") and self.input.data:\n                if isinstance(self.input.data, dict):\n                    import json\n\n                    return json.dumps(self.input.data, indent=2, ensure_ascii=False)\n                return str(self.input.data)\n            return str(self.input)\n        if self._get_input_type() == \"Message\":\n            return str(self.input.text) if self.input.text else str(self.input)\n        return str(self.input)\n"
              },
              "file_name": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "File Name",
                "dynamic": false,
                "info": "Name file will be saved as (without extension).",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "file_name",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "news-aggregated"
              },
              "folder_id": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Google Drive Folder ID",
                "dynamic": false,
                "info": "The Google Drive folder ID where the file will be uploaded. The folder must be shared with the service account email.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "folder_id",
                "placeholder": "",
                "required": true,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "gdrive_format": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "File Format",
                "dynamic": false,
                "external_options": {},
                "info": "Select the file format for Google Drive storage.",
                "name": "gdrive_format",
                "options": [
                  "txt",
                  "json",
                  "csv",
                  "xlsx",
                  "slides",
                  "docs",
                  "jpg",
                  "mp3"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "txt"
              },
              "input": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "File Content",
                "dynamic": true,
                "info": "The input to save.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "local_format": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "File Format",
                "dynamic": false,
                "external_options": {},
                "info": "Select the file format for local storage.",
                "name": "local_format",
                "options": [
                  "csv",
                  "excel",
                  "json",
                  "markdown",
                  "txt"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "json"
              },
              "s3_prefix": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "S3 Prefix",
                "dynamic": false,
                "info": "Prefix for all files in S3.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "s3_prefix",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "service_account_key": {
                "_input_type": "SecretStrInput",
                "advanced": true,
                "display_name": "GCP Credentials Secret Key",
                "dynamic": false,
                "info": "Your Google Cloud Platform service account JSON key as a secret string (complete JSON content).",
                "input_types": [],
                "load_from_db": false,
                "name": "service_account_key",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": false,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "storage_location": {
                "_input_type": "SortableListInput",
                "advanced": false,
                "display_name": "Storage Location",
                "dynamic": false,
                "info": "Choose where to save the file.",
                "limit": 1,
                "name": "storage_location",
                "options": [
                  {
                    "icon": "hard-drive",
                    "name": "Local"
                  },
                  {
                    "icon": "Amazon",
                    "name": "AWS"
                  },
                  {
                    "icon": "google",
                    "name": "Google Drive"
                  }
                ],
                "placeholder": "Select Location",
                "real_time_refresh": true,
                "required": false,
                "search_category": [],
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "sortableList",
                "value": [
                  {
                    "chosen": false,
                    "icon": "hard-drive",
                    "name": "Local",
                    "selected": false
                  }
                ]
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "SaveToFile"
        },
        "dragging": false,
        "id": "SaveToFile-VVVVb",
        "measured": {
          "height": 415,
          "width": 320
        },
        "position": {
          "x": 1794.2632899160462,
          "y": 380.70482755018264
        },
        "selected": true,
        "type": "genericNode"
      }
    ],
    "viewport": {
      "x": -27.058787075981854,
      "y": 101.24533456841135,
      "zoom": 0.7295800981010054
    }
  },
  "description": "Extracts data and information from webpages.",
  "endpoint_name": null,
  "id": "10090ba4-02d7-4c07-bc44-c635c4d4e7d3",
  "is_component": false,
  "last_tested_version": "1.6.0",
  "name": "News Aggregator",
  "tags": [
    "web-scraping",
    "agents"
  ]
}