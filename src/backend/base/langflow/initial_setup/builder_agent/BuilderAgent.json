{
  "data": {
    "edges": [
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ConversationMemoryTool",
            "id": "ConversationMemoryTool-WTlRm",
            "name": "component_as_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-La9qE",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-ConversationMemoryTool-WTlRm{œdataTypeœ:œConversationMemoryToolœ,œidœ:œConversationMemoryTool-WTlRmœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}-Agent-La9qE{œfieldNameœ:œtoolsœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "ConversationMemoryTool-WTlRm",
        "sourceHandle": "{œdataTypeœ:œConversationMemoryToolœ,œidœ:œConversationMemoryTool-WTlRmœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-La9qE",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ChatInput",
            "id": "ChatInput-m9DwD",
            "name": "message",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "Agent-La9qE",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-ChatInput-m9DwD{œdataTypeœ:œChatInputœ,œidœ:œChatInput-m9DwDœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}-Agent-La9qE{œfieldNameœ:œinput_valueœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ChatInput-m9DwD",
        "sourceHandle": "{œdataTypeœ:œChatInputœ,œidœ:œChatInput-m9DwDœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Agent-La9qE",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Agent",
            "id": "Agent-La9qE",
            "name": "response",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-RTsqB",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-Agent-La9qE{œdataTypeœ:œAgentœ,œidœ:œAgent-La9qEœ,œnameœ:œresponseœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-RTsqB{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-RTsqBœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "Agent-La9qE",
        "sourceHandle": "{œdataTypeœ:œAgentœ,œidœ:œAgent-La9qEœ,œnameœ:œresponseœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ChatOutput-RTsqB",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-RTsqBœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ConversationController",
            "id": "ConversationController-IftKs",
            "name": "component_as_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-La9qE",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-ConversationController-IftKs{œdataTypeœ:œConversationControllerœ,œidœ:œConversationController-IftKsœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}-Agent-La9qE{œfieldNameœ:œtoolsœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "ConversationController-IftKs",
        "sourceHandle": "{œdataTypeœ:œConversationControllerœ,œidœ:œConversationController-IftKsœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-La9qE",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "KnowledgeLoader",
            "id": "KnowledgeLoader-9hisZ",
            "name": "component_as_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-La9qE",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-KnowledgeLoader-9hisZ{œdataTypeœ:œKnowledgeLoaderœ,œidœ:œKnowledgeLoader-9hisZœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}-Agent-La9qE{œfieldNameœ:œtoolsœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "KnowledgeLoader-9hisZ",
        "sourceHandle": "{œdataTypeœ:œKnowledgeLoaderœ,œidœ:œKnowledgeLoader-9hisZœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-La9qE",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "IntegrationDecision",
            "id": "IntegrationDecision-5PE08",
            "name": "component_as_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-La9qE",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-IntegrationDecision-5PE08{œdataTypeœ:œIntegrationDecisionœ,œidœ:œIntegrationDecision-5PE08œ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}-Agent-La9qE{œfieldNameœ:œtoolsœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "IntegrationDecision-5PE08",
        "sourceHandle": "{œdataTypeœ:œIntegrationDecisionœ,œidœ:œIntegrationDecision-5PE08œ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-La9qE",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ComponentValidator",
            "id": "ComponentValidator-JpWcb",
            "name": "component_as_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-La9qE",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-ComponentValidator-JpWcb{œdataTypeœ:œComponentValidatorœ,œidœ:œComponentValidator-JpWcbœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}-Agent-La9qE{œfieldNameœ:œtoolsœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "ComponentValidator-JpWcb",
        "sourceHandle": "{œdataTypeœ:œComponentValidatorœ,œidœ:œComponentValidator-JpWcbœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-La9qE",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "SpecificationSearchTool",
            "id": "SpecificationSearchTool-9mb6x",
            "name": "component_as_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-La9qE",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__SpecificationSearchTool-9mb6x{œdataTypeœ:œSpecificationSearchToolœ,œidœ:œSpecificationSearchTool-9mb6xœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}-Agent-La9qE{œfieldNameœ:œtoolsœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "SpecificationSearchTool-9mb6x",
        "sourceHandle": "{œdataTypeœ:œSpecificationSearchToolœ,œidœ:œSpecificationSearchTool-9mb6xœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-La9qE",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "SpecValidatorTool",
            "id": "SpecValidatorTool-KRowR",
            "name": "component_as_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-La9qE",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__SpecValidatorTool-KRowR{œdataTypeœ:œSpecValidatorToolœ,œidœ:œSpecValidatorTool-KRowRœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}-Agent-La9qE{œfieldNameœ:œtoolsœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "SpecValidatorTool-KRowR",
        "sourceHandle": "{œdataTypeœ:œSpecValidatorToolœ,œidœ:œSpecValidatorTool-KRowRœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-La9qE",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "PatternAnalyzer",
            "id": "PatternAnalyzer-rDLXI",
            "name": "component_as_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-La9qE",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__PatternAnalyzer-rDLXI{œdataTypeœ:œPatternAnalyzerœ,œidœ:œPatternAnalyzer-rDLXIœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}-Agent-La9qE{œfieldNameœ:œtoolsœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "PatternAnalyzer-rDLXI",
        "sourceHandle": "{œdataTypeœ:œPatternAnalyzerœ,œidœ:œPatternAnalyzer-rDLXIœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-La9qE",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "MCPFramework",
            "id": "MCPFramework-r9Y5c",
            "name": "component_as_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-La9qE",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__MCPFramework-r9Y5c{œdataTypeœ:œMCPFrameworkœ,œidœ:œMCPFramework-r9Y5cœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}-Agent-La9qE{œfieldNameœ:œtoolsœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "MCPFramework-r9Y5c",
        "sourceHandle": "{œdataTypeœ:œMCPFrameworkœ,œidœ:œMCPFramework-r9Y5cœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-La9qE",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Agent",
            "id": "Agent-aQjuh",
            "name": "component_as_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-La9qE",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__Agent-aQjuh{œdataTypeœ:œAgentœ,œidœ:œAgent-aQjuhœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}-Agent-La9qE{œfieldNameœ:œtoolsœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "Agent-aQjuh",
        "sourceHandle": "{œdataTypeœ:œAgentœ,œidœ:œAgent-aQjuhœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-La9qE",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-La9qEœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      }
    ],
    "nodes": [
      {
        "data": {
          "id": "Agent-La9qE",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Define the agent's instructions, then enter a task to complete using tools.",
            "display_name": "AI Studio Builder Agent",
            "documentation": "https://docs.langflow.org/agents",
            "edited": false,
            "field_order": [
              "agent_llm",
              "max_tokens",
              "model_kwargs",
              "model_name",
              "openai_api_base",
              "api_key",
              "temperature",
              "seed",
              "max_retries",
              "timeout",
              "system_prompt",
              "n_messages",
              "format_instructions",
              "output_schema",
              "tools",
              "input_value",
              "handle_parsing_errors",
              "verbose",
              "max_iterations",
              "agent_description",
              "add_current_date_tool"
            ],
            "frozen": false,
            "icon": "bot",
            "last_updated": "2025-10-14T18:20:22.473Z",
            "legacy": false,
            "lf_version": "1.6.3",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Response",
                "group_outputs": false,
                "method": "message_response",
                "name": "response",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "add_current_date_tool": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Current Date",
                "dynamic": false,
                "info": "If true, will add a tool to the agent that returns the current date.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "add_current_date_tool",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "agent_description": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Agent Description [Deprecated]",
                "dynamic": false,
                "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "agent_description",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "A helpful assistant with access to the following tools:"
              },
              "agent_llm": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Model Provider",
                "dynamic": false,
                "external_options": {
                  "fields": {
                    "data": {
                      "node": {
                        "display_name": "Connect other models",
                        "icon": "CornerDownLeft",
                        "name": "connect_other_models"
                      }
                    }
                  }
                },
                "info": "The provider of the language model that the agent will use to generate responses.",
                "input_types": [],
                "load_from_db": false,
                "name": "agent_llm",
                "options": [
                  "Anthropic",
                  "Google Generative AI",
                  "OpenAI",
                  "Azure OpenAI"
                ],
                "options_metadata": [
                  {
                    "icon": "Anthropic"
                  },
                  {
                    "icon": "GoogleGenerativeAI"
                  },
                  {
                    "icon": "OpenAI"
                  },
                  {
                    "icon": "Azure"
                  },
                  {
                    "icon": "brain"
                  }
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "refresh_button": false,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Azure OpenAI"
              },
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Azure Chat OpenAI API Key",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": false,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "api_version": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "API Version",
                "dynamic": false,
                "external_options": {},
                "info": "",
                "input_types": [],
                "name": "api_version",
                "options": [
                  "2025-02-01-preview",
                  "2025-01-01-preview",
                  "2024-12-01-preview",
                  "2024-10-01-preview",
                  "2024-09-01-preview",
                  "2024-08-01-preview",
                  "2024-07-01-preview",
                  "2024-06-01",
                  "2024-03-01-preview",
                  "2024-02-15-preview",
                  "2023-12-01-preview",
                  "2023-05-15"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "2024-06-01"
              },
              "azure_deployment": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Deployment Name",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "azure_deployment",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "gpt-4o"
              },
              "azure_endpoint": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Azure Endpoint",
                "dynamic": false,
                "info": "Your Azure endpoint, including the resource. Example: `https://example-resource.azure.openai.com/`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "azure_endpoint",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "https://openai-v2-lab.openai.azure.com/"
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nimport re\n\nfrom langchain_core.tools import StructuredTool\nfrom pydantic import ValidationError\n\nfrom langflow.base.agents.agent import LCToolsAgentComponent\nfrom langflow.base.agents.events import ExceptionWithMessageError\nfrom langflow.base.models.model_input_constants import (\n    ALL_PROVIDER_FIELDS,\n    MODEL_DYNAMIC_UPDATE_FIELDS,\n    MODEL_PROVIDERS_DICT,\n    MODELS_METADATA,\n)\nfrom langflow.base.models.model_utils import get_model_name\nfrom langflow.components.helpers.current_date import CurrentDateComponent\nfrom langflow.components.helpers.memory import MemoryComponent\nfrom langflow.components.langchain_utilities.tool_calling import (\n    ToolCallingAgentComponent,\n)\nfrom langflow.custom.custom_component.component import _get_component_toolkit\nfrom langflow.custom.utils import update_component_build_config\nfrom langflow.field_typing import Tool\nfrom langflow.helpers.base_model import build_model_from_schema\nfrom langflow.io import (\n    BoolInput,\n    DropdownInput,\n    IntInput,\n    MultilineInput,\n    Output,\n    TableInput,\n)\nfrom langflow.logging import logger\nfrom langflow.schema.data import Data\nfrom langflow.schema.dotdict import dotdict\nfrom langflow.schema.message import Message\nfrom langflow.schema.table import EditMode\n\n\ndef set_advanced_true(component_input):\n    component_input.advanced = True\n    return component_input\n\n\nMODEL_PROVIDERS_LIST = [\"Anthropic\", \"Google Generative AI\", \"OpenAI\", \"Azure OpenAI\"]\n\n\nclass AgentComponent(ToolCallingAgentComponent):\n    display_name: str = \"Agent\"\n    description: str = \"Define the agent's instructions, then enter a task to complete using tools.\"\n    documentation: str = \"https://docs.langflow.org/agents\"\n    icon = \"bot\"\n    beta = False\n    name = \"Agent\"\n\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\n\n    # Filter out json_mode from OpenAI inputs since we handle structured output differently\n    if \"OpenAI\" in MODEL_PROVIDERS_DICT:\n        openai_inputs_filtered = [\n            input_field\n            for input_field in MODEL_PROVIDERS_DICT[\"OpenAI\"][\"inputs\"]\n            if not (hasattr(input_field, \"name\") and input_field.name == \"json_mode\")\n        ]\n    else:\n        openai_inputs_filtered = []\n\n    inputs = [\n        DropdownInput(\n            name=\"agent_llm\",\n            display_name=\"Model Provider\",\n            info=\"The provider of the language model that the agent will use to generate responses.\",\n            options=[*MODEL_PROVIDERS_LIST],\n            value=\"OpenAI\",\n            real_time_refresh=True,\n            refresh_button=False,\n            input_types=[],\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST if key in MODELS_METADATA]\n            + [{\"icon\": \"brain\"}],\n            external_options={\n                \"fields\": {\n                    \"data\": {\n                        \"node\": {\n                            \"name\": \"connect_other_models\",\n                            \"display_name\": \"Connect other models\",\n                            \"icon\": \"CornerDownLeft\",\n                        }\n                    }\n                },\n            },\n        ),\n        *openai_inputs_filtered,\n        MultilineInput(\n            name=\"system_prompt\",\n            display_name=\"Agent Instructions\",\n            info=\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\",\n            value=\"You are a helpful assistant that can use tools to answer questions and perform tasks.\",\n            advanced=False,\n        ),\n        IntInput(\n            name=\"n_messages\",\n            display_name=\"Number of Chat History Messages\",\n            value=100,\n            info=\"Number of chat history messages to retrieve.\",\n            advanced=True,\n            show=True,\n        ),\n        MultilineInput(\n            name=\"format_instructions\",\n            display_name=\"Output Format Instructions\",\n            info=\"Generic Template for structured output formatting. Valid only with Structured response.\",\n            value=(\n                \"You are an AI that extracts structured JSON objects from unstructured text. \"\n                \"Use a predefined schema with expected types (str, int, float, bool, dict). \"\n                \"Extract ALL relevant instances that match the schema - if multiple patterns exist, capture them all. \"\n                \"Fill missing or ambiguous values with defaults: null for missing values. \"\n                \"Remove exact duplicates but keep variations that have different field values. \"\n                \"Always return valid JSON in the expected format, never throw errors. \"\n                \"If multiple objects can be extracted, return them all in the structured format.\"\n            ),\n            advanced=True,\n        ),\n        TableInput(\n            name=\"output_schema\",\n            display_name=\"Output Schema\",\n            info=(\n                \"Schema Validation: Define the structure and data types for structured output. \"\n                \"No validation if no output schema.\"\n            ),\n            advanced=True,\n            required=False,\n            value=[],\n            table_schema=[\n                {\n                    \"name\": \"name\",\n                    \"display_name\": \"Name\",\n                    \"type\": \"str\",\n                    \"description\": \"Specify the name of the output field.\",\n                    \"default\": \"field\",\n                    \"edit_mode\": EditMode.INLINE,\n                },\n                {\n                    \"name\": \"description\",\n                    \"display_name\": \"Description\",\n                    \"type\": \"str\",\n                    \"description\": \"Describe the purpose of the output field.\",\n                    \"default\": \"description of field\",\n                    \"edit_mode\": EditMode.POPOVER,\n                },\n                {\n                    \"name\": \"type\",\n                    \"display_name\": \"Type\",\n                    \"type\": \"str\",\n                    \"edit_mode\": EditMode.INLINE,\n                    \"description\": (\"Indicate the data type of the output field (e.g., str, int, float, bool, dict).\"),\n                    \"options\": [\"str\", \"int\", \"float\", \"bool\", \"dict\"],\n                    \"default\": \"str\",\n                },\n                {\n                    \"name\": \"multiple\",\n                    \"display_name\": \"As List\",\n                    \"type\": \"boolean\",\n                    \"description\": \"Set to True if this output field should be a list of the specified type.\",\n                    \"default\": \"False\",\n                    \"edit_mode\": EditMode.INLINE,\n                },\n            ],\n        ),\n        *LCToolsAgentComponent._base_inputs,\n        # removed memory inputs from agent component\n        # *memory_inputs,\n        BoolInput(\n            name=\"add_current_date_tool\",\n            display_name=\"Current Date\",\n            advanced=True,\n            info=\"If true, will add a tool to the agent that returns the current date.\",\n            value=True,\n        ),\n    ]\n    outputs = [\n        Output(name=\"response\", display_name=\"Response\", method=\"message_response\"),\n    ]\n\n    async def get_agent_requirements(self):\n        \"\"\"Get the agent requirements for the agent.\"\"\"\n        llm_model, display_name = await self.get_llm()\n        if llm_model is None:\n            msg = \"No language model selected. Please choose a model to proceed.\"\n            raise ValueError(msg)\n        self.model_name = get_model_name(llm_model, display_name=display_name)\n\n        # Get memory data\n        self.chat_history = await self.get_memory_data()\n        if isinstance(self.chat_history, Message):\n            self.chat_history = [self.chat_history]\n\n        # Add current date tool if enabled\n        if self.add_current_date_tool:\n            if not isinstance(self.tools, list):  # type: ignore[has-type]\n                self.tools = []\n            current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\n            if not isinstance(current_date_tool, StructuredTool):\n                msg = \"CurrentDateComponent must be converted to a StructuredTool\"\n                raise TypeError(msg)\n            self.tools.append(current_date_tool)\n        return llm_model, self.chat_history, self.tools\n\n    async def message_response(self) -> Message:\n        try:\n            llm_model, self.chat_history, self.tools = await self.get_agent_requirements()\n            # Set up and run agent\n            self.set(\n                llm=llm_model,\n                tools=self.tools or [],\n                chat_history=self.chat_history,\n                input_value=self.input_value,\n                system_prompt=self.system_prompt,\n            )\n            agent = self.create_agent_runnable()\n            result = await self.run_agent(agent)\n\n            # Store result for potential JSON output\n            self._agent_result = result\n\n        except (ValueError, TypeError, KeyError) as e:\n            await logger.aerror(f\"{type(e).__name__}: {e!s}\")\n            raise\n        except ExceptionWithMessageError as e:\n            await logger.aerror(f\"ExceptionWithMessageError occurred: {e}\")\n            raise\n        # Avoid catching blind Exception; let truly unexpected exceptions propagate\n        except Exception as e:\n            await logger.aerror(f\"Unexpected error: {e!s}\")\n            raise\n        else:\n            return result\n\n    def _preprocess_schema(self, schema):\n        \"\"\"Preprocess schema to ensure correct data types for build_model_from_schema.\"\"\"\n        processed_schema = []\n        for field in schema:\n            processed_field = {\n                \"name\": str(field.get(\"name\", \"field\")),\n                \"type\": str(field.get(\"type\", \"str\")),\n                \"description\": str(field.get(\"description\", \"\")),\n                \"multiple\": field.get(\"multiple\", False),\n            }\n            # Ensure multiple is handled correctly\n            if isinstance(processed_field[\"multiple\"], str):\n                processed_field[\"multiple\"] = processed_field[\"multiple\"].lower() in [\n                    \"true\",\n                    \"1\",\n                    \"t\",\n                    \"y\",\n                    \"yes\",\n                ]\n            processed_schema.append(processed_field)\n        return processed_schema\n\n    async def build_structured_output_base(self, content: str):\n        \"\"\"Build structured output with optional BaseModel validation.\"\"\"\n        json_pattern = r\"\\{.*\\}\"\n        schema_error_msg = \"Try setting an output schema\"\n\n        # Try to parse content as JSON first\n        json_data = None\n        try:\n            json_data = json.loads(content)\n        except json.JSONDecodeError:\n            json_match = re.search(json_pattern, content, re.DOTALL)\n            if json_match:\n                try:\n                    json_data = json.loads(json_match.group())\n                except json.JSONDecodeError:\n                    return {\"content\": content, \"error\": schema_error_msg}\n            else:\n                return {\"content\": content, \"error\": schema_error_msg}\n\n        # If no output schema provided, return parsed JSON without validation\n        if not hasattr(self, \"output_schema\") or not self.output_schema or len(self.output_schema) == 0:\n            return json_data\n\n        # Use BaseModel validation with schema\n        try:\n            processed_schema = self._preprocess_schema(self.output_schema)\n            output_model = build_model_from_schema(processed_schema)\n\n            # Validate against the schema\n            if isinstance(json_data, list):\n                # Multiple objects\n                validated_objects = []\n                for item in json_data:\n                    try:\n                        validated_obj = output_model.model_validate(item)\n                        validated_objects.append(validated_obj.model_dump())\n                    except ValidationError as e:\n                        await logger.aerror(f\"Validation error for item: {e}\")\n                        # Include invalid items with error info\n                        validated_objects.append({\"data\": item, \"validation_error\": str(e)})\n                return validated_objects\n\n            # Single object\n            try:\n                validated_obj = output_model.model_validate(json_data)\n                return [validated_obj.model_dump()]  # Return as list for consistency\n            except ValidationError as e:\n                await logger.aerror(f\"Validation error: {e}\")\n                return [{\"data\": json_data, \"validation_error\": str(e)}]\n\n        except (TypeError, ValueError) as e:\n            await logger.aerror(f\"Error building structured output: {e}\")\n            # Fallback to parsed JSON without validation\n            return json_data\n\n    async def json_response(self) -> Data:\n        \"\"\"Convert agent response to structured JSON Data output with schema validation.\"\"\"\n        # Always use structured chat agent for JSON response mode for better JSON formatting\n        try:\n            system_components = []\n\n            # 1. Agent Instructions (system_prompt)\n            agent_instructions = getattr(self, \"system_prompt\", \"\") or \"\"\n            if agent_instructions:\n                system_components.append(f\"{agent_instructions}\")\n\n            # 2. Format Instructions\n            format_instructions = getattr(self, \"format_instructions\", \"\") or \"\"\n            if format_instructions:\n                system_components.append(f\"Format instructions: {format_instructions}\")\n\n            # 3. Schema Information from BaseModel\n            if hasattr(self, \"output_schema\") and self.output_schema and len(self.output_schema) > 0:\n                try:\n                    processed_schema = self._preprocess_schema(self.output_schema)\n                    output_model = build_model_from_schema(processed_schema)\n                    schema_dict = output_model.model_json_schema()\n                    schema_info = (\n                        \"You are given some text that may include format instructions, \"\n                        \"explanations, or other content alongside a JSON schema.\\n\\n\"\n                        \"Your task:\\n\"\n                        \"- Extract only the JSON schema.\\n\"\n                        \"- Return it as valid JSON.\\n\"\n                        \"- Do not include format instructions, explanations, or extra text.\\n\\n\"\n                        \"Input:\\n\"\n                        f\"{json.dumps(schema_dict, indent=2)}\\n\\n\"\n                        \"Output (only JSON schema):\"\n                    )\n                    system_components.append(schema_info)\n                except (ValidationError, ValueError, TypeError, KeyError) as e:\n                    await logger.aerror(f\"Could not build schema for prompt: {e}\", exc_info=True)\n\n            # Combine all components\n            combined_instructions = \"\\n\\n\".join(system_components) if system_components else \"\"\n            llm_model, self.chat_history, self.tools = await self.get_agent_requirements()\n            self.set(\n                llm=llm_model,\n                tools=self.tools or [],\n                chat_history=self.chat_history,\n                input_value=self.input_value,\n                system_prompt=combined_instructions,\n            )\n\n            # Create and run structured chat agent\n            try:\n                structured_agent = self.create_agent_runnable()\n            except (NotImplementedError, ValueError, TypeError) as e:\n                await logger.aerror(f\"Error with structured chat agent: {e}\")\n                raise\n            try:\n                result = await self.run_agent(structured_agent)\n            except (\n                ExceptionWithMessageError,\n                ValueError,\n                TypeError,\n                RuntimeError,\n            ) as e:\n                await logger.aerror(f\"Error with structured agent result: {e}\")\n                raise\n            # Extract content from structured agent result\n            if hasattr(result, \"content\"):\n                content = result.content\n            elif hasattr(result, \"text\"):\n                content = result.text\n            else:\n                content = str(result)\n\n        except (\n            ExceptionWithMessageError,\n            ValueError,\n            TypeError,\n            NotImplementedError,\n            AttributeError,\n        ) as e:\n            await logger.aerror(f\"Error with structured chat agent: {e}\")\n            # Fallback to regular agent\n            content_str = \"No content returned from agent\"\n            return Data(data={\"content\": content_str, \"error\": str(e)})\n\n        # Process with structured output validation\n        try:\n            structured_output = await self.build_structured_output_base(content)\n\n            # Handle different output formats\n            if isinstance(structured_output, list) and structured_output:\n                if len(structured_output) == 1:\n                    return Data(data=structured_output[0])\n                return Data(data={\"results\": structured_output})\n            if isinstance(structured_output, dict):\n                return Data(data=structured_output)\n            return Data(data={\"content\": content})\n\n        except (ValueError, TypeError) as e:\n            await logger.aerror(f\"Error in structured output processing: {e}\")\n            return Data(data={\"content\": content, \"error\": str(e)})\n\n    async def get_memory_data(self):\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\n        messages = (\n            await MemoryComponent(**self.get_base_args())\n            .set(\n                session_id=self.graph.session_id,\n                order=\"Ascending\",\n                n_messages=self.n_messages,\n            )\n            .retrieve_messages()\n        )\n        return [\n            message for message in messages if getattr(message, \"id\", None) != getattr(self.input_value, \"id\", None)\n        ]\n\n    async def get_llm(self):\n        if not isinstance(self.agent_llm, str):\n            return self.agent_llm, None\n\n        try:\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n            if not provider_info:\n                msg = f\"Invalid model provider: {self.agent_llm}\"\n                raise ValueError(msg)\n\n            component_class = provider_info.get(\"component_class\")\n            display_name = component_class.display_name\n            inputs = provider_info.get(\"inputs\")\n            prefix = provider_info.get(\"prefix\", \"\")\n\n            return self._build_llm_model(component_class, inputs, prefix), display_name\n\n        except (AttributeError, ValueError, TypeError, RuntimeError) as e:\n            await logger.aerror(f\"Error building {self.agent_llm} language model: {e!s}\")\n            msg = f\"Failed to initialize language model: {e!s}\"\n            raise ValueError(msg) from e\n\n    def _build_llm_model(self, component, inputs, prefix=\"\"):\n        model_kwargs = {}\n        for input_ in inputs:\n            if hasattr(self, f\"{prefix}{input_.name}\"):\n                model_kwargs[input_.name] = getattr(self, f\"{prefix}{input_.name}\")\n        return component.set(**model_kwargs).build_model()\n\n    def set_component_params(self, component):\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n        if provider_info:\n            inputs = provider_info.get(\"inputs\")\n            prefix = provider_info.get(\"prefix\")\n            # Filter out json_mode and only use attributes that exist on this component\n            model_kwargs = {}\n            for input_ in inputs:\n                if hasattr(self, f\"{prefix}{input_.name}\"):\n                    model_kwargs[input_.name] = getattr(self, f\"{prefix}{input_.name}\")\n\n            return component.set(**model_kwargs)\n        return component\n\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\n        \"\"\"Delete specified fields from build_config.\"\"\"\n        for field in fields:\n            build_config.pop(field, None)\n\n    def update_input_types(self, build_config: dotdict) -> dotdict:\n        \"\"\"Update input types for all fields in build_config.\"\"\"\n        for key, value in build_config.items():\n            if isinstance(value, dict):\n                if value.get(\"input_types\") is None:\n                    build_config[key][\"input_types\"] = []\n            elif hasattr(value, \"input_types\") and value.input_types is None:\n                value.input_types = []\n        return build_config\n\n    async def update_build_config(\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\n    ) -> dotdict:\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\n        # Existing logic for updating build_config\n        if field_name in (\"agent_llm\",):\n            build_config[\"agent_llm\"][\"value\"] = field_value\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\n            if provider_info:\n                component_class = provider_info.get(\"component_class\")\n                if component_class and hasattr(component_class, \"update_build_config\"):\n                    # Call the component class's update_build_config method\n                    build_config = await update_component_build_config(\n                        component_class, build_config, field_value, \"model_name\"\n                    )\n\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\n                provider: (\n                    MODEL_PROVIDERS_DICT[provider][\"fields\"],\n                    [\n                        MODEL_PROVIDERS_DICT[other_provider][\"fields\"]\n                        for other_provider in MODEL_PROVIDERS_DICT\n                        if other_provider != provider\n                    ],\n                )\n                for provider in MODEL_PROVIDERS_DICT\n            }\n            if field_value in provider_configs:\n                fields_to_add, fields_to_delete = provider_configs[field_value]\n\n                # Delete fields from other providers\n                for fields in fields_to_delete:\n                    self.delete_fields(build_config, fields)\n\n                # Add provider-specific fields\n                build_config.update(fields_to_add)\n                # Reset input types for agent_llm\n                build_config[\"agent_llm\"][\"input_types\"] = []\n                build_config[\"agent_llm\"][\"display_name\"] = \"Model Provider\"\n            elif field_value == \"connect_other_models\":\n                # Delete all provider fields\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\n                # # Update with custom component\n                custom_component = DropdownInput(\n                    name=\"agent_llm\",\n                    display_name=\"Language Model\",\n                    info=\"The provider of the language model that the agent will use to generate responses.\",\n                    options=[*MODEL_PROVIDERS_LIST],\n                    real_time_refresh=True,\n                    refresh_button=False,\n                    input_types=[\"LanguageModel\"],\n                    placeholder=\"Awaiting model input.\",\n                    options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST if key in MODELS_METADATA],\n                    external_options={\n                        \"fields\": {\n                            \"data\": {\n                                \"node\": {\n                                    \"name\": \"connect_other_models\",\n                                    \"display_name\": \"Connect other models\",\n                                    \"icon\": \"CornerDownLeft\",\n                                },\n                            }\n                        },\n                    },\n                )\n                build_config.update({\"agent_llm\": custom_component.to_dict()})\n            # Update input types for all fields\n            build_config = self.update_input_types(build_config)\n\n            # Validate required keys\n            default_keys = [\n                \"code\",\n                \"_type\",\n                \"agent_llm\",\n                \"tools\",\n                \"input_value\",\n                \"add_current_date_tool\",\n                \"system_prompt\",\n                \"agent_description\",\n                \"max_iterations\",\n                \"handle_parsing_errors\",\n                \"verbose\",\n            ]\n            missing_keys = [key for key in default_keys if key not in build_config]\n            if missing_keys:\n                msg = f\"Missing required keys in build_config: {missing_keys}\"\n                raise ValueError(msg)\n        if (\n            isinstance(self.agent_llm, str)\n            and self.agent_llm in MODEL_PROVIDERS_DICT\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\n        ):\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n            if provider_info:\n                component_class = provider_info.get(\"component_class\")\n                component_class = self.set_component_params(component_class)\n                prefix = provider_info.get(\"prefix\")\n                if component_class and hasattr(component_class, \"update_build_config\"):\n                    # Call each component class's update_build_config method\n                    # remove the prefix from the field_name\n                    if isinstance(field_name, str) and isinstance(prefix, str):\n                        field_name = field_name.replace(prefix, \"\")\n                    build_config = await update_component_build_config(\n                        component_class, build_config, field_value, \"model_name\"\n                    )\n        return dotdict({k: v.to_dict() if hasattr(v, \"to_dict\") else v for k, v in build_config.items()})\n\n    async def _get_tools(self) -> list[Tool]:\n        component_toolkit = _get_component_toolkit()\n        tools_names = self._build_tools_names()\n        agent_description = self.get_tool_description()\n        # TODO: Agent Description Depreciated Feature to be removed\n        description = f\"{agent_description}{tools_names}\"\n        tools = component_toolkit(component=self).get_tools(\n            tool_name=\"Call_Agent\",\n            tool_description=description,\n            callbacks=self.get_langchain_callbacks(),\n        )\n        if hasattr(self, \"tools_metadata\"):\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\n        return tools\n"
              },
              "format_instructions": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Output Format Instructions",
                "dynamic": false,
                "info": "Generic Template for structured output formatting. Valid only with Structured response.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "format_instructions",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "You are an AI that extracts structured JSON objects from unstructured text. Use a predefined schema with expected types (str, int, float, bool, dict). Extract ALL relevant instances that match the schema - if multiple patterns exist, capture them all. Fill missing or ambiguous values with defaults: null for missing values. Remove exact duplicates but keep variations that have different field values. Always return valid JSON in the expected format, never throw errors. If multiple objects can be extracted, return them all in the structured format."
              },
              "handle_parsing_errors": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Handle Parse Errors",
                "dynamic": false,
                "info": "Should the Agent fix errors when reading user input for better processing?",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "handle_parsing_errors",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "The input provided by the user for the agent to process.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "max_iterations": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Iterations",
                "dynamic": false,
                "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "max_iterations",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 15
              },
              "max_tokens": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Tokens",
                "dynamic": false,
                "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "max_tokens",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "n_messages": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Chat History Messages",
                "dynamic": false,
                "info": "Number of chat history messages to retrieve.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "n_messages",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 100
              },
              "output_schema": {
                "_input_type": "TableInput",
                "advanced": true,
                "display_name": "Output Schema",
                "dynamic": false,
                "info": "Schema Validation: Define the structure and data types for structured output. No validation if no output schema.",
                "input_types": [],
                "is_list": true,
                "list_add_label": "Add More",
                "name": "output_schema",
                "placeholder": "",
                "required": false,
                "show": true,
                "table_icon": "Table",
                "table_schema": {
                  "columns": [
                    {
                      "default": "field",
                      "description": "Specify the name of the output field.",
                      "disable_edit": false,
                      "display_name": "Name",
                      "edit_mode": "inline",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "name",
                      "sortable": true,
                      "type": "str"
                    },
                    {
                      "default": "description of field",
                      "description": "Describe the purpose of the output field.",
                      "disable_edit": false,
                      "display_name": "Description",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "description",
                      "sortable": true,
                      "type": "str"
                    },
                    {
                      "default": "str",
                      "description": "Indicate the data type of the output field (e.g., str, int, float, bool, dict).",
                      "disable_edit": false,
                      "display_name": "Type",
                      "edit_mode": "inline",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "type",
                      "options": [
                        "str",
                        "int",
                        "float",
                        "bool",
                        "dict"
                      ],
                      "sortable": true,
                      "type": "str"
                    },
                    {
                      "default": false,
                      "description": "Set to True if this output field should be a list of the specified type.",
                      "disable_edit": false,
                      "display_name": "As List",
                      "edit_mode": "inline",
                      "filterable": true,
                      "formatter": "boolean",
                      "hidden": false,
                      "name": "multiple",
                      "sortable": true,
                      "type": "boolean"
                    }
                  ]
                },
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "trigger_icon": "Table",
                "trigger_text": "Open table",
                "type": "table",
                "value": []
              },
              "system_prompt": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Agent Instructions",
                "dynamic": false,
                "info": "System Prompt: Initial instructions and context provided to guide the agent's behavior.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_prompt",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "<role>\nYou are the AI Studio Healthcare Agent & Workflow Builder Assistant. You are an expert system that specializes in creating AI agents and automated workflows specifically for healthcare applications using proven patterns from the specification library.\n\n**CRITICAL: Always use user-friendly language. NEVER mention technical component names like genesis:chat_output, genesis:mcp_tool, or genesis:agent in conversations. Use healthcare terminology and descriptive names instead.**\n\nYour core expertise includes:\n- Healthcare AI agent design and implementation\n- Clinical workflow automation\n- Medical coding systems (ICD-10, CPT, RxNorm)\n- Prior authorization automation\n- Healthcare compliance (HIPAA, security patterns)\n- API integration patterns for healthcare systems\n</role>\n\n<objective>\nYour primary task is to help users build healthcare AI agents through a structured 3-phase process:\n\n1. **Agent Definition Extraction**: First, identify and extract the agent name, agent goal, and description from user requirements\n2. **Planning & Design**: Create detailed implementation plans using proven patterns from the specification library\n3. **Implementation**: Generate validated YAML specifications ready for deployment\n\nYou must always start by extracting the agent name, goal, and description before proceeding to planning and implementation phases.\n</objective>\n\n<faq_detection_and_response>\n**CRITICAL: FAQ Detection Must Happen FIRST for Every User Input**\n\nThis section has ABSOLUTE HIGHEST PRIORITY over all other processing.\nFAQ detection uses pattern matching in the prompt - NO external tool required.\nFor EVERY user input, check FAQ patterns BEFORE proceeding to any Phase.\n\n---\n\n## Temperature Control Configuration\n\n**FAQ Response Mode:**\n- Temperature: 0.0 (deterministic, exact copy only)\n- Generation: DISABLED - retrieve and copy canonical responses verbatim\n- Tone: Professional, no emojis, business-appropriate\n- Format: Character-for-character match with canonical text\n\n**Normal Agent Building Mode:**\n- Temperature: 0.7 (standard for Phases 1, 2, 3)\n- Generation: ENABLED - creative, helpful responses\n- Tone: Professional with appropriate emojis where suitable\n- Format: Conversational, structured\n\n**Isolation Guarantee:**\n- FAQ handling does not affect conversation state or phase\n- After FAQ response, user continues exactly where they left off\n- Temperature resets to 0.7 immediately after FAQ delivery\n- FAQ is a separate, isolated process\n\n---\n\n## FAQ Detection Logic - STEP 0 (Execute BEFORE All Other Processing)\n\n**MANDATORY for EVERY user input:**\n```\n1. Read user input text\n\n2. Set temperature to 0.0 for FAQ detection\n\n3. Check if input matches ANY FAQ pattern:\n   - PRIORITY 1: Greeting patterns\n   - PRIORITY 2: Capability patterns\n   - PRIORITY 3: Definition patterns\n   - PRIORITY 4: Guided use case patterns\n   - PRIORITY 5: Out of scope patterns\n   - PRIORITY 6: Closing patterns\n\n4. IF MATCH FOUND:\n   a. Keep temperature at 0.0\n   b. Locate exact canonical response for matched intent\n   c. Copy canonical response VERBATIM (no modifications, no emojis)\n   d. Deliver response to user\n   e. STOP all processing (do NOT proceed to Phase 1/2/3)\n   f. Reset temperature to 0.7 after response delivered\n\n5. IF NO MATCH FOUND:\n   a. Reset temperature to 0.7\n   b. Proceed to Phase 1: Agent Definition Extraction\n   c. Continue normal agent building flow\n```\n\n---\n\n## PRIORITY 1: GREETING INTENTS\n\n**Pattern Matching:**\nTrigger words: hello, hi, hey, howdy, greetings, good morning, good afternoon, good evening\nVariations: \"hi there\", \"hello!\", \"hey there\"\nCase insensitive\n\n**Intent: Basic Greeting**\n**Canonical Response (COPY EXACTLY - NO EMOJIS):**\n```\nHello! I'm the Autonomize AI Agent Builder. I help you create smart AI Agents and workflows for healthcare. What would you like to build today?\n```\n\n**Intent: How are you**\n**Pattern:** how are you, how's it going, how are things, how are you doing\n**Canonical Response (COPY EXACTLY):**\n```\nI'm doing great, thanks for asking. Ready to build an AI Agent?\n```\n\n**Intent: Who are you / What is Agent Builder**\n**Pattern:** who are you, what is agent builder, introduce yourself, what can you do for me, tell me about yourself\n**Canonical Response (COPY EXACTLY):**\n```\nI'm the Autonomize AI Agent Builder. I help you create AI Agents through simple conversation.\n```\n\n---\n\n## PRIORITY 2: CAPABILITY & HELP INTENTS\n\n**Pattern Matching:**\nTrigger words: what can you do, how can you help, capabilities, features, what do you offer, how does this work, what are your abilities, help me\nVariations: \"what can you help with\", \"what are your capabilities\", \"how can you assist\"\n\n**Canonical Response (COPY EXACTLY - Adapted from document for healthcare/agents):**\n```\nHow I Help\n\n1. Planning - I'll help you define your Agent, choose the right components, and design the workflow\n\n2. Integration Setup - I can connect your Agent to healthcare systems like EHR, payer APIs, medical coding databases, and many others\n\n3. Implementation - Once you approve the plan, I'll build the complete Agent specification ready for deployment\n\nMy Approach:\n- Focus on getting a working Agent quickly\n- Use proven healthcare patterns and components\n- Create HIPAA-compliant, production-ready Agents\n- Plan for scalability and future enhancements\n\nWhat would you like to build? Just describe your healthcare use case, and I'll help you create the Agent.\n```\n\n---\n\n## PRIORITY 3: DEFINITION INTENTS\n\n### 3A. AGENT DEFINITION\n**Pattern:** what is an agent, what are agents, define agent, explain agent, tell me about agents, agent definition\n**Canonical Response (COPY EXACTLY - From document):**\n```\nAn Agent is a specialized AI assistant designed for specific tasks - like summarizing documents, processing data, or answering questions. What would you like your Agent to do?\n```\n\n### 3B. WORKFLOW DEFINITION\n**Pattern:** what is a workflow, what are workflows, define workflow, explain workflow, workflow definition, tell me about workflows\n**Canonical Response (COPY EXACTLY - From document):**\n```\nA workflow is a sequence of automated steps that accomplish a specific task or process. It's like a recipe that defines what happens, in what order, and under what conditions. What task would you like to automate?\n```\n\n### 3C. TASK DEFINITION\n**Pattern:** what is a task, what are tasks, define task, explain task, task definition, tell me about tasks\n**Canonical Response (COPY EXACTLY):**\n```\nA task is a single action or operation that an Agent performs - like extracting data, making an API call, or processing a document. Multiple tasks combine to form a workflow. What task would you like your Agent to perform?\n```\n\n### 3D. COMPONENT DEFINITION\n**Pattern:** what is a component, what are components, define component, explain component, component definition, tell me about components\n**Canonical Response (COPY EXACTLY - From document):**\n```\nComponents are individual tasks that Agents work on. Think of components as steps that an Agent performs to accomplish a goal.\n```\n\n### 3E. CONNECTOR DEFINITION\n**Pattern:** what is a connector, what are connectors, define connector, explain connector, connector definition, tell me about connectors\n**Canonical Response (COPY EXACTLY):**\n```\nA connector is a pre-built integration that links your Agent to external systems - like EHR systems, payer APIs, or databases. Connectors handle authentication, data formatting, and API communication automatically. Which system would you like to connect to?\n```\n\n### 3F. MCP DEFINITION\n**Pattern:** what is MCP, what does MCP mean, define MCP, explain MCP, MCP definition, what is model context protocol, tell me about MCP\n**Canonical Response (COPY EXACTLY):**\n```\nMCP (Model Context Protocol) is a standard for connecting AI Agents to external data sources and tools. MCP tools allow your Agent to access healthcare systems, databases, and APIs in a standardized way. Would you like to explore available MCP tools for healthcare?\n```\n\n### 3G. TOOLS DEFINITION\n**Pattern:** what are tools, define tools, explain tools, tool definition, what tools are available, tell me about tools\n**Canonical Response (COPY EXACTLY):**\n```\nTools are capabilities that enhance your Agent's functionality - like accessing EHR data, calling APIs, processing documents, or querying databases. Tools can be MCP-based integrations or built-in components. What capability would you like to add to your Agent?\n```\n\n### 3H. AUTONOMIZE PLATFORM DEFINITION\n**Pattern:** what is autonomize, what is autonomize platform, explain autonomize, in autonomize, autonomize definition, tell me about autonomize\n**Canonical Response (COPY EXACTLY):**\n```\nIn Autonomize, an Agent is built with:\n- Input (what it receives)\n- Processing (how it works)\n- Output (what it delivers)\nWhat would you like your Agent to do?\n```\n\n---\n\n## PRIORITY 4: GUIDED USE CASE INTENTS\n\n### 4A. TEXT EXTRACTION USE CASE\n**Pattern:** extract text from images, extract text from PDF, OCR, document extraction, text extraction agent, extract from documents, read PDFs, process images\n**Canonical Response (COPY EXACTLY - From document with task breakdown):**\n```\nGreat! I'll help you create a Document Text Extraction Agent.\n\nThis Agent will perform the following tasks:\n1. Document Upload - Accept images (PNG, JPG) and PDF files\n2. OCR Processing - Extract text using optical character recognition\n3. Text Cleaning - Format and structure the extracted content\n4. Output Delivery - Return clean, searchable text\n\nCommon healthcare use cases:\n- Extracting data from faxed Prior Authorization forms\n- Processing scanned medical records\n- Reading handwritten clinical notes\n- Digitizing insurance cards and ID documents\n\nShould I proceed with creating this Document Text Extraction Agent?\n```\n\n### 4B. PRIOR AUTHORIZATION CLASSIFICATION USE CASE\n**Pattern:** classify prior authorization, PA classification, prior auth forms, classification of PA, categorize prior authorization, PA forms classification\n**Canonical Response (COPY EXACTLY - From document with follow-up):**\n```\nPerfect! I'll help you create a Prior Authorization Classification Agent.\n\nFirst, let me understand your needs. What type of Prior Authorization would you like to classify?\n\n1. Medical Prior Authorization - For procedures, treatments, surgeries, imaging\n2. Pharmacy Prior Authorization - For prescription medications and specialty drugs\n\nPlease select one, or let me know if you need both.\n```\n\n**Follow-up Responses:**\n\n**If user selects \"Medical\" or \"1\" (COPY EXACTLY):**\n```\nUnderstood. I'll create a Medical PA Classification Agent that categorizes requests by specialty (cardiology, orthopedics, radiology, etc.) and urgency. Should I proceed with building this agent?\n```\n\n**If user selects \"Pharmacy\" or \"2\" (COPY EXACTLY):**\n```\nUnderstood. I'll create a Pharmacy PA Classification Agent that categorizes requests by drug type (specialty, generic, brand) and formulary tier. Should I proceed with building this agent?\n```\n\n**If user selects \"Both\" (COPY EXACTLY):**\n```\nExcellent. I'll create a comprehensive PA Classification Agent that handles both Medical and Pharmacy prior authorizations with appropriate routing logic. Should I proceed with building this agent?\n```\n\n### 4C. WORKFLOW TEMPLATE SELECTION USE CASE\n**Pattern:** create a workflow, build a workflow, workflow for me, need a workflow, set up workflow, workflow templates, show me workflows\n**Canonical Response (COPY EXACTLY - From document with all 9 templates):**\n```\nGreat! I can create workflows for the following healthcare processes:\n\nAvailable Workflow Templates:\n1. Case Intake and Extraction - Automate patient case intake and data extraction\n2. Medical Prior Authorization - Streamline medical PA request processing\n3. Pharmacy Authorization for Specialty Drugs - Handle specialty drug PA workflows\n4. DME Authorization - Process durable medical equipment authorizations\n5. Care Gaps for HEDIS - Identify and close HEDIS quality measure gaps\n6. Claims Operations - Automate claims processing and adjudication\n7. Correspondence Transformation - Convert and standardize healthcare communications\n8. Appeals and Grievances - Manage member appeals and grievance workflows\n9. Benefits and Coverage Verification - Verify patient eligibility and benefits\n\nWhich workflow would you like to create? You can select one from the list above (by number or name) or start a new custom workflow from scratch.\n```\n\n---\n\n## PRIORITY 5: OUT OF SCOPE INTENTS\n\n**Pattern Matching:**\nTopics NOT related to: agents, workflows, healthcare, automation, AI building\n\n**Out of Scope Topics:**\n- Weather queries\n- Sports\n- News and current events (unless healthcare-related)\n- Entertainment\n- General knowledge questions\n- Personal advice\n- Cooking and recipes\n- Travel planning\n- Non-healthcare/non-agent technical questions\n\n**Canonical Response (COPY EXACTLY):**\n```\nI can't help with that, but I'd be happy to help you build an AI Agent. What task would you like to automate?\n```\n\n---\n\n## PRIORITY 6: CLOSING INTENTS\n\n**Pattern Matching:**\nTrigger words: goodbye, bye, thanks, thank you, that's all, I'm done, see you later, farewell, have a good day, take care, thanks for your help\nVariations: \"thanks for the help\", \"that's all for now\", \"I'm finished\"\n\n**Canonical Response (COPY EXACTLY):**\n```\nYou're welcome! I'm glad I could help with your agent building needs. Feel free to come back anytime you need to create or modify AI agents and workflows. Take care.\n```\n\n---\n\n## Response Delivery Protocol\n\n**MANDATORY: When delivering ANY FAQ canonical response:**\n\n**Step 1: Confirm Pattern Match**\n- Verify user input matches one of the FAQ patterns above\n- Identify which priority category (1-6) and specific intent\n- Confirm temperature is set to 0.0\n\n**Step 2: Locate Canonical Response**\n- Find the exact canonical response for the matched intent\n- DO NOT generate a similar response\n- DO NOT paraphrase or improve the text\n- DO NOT add emojis or casual language\n\n**Step 3: Copy Response Verbatim**\n- Copy the canonical response EXACTLY as written above\n- Include all formatting: line breaks, bullets, numbered lists\n- Match character-for-character including punctuation and spacing\n- NO additions, NO modifications, NO emojis\n\n**Step 4: Validation Checklist**\nBefore sending, verify:\n- Is this EXACTLY the canonical response from this prompt?\n- Did I add ANY words not in the canonical response?\n- Did I change ANY wording or punctuation?\n- Did I add ANY emojis?\n- Is the tone professional?\n- Is temperature at 0.0?\n\nIf ANY answer is wrong, start over at Step 2.\n\n**Step 5: Deliver Response**\n- Send ONLY the canonical response\n- NO additional commentary\n- Just the clean, exact canonical response\n\n**Step 6: Reset and Continue**\n- After FAQ response delivered, reset temperature to 0.7\n- User can continue conversation from where they were\n- If next input is FAQ, repeat this process\n- If next input is agent building, proceed to Phase 1 with temp 0.7\n\n---\n\n## Anti-Pattern Examples\n\n**WRONG - Adding Emojis:**\n```\n❌ \"Hello! 👋 I'm the Autonomize AI Agent Builder...\"\n✅ \"Hello! I'm the Autonomize AI Agent Builder...\"\n```\n\n**WRONG - Paraphrasing:**\n```\n❌ \"An Agent is a specialized AI helper designed for particular tasks\"\n✅ \"An Agent is a specialized AI assistant designed for specific tasks\"\n```\n\n**WRONG - Adding Words:**\n```\n❌ \"I'm doing great, thanks for asking! I'm excited to help you build an AI Agent!\"\n✅ \"I'm doing great, thanks for asking. Ready to build an AI Agent?\"\n```\n\n**WRONG - Changing Structure:**\n```\n❌ \"Here's how I can help: 1. Planning...\"\n✅ \"How I Help\\n\\n1. Planning...\"\n```\n\n**RIGHT - Exact Copy:**\n```\n✅ Canonical response exactly as written\n✅ Professional tone, no emojis\n✅ No additions or modifications\n✅ Character-for-character match\n```\n\n---\n\n## Integration with Main Agent Building Flow\n\n**FAQ Detection Flow:**\n```\nUser Input\n    ↓\n[Step 0: FAQ Detection]\nTemperature = 0.0\nPattern match against FAQ intents\n    ↓\nIs FAQ?\n    ↓\nYES → Copy canonical response (temp 0.0) → Deliver → Reset to 0.7 → STOP\n    ↓\nNO → Reset to 0.7 → Phase 1: Agent Definition → Phase 2: Planning → Phase 3: Implementation\n```\n\n**Critical Integration Points:**\n- FAQ check happens FIRST, before any Phase 1/2/3 logic\n- FAQ responses use temp 0.0, normal flow uses temp 0.7\n- FAQ handling is isolated - doesn't affect conversation state\n- After FAQ, user can immediately continue building agent\n- Multiple FAQ questions handled independently\n\n---\n\n## Summary: FAQ Detection Rules\n\n**ALWAYS:**\n- Check for FAQ patterns FIRST before any other processing\n- Set temperature to 0.0 for FAQ responses\n- Copy canonical responses EXACTLY (no modifications)\n- Use professional tone with NO emojis in FAQ responses\n- Reset temperature to 0.7 after FAQ delivery\n- Allow user to continue conversation after FAQ\n\n**NEVER:**\n- Skip FAQ detection for any reason\n- Paraphrase or improve canonical responses\n- Add emojis to FAQ responses\n- Generate similar responses instead of copying\n- Interrupt normal agent building flow with FAQ logic\n- Keep temperature at 0.0 after FAQ response delivered\n\n</faq_detection_and_response>\n\n<instructions>\n\n## Phase 1: Agent Definition Extraction (ALWAYS START HERE)\n\n**For ANY agent creation request, you MUST first extract these 3 core elements:**\n\n### Step 1.1: Extract Agent Name\n- Identify or derive a clear, descriptive name for the agent\n- Use healthcare terminology and be specific\n- Format: \"[Function] [Domain] Agent\" (e.g., \"Prior Authorization Cardiology Agent\")\n\n### Step 1.2: Extract Agent Goal\n- Define the primary purpose in one clear sentence\n- Focus on the specific healthcare problem being solved\n- Format: \"To [action] [healthcare process] for [target users/systems]\"\n\n### Step 1.3: Extract Agent Description\n- Provide a comprehensive description of what the agent does\n- Include key functionalities, integrations, and expected outcomes\n- Be specific about healthcare context and compliance requirements\n\n**CRITICAL: Only proceed to Phase 2 after these 3 elements are clearly defined AND you explicitly ask for user confirmation to proceed.**\n\n## Phase 2: Planning & Design\n\n**IMPORTANT: Do NOT start Phase 2 automatically. Always wait for user confirmation after Phase 1.**\n\nAfter user confirms the agent definition, proceed with:\n\n### Step 2.1: Component Knowledge Loading (MANDATORY)\n**CRITICAL: You MUST call LOAD_KNOWLEDGE first in Phase 2 before suggesting any components**\n- Call LOAD_KNOWLEDGE to get all available components from the specification library\n- Analyze the genesis_mapped components that actually exist\n- NEVER suggest components that don't exist in the knowledge base\n- Use only validated, available components in your architecture plans\n\n### Step 2.2: Intent Classification\nBased on the extracted agent definition and available components, classify the request:\n- **Simple Agent Creation** → Use specification_search to find patterns + available components\n- **Integration-Heavy Agent** → Use MCP_FRAMEWORK for intelligent MCP tool selection + available components\n- **Modification Request** → Use specification_search with validated components\n- **Validation Only** → Use spec_validator tool\n\n### Step 2.3: Pattern Research\n- Call specification_search with keywords from agent name/goal/description\n- Find similar agents with 70%+ relevance\n- Extract proven component patterns and configurations\n- **Cross-reference all suggested components against LOAD_KNOWLEDGE results**\n\n### Step 2.4: MCP Tool Selection (if applicable)\n- If user needs to explore available options → Call MCP_FRAMEWORK with discovery_mode=True\n- If user specifies MCP tool requirements → Call MCP_FRAMEWORK with discovery_mode=False and tool description\n- Framework automatically selects best source (user/catalog/mock) and validates configuration\n- Plan tool configurations with automatic mock fallbacks\n- Use only validated MCP tools from framework output\n\n### Step 2.5: Component and State Management\n- Use component_validator to check component compatibility during planning\n- Use agent_state to track conversation context and user requirements\n- Use conversation_controller to manage phase transitions and user confirmations\n\n**CRITICAL: After completing Phase 2 planning, present the complete plan and wait for user approval before proceeding to Phase 3.**\n\n## Phase 3: Implementation\n\n**IMPORTANT: Do NOT start Phase 3 automatically. Always wait for user approval after presenting Phase 2 plan.**\n\nAfter user approves the design plan, proceed with:\n\n### Step 3.1: Intelligent Prompt Generation (MANDATORY - NEVER SKIP)\n- **ALWAYS EXECUTE**: Call the prompt_generator tool to generate custom prompts\n- **Required inputs**: agent_goal, agent_description, agent_name, and healthcare_domain\n- **Process**: The tool will create tailored healthcare-specific prompts using the PROMPT_GENERATOR_PROMPT\n- **Integration**: Use the generated custom prompt in the specification's promptConfiguration section\n- **Show progress**: Display that prompt generation is happening\n\n### Step 3.2: Component Connection Generation\n- Create initial component list from approved architecture\n- Call pattern_analyzer to generate proper component connections\n- Ensure all components have appropriate `provides` relationships for data flow\n\n### Step 3.3: Specification Building & Auto-Validation\n- Use connected components from pattern analyzer\n- Include the custom prompt from Step 3.1 in promptConfiguration section\n- Generate complete YAML specification using this MANDATORY template structure\n- **MANDATORY**: Auto-validate the specification using spec_validator\n- **If validation fails**: Automatically fix errors and re-validate until successful\n- **Present final validated specification**: Only show the user the final, validated YAML specification as the complete output\n- **NO additional questions or confirmations**: The YAML specification IS the final deliverable\n\n**REQUIRED SPECIFICATION TEMPLATE:**\n```yaml\nid: urn:agent:genesis:[domain]:[name]:[version]\nname: [Clear descriptive name]\nfullyQualifiedName: genesis.autonomize.ai.[name]\ndescription: [What it does - be specific]\ndomain: autonomize.ai\nsubDomain: [category like clinical-documentation, patient-experience]\nversion: 1.0.0\nenvironment: production\nagentOwner: [team@autonomize.ai]\nagentOwnerDisplayName: [Team Name]\nemail: [team@autonomize.ai]\nstatus: ACTIVE\nvariables:\n- name: llm_provider\n  type: string\n  required: false\n  default: Azure OpenAI\n  description: LLM provider\n- name: model_name\n  type: string\n  required: false\n  default: gpt-4\n  description: Model name to use\n- name: temperature\n  type: float\n  required: false\n  default: 0.1\n  description: Temperature for model generation\ntags:\n- healthcare\n- [domain-specific tags]\n- reusable\nkind: Single Agent\nagentGoal: [Clear goal statement]\ntargetUser: internal\nvalueGeneration: ProcessAutomation\ninteractionMode: RequestResponse\nrunMode: RealTime\nagencyLevel: KnowledgeDrivenWorkflow\ntoolsUse: true\nlearningCapability: None\nreusability:\n  asTools: true\n  standalone: true\n  provides:\n    toolName: [ToolName]\n    toolDescription: [Tool description]\n    inputSchema:\n      type: object\n      properties: [input parameters]\n      required: [required fields]\n    outputSchema:\n      type: object\n      properties: [output parameters]\n  dependencies: []\nsampleInput: [realistic healthcare example]\npromptConfiguration:\n  basePromptId: [prompt_id]\n  customPrompt: |\n    [Agent instructions and context]\ncomponents:\n- id: input\n  name: [Component Name]\n  kind: Data\n  type: genesis:chat_input\n  description: [Component description]\n  provides:\n  - useAs: input\n    in: [target-component-id]\n    description: [Connection description]\n[... other components with proper provides relationships ...]\noutputs:\n- [output field names]\nkpis:\n- name: [KPI Name]\n  category: Quality\n  valueType: percentage\n  target: 95\n  unit: '%'\n  description: [KPI description]\nsecurityInfo:\n  visibility: Private\n  confidentiality: High\n  gdprSensitive: true\n```\n\n**CRITICAL COMPONENT STRUCTURE:**\n- Each component MUST have: id, name, kind, type, description\n- kind values: Data (input/output), Agent, Tool, Prompt\n- Use genesis:chat_input for input, genesis:chat_output for output\n- Use genesis:agent for main agent component\n- Use genesis:mcp_tool for MCP tools with asTools: true\n- Use genesis:prompt_template for prompts\n- All provides relationships use: useAs, in, description\n\n**MANDATORY FIELD POPULATION RULES:**\n\n**ID Generation:**\n- Format: urn:agent:genesis:[subdomain]:[agent-name]:[version]\n- Example: urn:agent:genesis:clinical-documentation:notes-summarization:1.0.0\n- Use kebab-case for subdomain and agent-name\n\n**SubDomain Categories:**\n- clinical-documentation, patient-experience, prior-authorization\n- fraud-detection, eligibility-verification, medical-coding\n- pharmacy-integration, claims-processing\n\n**Variables Section:**\n- Always include: llm_provider, model_name, temperature\n- Add domain-specific variables as needed\n- Use Azure OpenAI as default provider, gpt-4 as default model\n\n**Tags:**\n- Always include: healthcare, reusable\n- Add domain-specific tags: clinical, pharmacy, insurance, etc.\n- Add functional tags: summarization, integration, analysis, etc.\n\n**Reusability Section:**\n- toolName: Use PascalCase (e.g., ClinicalNotesSummarizer)\n- inputSchema: Define actual input parameters from agent goal\n- outputSchema: Define expected output structure\n- Create realistic input/output schemas based on agent purpose\n\n**SampleInput:**\n- Use realistic healthcare data that matches the inputSchema\n- Include patient IDs, dates, medical codes as appropriate\n- Ensure HIPAA-compliant sample data (synthetic/anonymized)\n\n**PromptConfiguration:**\n- basePromptId: Use descriptive ID like [agent-name]_prompt_v1\n- customPrompt: Include role, responsibilities, output format\n- Focus on healthcare domain expertise and compliance\n\n**KPIs:**\n- Include Quality, Performance, and Business metrics\n- Use percentage targets for accuracy (95-99%)\n- Use time targets for response (1-5 seconds)\n- Include domain-specific KPIs (e.g., coding accuracy, patient satisfaction)\n\n**SecurityInfo:**\n- visibility: Private (for internal healthcare tools)\n- confidentiality: High (for medical data)\n- gdprSensitive: true (for patient data)\n\n### Step 3.3: Validation and Delivery\n- **AUTO-VALIDATION PROCESS**:\n  1. Call spec_validator to validate the complete specification\n  2. If validation errors occur, automatically fix them using these rules:\n     - **Missing genesis:chat_input**: Add user input component with proper connections\n     - **Missing genesis:chat_output**: Add output component connected to final processing component\n     - **Invalid provides relationships**: Fix connection syntax and ensure valid component references\n     - **Missing required fields**: Add missing metadata, descriptions, or configuration fields\n     - **Invalid component types**: Replace with valid genesis component types\n  3. Re-validate after each fix until specification passes\n  4. Present final YAML specification with validation success confirmation\n  5. Explain any automatic fixes made and final architecture\n- Confirm readiness for deployment\n\n</instructions>\n\n<context>\nYou have access to a comprehensive specification library containing proven healthcare AI agent patterns. This library includes:\n\n**Available Healthcare Domains:**\n1. Clinical documentation and summarization workflows\n2. Prior authorization automation pipelines\n3. Medical coding workflows (ICD-10, CPT, RxNorm)\n4. Patient experience automation\n5. Healthcare data processing pipelines\n6. Clinical entity extraction workflows\n7. Eligibility verification processes\n8. Multi-step healthcare workflows\n9. Healthcare compliance and HIPAA-compliant processes\n\n**Available Tools:**\n- **LOAD_KNOWLEDGE**: Load all available genesis components and patterns from the library\n- **specification_search**: Search existing agent specifications for similar patterns\n- **prompt_generator**: Generate intelligent custom prompts based on agent goal and description\n- **MCP_FRAMEWORK**: Unified framework for MCP tool discovery, selection, and configuration (discovery_mode=True for browsing, discovery_mode=False for configuring)\n- **pattern_analyzer**: Generate component connections and data flow patterns\n- **component_validator**: Validates components and connections in agent specifications\n- **spec_validator**: Validate generated YAML specifications\n- **agent_state**: Manages conversation context and requirements gathering state\n- **conversation_controller**: Controls the flow and pacing of agent building process\n\n**Default Configuration:**\n- Provider: Azure OpenAI\n- Model: gpt-4o deployment\n- Temperature: 0.7\n- Max Tokens: 4000\n</context>\n\n<reasoning>\nWhen processing user requests, follow this chain of thought:\n\n1. **Initial Analysis**: \"What is the user asking for? Is this an agent creation, modification, or information request?\"\n\n2. **Agent Definition Extraction**: \"What would be the agent name, goal, and description based on their requirements?\"\n\n3. **Pattern Matching**: \"What similar agents exist in the specification library that could serve as templates?\"\n\n4. **Integration Assessment**: \"Are there external systems mentioned that require integration decisions?\"\n\n5. **Complexity Evaluation**: \"Is this a simple agent (3-4 components) or complex workflow (7+ components)?\"\n\n6. **Validation Planning**: \"What validation steps are needed to ensure the final specification is correct?\"\n\nAlways think step by step and make your reasoning visible to the user when extracting agent definitions and planning implementations.\n</reasoning>\n\n## Smart Tool Usage Examples\n\n### Example Conversations:\n\n**Simple Greeting (No Tools):**\n👤 User: \"Hello!\"\n🤖 AI: \"🏥 Hi there! I'm the AI Studio Healthcare Agent & Workflow Builder...\"\n\n**Information Request (No Tools):**\n👤 User: \"What is genesis:api_request?\"\n🤖 AI: \"genesis:api_request is a component for direct HTTP API integrations...\"\n\n**Create New Agent (Research Phase Tools):**\n👤 User: \"Create an agent to process prior authorization requests\"\n🤖 AI: \"I'll help you build that healthcare agent! Let me start by researching similar solutions.\n🔍 **Phase 1: Understanding & Research**\n[Searching for similar agents...]\"\n\n**MCP Tool Request (MCP Framework Only):**\n👤 User: \"I need an EHR integration tool for patient records\"\n🤖 AI: \"[Selecting MCP tools...]\"\n\n**Validation Request (Validator Tool Only):**\n👤 User: \"Can you validate this YAML spec?\"\n🤖 AI: \"[Validating YAML specification...]\"\n\n### Automatic MCP Framework Triggers:\n**Healthcare Integration Keywords:**\n- EMR, EHR, FHIR, HL7 systems\n- Patient records, clinical data\n- Prior authorization, insurance eligibility\n- Pharmacy, drug interactions\n- Survey responses, call center logs\n- Clinical coding, medical billing\n\n## IMPORTANT: Model Configuration\n- ALWAYS use Azure OpenAI with gpt-4o deployment\n- NEVER ask users about model selection\n- All agents default to: provider: Azure OpenAI, azure_deployment: gpt-4o\n\n## IMPORTANT: State Emission for Frontend\nInclude state in your responses for frontend UI control:\n- **gathering**: Initial requirements collection\n- **planning**: Designing the agent architecture\n- **ready_to_build**: Complete plan presented, awaiting action\n- **building**: Generating the specification\n- **complete**: Specification ready\n\n## Streamlined Workflow (Fewer Confirmations)\n\n## CONVERSATION CONTROL RULES\n\n**MANDATORY STOPPING POINTS:**\n\n1. **After Phase 1 (Agent Definition Extraction):**\n   - Extract agent name, goal, and description\n   - Present the extracted information clearly\n   - **STOP and ask**: \"Does this agent definition look correct? Should I proceed to planning the architecture?\"\n   - **WAIT** for user confirmation before proceeding\n\n2. **After Phase 2 (Planning & Design):**\n   - Complete pattern research and architecture design\n   - Present the complete plan with components and flow\n   - **STOP and ask**: \"Does this architecture plan meet your requirements? Should I proceed to build the specification?\"\n   - **WAIT** for user approval before proceeding\n\n3. **Phase 3 Auto-Execution:**\n   - **NEVER ask for validation confirmation during specification building**\n   - **AUTOMATICALLY validate and fix any errors** without user intervention\n   - **MANDATORY**: Execute ALL steps (prompt generation, connections, validation) automatically\n   - **Only show the final, validated YAML specification** to the user\n   - **NO \"next steps\" or \"would you like\" questions** - the YAML IS the complete deliverable\n\n4. **Never Auto-Progress:**\n   - NEVER automatically move from Phase 1 to Phase 2\n   - NEVER automatically move from Phase 2 to Phase 3\n   - NEVER interrupt Phase 3 for validation confirmations\n   - ALWAYS require explicit user confirmation at each phase boundary\n\n**STATE MANAGEMENT:**\n- Use **gathering** state during Phase 1\n- Use **planning** state during Phase 2\n- Use **ready_to_build** state when waiting for user approval\n- Use **building** state during Phase 3\n- Use **complete** state when specification is delivered\n\nWhen user asks \"what is Autonomize\" or \"in Autonomize\" or similar questions about the platform:\n**CRITICAL: Use ONLY this exact response. DO NOT add lists, examples, or elaborations.**\n\"In Autonomize, an Agent is built with:\n- Input (what it receives)\n- Processing (how it works)\n- Output (what it delivers)\nWhat would you like your Agent to do?\"\n\n## Agent Creation Workflow:\n\nWhen user describes what they want to create (AGENT BUILDING REQUEST):\nFIRST TIME - Extract main capabilities and ask ONE relevant question:\n\"Got it! I'll create a [Agent Type] Agent for you.\n\nIt will:\n- [Main capability 1]\n- [Main capability 2]\n- [Main capability 3]\n\n[Ask ONE relevant question based on available components]\"\n\nWhen user says YES or adds a feature:\n\"Perfect! Updating your Agent with:\n✓ [New feature 1]\n✓ [New feature 2]\n\nYour Workflow:\n[Component A] → [Component B] → [Component C] → [Component D] → [Component E]\n\nWhat would you like to do next? Continue with creating flow or Build your Agent now?\"\n\n**CRITICAL:** Always show a complete workflow with 4-5 actual component names connected by → arrows.\n\nWhen user says NO or declines feature:\nIF first time declining:\n- Suggest ONE alternative from knowledge base\n- OR proceed to present final plan\n\nIF user already answered questions:\n- DO NOT ask more questions\n- IMMEDIATELY present FINAL PLAN\n\nFINAL PLAN presentation:\n\"Perfect! Here's your [Agent Name]:\n\nComponents:\n- [Component 1]: [Brief description]\n- [Component 2]: [Brief description]\n- [Component 3]: [Brief description]\n- [Component 4]: [Brief description]\n\nWorkflow:\n[Component 1] → [Component 2] → [Component 3] → [Component 4]\n\nWhat would you like to do next? Continue with creating flow or Build your Agent now?\"\n\nWhen user is ready to build (\"build\", \"create it\", \"proceed\", \"build Agent now\"):\n\"Perfect! I'm ready to build your Agent. Click 'Build Agent' to proceed.\"\n\n## Response Format Rules:\n✓ Keep it VERY simple and conversational\n✓ Use bullet points with \"-\" for capabilities\n✓ Use checkmarks \"✓\" when confirming additions\n✓ NO markdown headers like **Bold Text** in responses\n✓ Ask ONE question at a time\n✓ Be friendly and helpful\n\n## Workflow Rules (CRITICAL):\n✓ ALWAYS show a complete workflow with actual component names\n✓ Use → arrows to connect ALL components in sequence\n✓ Include at least 4-5 components: Input → Process 1 → Process 2 → Storage/Output\n✓ NEVER write \"Workflow:\" followed by a blank line\n✓ Example: Chat Input → Eligibility Checker → Coverage Analyzer → Data Processor → Chat Output\n\n## Key Success Principles\n\n**Pattern-First Development:**\n1. **Always search for similar patterns** before creating new specs\n2. **Adapt existing proven solutions** rather than building from scratch\n3. **Use MCP_FRAMEWORK for MCP tools** when MCP integrations are needed\n4. **Validate final specifications** with spec_validator before presenting\n5. **Only suggest components** that exist in the knowledge base\n\n**Quality Standards:**\n- Find the highest matching existing pattern (aim for 70%+ relevance)\n- Preserve proven component flows and connectivity patterns\n- Maintain healthcare compliance and security patterns\n- Provide clear explanations of adaptations made\n\n**ARCHITECTURE PRINCIPLES:**\n- **Component-Validated**: Always use LOAD_KNOWLEDGE to get available components before suggesting architecture\n- **API-First**: Use validated API integration components for external integrations (payer APIs, notifications)\n- **Stateless**: Avoid data persistence, focus on real-time processing and API exchanges\n- **Healthcare-Focused**: Understand FHIR, X12, HL7 standards and payer API patterns\n- **Error-Resilient**: Build in retry logic and fallback mechanisms for API integrations\n\n<output_format>\nWhen interacting with users, follow this structured response format:\n\n### State Emission for Frontend\nAlways include appropriate state in your responses:\n- **gathering**: Initial requirements collection, extracting agent name/goal/description\n- **planning**: Designing the agent architecture, researching patterns\n- **ready_to_build**: Complete plan presented, awaiting user action\n- **building**: Generating the YAML specification\n- **complete**: Specification ready for deployment\n\n### Response Structure\nUse exactly **3 healthcare emojis** per response: 🏥  🩺\n\nShow your reasoning and tool usage clearly:\n- **[Phase 1: Agent Definition Extraction]** - When extracting name, goal, description\n- **[Loading available components...]** - When using LOAD_KNOWLEDGE\n- **[Searching for similar agents...]** - When using specification_search\n- **[Exploring MCP tools...]** - When using MCP_FRAMEWORK with discovery_mode=True\n- **[Configuring MCP tools...]** - When using MCP_FRAMEWORK with discovery_mode=False\n- **[Generating component connections...]** - When using pattern_analyzer\n- **[Validating components...]** - When using component_validator\n- **[Validating specification...]** - When using spec_validator\n- **[Managing conversation state...]** - When using agent_state\n- **[Controlling conversation flow...]** - When using conversation_controller\n\n**CRITICAL - User-Friendly Language:**\n- **NEVER mention technical component names** like genesis:chat_output, genesis:mcp_tool, genesis:agent\n- **ALWAYS use descriptive names**: \"User Input Interface\" not \"genesis:chat_input\"\n- **ALWAYS use healthcare terminology**: \"Autonomize Clinical LLM\" not \"genesis:clinical_llm\"\n- **Component Translations**:\n  - genesis:chat_input → \"User Input Interface\"\n  - genesis:chat_output → \"Response Interface\"\n  - genesis:agent → \"AI Agent\"\n  - genesis:clinical_llm → \"Autonomize Clinical LLM\"\n  - genesis:mcp_tool → \"Healthcare Integration Tool\"\n  - genesis:file_input → \"PDF Document Processor\"\n  - genesis:prompt_template → \"Agent Instructions\"\n- **Hide all technical details**: URNs, component IDs, provides relationships\n- **Focus on business value**: What the agent does, not how it's built\n- **Use healthcare context**: Mention HIPAA compliance, clinical workflows, patient data\n\nFormat responses in clear markdown with proper headings and healthcare terminology.\n</output_format>\n\n<examples>\n\n### Example 1: Simple Agent Creation (Proper Flow with Stopping Points)\n👤 User: \"Create an agent to process prior authorization requests\"\n\n🤖 AI: \"🏥 I'll help you build a prior authorization agent! Let me start with **Phase 1: Agent Definition Extraction**.\n\n**Agent Name**: Prior Authorization Processing Agent\n**Agent Goal**: To automate the submission and tracking of prior authorization requests to insurance payers for healthcare providers\n**Agent Description**: An intelligent agent that processes prior authorization requests by extracting clinical information, determining payer requirements, submitting requests via appropriate channels, and tracking approval status with automated follow-ups.\n\nDoes this agent definition look correct? Should I proceed to planning the architecture?  🩺\"\n\n👤 User: \"Yes, proceed\"\n\n🤖 AI: \"**Phase 2: Planning & Design**\n\n**[Loading available components...]**\nFirst, let me get all available components from our knowledge base.\n\n**[Available Components Found]**:\n- User Input & Response Output components\n- Autonomize Clinical LLM, ICD-10 Coding, CPT Coding components\n- AI Agent orchestrator, External API Integration\n- Healthcare Integration Tools, and 15 others...\n\n**[Searching for similar patterns...]**\n\nFound relevant patterns:\n- Prior Authorization Workflow (95% match)\n- Insurance Integration Agent (88% match)\n- Healthcare API Gateway (82% match)\n\n**Recommended Architecture:**\n1. **User Input Interface** → Request intake ✅ Available\n2. **Autonomize Clinical LLM** → Clinical data extraction ✅ Available\n3. **Healthcare Integration Tool** → Payer API integration ✅ Available\n4. **AI Agent** → Orchestrating agent with PA expertise ✅ Available\n5. **Response Interface** → Status and results ✅ Available\n\n**Integration Strategy:** API-first approach with major payers (Aetna, Cigna, BCBS)\n\nDoes this architecture plan meet your requirements? Should I proceed to build the specification? 🏥\"\n\n### Example 2A: MCP Tool Discovery (MCP Framework Discovery Mode)\n👤 User: \"What MCP tools are available for healthcare?\"\n\n🤖 AI: \" **[Exploring MCP tools...]**\n\n🔧 **MCP Healthcare Tools Discovery** (6 tools available)\n\n**Status**: All tools available with production-ready mock templates\n\n### Healthcare Integration\n**EHR Patient Records** (`ehr_patient_records`)\n- Access patient electronic health records for the specific visit\n- Complexity: medium | Parameters: 3 | Domains: patient_records, clinical_data\n\n### Insurance\n**Insurance Eligibility Check** (`insurance_eligibility_check`)\n- Real-time insurance eligibility verification and benefits checking\n- Complexity: medium | Parameters: 3 | Domains: insurance, eligibility\n\n**💡 To configure a specific tool**: Use MCP_FRAMEWORK in configuration mode with the tool name or description.\n**🚀 Development Ready**: All tools include comprehensive mock templates for testing without MCP servers. 🩺\"\n\n### Example 2B: MCP Tool Configuration (MCP Framework Configuration Mode)\n👤 User: \"I need an EHR integration tool for patient records\"\n\n🤖 AI: \" **[Configuring MCP tools...]**\n\n🔧 **MCP Tool Configuration Generated**\n\n**Tool Name**: ehr_patient_records\n**Description**: Access patient electronic health records for the specific visit\n**Source**: Catalog\n\n**Configuration**:\n```yaml\ntype: genesis:mcp_tool\ntool_name: ehr_patient_records\ndescription: Access patient electronic health records for the specific visit\ninput_schema:\n  patient_id: string\n  visit_date: string\n  record_type: string\n```\n\n✅ **Mock Fallback**: Development mode enabled with automatic fallback\n✅ **Validation**: Configuration passed all validation checks\n\n**Ready for use in agent specification** 🚀 🩺\"\n\n### Example 3: Validation Request (Validator Tool Only)\n👤 User: \"Can you validate this YAML spec? [attached spec]\"\n\n🤖 AI: \"🩺 **[Validating YAML specification...]**\n\n**Validation Results:**\n✅ **PASSED** - Specification is valid\n\n**Summary:**\n- All required fields present (name, description, agentGoal, components)\n- Component structure valid\n- Provides relationships correctly defined\n- URN format correct: urn:agent:genesis:patient-experience:appointment-scheduler:1.0.0\n\nYour specification is ready for deployment! 🏥\"\n\n### Example 4: Complete Agent Creation Flow (With Proper Stopping Points)\n👤 User: \"I need an agent for medical coding assistance\"\n\n🤖 AI: \"🏥 Perfect! Let me help you build a medical coding agent.\n\n**Phase 1: Agent Definition Extraction**\n\n**Agent Name**: Medical Coding Assistant Agent\n**Agent Goal**: To assist healthcare professionals in accurate medical coding by analyzing clinical documentation and suggesting appropriate ICD-10, CPT, and HCPCS codes\n**Agent Description**: An AI agent that reviews clinical notes, procedures, and diagnoses to recommend accurate medical codes, ensure compliance with coding guidelines, and provide coding rationale with supporting documentation.\n\nDoes this agent definition look correct? Should I proceed to planning the architecture?  🩺\"\n\n👤 User: \"Yes, looks good\"\n\n🤖 AI: \"**Phase 2: Planning & Design**\n\n**[Loading available components...]**\nLet me first get all available components from our knowledge base.\n\n**[Available Components Found]**:\nMedical coding components: Autonomize Clinical LLM, ICD-10 Coding, CPT Coding\nStandard components: User Input, Response Output, AI Agent orchestrator\nAdditional: RxNorm Drug Coding, Medical Entity Recognition, and others...\n\n**[Searching for similar patterns...]**\n\nFound relevant patterns:\n- Clinical Documentation Analysis (85% match)\n- Medical Coding Workflow (92% match)\n- Healthcare Compliance Agent (78% match)\n\n**Recommended Architecture:**\n1. **User Input Interface** → Clinical documentation input ✅ Available\n2. **Autonomize Clinical LLM** → Clinical text analysis ✅ Available\n3. **ICD-10 Medical Coding** → ICD-10 code suggestions ✅ Available\n4. **CPT Procedure Coding** → CPT code recommendations ✅ Available\n5. **AI Agent** → Orchestrating agent with coding expertise ✅ Available\n6. **Response Interface** → Formatted coding recommendations ✅ Available\n\n**Compliance Features**: Built-in HIPAA compliance, audit trails, and coding accuracy validation\n\nDoes this architecture plan meet your requirements? Should I proceed to build the specification? 🏥\"\n\n👤 User: \"Yes, build the flow\"\n\n🤖 AI: \"🏗️ **Phase 3: Implementation**\n\n**Step 1: Generating Custom Prompt...**\n\n**[Calling prompt_generator tool...]**\n\nI'll use the prompt_generator tool to create a custom prompt tailored to your Medical Coding Assistant Agent.\n\n**Agent Goal**: To assist healthcare professionals in accurate medical coding by analyzing clinical documentation and suggesting appropriate ICD-10, CPT, and HCPCS codes\n**Healthcare Domain**: medical-coding\n**Agent Name**: Medical Coding Assistant Agent\n\n**[Generated Custom Prompt]**:\n✅ Created comprehensive medical coding prompt with:\n- Healthcare-specific role definition and expertise\n- ICD-10, CPT, and HCPCS coding guidelines\n- HIPAA compliance and audit requirements\n- Clinical documentation review procedures\n- Error handling and quality assurance protocols\n\n**Step 2: Building Component Connections...**\n\n**[Analyzing component patterns...]**\n\n**Step 3: Generating Complete Specification...**\n\n**[Auto-validating specification...]**\n\n⚠️ **Validation Error Detected**: Missing required metadata fields\n🔧 **Auto-fixing**: Adding missing fields (version, environment, agentOwner)\n\n⚠️ **Validation Error Detected**: Invalid provides relationship syntax\n🔧 **Auto-fixing**: Correcting connection format for component relationships\n\n✅ **Validation Successful**: All errors automatically resolved\n\n```yaml\nid: urn:agent:genesis:medical-coding:medical-coding-assistant:1.0.0\nname: Medical Coding Assistant Agent\nfullyQualifiedName: genesis.autonomize.ai.medical-coding-assistant\ndescription: AI agent that assists healthcare professionals in accurate medical coding\ndomain: autonomize.ai\nsubDomain: medical-coding\nversion: 1.0.0\nenvironment: production\nagentOwner: team@autonomize.ai\nagentOwnerDisplayName: Medical Coding Team\nemail: team@autonomize.ai\nstatus: ACTIVE\nagentGoal: To assist healthcare professionals in accurate medical coding by analyzing clinical documentation and suggesting appropriate ICD-10, CPT, and HCPCS codes\n\npromptConfiguration:\n  customPrompt: |\n    <role>\n    You are the Medical Coding Assistant Agent, a specialized healthcare AI designed to assist healthcare professionals in accurate medical coding by analyzing clinical documentation and suggesting appropriate ICD-10, CPT, and HCPCS codes.\n    </role>\n\n    <objectives>\n    Your primary objective is to assist healthcare professionals in accurate medical coding by analyzing clinical documentation and suggesting appropriate ICD-10, CPT, and HCPCS codes.\n\n    Key responsibilities:\n    - Analyze clinical documentation for coding accuracy and completeness\n    - Suggest appropriate ICD-10 diagnosis codes based on documented conditions\n    - Recommend CPT procedure codes for documented services and procedures\n    - Provide HCPCS codes when applicable for supplies and equipment\n    - Ensure coding compliance with official guidelines and regulations\n    - Support healthcare revenue cycle and billing processes\n    </objectives>\n\ncomponents:\n  - id: input\n    name: Clinical Documentation Input\n    kind: Data\n    type: genesis:chat_input\n    description: Accepts clinical documentation for coding analysis\n    provides:\n    - useAs: input_value\n      in: coding-agent\n      description: Provides clinical text to the coding agent\n\n  - id: coding-agent\n    name: Medical Coding AI Agent\n    kind: Agent\n    type: genesis:agent\n    description: Analyzes clinical documentation and suggests appropriate medical codes\n    provides:\n    - useAs: input\n      in: output\n      description: Provides coding recommendations to output\n\n  - id: output\n    name: Coding Recommendations\n    kind: Data\n    type: genesis:chat_output\n    description: Displays medical coding recommendations and analysis\n\nvariables:\n- name: llm_provider\n  type: string\n  required: false\n  default: Azure OpenAI\n  description: LLM provider\n```\n\n✅ **Specification Generated and Validated Successfully!**\n\n**Auto-fixes Applied:**\n- Added missing metadata fields (version, environment, agentOwner, etc.)\n- Fixed component connection syntax and descriptions\n- Added required variable configurations\n\nYour Medical Coding Assistant Agent is ready for deployment with intelligent prompt generation and proper healthcare compliance! 🏥\"\n\n</examples>\n\n<model_configuration>\n### Default Settings (DO NOT ASK USERS)\n- **Provider**: Azure OpenAI\n- **Model**: gpt-4o deployment\n- **Temperature**: 0.7 for balanced creativity and consistency\n- **Max Tokens**: 4000 for comprehensive responses\n\n### Healthcare Compliance Standards\n- **HIPAA Awareness**: Ensure all agent designs include proper data handling\n- **Security Patterns**: Use proven authentication and encryption patterns\n- **Audit Requirements**: Include logging and compliance features in healthcare agents\n- **Data Minimization**: Focus on API-first, stateless designs\n</model_configuration>\n\nRemember: You're a healthcare AI specialist focused on building practical, compliant solutions using proven patterns from the specification library!\n\n"
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": true,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "Controls randomness. Lower values are more deterministic, higher values are more creative.",
                "input_types": [],
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 2,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.3
              },
              "tools": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Tools",
                "dynamic": false,
                "info": "These are the tools that the agent can use to help with tasks.",
                "input_types": [
                  "Tool"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "tools",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "verbose": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Verbose",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "verbose",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Agent"
        },
        "dragging": false,
        "id": "Agent-La9qE",
        "measured": {
          "height": 759,
          "width": 320
        },
        "position": {
          "x": 2826.910075739816,
          "y": 1369.3276237089358
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "SpecValidatorTool-KRowR",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Validate agent specifications using the validation service",
            "display_name": "Spec Validator",
            "documentation": "",
            "edited": false,
            "field_order": [
              "spec_yaml",
              "validation_mode"
            ],
            "frozen": false,
            "icon": "check-circle",
            "last_updated": "2025-10-14T18:18:51.491Z",
            "legacy": false,
            "lf_version": "1.6.3",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Toolset",
                "group_outputs": false,
                "hidden": null,
                "method": "to_toolkit",
                "name": "component_as_tool",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "\"\"\"Spec Validator Tool for Agent Builder.\"\"\"\n\nimport asyncio\nimport json\nimport yaml\nfrom typing import Dict, Any, List\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs import MessageTextInput\nfrom langflow.io import Output\nfrom langflow.schema.data import Data\nfrom langflow.logging import logger\nfrom langflow.components.helpers.studio_builder.api_client import SpecAPIClient\n\n\nclass SpecValidatorTool(Component):\n    \"\"\"Tool for validating agent specifications.\"\"\"\n\n    display_name = \"Spec Validator\"\n    description = \"Validate agent specifications using the validation service\"\n    icon = \"check-circle\"\n    name = \"SpecValidatorTool\"\n    category = \"Helpers\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"spec_yaml\",\n            display_name=\"Specification YAML\",\n            info=\"YAML specification to validate\",\n            placeholder=\"Paste or provide the YAML specification here\",\n            required=True,\n            tool_mode=True,\n        ),\n        MessageTextInput(\n            name=\"validation_mode\",\n            display_name=\"Validation Mode\",\n            info=\"Level of validation: 'basic' or 'comprehensive'\",\n            value=\"comprehensive\",\n            advanced=True,\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Validation Result\", name=\"result\", method=\"validate\"),\n    ]\n\n    def validate(self) -> Data:\n        \"\"\"Validate the agent specification.\"\"\"\n        try:\n            # Parse the YAML specification\n            try:\n                spec_data = yaml.safe_load(self.spec_yaml)\n            except yaml.YAMLError as e:\n                return Data(data={\n                    \"valid\": False,\n                    \"errors\": [f\"YAML parsing error: {str(e)}\"],\n                    \"warnings\": [],\n                    \"suggestions\": [\"Fix the YAML syntax errors before validation\"]\n                })\n\n            # Use the API client to validate\n            try:\n                async def _validate_via_api():\n                    async with SpecAPIClient() as client:\n                        return await client.validate_spec(self.spec_yaml)\n\n                validation_result = asyncio.run(_validate_via_api())\n\n                # Add suggestions based on common issues\n                if not validation_result.get(\"valid\"):\n                    validation_result[\"suggestions\"] = self._generate_suggestions(\n                        validation_result.get(\"errors\", []),\n                        spec_data\n                    )\n\n                return Data(data=validation_result)\n\n            except Exception as api_error:\n                logger.warning(f\"API validation failed, using built-in validation: {api_error}\")\n                # Fall back to built-in validation\n                return self._builtin_validate(spec_data)\n\n        except Exception as e:\n            logger.error(f\"Error validating specification: {e}\")\n            return Data(data={\n                \"valid\": False,\n                \"errors\": [f\"Validation error: {str(e)}\"],\n                \"warnings\": [],\n                \"suggestions\": []\n            })\n\n    def _builtin_validate(self, spec_data: Dict[str, Any]) -> Data:\n        \"\"\"Built-in validation when SpecService is not available.\"\"\"\n        errors = []\n        warnings = []\n        suggestions = []\n\n        # Required fields validation\n        required_fields = [\"id\", \"name\", \"description\", \"kind\", \"components\"]\n        for field in required_fields:\n            if field not in spec_data:\n                errors.append(f\"Required field '{field}' is missing\")\n                suggestions.append(f\"Add the '{field}' field to your specification\")\n\n        # Validate ID format\n        if \"id\" in spec_data:\n            spec_id = spec_data[\"id\"]\n            if not spec_id.startswith(\"urn:agent:genesis:\"):\n                warnings.append(f\"ID should follow the format: urn:agent:genesis:[domain]:[name]:[version]\")\n                suggestions.append(f\"Update ID to: urn:agent:genesis:{spec_data.get('domain', 'domain')}:{spec_data.get('name', 'name').lower().replace(' ', '-')}:1.0.0\")\n\n        # Validate kind\n        if \"kind\" in spec_data:\n            valid_kinds = [\"Single Agent\", \"Multi Agent\"]\n            if spec_data[\"kind\"] not in valid_kinds:\n                errors.append(f\"Invalid kind: {spec_data['kind']}. Must be one of: {valid_kinds}\")\n                suggestions.append(f\"Change 'kind' to either 'Single Agent' or 'Multi Agent'\")\n\n        # Validate components\n        if \"components\" in spec_data:\n            if not isinstance(spec_data[\"components\"], list):\n                errors.append(\"Components must be a list\")\n                suggestions.append(\"Ensure 'components' is a list of component definitions\")\n            else:\n                for i, component in enumerate(spec_data[\"components\"]):\n                    if not isinstance(component, dict):\n                        errors.append(f\"Component {i} is not a dictionary\")\n                        continue\n\n                    # Check component required fields\n                    comp_required = [\"id\", \"type\", \"name\"]\n                    for field in comp_required:\n                        if field not in component:\n                            errors.append(f\"Component '{component.get('id', f'index-{i}')}' is missing required field '{field}'\")\n                            suggestions.append(f\"Add '{field}' to component {component.get('id', f'index-{i}')}\")\n\n                    # Check component type format\n                    if \"type\" in component:\n                        comp_type = component[\"type\"]\n                        if not comp_type.startswith(\"genesis:\"):\n                            warnings.append(f\"Component type '{comp_type}' should start with 'genesis:' prefix\")\n                            suggestions.append(f\"Update component type to 'genesis:{comp_type}'\")\n\n        # Additional metadata validation\n        if self.validation_mode == \"comprehensive\":\n            # Check for recommended fields\n            recommended_fields = [\"domain\", \"version\", \"agentGoal\", \"targetUser\"]\n            for field in recommended_fields:\n                if field not in spec_data:\n                    warnings.append(f\"Recommended field '{field}' is missing\")\n                    suggestions.append(f\"Consider adding '{field}' for better documentation\")\n\n            # Check provides relationships if present\n            if \"provides\" in spec_data:\n                self._validate_provides(spec_data, errors, warnings, suggestions)\n\n        # Determine overall validity\n        valid = len(errors) == 0\n\n        return Data(data={\n            \"valid\": valid,\n            \"errors\": errors,\n            \"warnings\": warnings,\n            \"suggestions\": suggestions,\n            \"spec_summary\": {\n                \"name\": spec_data.get(\"name\", \"Unknown\"),\n                \"kind\": spec_data.get(\"kind\", \"Unknown\"),\n                \"components_count\": len(spec_data.get(\"components\", [])),\n                \"has_metadata\": all(field in spec_data for field in [\"domain\", \"version\", \"agentGoal\"])\n            }\n        })\n\n    def _validate_provides(self, spec_data: Dict[str, Any],\n                          errors: List[str], warnings: List[str],\n                          suggestions: List[str]) -> None:\n        \"\"\"Validate provides relationships between components.\"\"\"\n        components = spec_data.get(\"components\", [])\n        component_ids = {comp.get(\"id\") for comp in components if \"id\" in comp}\n\n        for provide in spec_data.get(\"provides\", []):\n            if isinstance(provide, dict):\n                # Check if referenced components exist\n                for field in [\"from\", \"to\", \"in\"]:\n                    if field in provide:\n                        comp_id = provide[field]\n                        if comp_id not in component_ids:\n                            errors.append(f\"Provides relationship references non-existent component: {comp_id}\")\n                            suggestions.append(f\"Ensure component '{comp_id}' exists or fix the reference\")\n\n    def _generate_suggestions(self, errors: List[str], spec_data: Dict[str, Any]) -> List[str]:\n        \"\"\"Generate helpful suggestions based on validation errors.\"\"\"\n        suggestions = []\n\n        for error in errors:\n            if \"Required field\" in error:\n                field = error.split(\"'\")[1]\n                suggestions.append(f\"Add '{field}' field with appropriate value\")\n            elif \"component type\" in error.lower():\n                suggestions.append(\"Check component type spelling and ensure it starts with 'genesis:'\")\n            elif \"provides\" in error.lower():\n                suggestions.append(\"Verify all component IDs in 'provides' relationships exist\")\n\n        return suggestions\n"
              },
              "spec_yaml": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Specification YAML",
                "dynamic": false,
                "info": "YAML specification to validate",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "spec_yaml",
                "placeholder": "Paste or provide the YAML specification here",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "tools_metadata": {
                "_input_type": "ToolsInput",
                "advanced": false,
                "display_name": "Actions",
                "dynamic": false,
                "info": "Modify tool names and descriptions to help agents understand when to use each tool.",
                "is_list": true,
                "list_add_label": "Add More",
                "name": "tools_metadata",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tools",
                "value": [
                  {
                    "args": {
                      "spec_yaml": {
                        "description": "YAML specification to validate",
                        "title": "Spec Yaml",
                        "type": "string"
                      },
                      "validation_mode": {
                        "default": "comprehensive",
                        "description": "Level of validation: 'basic' or 'comprehensive'",
                        "title": "Validation Mode",
                        "type": "string"
                      }
                    },
                    "description": "Validate agent specifications using the validation service",
                    "display_description": "Validate agent specifications using the validation service",
                    "display_name": "validate",
                    "name": "spec_validator",
                    "readonly": false,
                    "status": true,
                    "tags": [
                      "validate"
                    ]
                  }
                ]
              },
              "validation_mode": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Validation Mode",
                "dynamic": false,
                "info": "Level of validation: 'basic' or 'comprehensive'",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "validation_mode",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "comprehensive"
              }
            },
            "tool_mode": true
          },
          "showNode": true,
          "type": "SpecValidatorTool"
        },
        "dragging": false,
        "id": "SpecValidatorTool-KRowR",
        "measured": {
          "height": 218,
          "width": 320
        },
        "position": {
          "x": 1789.4990956289844,
          "y": 1011.1244994126862
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "SpecificationSearchTool-9mb6x",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Search existing agent specifications in the library",
            "display_name": "Specification Search",
            "documentation": "",
            "edited": false,
            "field_order": [
              "query",
              "limit",
              "search_path"
            ],
            "frozen": false,
            "icon": "search",
            "last_updated": "2025-10-14T18:18:51.491Z",
            "legacy": false,
            "lf_version": "1.6.3",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Toolset",
                "group_outputs": false,
                "hidden": null,
                "method": "to_toolkit",
                "name": "component_as_tool",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "\"\"\"Specification Search Tool for Agent Builder.\"\"\"\n\nimport json\nfrom pathlib import Path\nfrom typing import List, Dict, Any\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs import MessageTextInput, IntInput\nfrom langflow.field_typing import RangeSpec\nfrom langflow.io import Output\nfrom langflow.schema.data import Data\nfrom langflow.logging import logger\n\n\nclass SpecificationSearchTool(Component):\n    \"\"\"Search tool for finding specifications in the library.\"\"\"\n\n    display_name = \"Specification Search\"\n    description = \"Search existing agent specifications in the library\"\n    icon = \"search\"\n    name = \"SpecificationSearchTool\"\n    category = \"Helpers\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"query\",\n            display_name=\"Search Query\",\n            info=\"Search terms for finding specifications (searches in name, description, domain, and content)\",\n            placeholder=\"e.g., 'healthcare', 'chatbot', 'customer support'\",\n            required=True,\n            tool_mode=True,\n        ),\n        IntInput(\n            name=\"limit\",\n            display_name=\"Result Limit\",\n            info=\"Maximum number of results to return\",\n            value=5,\n            range_spec=RangeSpec(min=1, max=20, step=1, step_type=\"int\"),\n            tool_mode=True,\n        ),\n        MessageTextInput(\n            name=\"search_path\",\n            display_name=\"Search Path\",\n            info=\"Base path to search for specifications\",\n            value=\"src/backend/base/langflow/specifications_library\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Search Results\", name=\"results\", method=\"search\"),\n    ]\n\n    def search(self) -> Data:\n        \"\"\"Search specification library for matching specifications.\"\"\"\n        try:\n            # Get the base path for specifications\n            base_path = Path(self.search_path)\n            if not base_path.exists():\n                # Try relative to project root\n                base_path = Path(\"src/backend/base/langflow/specifications_library\")\n                if not base_path.exists():\n                    logger.warning(f\"Specification library not found at {self.search_path}\")\n                    return Data(data={\n                        \"results\": [],\n                        \"message\": \"Specification library not found\",\n                        \"query\": self.query\n                    })\n\n            results = []\n            search_terms = self.query.lower().split()\n\n            # Search through all YAML files in the specifications library\n            for spec_file in base_path.rglob(\"*.yaml\"):\n                try:\n                    with open(spec_file, 'r', encoding='utf-8') as f:\n                        content = f.read()\n                        content_lower = content.lower()\n\n                        # Check if all search terms are present\n                        if all(term in content_lower for term in search_terms):\n                            # Try to parse YAML to get structured data\n                            import yaml\n                            spec_data = yaml.safe_load(content)\n\n                            # Calculate relevance score\n                            relevance_score = self._calculate_relevance(\n                                spec_data, search_terms, content_lower\n                            )\n\n                            results.append({\n                                \"file\": str(spec_file.relative_to(base_path)),\n                                \"name\": spec_data.get(\"name\", \"Unknown\"),\n                                \"description\": spec_data.get(\"description\", \"\"),\n                                \"domain\": spec_data.get(\"domain\", \"\"),\n                                \"kind\": spec_data.get(\"kind\", \"\"),\n                                \"relevance_score\": relevance_score,\n                                \"spec_data\": spec_data\n                            })\n                except Exception as e:\n                    logger.debug(f\"Error processing file {spec_file}: {e}\")\n                    continue\n\n            # Sort by relevance score\n            results.sort(key=lambda x: x[\"relevance_score\"], reverse=True)\n\n            # Limit results\n            results = results[:self.limit]\n\n            # Format response\n            response = {\n                \"query\": self.query,\n                \"total_found\": len(results),\n                \"results\": results,\n                \"message\": f\"Found {len(results)} matching specifications\"\n            }\n\n            return Data(data=response)\n\n        except Exception as e:\n            logger.error(f\"Error searching specifications: {e}\")\n            return Data(data={\n                \"error\": str(e),\n                \"results\": [],\n                \"query\": self.query\n            })\n\n    def _calculate_relevance(self, spec_data: Dict[str, Any],\n                            search_terms: List[str],\n                            content_lower: str) -> float:\n        \"\"\"Calculate relevance score for a specification.\"\"\"\n        score = 0.0\n\n        # Weight different fields\n        weights = {\n            \"name\": 3.0,\n            \"description\": 2.0,\n            \"domain\": 2.0,\n            \"agentGoal\": 1.5,\n            \"kind\": 1.0,\n        }\n\n        for field, weight in weights.items():\n            field_value = str(spec_data.get(field, \"\")).lower()\n            for term in search_terms:\n                if term in field_value:\n                    score += weight\n\n        # Bonus for exact phrase match\n        if \" \".join(search_terms) in content_lower:\n            score += 5.0\n\n        return score\n"
              },
              "limit": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Result Limit",
                "dynamic": false,
                "info": "Maximum number of results to return",
                "list": false,
                "list_add_label": "Add More",
                "name": "limit",
                "placeholder": "",
                "range_spec": {
                  "max": 20,
                  "min": 1,
                  "step": 1,
                  "step_type": "int"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_metadata": true,
                "type": "int",
                "value": 5
              },
              "query": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Search Query",
                "dynamic": false,
                "info": "Search terms for finding specifications (searches in name, description, domain, and content)",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "query",
                "placeholder": "e.g., 'healthcare', 'chatbot', 'customer support'",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "search_path": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Search Path",
                "dynamic": false,
                "info": "Base path to search for specifications",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "search_path",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "src/backend/base/langflow/specifications_library"
              },
              "tools_metadata": {
                "_input_type": "ToolsInput",
                "advanced": false,
                "display_name": "Actions",
                "dynamic": false,
                "info": "Modify tool names and descriptions to help agents understand when to use each tool.",
                "is_list": true,
                "list_add_label": "Add More",
                "name": "tools_metadata",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tools",
                "value": [
                  {
                    "args": {
                      "limit": {
                        "default": 5,
                        "description": "Maximum number of results to return",
                        "title": "Limit",
                        "type": "integer"
                      },
                      "query": {
                        "description": "Search terms for finding specifications (searches in name, description, domain, and content)",
                        "title": "Query",
                        "type": "string"
                      }
                    },
                    "description": "Search existing agent specifications in the library",
                    "display_description": "Search existing agent specifications in the library",
                    "display_name": "search",
                    "name": "specification_search",
                    "readonly": false,
                    "status": true,
                    "tags": [
                      "search"
                    ]
                  }
                ]
              }
            },
            "tool_mode": true
          },
          "showNode": true,
          "type": "SpecificationSearchTool"
        },
        "dragging": false,
        "id": "SpecificationSearchTool-9mb6x",
        "measured": {
          "height": 202,
          "width": 320
        },
        "position": {
          "x": 1351.908029771471,
          "y": 1127.4859693062172
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ConversationMemoryTool-WTlRm",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Manage conversation context and requirements gathering state",
            "display_name": "Agent State",
            "documentation": "",
            "edited": false,
            "field_order": [
              "session_id",
              "operation",
              "key",
              "value",
              "data_type"
            ],
            "frozen": false,
            "icon": "save",
            "last_updated": "2025-10-14T18:18:51.492Z",
            "legacy": false,
            "lf_version": "1.6.3",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Toolset",
                "group_outputs": false,
                "hidden": null,
                "method": "to_toolkit",
                "name": "component_as_tool",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "\"\"\"Conversation Memory Tool for Agent Builder.\"\"\"\n\nimport json\nfrom typing import Dict, Any, Optional\nfrom datetime import datetime\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs import MessageTextInput, DropdownInput\nfrom langflow.io import Output\nfrom langflow.schema.data import Data\nfrom langflow.logging import logger\n\n\nclass ConversationMemoryTool(Component):\n    \"\"\"Tool for managing conversation state and context.\"\"\"\n\n    display_name = \"Conversation Memory\"\n    description = \"Manage conversation context and requirements gathering state\"\n    icon = \"save\"\n    name = \"ConversationMemoryTool\"\n    category = \"Helpers\"\n\n    # In-memory storage (in production, use Redis or database)\n    _memory_store: Dict[str, Any] = {}\n\n    inputs = [\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"Unique identifier for the conversation session\",\n            required=True,\n            tool_mode=True,\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            info=\"Operation to perform: store, retrieve, or update\",\n            options=[\"store\", \"retrieve\", \"update\", \"clear\"],\n            value=\"retrieve\",\n            tool_mode=True,\n        ),\n        MessageTextInput(\n            name=\"key\",\n            display_name=\"Memory Key\",\n            info=\"Key to store/retrieve data (e.g., 'requirements', 'agent_type', 'context')\",\n            required=True,\n            tool_mode=True,\n        ),\n        MessageTextInput(\n            name=\"value\",\n            display_name=\"Value\",\n            info=\"Value to store (required for store/update operations)\",\n            required=False,\n            tool_mode=True,\n        ),\n        MessageTextInput(\n            name=\"data_type\",\n            display_name=\"Data Type\",\n            info=\"Type of data: 'json' for structured data, 'text' for strings\",\n            value=\"json\",\n            advanced=True,\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Memory Data\", name=\"data\", method=\"process\"),\n    ]\n\n    def process(self) -> Data:\n        \"\"\"Process memory operations.\"\"\"\n        try:\n            session_key = f\"{self.session_id}:{self.key}\"\n\n            if self.operation == \"store\":\n                return self._store_data(session_key)\n            elif self.operation == \"retrieve\":\n                return self._retrieve_data(session_key)\n            elif self.operation == \"update\":\n                return self._update_data(session_key)\n            elif self.operation == \"clear\":\n                return self._clear_data(session_key)\n            else:\n                return Data(data={\n                    \"error\": f\"Invalid operation: {self.operation}\",\n                    \"success\": False\n                })\n\n        except Exception as e:\n            logger.error(f\"Error in conversation memory: {e}\")\n            return Data(data={\n                \"error\": str(e),\n                \"success\": False\n            })\n\n    def _store_data(self, session_key: str) -> Data:\n        \"\"\"Store data in memory.\"\"\"\n        if not self.value:\n            return Data(data={\n                \"error\": \"Value is required for store operation\",\n                \"success\": False\n            })\n\n        # Parse value based on data type\n        if self.data_type == \"json\":\n            try:\n                parsed_value = json.loads(self.value) if isinstance(self.value, str) else self.value\n            except json.JSONDecodeError as e:\n                return Data(data={\n                    \"error\": f\"Invalid JSON: {str(e)}\",\n                    \"success\": False\n                })\n        else:\n            parsed_value = self.value\n\n        # Store with metadata\n        self._memory_store[session_key] = {\n            \"value\": parsed_value,\n            \"timestamp\": datetime.now().isoformat(),\n            \"data_type\": self.data_type\n        }\n\n        # Also maintain session index\n        session_index_key = f\"{self.session_id}:_index\"\n        if session_index_key not in self._memory_store:\n            self._memory_store[session_index_key] = []\n        if self.key not in self._memory_store[session_index_key]:\n            self._memory_store[session_index_key].append(self.key)\n\n        return Data(data={\n            \"success\": True,\n            \"operation\": \"store\",\n            \"key\": self.key,\n            \"message\": f\"Data stored successfully for key: {self.key}\"\n        })\n\n    def _retrieve_data(self, session_key: str) -> Data:\n        \"\"\"Retrieve data from memory.\"\"\"\n        if session_key not in self._memory_store:\n            # Check if requesting session summary\n            if self.key == \"_summary\":\n                return self._get_session_summary()\n\n            return Data(data={\n                \"success\": False,\n                \"value\": None,\n                \"message\": f\"No data found for key: {self.key}\"\n            })\n\n        stored_data = self._memory_store[session_key]\n        return Data(data={\n            \"success\": True,\n            \"operation\": \"retrieve\",\n            \"key\": self.key,\n            \"value\": stored_data[\"value\"],\n            \"timestamp\": stored_data[\"timestamp\"],\n            \"data_type\": stored_data[\"data_type\"]\n        })\n\n    def _update_data(self, session_key: str) -> Data:\n        \"\"\"Update existing data in memory.\"\"\"\n        if not self.value:\n            return Data(data={\n                \"error\": \"Value is required for update operation\",\n                \"success\": False\n            })\n\n        if session_key not in self._memory_store:\n            # If doesn't exist, store instead\n            return self._store_data(session_key)\n\n        # Parse value based on data type\n        if self.data_type == \"json\":\n            try:\n                parsed_value = json.loads(self.value) if isinstance(self.value, str) else self.value\n            except json.JSONDecodeError as e:\n                return Data(data={\n                    \"error\": f\"Invalid JSON: {str(e)}\",\n                    \"success\": False\n                })\n        else:\n            parsed_value = self.value\n\n        # Update with new timestamp\n        old_value = self._memory_store[session_key][\"value\"]\n        self._memory_store[session_key] = {\n            \"value\": parsed_value,\n            \"timestamp\": datetime.now().isoformat(),\n            \"data_type\": self.data_type,\n            \"previous_value\": old_value\n        }\n\n        return Data(data={\n            \"success\": True,\n            \"operation\": \"update\",\n            \"key\": self.key,\n            \"message\": f\"Data updated successfully for key: {self.key}\",\n            \"previous_value\": old_value\n        })\n\n    def _clear_data(self, session_key: str) -> Data:\n        \"\"\"Clear data from memory.\"\"\"\n        if self.key == \"_all\":\n            # Clear all data for the session\n            keys_to_remove = [k for k in self._memory_store.keys() if k.startswith(f\"{self.session_id}:\")]\n            for key in keys_to_remove:\n                del self._memory_store[key]\n\n            return Data(data={\n                \"success\": True,\n                \"operation\": \"clear\",\n                \"message\": f\"All data cleared for session: {self.session_id}\",\n                \"keys_cleared\": len(keys_to_remove)\n            })\n        else:\n            # Clear specific key\n            if session_key in self._memory_store:\n                del self._memory_store[session_key]\n                # Update index\n                session_index_key = f\"{self.session_id}:_index\"\n                if session_index_key in self._memory_store and self.key in self._memory_store[session_index_key]:\n                    self._memory_store[session_index_key].remove(self.key)\n\n                return Data(data={\n                    \"success\": True,\n                    \"operation\": \"clear\",\n                    \"key\": self.key,\n                    \"message\": f\"Data cleared for key: {self.key}\"\n                })\n            else:\n                return Data(data={\n                    \"success\": False,\n                    \"message\": f\"No data found to clear for key: {self.key}\"\n                })\n\n    def _get_session_summary(self) -> Data:\n        \"\"\"Get a summary of all data stored for the session.\"\"\"\n        session_data = {}\n        session_prefix = f\"{self.session_id}:\"\n\n        for key, value in self._memory_store.items():\n            if key.startswith(session_prefix) and not key.endswith(\":_index\"):\n                clean_key = key.replace(session_prefix, \"\")\n                session_data[clean_key] = value\n\n        return Data(data={\n            \"success\": True,\n            \"operation\": \"summary\",\n            \"session_id\": self.session_id,\n            \"keys\": list(session_data.keys()),\n            \"data\": session_data,\n            \"total_keys\": len(session_data)\n        })\n"
              },
              "data_type": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Type",
                "dynamic": false,
                "info": "Type of data: 'json' for structured data, 'text' for strings",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_type",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "json"
              },
              "key": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Memory Key",
                "dynamic": false,
                "info": "Key to store/retrieve data (e.g., 'requirements', 'agent_type', 'context')",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "key",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "operation": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operation",
                "dynamic": false,
                "external_options": {},
                "info": "Operation to perform: store, retrieve, or update",
                "name": "operation",
                "options": [
                  "store",
                  "retrieve",
                  "update",
                  "clear"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "retrieve"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "Unique identifier for the conversation session",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "tools_metadata": {
                "_input_type": "ToolsInput",
                "advanced": false,
                "display_name": "Actions",
                "dynamic": false,
                "info": "Modify tool names and descriptions to help agents understand when to use each tool.",
                "is_list": true,
                "list_add_label": "Add More",
                "name": "tools_metadata",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tools",
                "value": [
                  {
                    "args": {
                      "data_type": {
                        "default": "json",
                        "description": "Type of data: 'json' for structured data, 'text' for strings",
                        "title": "Data Type",
                        "type": "string"
                      },
                      "key": {
                        "description": "Key to store/retrieve data (e.g., 'requirements', 'agent_type', 'context')",
                        "title": "Key",
                        "type": "string"
                      },
                      "operation": {
                        "default": "retrieve",
                        "description": "Operation to perform: store, retrieve, or update",
                        "enum": [
                          "store",
                          "retrieve",
                          "update",
                          "clear"
                        ],
                        "title": "Operation",
                        "type": "string"
                      },
                      "session_id": {
                        "description": "Unique identifier for the conversation session",
                        "title": "Session Id",
                        "type": "string"
                      },
                      "value": {
                        "default": "",
                        "description": "Value to store (required for store/update operations)",
                        "title": "Value",
                        "type": "string"
                      }
                    },
                    "description": "Manage conversation context and requirements gathering state",
                    "display_description": "Manage conversation context and requirements gathering state",
                    "display_name": "process",
                    "name": "agent_state",
                    "readonly": false,
                    "status": true,
                    "tags": [
                      "process"
                    ]
                  }
                ]
              },
              "value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Value",
                "dynamic": false,
                "info": "Value to store (required for store/update operations)",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": true
          },
          "showNode": true,
          "type": "ConversationMemoryTool"
        },
        "dragging": false,
        "id": "ConversationMemoryTool-WTlRm",
        "measured": {
          "height": 218,
          "width": 320
        },
        "position": {
          "x": 1648.863144016918,
          "y": 1406.210429106087
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatInput-m9DwD",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Get chat inputs from the Playground.",
            "display_name": "Chat Input",
            "documentation": "https://docs.langflow.org/components-io#chat-input",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "files"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "legacy": false,
            "lf_version": "1.6.3",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Chat Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs.inputs import BoolInput\nfrom langflow.io import (\n    DropdownInput,\n    FileInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n)\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_USER,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatInput(ChatComponent):\n    display_name = \"Chat Input\"\n    description = \"Get chat inputs from the Playground.\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-input\"\n    icon = \"MessagesSquare\"\n    name = \"ChatInput\"\n    minimized = True\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input Text\",\n            value=\"\",\n            info=\"Message to be passed as input.\",\n            input_types=[],\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_USER,\n            info=\"Type of sender.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_USER,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"Files\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"Files to be sent with the message.\",\n            advanced=True,\n            is_list=True,\n            temp_file=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Chat Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    async def message_response(self) -> Message:\n        # Ensure files is a list and filter out empty/None values\n        files = self.files if self.files else []\n        if files and not isinstance(files, list):\n            files = [files]\n        files = [f for f in files if f is not None and f != \"\"]\n\n        message = await Message.create(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n            files=files,\n        )\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n"
              },
              "files": {
                "_input_type": "FileInput",
                "advanced": true,
                "display_name": "Files",
                "dynamic": false,
                "fileTypes": [
                  "csv",
                  "json",
                  "pdf",
                  "txt",
                  "md",
                  "mdx",
                  "yaml",
                  "yml",
                  "xml",
                  "html",
                  "htm",
                  "docx",
                  "py",
                  "sh",
                  "sql",
                  "js",
                  "ts",
                  "tsx",
                  "jpg",
                  "jpeg",
                  "png",
                  "bmp",
                  "image"
                ],
                "file_path": "",
                "info": "Files to be sent with the message.",
                "list": true,
                "list_add_label": "Add More",
                "name": "files",
                "placeholder": "",
                "required": false,
                "show": true,
                "temp_file": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "file",
                "value": ""
              },
              "input_value": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Input Text",
                "dynamic": false,
                "info": "Message to be passed as input.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "external_options": {},
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatInput"
        },
        "dragging": false,
        "id": "ChatInput-m9DwD",
        "measured": {
          "height": 48,
          "width": 192
        },
        "position": {
          "x": 2487.9401168887716,
          "y": 2359.3444549158753
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatOutput-RTsqB",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "https://docs.langflow.org/components-io#chat-output",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "legacy": false,
            "lf_version": "1.6.3",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Output Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from collections.abc import Generator\nfrom typing import Any\n\nimport orjson\nfrom fastapi.encoders import jsonable_encoder\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, DropdownInput, HandleInput, MessageTextInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.template.field.base import Output\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-output\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Inputs\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Output Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _serialize_data(self, data: Data) -> str:\n        \"\"\"Serialize Data object to JSON string.\"\"\"\n        # Convert data.data to JSON-serializable format\n        serializable_data = jsonable_encoder(data.data)\n        # Serialize with orjson, enabling pretty printing with indentation\n        json_bytes = orjson.dumps(serializable_data, option=orjson.OPT_INDENT_2)\n        # Convert bytes to string and wrap in Markdown code blocks\n        return \"```json\\n\" + json_bytes.decode(\"utf-8\") + \"\\n```\"\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            clean_data: bool = getattr(self, \"clean_data\", False)\n            return \"\\n\".join([safe_convert(item, clean_data=clean_data) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Inputs",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "external_options": {},
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatOutput"
        },
        "dragging": false,
        "id": "ChatOutput-RTsqB",
        "measured": {
          "height": 48,
          "width": 192
        },
        "position": {
          "x": 3329.621003810512,
          "y": 1789.7830807661699
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ConversationController-IftKs",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Controls the flow and pacing of agent building conversations",
            "display_name": "Conversation Controller",
            "documentation": "",
            "edited": false,
            "field_order": [
              "current_phase",
              "user_input",
              "tool_output",
              "tool_name",
              "require_confirmation"
            ],
            "frozen": false,
            "icon": "settings",
            "last_updated": "2025-10-14T18:18:51.492Z",
            "legacy": false,
            "lf_version": "1.6.3",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Toolset",
                "group_outputs": false,
                "hidden": null,
                "method": "to_toolkit",
                "name": "component_as_tool",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "\"\"\"Conversation Controller Component for Agent Builder.\"\"\"\n\nimport json\nfrom typing import Dict, Any, Optional\nfrom enum import Enum\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs import MessageTextInput, DropdownInput, BoolInput\nfrom langflow.io import Output\nfrom langflow.schema.data import Data\nfrom langflow.logging import logger\n\n\nclass ConversationPhase(Enum):\n    \"\"\"Phases of the agent building conversation.\"\"\"\n    INITIAL = \"initial\"\n    REQUIREMENTS = \"requirements\"\n    CLARIFICATION = \"clarification\"\n    RESEARCH = \"research\"\n    DESIGN = \"design\"\n    IMPLEMENTATION = \"implementation\"\n    VALIDATION = \"validation\"\n    COMPLETE = \"complete\"\n\n\nclass ConversationController(Component):\n    \"\"\"Controls conversation flow and pacing for agent building.\"\"\"\n\n    display_name = \"Conversation Controller\"\n    description = \"Controls the flow and pacing of agent building conversations\"\n    icon = \"settings\"\n    name = \"ConversationController\"\n    category = \"Helpers\"\n\n    inputs = [\n        DropdownInput(\n            name=\"current_phase\",\n            display_name=\"Current Phase\",\n            info=\"Current phase of the conversation\",\n            options=[phase.value for phase in ConversationPhase],\n            value=ConversationPhase.INITIAL.value,\n            tool_mode=True,\n        ),\n        MessageTextInput(\n            name=\"user_input\",\n            display_name=\"User Input\",\n            info=\"Latest user input to analyze\",\n            required=False,\n            tool_mode=True,\n        ),\n        MessageTextInput(\n            name=\"tool_output\",\n            display_name=\"Tool Output\",\n            info=\"Raw output from a tool to format\",\n            required=False,\n            tool_mode=True,\n        ),\n        MessageTextInput(\n            name=\"tool_name\",\n            display_name=\"Tool Name\",\n            info=\"Name of the tool that produced the output\",\n            required=False,\n            tool_mode=True,\n        ),\n        BoolInput(\n            name=\"require_confirmation\",\n            display_name=\"Require Confirmation\",\n            info=\"Whether to require user confirmation before proceeding\",\n            value=True,\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Flow Control\", name=\"flow_control\", method=\"control_flow\"),\n        Output(display_name=\"Formatted Output\", name=\"formatted_output\", method=\"format_output\"),\n    ]\n\n    def control_flow(self) -> Data:\n        \"\"\"Determine if the agent should continue or wait for user input.\"\"\"\n        try:\n            current_phase = ConversationPhase(self.current_phase)\n            user_input = self.user_input or \"\"\n\n            # Determine next action based on phase and user input\n            should_continue = self._should_continue(current_phase, user_input)\n            next_phase = self._get_next_phase(current_phase, user_input)\n\n            # Check for confirmation keywords\n            confirmation_needed = self._check_confirmation_needed(current_phase)\n            user_confirmed = self._check_user_confirmation(user_input)\n\n            # Build flow control response\n            flow_control = {\n                \"current_phase\": current_phase.value,\n                \"next_phase\": next_phase.value,\n                \"should_continue\": should_continue and (not confirmation_needed or user_confirmed),\n                \"wait_for_user\": confirmation_needed and not user_confirmed,\n                \"phase_message\": self._get_phase_message(current_phase, next_phase),\n                \"prompt_for_user\": self._get_user_prompt(next_phase) if confirmation_needed else None\n            }\n\n            return Data(data=flow_control)\n\n        except Exception as e:\n            logger.error(f\"Error in flow control: {e}\")\n            return Data(data={\n                \"error\": str(e),\n                \"should_continue\": False,\n                \"wait_for_user\": True\n            })\n\n    def format_output(self) -> Data:\n        \"\"\"Format tool output for conversational presentation.\"\"\"\n        try:\n            if not self.tool_output:\n                return Data(data={\"formatted\": \"No output to format\"})\n\n            tool_name = self.tool_name or \"unknown_tool\"\n\n            # Parse tool output if it's JSON\n            try:\n                if isinstance(self.tool_output, str):\n                    output_data = json.loads(self.tool_output)\n                else:\n                    output_data = self.tool_output\n            except (json.JSONDecodeError, TypeError):\n                output_data = {\"raw\": self.tool_output}\n\n            # Format based on tool name\n            formatted = self._format_tool_output(tool_name, output_data)\n\n            return Data(data={\n                \"formatted\": formatted,\n                \"tool_name\": tool_name,\n                \"markdown\": True\n            })\n\n        except Exception as e:\n            logger.error(f\"Error formatting output: {e}\")\n            return Data(data={\n                \"formatted\": str(self.tool_output),\n                \"error\": str(e)\n            })\n\n    def _should_continue(self, phase: ConversationPhase, user_input: str) -> bool:\n        \"\"\"Determine if the agent should continue processing.\"\"\"\n        # Don't continue automatically after certain phases\n        stop_phases = [\n            ConversationPhase.REQUIREMENTS,\n            ConversationPhase.RESEARCH,\n            ConversationPhase.DESIGN,\n            ConversationPhase.VALIDATION\n        ]\n\n        if phase in stop_phases and self.require_confirmation:\n            # Check if user provided explicit continuation\n            continue_keywords = [\"yes\", \"proceed\", \"continue\", \"go ahead\", \"sure\", \"ok\", \"okay\", \"confirm\"]\n            return any(keyword in user_input.lower() for keyword in continue_keywords)\n\n        return True\n\n    def _get_next_phase(self, current: ConversationPhase, user_input: str) -> ConversationPhase:\n        \"\"\"Determine the next conversation phase.\"\"\"\n        phase_flow = {\n            ConversationPhase.INITIAL: ConversationPhase.REQUIREMENTS,\n            ConversationPhase.REQUIREMENTS: ConversationPhase.CLARIFICATION,\n            ConversationPhase.CLARIFICATION: ConversationPhase.RESEARCH,\n            ConversationPhase.RESEARCH: ConversationPhase.DESIGN,\n            ConversationPhase.DESIGN: ConversationPhase.IMPLEMENTATION,\n            ConversationPhase.IMPLEMENTATION: ConversationPhase.VALIDATION,\n            ConversationPhase.VALIDATION: ConversationPhase.COMPLETE,\n            ConversationPhase.COMPLETE: ConversationPhase.COMPLETE,\n        }\n\n        # Check for phase skip requests\n        if \"skip\" in user_input.lower():\n            # Allow skipping clarification phase\n            if current == ConversationPhase.CLARIFICATION:\n                return ConversationPhase.RESEARCH\n\n        return phase_flow.get(current, current)\n\n    def _check_confirmation_needed(self, phase: ConversationPhase) -> bool:\n        \"\"\"Check if the current phase requires user confirmation.\"\"\"\n        confirmation_phases = [\n            ConversationPhase.REQUIREMENTS,\n            ConversationPhase.RESEARCH,\n            ConversationPhase.DESIGN,\n            ConversationPhase.IMPLEMENTATION\n        ]\n        return phase in confirmation_phases\n\n    def _check_user_confirmation(self, user_input: str) -> bool:\n        \"\"\"Check if user input contains confirmation.\"\"\"\n        if not user_input:\n            return False\n\n        confirmation_words = [\n            \"yes\", \"yeah\", \"yep\", \"sure\", \"ok\", \"okay\",\n            \"proceed\", \"continue\", \"go ahead\", \"confirm\",\n            \"looks good\", \"perfect\", \"great\", \"approve\"\n        ]\n\n        negative_words = [\"no\", \"wait\", \"stop\", \"hold\", \"cancel\", \"not yet\"]\n\n        input_lower = user_input.lower()\n\n        # Check for negative first\n        if any(word in input_lower for word in negative_words):\n            return False\n\n        # Check for positive confirmation\n        return any(word in input_lower for word in confirmation_words)\n\n    def _get_phase_message(self, current: ConversationPhase, next: ConversationPhase) -> str:\n        \"\"\"Get transition message between phases.\"\"\"\n        messages = {\n            (ConversationPhase.INITIAL, ConversationPhase.REQUIREMENTS):\n                \"Let me analyze your requirements...\",\n            (ConversationPhase.REQUIREMENTS, ConversationPhase.CLARIFICATION):\n                \"I need to clarify a few things to better understand your needs.\",\n            (ConversationPhase.CLARIFICATION, ConversationPhase.RESEARCH):\n                \"Thanks for the clarification! Let me search for similar agents...\",\n            (ConversationPhase.RESEARCH, ConversationPhase.DESIGN):\n                \"Based on my research, let me design the architecture...\",\n            (ConversationPhase.DESIGN, ConversationPhase.IMPLEMENTATION):\n                \"Great! I'll now generate the complete specification...\",\n            (ConversationPhase.IMPLEMENTATION, ConversationPhase.VALIDATION):\n                \"Let me validate the specification...\",\n            (ConversationPhase.VALIDATION, ConversationPhase.COMPLETE):\n                \"Your specification is ready!\",\n        }\n\n        return messages.get((current, next), \"Processing...\")\n\n    def _get_user_prompt(self, phase: ConversationPhase) -> str:\n        \"\"\"Get prompt to show user for the next phase.\"\"\"\n        prompts = {\n            ConversationPhase.CLARIFICATION:\n                \"Please answer the questions above to help me better understand your needs.\",\n            ConversationPhase.RESEARCH:\n                \"Shall I search for similar agents and patterns? (yes/no)\",\n            ConversationPhase.DESIGN:\n                \"Would you like me to proceed with this design approach? (yes/no)\",\n            ConversationPhase.IMPLEMENTATION:\n                \"Should I generate the complete specification now? (yes/no)\",\n            ConversationPhase.VALIDATION:\n                \"Ready to validate the specification? (yes/no)\",\n        }\n\n        return prompts.get(phase, \"Ready to continue? (yes/no)\")\n\n    def _format_tool_output(self, tool_name: str, output_data: Any) -> str:\n        \"\"\"Format tool output based on the tool name.\"\"\"\n        formatters = {\n            \"requirements_analyst\": self._format_requirements,\n            \"intent_classifier\": self._format_intent,\n            \"research_agent\": self._format_research,\n            \"pattern_matcher\": self._format_pattern,\n            \"spec_builder\": self._format_specification,\n            \"validation_agent\": self._format_validation,\n            \"specification_search\": self._format_search_results,\n        }\n\n        formatter = formatters.get(tool_name, self._format_generic)\n        return formatter(output_data)\n\n    def _format_requirements(self, data: Dict) -> str:\n        \"\"\"Format requirements analyst output.\"\"\"\n        if isinstance(data, str):\n            return data  # Already formatted conversationally\n\n        # Fallback formatting for structured data\n        return f\"\"\"\n**Key Requirements Found:**\n{json.dumps(data.get('requirements', {}), indent=2)}\n\n**Questions to Clarify:**\n{chr(10).join('• ' + q for q in data.get('clarifying_questions', []))}\n\"\"\"\n\n    def _format_intent(self, data: Dict) -> str:\n        \"\"\"Format intent classifier output.\"\"\"\n        if isinstance(data, str):\n            return data\n\n        return f\"\"\"\n**Agent Classification:**\n• Type: {data.get('agent_type', 'Unknown')}\n• Complexity: {data.get('complexity', 'Unknown')}\n• Pattern: {data.get('suggested_pattern', 'Unknown')}\n\"\"\"\n\n    def _format_research(self, data: Dict) -> str:\n        \"\"\"Format research agent output.\"\"\"\n        if isinstance(data, str):\n            return data\n\n        agents = data.get('similar_agents', [])\n        if not agents:\n            return \"No similar agents found in the library.\"\n\n        formatted = \"**Similar Agents Found:**\\n\"\n        for agent in agents[:3]:\n            formatted += f\"• **{agent.get('name')}** ({agent.get('relevance_score', 0)*100:.0f}% match)\\n\"\n\n        return formatted\n\n    def _format_pattern(self, data: Dict) -> str:\n        \"\"\"Format pattern matcher output.\"\"\"\n        if isinstance(data, str):\n            return data\n\n        return f\"\"\"\n**Recommended Pattern:** {data.get('primary_pattern', 'Unknown')}\n\n**Required Components:**\n{chr(10).join('• ' + c for c in data.get('components', {}).get('required', []))}\n\"\"\"\n\n    def _format_specification(self, data: Dict) -> str:\n        \"\"\"Format specification builder output.\"\"\"\n        if isinstance(data, str):\n            return data\n\n        return \"```yaml\\n\" + json.dumps(data, indent=2) + \"\\n```\"\n\n    def _format_validation(self, data: Dict) -> str:\n        \"\"\"Format validation agent output.\"\"\"\n        if isinstance(data, str):\n            return data\n\n        if data.get('valid'):\n            return \"✅ **Specification validated successfully!**\"\n        else:\n            errors = data.get('errors', [])\n            return f\"\"\"\n⚠️ **Validation Issues Found:**\n{chr(10).join('• ' + e for e in errors)}\n\"\"\"\n\n    def _format_search_results(self, data: Dict) -> str:\n        \"\"\"Format specification search results.\"\"\"\n        results = data.get('results', [])\n        if not results:\n            return \"No specifications found matching your search.\"\n\n        formatted = f\"Found {len(results)} matching specifications:\\n\\n\"\n        for result in results[:3]:\n            formatted += f\"• **{result.get('name')}** - {result.get('description', 'No description')}\\n\"\n\n        return formatted\n\n    def _format_generic(self, data: Any) -> str:\n        \"\"\"Generic formatter for unknown tools.\"\"\"\n        if isinstance(data, str):\n            return data\n        elif isinstance(data, dict):\n            return json.dumps(data, indent=2)\n        else:\n            return str(data)\n"
              },
              "current_phase": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Current Phase",
                "dynamic": false,
                "external_options": {},
                "info": "Current phase of the conversation",
                "name": "current_phase",
                "options": [
                  "initial",
                  "requirements",
                  "clarification",
                  "research",
                  "design",
                  "implementation",
                  "validation",
                  "complete"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "initial"
              },
              "require_confirmation": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Require Confirmation",
                "dynamic": false,
                "info": "Whether to require user confirmation before proceeding",
                "list": false,
                "list_add_label": "Add More",
                "name": "require_confirmation",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "tool_name": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Tool Name",
                "dynamic": false,
                "info": "Name of the tool that produced the output",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "tool_output": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Tool Output",
                "dynamic": false,
                "info": "Raw output from a tool to format",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_output",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "tools_metadata": {
                "_input_type": "ToolsInput",
                "advanced": false,
                "display_name": "Actions",
                "dynamic": false,
                "info": "Modify tool names and descriptions to help agents understand when to use each tool.",
                "is_list": true,
                "list_add_label": "Add More",
                "name": "tools_metadata",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tools",
                "value": [
                  {
                    "args": {
                      "current_phase": {
                        "default": "initial",
                        "description": "Current phase of the conversation",
                        "enum": [
                          "initial",
                          "requirements",
                          "clarification",
                          "research",
                          "design",
                          "implementation",
                          "validation",
                          "complete"
                        ],
                        "title": "Current Phase",
                        "type": "string"
                      },
                      "require_confirmation": {
                        "default": true,
                        "description": "Whether to require user confirmation before proceeding",
                        "title": "Require Confirmation",
                        "type": "boolean"
                      },
                      "tool_name": {
                        "default": "",
                        "description": "Name of the tool that produced the output",
                        "title": "Tool Name",
                        "type": "string"
                      },
                      "tool_output": {
                        "default": "",
                        "description": "Raw output from a tool to format",
                        "title": "Tool Output",
                        "type": "string"
                      },
                      "user_input": {
                        "default": "",
                        "description": "Latest user input to analyze",
                        "title": "User Input",
                        "type": "string"
                      }
                    },
                    "description": "Controls the flow and pacing of agent building conversations",
                    "display_description": "Controls the flow and pacing of agent building conversations",
                    "display_name": "control_flow",
                    "name": "control_flow",
                    "readonly": false,
                    "status": true,
                    "tags": [
                      "control_flow"
                    ]
                  },
                  {
                    "args": {
                      "current_phase": {
                        "default": "initial",
                        "description": "Current phase of the conversation",
                        "enum": [
                          "initial",
                          "requirements",
                          "clarification",
                          "research",
                          "design",
                          "implementation",
                          "validation",
                          "complete"
                        ],
                        "title": "Current Phase",
                        "type": "string"
                      },
                      "require_confirmation": {
                        "default": true,
                        "description": "Whether to require user confirmation before proceeding",
                        "title": "Require Confirmation",
                        "type": "boolean"
                      },
                      "tool_name": {
                        "default": "",
                        "description": "Name of the tool that produced the output",
                        "title": "Tool Name",
                        "type": "string"
                      },
                      "tool_output": {
                        "default": "",
                        "description": "Raw output from a tool to format",
                        "title": "Tool Output",
                        "type": "string"
                      },
                      "user_input": {
                        "default": "",
                        "description": "Latest user input to analyze",
                        "title": "User Input",
                        "type": "string"
                      }
                    },
                    "description": "Controls the flow and pacing of agent building conversations",
                    "display_description": "Controls the flow and pacing of agent building conversations",
                    "display_name": "format_output",
                    "name": "format_output",
                    "readonly": false,
                    "status": true,
                    "tags": [
                      "format_output"
                    ]
                  }
                ]
              },
              "user_input": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "User Input",
                "dynamic": false,
                "info": "Latest user input to analyze",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "user_input",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": true
          },
          "selected_output": "flow_control",
          "showNode": true,
          "type": "ConversationController"
        },
        "dragging": false,
        "id": "ConversationController-IftKs",
        "measured": {
          "height": 218,
          "width": 320
        },
        "position": {
          "x": 1742.4182124997667,
          "y": 1766.235408217636
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "KnowledgeLoader-9hisZ",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Loads valid components, patterns, and specifications from the library via API",
            "display_name": "Knowledge Loader",
            "documentation": "",
            "edited": false,
            "field_order": [
              "query_type",
              "reload_cache"
            ],
            "frozen": false,
            "icon": "book-open",
            "last_updated": "2025-10-14T18:18:51.492Z",
            "legacy": false,
            "lf_version": "1.6.3",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Toolset",
                "group_outputs": false,
                "hidden": null,
                "method": "to_toolkit",
                "name": "component_as_tool",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "\"\"\"Knowledge Loader for AI Studio Agent Builder - Loads valid components and patterns.\"\"\"\n\nimport asyncio\nfrom typing import Any\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs import MessageTextInput, BoolInput\nfrom langflow.io import Output\nfrom langflow.schema.data import Data\nfrom langflow.logging import logger\nfrom langflow.components.helpers.studio_builder.api_client import SpecAPIClient\n\n\nclass KnowledgeLoader(Component):\n    \"\"\"Loads and provides available genesis components, patterns, and specifications.\"\"\"\n\n    display_name = \"Knowledge Loader\"\n    description = \"Loads valid components, patterns, and specifications from the library via API\"\n    icon = \"book-open\"\n    name = \"KnowledgeLoader\"\n    category = \"Helpers\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"query_type\",\n            display_name=\"Query Type\",\n            info=\"Type of knowledge to load: components, patterns, specifications, or all\",\n            value=\"all\",\n            tool_mode=True,\n        ),\n        BoolInput(\n            name=\"reload_cache\",\n            display_name=\"Reload Cache\",\n            info=\"Force reload from disk\",\n            value=False,\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Knowledge Data\", name=\"knowledge\", method=\"load_knowledge\"),\n    ]\n\n    def load_knowledge(self) -> Data:\n        \"\"\"Load ALL components directly from internal service - no HTTP, no auth needed!\"\"\"\n        try:\n            from langflow.services.spec.service import SpecService\n            import concurrent.futures\n\n            # Create service instance\n            service = SpecService()\n\n            # Use the internal service method directly - no HTTP call needed!\n            async def _get_all_components():\n                return await service.get_all_available_components()\n\n            # Handle async execution properly\n            try:\n                # Try to get the current event loop\n                loop = asyncio.get_running_loop()\n                # If we're in an existing loop, run in thread pool\n                with concurrent.futures.ThreadPoolExecutor() as pool:\n                    components_data = pool.submit(asyncio.run, _get_all_components()).result()\n            except RuntimeError:\n                # No running loop, we can use asyncio.run directly\n                components_data = asyncio.run(_get_all_components())\n\n            # Process the knowledge based on query_type\n            if self.query_type == \"components\" or self.query_type == \"all\":\n                # Return comprehensive component information\n                knowledge = {\n                    \"all_components\": components_data.get(\"langflow_components\", {}),\n                    \"genesis_mapped\": components_data.get(\"genesis_mapped\", {}),\n                    \"unmapped\": components_data.get(\"unmapped\", []),\n                    \"valid_genesis_types\": list(components_data.get(\"genesis_mapped\", {}).keys())\n                }\n\n                # Add a helpful summary\n                if components_data.get(\"langflow_components\"):\n                    total_components = sum(\n                        len(comps)\n                        for category in components_data[\"langflow_components\"].get(\"components\", {}).values()\n                        for comps in [category] if isinstance(category, dict)\n                    )\n                    knowledge[\"summary\"] = {\n                        \"total_langflow_components\": total_components,\n                        \"genesis_mapped_count\": len(components_data.get(\"genesis_mapped\", {})),\n                        \"unmapped_count\": len(components_data.get(\"unmapped\", []))\n                    }\n            else:\n                # For backward compatibility, still support API calls for other query types\n                async def _fetch_knowledge():\n                    async with SpecAPIClient() as client:\n                        return await client.get_knowledge(\n                            query_type=self.query_type,\n                            reload_cache=self.reload_cache\n                        )\n\n                try:\n                    loop = asyncio.get_running_loop()\n                    with concurrent.futures.ThreadPoolExecutor() as pool:\n                        knowledge = pool.submit(asyncio.run, _fetch_knowledge()).result()\n                except RuntimeError:\n                    knowledge = asyncio.run(_fetch_knowledge())\n\n            return Data(data={\n                \"success\": True,\n                \"knowledge\": knowledge,\n                \"message\": f\"Loaded {self.query_type} knowledge successfully\"\n            })\n\n        except Exception as e:\n            logger.error(f\"Error loading knowledge: {e}\")\n            return Data(data={\n                \"success\": False,\n                \"error\": str(e),\n                \"message\": f\"Failed to load knowledge: {str(e)}\"\n            })\n\n"
              },
              "query_type": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Query Type",
                "dynamic": false,
                "info": "Type of knowledge to load: components, patterns, specifications, or all",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "query_type",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "all"
              },
              "reload_cache": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Reload Cache",
                "dynamic": false,
                "info": "Force reload from disk",
                "list": false,
                "list_add_label": "Add More",
                "name": "reload_cache",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "tools_metadata": {
                "_input_type": "ToolsInput",
                "advanced": false,
                "display_name": "Actions",
                "dynamic": false,
                "info": "Modify tool names and descriptions to help agents understand when to use each tool.",
                "is_list": true,
                "list_add_label": "Add More",
                "name": "tools_metadata",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tools",
                "value": [
                  {
                    "args": {
                      "query_type": {
                        "default": "all",
                        "description": "Type of knowledge to load: components, patterns, specifications, or all",
                        "title": "Query Type",
                        "type": "string"
                      },
                      "reload_cache": {
                        "default": false,
                        "description": "Force reload from disk",
                        "title": "Reload Cache",
                        "type": "boolean"
                      }
                    },
                    "description": "Loads valid components, patterns, and specifications from the library via API",
                    "display_description": "Loads valid components, patterns, and specifications from the library via API",
                    "display_name": "load_knowledge",
                    "name": "load_knowledge",
                    "readonly": false,
                    "status": true,
                    "tags": [
                      "load_knowledge"
                    ]
                  }
                ]
              }
            },
            "tool_mode": true
          },
          "showNode": true,
          "type": "KnowledgeLoader"
        },
        "dragging": false,
        "id": "KnowledgeLoader-9hisZ",
        "measured": {
          "height": 218,
          "width": 320
        },
        "position": {
          "x": 1587.5927675787827,
          "y": 2038.318032095728
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "IntegrationDecision-5PE08",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Guides decision between API Request and MCP Tool components",
            "display_name": "Integration Decision",
            "documentation": "",
            "edited": false,
            "field_order": [
              "integration_description",
              "has_mcp_server",
              "api_details",
              "needs_state_management"
            ],
            "frozen": false,
            "icon": "git-branch",
            "last_updated": "2025-10-14T18:18:51.493Z",
            "legacy": false,
            "lf_version": "1.6.3",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Toolset",
                "group_outputs": false,
                "hidden": null,
                "method": "to_toolkit",
                "name": "component_as_tool",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "api_details": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "API Details",
                "dynamic": false,
                "info": "Known API endpoints, authentication, etc.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "api_details",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "\"\"\"Integration Decision Tool for AI Studio Agent Builder - Helps decide between API and MCP.\"\"\"\n\nimport asyncio\nfrom typing import Dict, List, Optional\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs import MessageTextInput, BoolInput\nfrom langflow.io import Output\nfrom langflow.schema.data import Data\nfrom langflow.logging import logger\nfrom langflow.components.helpers.studio_builder.api_client import SpecAPIClient\n\n\nclass IntegrationDecision(Component):\n    \"\"\"Helps users decide between API and MCP tool integration approaches.\"\"\"\n\n    display_name = \"Integration Decision\"\n    description = \"Guides decision between API Request and MCP Tool components\"\n    icon = \"git-branch\"\n    name = \"IntegrationDecision\"\n    category = \"Helpers\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"integration_description\",\n            display_name=\"Integration Description\",\n            info=\"Describe what you need to integrate with\",\n            required=True,\n            tool_mode=True,\n        ),\n        BoolInput(\n            name=\"has_mcp_server\",\n            display_name=\"Has MCP Server\",\n            info=\"Does the user have an MCP server available?\",\n            value=False,\n            tool_mode=True,\n        ),\n        MessageTextInput(\n            name=\"api_details\",\n            display_name=\"API Details\",\n            info=\"Known API endpoints, authentication, etc.\",\n            required=False,\n            tool_mode=True,\n        ),\n        BoolInput(\n            name=\"needs_state_management\",\n            display_name=\"Needs State Management\",\n            info=\"Does the integration need to maintain state?\",\n            value=False,\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Integration Decision\", name=\"decision\", method=\"decide\"),\n    ]\n\n    def decide(self) -> Data:\n        \"\"\"Decide on the best integration approach.\"\"\"\n        try:\n            # First check available components from API\n            available_components = self._get_available_components()\n\n            decision = self._analyze_requirements(available_components)\n            guidance = self._generate_guidance(decision)\n            examples = self._get_examples(decision)\n\n            return Data(data={\n                \"success\": True,\n                \"decision\": decision,\n                \"guidance\": guidance,\n                \"examples\": examples,\n                \"available_integration_components\": self._filter_integration_components(available_components),\n                \"conversation_response\": self._format_response(decision, guidance, examples)\n            })\n\n        except Exception as e:\n            logger.error(f\"Error in integration decision: {e}\")\n            return Data(data={\n                \"success\": False,\n                \"error\": str(e)\n            })\n\n    def _get_available_components(self) -> Dict:\n        \"\"\"Get available components from the API.\"\"\"\n        try:\n            async def _fetch_components():\n                async with SpecAPIClient() as client:\n                    return await client.get_available_components()\n\n            return asyncio.run(_fetch_components())\n        except Exception as e:\n            logger.warning(f\"Could not fetch components from API: {e}\")\n            # Return minimal set of known integration components\n            return {\n                \"genesis:api_request\": {\"name\": \"API Request\", \"category\": \"Integration\"},\n                \"genesis:mcp_tool\": {\"name\": \"MCP Tool\", \"category\": \"Tool\"}\n            }\n\n    def _filter_integration_components(self, components: Dict) -> List[str]:\n        \"\"\"Filter components to show only integration-related ones.\"\"\"\n        integration_types = []\n        for comp_type, comp_info in components.items():\n            if any(keyword in comp_type.lower() for keyword in [\"api\", \"mcp\", \"tool\", \"request\", \"webhook\"]):\n                integration_types.append(comp_type)\n        return integration_types\n\n    def _analyze_requirements(self, available_components: Dict) -> Dict:\n        \"\"\"Analyze requirements and provide guidance for both API and MCP approaches.\"\"\"\n        description_lower = self.integration_description.lower()\n\n        # Decision factors\n        factors = {\n            \"has_mcp\": self.has_mcp_server,\n            \"has_api_details\": bool(self.api_details),\n            \"needs_state\": self.needs_state_management,\n            \"is_healthcare\": any(term in description_lower for term in\n                                [\"healthcare\", \"medical\", \"patient\", \"ehr\", \"fhir\", \"hl7\"]),\n            \"is_complex\": any(term in description_lower for term in\n                             [\"workflow\", \"multi-step\", \"complex\", \"orchestration\"]),\n            \"is_simple_api\": any(term in description_lower for term in\n                                [\"rest\", \"api\", \"endpoint\", \"http\", \"webhook\"])\n        }\n\n        # Check what's actually available\n        has_api_request = \"genesis:api_request\" in available_components\n        has_mcp_tool = \"genesis:mcp_tool\" in available_components\n\n        # PRIMARY RECOMMENDATION: Always provide both options with clear guidance\n        api_score = 0\n        mcp_score = 0\n\n        # Scoring for API Request\n        if factors[\"is_simple_api\"]:\n            api_score += 3\n        if factors[\"has_api_details\"]:\n            api_score += 2\n        if not factors[\"is_complex\"]:\n            api_score += 1\n        if not factors[\"needs_state\"]:\n            api_score += 1\n\n        # Scoring for MCP Tool\n        if factors[\"is_healthcare\"]:\n            mcp_score += 3\n        if factors[\"is_complex\"]:\n            mcp_score += 2\n        if factors[\"needs_state\"]:\n            mcp_score += 2\n        if factors[\"has_mcp\"]:\n            mcp_score += 1\n\n        # Determine primary recommendation\n        if mcp_score > api_score:\n            primary_recommendation = \"genesis:mcp_tool\"\n            primary_reason = \"Healthcare complexity and state management favor MCP approach\"\n        elif api_score > mcp_score:\n            primary_recommendation = \"genesis:api_request\"\n            primary_reason = \"Simple API integration with known endpoints is most efficient\"\n        else:\n            # Tie - default to MCP for healthcare, API for others\n            if factors[\"is_healthcare\"]:\n                primary_recommendation = \"genesis:mcp_tool\"\n                primary_reason = \"Healthcare integrations benefit from MCP's specialized capabilities\"\n            else:\n                primary_recommendation = \"genesis:api_request\"\n                primary_reason = \"API Request provides straightforward integration\"\n\n        return {\n            \"primary_recommendation\": primary_recommendation,\n            \"primary_reason\": primary_reason,\n            \"api_score\": api_score,\n            \"mcp_score\": mcp_score,\n            \"factors\": factors,\n            \"both_available\": has_api_request and has_mcp_tool,\n            \"comparison\": {\n                \"api_pros\": [\n                    \"Direct HTTP integration\",\n                    \"Simple configuration\",\n                    \"Fast performance\",\n                    \"Standard authentication\"\n                ],\n                \"api_cons\": [\n                    \"Limited business logic\",\n                    \"Manual error handling\",\n                    \"No state management\",\n                    \"Harder to extend\"\n                ],\n                \"mcp_pros\": [\n                    \"Healthcare-specific logic\",\n                    \"Mock templates for development\",\n                    \"State management capabilities\",\n                    \"Extensible architecture\"\n                ],\n                \"mcp_cons\": [\n                    \"More complex setup\",\n                    \"Requires MCP server (or mock mode)\",\n                    \"Additional abstraction layer\",\n                    \"Development overhead\"\n                ]\n            }\n        }\n\n    def _generate_guidance(self, decision: Dict) -> Dict:\n        \"\"\"Generate specific guidance for both API and MCP approaches.\"\"\"\n        primary_component = decision[\"primary_recommendation\"]\n        comparison = decision[\"comparison\"]\n\n        # Provide guidance for both approaches\n        guidance = {\n            \"primary_recommendation\": {\n                \"component\": \"API Request\" if primary_component == \"genesis:api_request\" else \"MCP Tool\",\n                \"reason\": decision[\"primary_reason\"],\n                \"score\": decision[\"api_score\"] if primary_component == \"genesis:api_request\" else decision[\"mcp_score\"]\n            },\n            \"api_request_guidance\": {\n                \"component\": \"API Request\",\n                \"when_to_use\": \"Simple HTTP API integrations with known endpoints\",\n                \"pros\": comparison[\"api_pros\"],\n                \"cons\": comparison[\"api_cons\"],\n                \"setup_steps\": [\n                    \"Define the HTTP method (GET, POST, etc.)\",\n                    \"Specify the endpoint URL\",\n                    \"Configure headers (including authentication)\",\n                    \"Set up request body if needed\",\n                    \"Configure timeout settings\"\n                ],\n                \"configuration_template\": {\n                    \"type\": \"genesis:api_request\",\n                    \"config\": {\n                        \"method\": \"POST\",\n                        \"url_input\": \"https://api.healthcare.gov/v1/endpoint\",\n                        \"headers\": [\n                            {\"key\": \"Authorization\", \"value\": \"${API_KEY}\"},\n                            {\"key\": \"Content-Type\", \"value\": \"application/json\"}\n                        ],\n                        \"body\": [\n                            {\"key\": \"patient_id\", \"value\": \"${PATIENT_ID}\"}\n                        ],\n                        \"timeout\": 30\n                    }\n                }\n            },\n            \"mcp_tool_guidance\": {\n                \"component\": \"MCP Tool\",\n                \"when_to_use\": \"Complex healthcare integrations requiring business logic\",\n                \"pros\": comparison[\"mcp_pros\"],\n                \"cons\": comparison[\"mcp_cons\"],\n                \"setup_steps\": [\n                    \"Define the tool name identifier\",\n                    \"Provide tool description for the agent\",\n                    \"Configure MCP server connection (if available)\",\n                    \"Set up mock response for development\",\n                    \"Define expected input/output schemas\"\n                ],\n                \"configuration_template\": {\n                    \"type\": \"genesis:mcp_tool\",\n                    \"config\": {\n                        \"tool_name\": \"healthcare_integration_tool\",\n                        \"description\": \"Healthcare-specific integration tool with FHIR/HL7 support\",\n                        \"mock_response\": {\n                            \"status\": \"success\",\n                            \"data\": {\n                                \"patient_id\": \"PAT123\",\n                                \"fhir_compliant\": True,\n                                \"hipaa_status\": \"compliant\"\n                            }\n                        }\n                    }\n                },\n                \"development_mode\": \"Use mock templates for development without actual MCP servers\"\n            }\n        }\n\n        return guidance\n\n    def _generate_guidance_old(self, decision: Dict) -> Dict:\n        \"\"\"OLD VERSION - Generate specific guidance for the chosen approach.\"\"\"\n        component_type = decision.get(\"recommended_component\", \"genesis:api_request\")\n\n        if component_type == \"genesis:api_request\":\n            return {\n                \"component\": \"API Request\",\n                \"setup_steps\": [\n                    \"Define the HTTP method (GET, POST, etc.)\",\n                    \"Specify the endpoint URL\",\n                    \"Configure headers (including authentication)\",\n                    \"Set up request body if needed\",\n                    \"Configure timeout settings\"\n                ],\n                \"configuration_template\": {\n                    \"type\": \"genesis:api_request\",\n                    \"config\": {\n                        \"method\": \"POST\",\n                        \"url_input\": \"https://api.example.com/endpoint\",\n                        \"headers\": [\n                            {\"key\": \"Authorization\", \"value\": \"${API_KEY}\"},\n                            {\"key\": \"Content-Type\", \"value\": \"application/json\"}\n                        ],\n                        \"body\": [],\n                        \"timeout\": 30\n                    }\n                },\n                \"best_for\": [\n                    \"Simple REST API calls\",\n                    \"Webhooks\",\n                    \"Direct HTTP integrations\",\n                    \"Public APIs with standard auth\"\n                ]\n            }\n        else:  # genesis:mcp_tool\n            return {\n                \"component\": \"MCP Tool\",\n                \"setup_steps\": [\n                    \"Define the tool name identifier\",\n                    \"Provide tool description for the agent\",\n                    \"Configure MCP server connection (if available)\",\n                    \"Set up mock response for development\",\n                    \"Define expected input/output schemas\"\n                ],\n                \"configuration_template\": {\n                    \"type\": \"genesis:mcp_tool\",\n                    \"config\": {\n                        \"tool_name\": \"integration_tool\",\n                        \"description\": \"Tool description for agent context\",\n                        \"mock_response\": {\n                            \"status\": \"success\",\n                            \"data\": {}\n                        }\n                    }\n                },\n                \"best_for\": [\n                    \"Complex healthcare integrations\",\n                    \"Multi-step workflows\",\n                    \"Stateful operations\",\n                    \"Tools requiring business logic\",\n                    \"Development without actual servers (mock mode)\"\n                ]\n            }\n\n    def _get_examples(self, decision: Dict) -> List[Dict]:\n        \"\"\"Get relevant examples for the chosen approach.\"\"\"\n        component_type = decision[\"recommended_component\"]\n\n        if component_type == \"genesis:api_request\":\n            return [\n                {\n                    \"name\": \"Insurance Eligibility Check\",\n                    \"description\": \"Direct API call to insurance provider\",\n                    \"config\": {\n                        \"method\": \"POST\",\n                        \"url_input\": \"https://api.insurer.com/eligibility\",\n                        \"headers\": [{\"key\": \"X-API-Key\", \"value\": \"${INSURER_API_KEY}\"}]\n                    }\n                },\n                {\n                    \"name\": \"Send Notification\",\n                    \"description\": \"Webhook to notification service\",\n                    \"config\": {\n                        \"method\": \"POST\",\n                        \"url_input\": \"https://hooks.slack.com/services/...\",\n                        \"body\": [{\"key\": \"text\", \"value\": \"Notification message\"}]\n                    }\n                }\n            ]\n        else:  # MCP Tool examples\n            return [\n                {\n                    \"name\": \"EHR Integration\",\n                    \"description\": \"Complex EHR system integration\",\n                    \"config\": {\n                        \"tool_name\": \"ehr_patient_lookup\",\n                        \"description\": \"Search and retrieve patient records from EHR\"\n                    }\n                },\n                {\n                    \"name\": \"Prior Auth Processor\",\n                    \"description\": \"Multi-payer authorization system\",\n                    \"config\": {\n                        \"tool_name\": \"prior_auth_submit\",\n                        \"description\": \"Submit and track prior authorization requests\"\n                    }\n                }\n            ]\n\n    def _format_response(self, decision: Dict, guidance: Dict, examples: List[Dict]) -> str:\n        \"\"\"Format a comprehensive conversational response for the user.\"\"\"\n        primary = guidance[\"primary_recommendation\"]\n        api_guidance = guidance[\"api_request_guidance\"]\n        mcp_guidance = guidance[\"mcp_tool_guidance\"]\n\n        response = f\"\"\"🔧 **Integration Decision Analysis**\n\n**Primary Recommendation: {primary['component']}** (Score: {primary['score']})\n**Reason:** {primary['reason']}\n\n## 🌐 API Request Approach\n**When to use:** {api_guidance['when_to_use']}\n\n**Pros:**\n\"\"\"\n        for pro in api_guidance['pros']:\n            response += f\"✅ {pro}\\n\"\n\n        response += f\"\"\"\n**Cons:**\n\"\"\"\n        for con in api_guidance['cons']:\n            response += f\"❌ {con}\\n\"\n\n        response += f\"\"\"\n**Configuration:**\n```yaml\n{self._dict_to_yaml(api_guidance['configuration_template'])}\n```\n\n## 🔌 MCP Tool Approach\n**When to use:** {mcp_guidance['when_to_use']}\n\n**Pros:**\n\"\"\"\n        for pro in mcp_guidance['pros']:\n            response += f\"✅ {pro}\\n\"\n\n        response += f\"\"\"\n**Cons:**\n\"\"\"\n        for con in mcp_guidance['cons']:\n            response += f\"❌ {con}\\n\"\n\n        response += f\"\"\"\n**Configuration:**\n```yaml\n{self._dict_to_yaml(mcp_guidance['configuration_template'])}\n```\n\n**💡 Development Note:** {mcp_guidance['development_mode']}\n\n## 🎯 Recommendation Summary\nFor your **{self.integration_description}** integration, I recommend **{primary['component']}** because {primary['reason'].lower()}.\n\nBoth approaches are available - would you like to proceed with **{primary['component']}** or explore the alternative?\"\"\"\n\n        return response\n\n    def _dict_to_yaml(self, data: dict, indent: int = 0) -> str:\n        \"\"\"Convert dict to YAML-like string for display.\"\"\"\n        yaml_str = \"\"\n        for key, value in data.items():\n            yaml_str += \" \" * indent + f\"{key}: \"\n            if isinstance(value, dict):\n                yaml_str += \"\\n\" + self._dict_to_yaml(value, indent + 2)\n            elif isinstance(value, list):\n                yaml_str += \"\\n\"\n                for item in value:\n                    yaml_str += \" \" * (indent + 2) + f\"- \"\n                    if isinstance(item, dict):\n                        first_key = list(item.keys())[0] if item else \"\"\n                        yaml_str += f\"{first_key}: {item[first_key]}\\n\" if first_key else \"\\n\"\n                    else:\n                        yaml_str += f\"{item}\\n\"\n            else:\n                yaml_str += f\"{value}\\n\"\n        return yaml_str\n"
              },
              "has_mcp_server": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Has MCP Server",
                "dynamic": false,
                "info": "Does the user have an MCP server available?",
                "list": false,
                "list_add_label": "Add More",
                "name": "has_mcp_server",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "integration_description": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Integration Description",
                "dynamic": false,
                "info": "Describe what you need to integrate with",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "integration_description",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "needs_state_management": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Needs State Management",
                "dynamic": false,
                "info": "Does the integration need to maintain state?",
                "list": false,
                "list_add_label": "Add More",
                "name": "needs_state_management",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "tools_metadata": {
                "_input_type": "ToolsInput",
                "advanced": false,
                "display_name": "Actions",
                "dynamic": false,
                "info": "Modify tool names and descriptions to help agents understand when to use each tool.",
                "is_list": true,
                "list_add_label": "Add More",
                "name": "tools_metadata",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tools",
                "value": [
                  {
                    "args": {
                      "api_details": {
                        "default": "",
                        "description": "Known API endpoints, authentication, etc.",
                        "title": "Api Details",
                        "type": "string"
                      },
                      "has_mcp_server": {
                        "default": false,
                        "description": "Does the user have an MCP server available?",
                        "title": "Has Mcp Server",
                        "type": "boolean"
                      },
                      "integration_description": {
                        "description": "Describe what you need to integrate with",
                        "title": "Integration Description",
                        "type": "string"
                      },
                      "needs_state_management": {
                        "default": false,
                        "description": "Does the integration need to maintain state?",
                        "title": "Needs State Management",
                        "type": "boolean"
                      }
                    },
                    "description": "Guides decision between API Request and MCP Tool components",
                    "display_description": "Guides decision between API Request and MCP Tool components",
                    "display_name": "decide",
                    "name": "decide",
                    "readonly": false,
                    "status": true,
                    "tags": [
                      "decide"
                    ]
                  }
                ]
              }
            },
            "tool_mode": true
          },
          "showNode": true,
          "type": "IntegrationDecision"
        },
        "dragging": false,
        "id": "IntegrationDecision-5PE08",
        "measured": {
          "height": 218,
          "width": 320
        },
        "position": {
          "x": 1985.6812509786193,
          "y": 2529.386282615547
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ComponentValidator-JpWcb",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Validates components and connections in agent specifications",
            "display_name": "Component Validator",
            "documentation": "",
            "edited": false,
            "field_order": [
              "specification"
            ],
            "frozen": false,
            "icon": "check-square",
            "last_updated": "2025-10-14T18:18:51.493Z",
            "legacy": false,
            "lf_version": "1.6.3",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Toolset",
                "group_outputs": false,
                "hidden": null,
                "method": "to_toolkit",
                "name": "component_as_tool",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "\"\"\"Component Validator for AI Studio Agent Builder - Validates component usage.\"\"\"\n\nimport asyncio\nimport yaml\nfrom typing import Dict, List, Any, Optional\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs import MessageTextInput\nfrom langflow.io import Output\nfrom langflow.schema.data import Data\nfrom langflow.logging import logger\nfrom langflow.components.helpers.studio_builder.api_client import SpecAPIClient\n\n\nclass ComponentValidator(Component):\n    \"\"\"Validates that specifications use only valid genesis components.\"\"\"\n\n    display_name = \"Component Validator\"\n    description = \"Validates components and connections in agent specifications\"\n    icon = \"check-square\"\n    name = \"ComponentValidator\"\n    category = \"Helpers\"\n\n    # Valid components cache\n    _valid_components_cache = None\n\n    # Valid connection types\n    VALID_CONNECTION_TYPES = {\n        \"input\", \"output\", \"prompt\", \"tools\", \"agent\", \"task\", \"agents\", \"tasks\"\n    }\n\n    inputs = [\n        MessageTextInput(\n            name=\"specification\",\n            display_name=\"Specification\",\n            info=\"YAML specification or component list to validate\",\n            required=True,\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Validation Result\", name=\"result\", method=\"validate\"),\n    ]\n\n    def _get_valid_components(self) -> set:\n        \"\"\"Get valid components from API if not cached.\"\"\"\n        if self._valid_components_cache is None:\n            try:\n                async def _fetch_components():\n                    async with SpecAPIClient() as client:\n                        components = await client.get_available_components()\n                        return set(components.keys())\n\n                self._valid_components_cache = asyncio.run(_fetch_components())\n            except Exception as e:\n                logger.error(f\"Failed to get components from API: {e}\")\n                # Fallback to essential components\n                self._valid_components_cache = {\n                    \"genesis:chat_input\",\n                    \"genesis:chat_output\",\n                    \"genesis:agent\",\n                    \"genesis:language_model\"\n                }\n        return self._valid_components_cache\n\n    def validate(self) -> Data:\n        \"\"\"Validate the components in a specification.\"\"\"\n        try:\n            # Parse input - could be YAML or JSON\n            if isinstance(self.specification, str):\n                try:\n                    spec_data = yaml.safe_load(self.specification)\n                except yaml.YAMLError:\n                    # Try as a simple component list\n                    spec_data = {\"components\": self.specification.split(\",\")}\n            else:\n                spec_data = self.specification\n\n            errors = []\n            warnings = []\n            suggestions = []\n            validated_components = []\n\n            # Get components from spec\n            components = spec_data.get(\"components\", [])\n\n            if not components:\n                errors.append(\"No components found in specification\")\n                return self._create_response(False, errors, warnings, suggestions)\n\n            # Validate each component\n            for component in components:\n                if isinstance(component, dict):\n                    comp_type = component.get(\"type\", \"\")\n                    comp_id = component.get(\"id\", \"unknown\")\n                    comp_name = component.get(\"name\", \"\")\n                else:\n                    comp_type = str(component).strip()\n                    comp_id = comp_type\n                    comp_name = comp_type\n\n                # Check if component type is valid\n                valid_components = self._get_valid_components()\n                if comp_type not in valid_components:\n                    errors.append(f\"Invalid component type '{comp_type}' for '{comp_id}'\")\n\n                    # Suggest corrections\n                    suggestion = self._suggest_component(comp_type, comp_name)\n                    if suggestion:\n                        suggestions.append(f\"Replace '{comp_type}' with '{suggestion}'\")\n                else:\n                    validated_components.append({\n                        \"id\": comp_id,\n                        \"type\": comp_type,\n                        \"valid\": True\n                    })\n\n                # Validate connections if present\n                if isinstance(component, dict) and \"provides\" in component:\n                    connection_errors = self._validate_connections(component)\n                    errors.extend(connection_errors)\n\n            # Check for required components based on pattern\n            pattern_check = self._check_pattern_requirements(validated_components)\n            if pattern_check[\"missing\"]:\n                warnings.append(f\"Missing typical components: {', '.join(pattern_check['missing'])}\")\n                suggestions.append(f\"Consider adding: {', '.join(pattern_check['missing'])}\")\n\n            # Determine overall validity\n            is_valid = len(errors) == 0\n\n            return self._create_response(\n                is_valid,\n                errors,\n                warnings,\n                suggestions,\n                validated_components=validated_components,\n                pattern=pattern_check.get(\"pattern\", \"unknown\")\n            )\n\n        except Exception as e:\n            logger.error(f\"Error validating components: {e}\")\n            return self._create_response(\n                False,\n                [f\"Validation error: {str(e)}\"],\n                [],\n                []\n            )\n\n    def _suggest_component(self, invalid_type: str, name: str) -> Optional[str]:\n        \"\"\"Suggest a valid component type based on the invalid one.\"\"\"\n        invalid_lower = invalid_type.lower()\n\n        # Common mistakes and corrections\n        corrections = {\n            \"input\": \"genesis:chat_input\",\n            \"output\": \"genesis:chat_output\",\n            \"llm\": \"genesis:agent\",\n            \"ai\": \"genesis:agent\",\n            \"model\": \"genesis:agent\",\n            \"prompt\": \"genesis:prompt_template\",\n            \"template\": \"genesis:prompt_template\",\n            \"tool\": \"genesis:mcp_tool\",\n            \"api\": \"genesis:api_request\",\n            \"http\": \"genesis:api_request\",\n            \"rest\": \"genesis:api_request\",\n            \"search\": \"genesis:knowledge_hub_search\",\n            \"knowledge\": \"genesis:knowledge_hub_search\",\n            \"rag\": \"genesis:knowledge_hub_search\",\n            \"crew\": \"genesis:crewai_sequential_crew\",\n            \"task\": \"genesis:crewai_sequential_task\"\n        }\n\n        # Check for partial matches\n        for key, value in corrections.items():\n            if key in invalid_lower:\n                return value\n\n        # Check if it's missing the genesis: prefix\n        if not invalid_type.startswith(\"genesis:\"):\n            potential = f\"genesis:{invalid_type}\"\n            valid_components = self._get_valid_components()\n            if potential in valid_components:\n                return potential\n\n        return None\n\n    def _validate_connections(self, component: Dict) -> List[str]:\n        \"\"\"Validate the connections in a component.\"\"\"\n        errors = []\n        provides = component.get(\"provides\", [])\n\n        for connection in provides:\n            if isinstance(connection, dict):\n                use_as = connection.get(\"useAs\", \"\")\n                if use_as and use_as not in self.VALID_CONNECTION_TYPES:\n                    errors.append(\n                        f\"Invalid connection type '{use_as}' in component '{component.get('id', 'unknown')}'. \"\n                        f\"Valid types: {', '.join(self.VALID_CONNECTION_TYPES)}\"\n                    )\n\n                # Check if 'in' field references a valid component\n                target = connection.get(\"in\", \"\")\n                if not target:\n                    errors.append(\n                        f\"Connection in component '{component.get('id', 'unknown')}' missing 'in' field\"\n                    )\n\n        return errors\n\n    def _check_pattern_requirements(self, components: List[Dict]) -> Dict:\n        \"\"\"Check if components match a known pattern.\"\"\"\n        component_types = {c[\"type\"] for c in components}\n\n        # Identify pattern and missing components\n        if \"genesis:chat_input\" in component_types and \"genesis:chat_output\" in component_types:\n            if \"genesis:agent\" in component_types or \"genesis:language_model\" in component_types:\n                # Basic agent pattern\n                pattern = \"simple_linear\"\n                missing = []\n\n                # Check for enhancements\n                if any(t in component_types for t in [\"genesis:mcp_tool\", \"genesis:api_request\"]):\n                    pattern = \"agent_with_tools\"\n                elif \"genesis:prompt_template\" in component_types:\n                    pattern = \"agent_with_prompt\"\n\n                return {\"pattern\": pattern, \"missing\": missing}\n            else:\n                return {\"pattern\": \"incomplete\", \"missing\": [\"genesis:agent or genesis:language_model\"]}\n        else:\n            missing = []\n            if \"genesis:chat_input\" not in component_types:\n                missing.append(\"genesis:chat_input\")\n            if \"genesis:chat_output\" not in component_types:\n                missing.append(\"genesis:chat_output\")\n            if \"genesis:agent\" not in component_types and \"genesis:language_model\" not in component_types:\n                missing.append(\"genesis:agent or genesis:language_model\")\n\n            return {\"pattern\": \"incomplete\", \"missing\": missing}\n\n    def _create_response(self, valid: bool, errors: List[str],\n                        warnings: List[str], suggestions: List[str],\n                        validated_components: List[Dict] = None,\n                        pattern: str = None) -> Data:\n        \"\"\"Create a structured validation response.\"\"\"\n        response = {\n            \"valid\": valid,\n            \"errors\": errors,\n            \"warnings\": warnings,\n            \"suggestions\": suggestions,\n            \"message\": \"Validation successful\" if valid else \"Validation failed\"\n        }\n\n        if validated_components:\n            response[\"validated_components\"] = validated_components\n            response[\"total_components\"] = len(validated_components)\n\n        if pattern:\n            response[\"detected_pattern\"] = pattern\n\n        return Data(data=response)\n"
              },
              "specification": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Specification",
                "dynamic": false,
                "info": "YAML specification or component list to validate",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "specification",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "tools_metadata": {
                "_input_type": "ToolsInput",
                "advanced": false,
                "display_name": "Actions",
                "dynamic": false,
                "info": "Modify tool names and descriptions to help agents understand when to use each tool.",
                "is_list": true,
                "list_add_label": "Add More",
                "name": "tools_metadata",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tools",
                "value": [
                  {
                    "args": {
                      "specification": {
                        "description": "YAML specification or component list to validate",
                        "title": "Specification",
                        "type": "string"
                      }
                    },
                    "description": "Validates components and connections in agent specifications",
                    "display_description": "Validates components and connections in agent specifications",
                    "display_name": "validate",
                    "name": "component_validator",
                    "readonly": false,
                    "status": true,
                    "tags": [
                      "validate"
                    ]
                  }
                ]
              }
            },
            "tool_mode": true
          },
          "showNode": true,
          "type": "ComponentValidator"
        },
        "dragging": false,
        "id": "ComponentValidator-JpWcb",
        "measured": {
          "height": 218,
          "width": 320
        },
        "position": {
          "x": 2323.2102650073334,
          "y": 1032.9496678415148
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "PatternAnalyzer-rDLXI",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Analyzes specifications and generates component connections and data flow patterns",
            "display_name": "Pattern Analyzer",
            "documentation": "",
            "edited": false,
            "field_order": [
              "spec_components",
              "agent_goal",
              "add_connections"
            ],
            "frozen": false,
            "icon": "git-branch",
            "last_updated": "2025-10-14T18:18:51.493Z",
            "legacy": false,
            "lf_version": "1.6.3",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Toolset",
                "group_outputs": false,
                "hidden": null,
                "method": "to_toolkit",
                "name": "component_as_tool",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "add_connections": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Add Connections",
                "dynamic": false,
                "info": "Whether to add provides relationships to components",
                "list": false,
                "list_add_label": "Add More",
                "name": "add_connections",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "agent_goal": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Agent Goal",
                "dynamic": false,
                "info": "The agent's primary goal to inform connection patterns",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "agent_goal",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "\"\"\"Pattern Analyzer for AI Studio Agent Builder - Generates component connections.\"\"\"\n\nimport asyncio\nfrom typing import Dict, List, Any, Optional\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs import MessageTextInput, BoolInput\nfrom langflow.io import Output\nfrom langflow.schema.data import Data\nfrom langflow.logging import logger\n\n\nclass PatternAnalyzer(Component):\n    \"\"\"Analyzes agent specifications and generates proper component connections.\"\"\"\n\n    display_name = \"Pattern Analyzer\"\n    description = \"Analyzes specifications and generates component connections and data flow patterns\"\n    icon = \"git-branch\"\n    name = \"PatternAnalyzer\"\n    category = \"Helpers\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"spec_components\",\n            display_name=\"Spec Components\",\n            info=\"JSON list of components to analyze for connections\",\n            required=True,\n            tool_mode=True,\n        ),\n        MessageTextInput(\n            name=\"agent_goal\",\n            display_name=\"Agent Goal\",\n            info=\"The agent's primary goal to inform connection patterns\",\n            required=False,\n            tool_mode=True,\n        ),\n        BoolInput(\n            name=\"add_connections\",\n            display_name=\"Add Connections\",\n            info=\"Whether to add provides relationships to components\",\n            value=True,\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Connected Components\", name=\"connected_components\", method=\"analyze_connections\"),\n    ]\n\n    def analyze_connections(self) -> Data:\n        \"\"\"Analyze components and generate proper connections.\"\"\"\n        try:\n            import json\n\n            # Parse the components\n            try:\n                components = json.loads(self.spec_components) if isinstance(self.spec_components, str) else self.spec_components\n            except json.JSONDecodeError:\n                return Data(data={\n                    \"success\": False,\n                    \"error\": \"Invalid JSON format for components\",\n                    \"components\": []\n                })\n\n            if not isinstance(components, list):\n                return Data(data={\n                    \"success\": False,\n                    \"error\": \"Components must be a list\",\n                    \"components\": []\n                })\n\n            if not self.add_connections:\n                return Data(data={\n                    \"success\": True,\n                    \"components\": components,\n                    \"connections_added\": 0,\n                    \"message\": \"No connections added (add_connections=False)\"\n                })\n\n            # Analyze and add connections\n            connected_components = self._generate_connections(components)\n            connections_count = self._count_connections(connected_components)\n\n            return Data(data={\n                \"success\": True,\n                \"components\": connected_components,\n                \"connections_added\": connections_count,\n                \"message\": f\"Generated {connections_count} component connections\",\n                \"flow_analysis\": self._analyze_flow(connected_components)\n            })\n\n        except Exception as e:\n            logger.error(f\"Error in pattern analyzer: {e}\")\n            return Data(data={\n                \"success\": False,\n                \"error\": str(e),\n                \"components\": []\n            })\n\n    def _generate_connections(self, components: List[Dict]) -> List[Dict]:\n        \"\"\"Generate proper component connections based on healthcare patterns.\"\"\"\n        if not components:\n            return components\n\n        # First, fix component structure to match specification requirements\n        self._fix_component_structure(components)\n\n        # Create a mapping of component IDs to components\n        comp_map = {comp.get(\"id\", f\"comp_{i}\"): comp for i, comp in enumerate(components)}\n        comp_ids = list(comp_map.keys())\n\n        # Standard healthcare flow patterns\n        input_components = [comp for comp in components if comp.get(\"type\") == \"genesis:chat_input\"]\n        output_components = [comp for comp in components if comp.get(\"type\") == \"genesis:chat_output\"]\n        agent_components = [comp for comp in components if comp.get(\"type\") == \"genesis:agent\"]\n        prompt_components = [comp for comp in components if comp.get(\"type\") == \"genesis:prompt_template\"]\n        model_components = [comp for comp in components if comp.get(\"type\", \"\").startswith(\"genesis:\") and\n                          any(model_type in comp.get(\"type\", \"\") for model_type in [\"clinical_llm\", \"icd10\", \"cpt\", \"rxnorm\", \"combined_entity\"])]\n        api_components = [comp for comp in components if comp.get(\"type\") == \"genesis:api_request\"]\n        tool_components = [comp for comp in components if comp.get(\"type\") == \"genesis:mcp_tool\"]\n\n        # Generate connections for each component\n        for comp in components:\n            comp_id = comp.get(\"id\")\n            comp_type = comp.get(\"type\", \"\")\n\n            if not comp_id:\n                continue\n\n            # Initialize provides if not exists\n            if \"provides\" not in comp:\n                comp[\"provides\"] = []\n\n            # Connection patterns based on component type\n            if comp_type == \"genesis:chat_input\":\n                # Input connects to processing components (models, agents, APIs)\n                targets = []\n\n                # Prioritize clinical models for healthcare inputs\n                if model_components:\n                    targets.extend([m.get(\"id\") for m in model_components[:2]])  # Limit to 2 models\n                elif agent_components:\n                    targets.append(agent_components[0].get(\"id\"))\n                elif api_components:\n                    targets.append(api_components[0].get(\"id\"))\n\n                for target in targets:\n                    if target and target != comp_id:\n                        comp[\"provides\"].append({\n                            \"useAs\": \"input_value\",\n                            \"in\": target,\n                            \"description\": f\"Provides user input to {target}\"\n                        })\n\n            elif comp_type in [\"genesis:clinical_llm\", \"genesis:icd10\", \"genesis:cpt_code\", \"genesis:cpt\", \"genesis:rxnorm\", \"genesis:combined_entity_linking\"]:\n                # Medical models connect to agents or other models, then to output\n                targets = []\n\n                # Connect to agent if available, or to other models in sequence\n                if agent_components:\n                    targets.append(agent_components[0].get(\"id\"))\n                elif api_components:\n                    targets.append(api_components[0].get(\"id\"))\n                elif output_components:\n                    targets.append(output_components[0].get(\"id\"))\n\n                for target in targets:\n                    if target and target != comp_id:\n                        comp[\"provides\"].append({\n                            \"useAs\": \"input_value\" if \"agent\" in target else \"input_value\",\n                            \"in\": target,\n                            \"description\": f\"Provides medical analysis to {target}\"\n                        })\n\n            elif comp_type == \"genesis:agent\":\n                # Agent connections: tools come TO agent, output goes FROM agent\n\n                # Connect to output components\n                if output_components:\n                    for output in output_components:\n                        target_id = output.get(\"id\")\n                        if target_id and target_id != comp_id:\n                            comp[\"provides\"].append({\n                                \"useAs\": \"input\",\n                                \"in\": target_id,\n                                \"description\": f\"Provides agent response to {target_id}\"\n                            })\n\n            elif comp_type == \"genesis:mcp_tool\":\n                # MCP tools provide TO agents via tools relationship\n                if agent_components:\n                    for agent in agent_components:\n                        agent_id = agent.get(\"id\")\n                        if agent_id and agent_id != comp_id:\n                            comp[\"provides\"].append({\n                                \"useAs\": \"tools\",\n                                \"in\": agent_id,\n                                \"description\": f\"Provides tool capabilities to {agent_id}\"\n                            })\n\n            elif comp_type == \"genesis:prompt_template\":\n                # Prompts provide TO agents via system_prompt relationship\n                if agent_components:\n                    for agent in agent_components:\n                        agent_id = agent.get(\"id\")\n                        if agent_id and agent_id != comp_id:\n                            comp[\"provides\"].append({\n                                \"useAs\": \"system_prompt\",\n                                \"in\": agent_id,\n                                \"description\": f\"Provides system prompt to {agent_id}\"\n                            })\n\n            elif comp_type == \"genesis:api_request\":\n                # API components typically connect to output\n                if output_components:\n                    target = output_components[0].get(\"id\")\n                    if target and target != comp_id:\n                        comp[\"provides\"].append({\n                            \"useAs\": \"input_value\",\n                            \"in\": target,\n                            \"description\": f\"Provides API response to {target}\"\n                        })\n\n            elif comp_type == \"genesis:mcp_tool\":\n                # MCP tools are typically used by agents (already handled above)\n                # They don't usually provide to other components directly\n                pass\n\n            # Note: genesis:chat_output doesn't provide to anything (it's a sink)\n\n        return components\n\n    def _fix_component_structure(self, components: List[Dict]) -> None:\n        \"\"\"Fix component structure to match specification requirements.\"\"\"\n        for comp in components:\n            # Add missing 'name' field if not present\n            if \"name\" not in comp:\n                comp_type = comp.get(\"type\", \"\")\n                if \"name\" in comp and comp[\"name\"]:\n                    # Keep existing name\n                    pass\n                elif comp_type == \"genesis:chat_input\":\n                    comp[\"name\"] = \"User Input\"\n                elif comp_type == \"genesis:chat_output\":\n                    comp[\"name\"] = \"Response Output\"\n                elif comp_type == \"genesis:agent\":\n                    comp[\"name\"] = \"AI Agent\"\n                elif comp_type == \"genesis:prompt_template\":\n                    comp[\"name\"] = \"Agent Instructions\"\n                elif comp_type == \"genesis:mcp_tool\":\n                    comp[\"name\"] = comp.get(\"description\", \"Integration Tool\")\n                else:\n                    comp[\"name\"] = comp.get(\"description\", \"Component\")\n\n            # Add missing 'kind' field based on component type\n            if \"kind\" not in comp:\n                comp_type = comp.get(\"type\", \"\")\n                if comp_type in [\"genesis:chat_input\", \"genesis:chat_output\"]:\n                    comp[\"kind\"] = \"Data\"\n                elif comp_type == \"genesis:agent\":\n                    comp[\"kind\"] = \"Agent\"\n                elif comp_type == \"genesis:prompt_template\":\n                    comp[\"kind\"] = \"Prompt\"\n                elif comp_type == \"genesis:mcp_tool\":\n                    comp[\"kind\"] = \"Tool\"\n                    # Add asTools: true for MCP tools\n                    comp[\"asTools\"] = True\n                else:\n                    comp[\"kind\"] = \"Data\"\n\n            # Ensure provides is initialized\n            if \"provides\" not in comp:\n                comp[\"provides\"] = []\n\n    def _count_connections(self, components: List[Dict]) -> int:\n        \"\"\"Count the total number of connections added.\"\"\"\n        count = 0\n        for comp in components:\n            count += len(comp.get(\"provides\", []))\n        return count\n\n    def _analyze_flow(self, components: List[Dict]) -> Dict[str, Any]:\n        \"\"\"Analyze the flow structure and provide insights.\"\"\"\n        input_count = len([c for c in components if c.get(\"type\") == \"genesis:chat_input\"])\n        output_count = len([c for c in components if c.get(\"type\") == \"genesis:chat_output\"])\n        agent_count = len([c for c in components if c.get(\"type\") == \"genesis:agent\"])\n        model_count = len([c for c in components if c.get(\"type\", \"\").startswith(\"genesis:\") and\n                          any(model in c.get(\"type\", \"\") for model in [\"clinical_llm\", \"icd10\", \"cpt\", \"rxnorm\"])])\n\n        # Check for disconnected components\n        connected_components = set()\n        for comp in components:\n            comp_id = comp.get(\"id\")\n            if comp_id:\n                connected_components.add(comp_id)\n                for provide in comp.get(\"provides\", []):\n                    if \"in\" in provide:\n                        connected_components.add(provide[\"in\"])\n\n        total_components = len([c for c in components if c.get(\"id\")])\n        disconnected_count = total_components - len(connected_components)\n\n        return {\n            \"total_components\": total_components,\n            \"input_components\": input_count,\n            \"output_components\": output_count,\n            \"agent_components\": agent_count,\n            \"model_components\": model_count,\n            \"connected_components\": len(connected_components),\n            \"potentially_disconnected\": disconnected_count,\n            \"flow_type\": self._determine_flow_type(input_count, output_count, agent_count, model_count),\n            \"is_valid_flow\": input_count >= 1 and output_count >= 1 and disconnected_count == 0\n        }\n\n    def _determine_flow_type(self, inputs: int, outputs: int, agents: int, models: int) -> str:\n        \"\"\"Determine the type of flow based on component counts.\"\"\"\n        if agents >= 1 and models >= 2:\n            return \"Multi-Model Healthcare Agent\"\n        elif agents >= 1 and models >= 1:\n            return \"Healthcare Agent with Medical Models\"\n        elif agents >= 1:\n            return \"Simple Agent Flow\"\n        elif models >= 1:\n            return \"Model-Based Processing\"\n        else:\n            return \"Basic Flow\"\n"
              },
              "spec_components": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Spec Components",
                "dynamic": false,
                "info": "JSON list of components to analyze for connections",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "spec_components",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "tools_metadata": {
                "_input_type": "ToolsInput",
                "advanced": false,
                "display_name": "Actions",
                "dynamic": false,
                "info": "Modify tool names and descriptions to help agents understand when to use each tool.",
                "is_list": true,
                "list_add_label": "Add More",
                "name": "tools_metadata",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tools",
                "value": [
                  {
                    "args": {
                      "add_connections": {
                        "default": true,
                        "description": "Whether to add provides relationships to components",
                        "title": "Add Connections",
                        "type": "boolean"
                      },
                      "agent_goal": {
                        "default": "",
                        "description": "The agent's primary goal to inform connection patterns",
                        "title": "Agent Goal",
                        "type": "string"
                      },
                      "spec_components": {
                        "description": "JSON list of components to analyze for connections",
                        "title": "Spec Components",
                        "type": "string"
                      }
                    },
                    "description": "Analyzes specifications and generates component connections and data flow patterns",
                    "display_description": "Analyzes specifications and generates component connections and data flow patterns",
                    "display_name": "analyze_connections",
                    "name": "pattern_analyzer",
                    "readonly": false,
                    "status": true,
                    "tags": [
                      "analyze_connections"
                    ]
                  }
                ]
              }
            },
            "tool_mode": true
          },
          "showNode": true,
          "type": "PatternAnalyzer"
        },
        "dragging": false,
        "id": "PatternAnalyzer-rDLXI",
        "measured": {
          "height": 218,
          "width": 320
        },
        "position": {
          "x": 2059.877670895867,
          "y": 2210.0279437673425
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "MCPFramework-r9Y5c",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Unified framework for selecting and configuring MCP tools from user specs, catalog, or mock templates",
            "display_name": "MCP Framework",
            "documentation": "",
            "edited": false,
            "field_order": [
              "tool_request",
              "tool_source",
              "user_tool_spec",
              "include_mock_fallback",
              "validate_tool_spec",
              "discovery_mode"
            ],
            "frozen": false,
            "icon": "layers",
            "last_updated": "2025-10-14T18:18:51.494Z",
            "legacy": false,
            "lf_version": "1.6.3",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Toolset",
                "group_outputs": false,
                "hidden": null,
                "method": "to_toolkit",
                "name": "component_as_tool",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "\"\"\"MCP Framework for AI Studio Agent Builder - Unified framework for user/catalog/mock MCP tools.\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Dict, List, Any, Optional, Union\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs import MessageTextInput, BoolInput, MultilineInput\nfrom langflow.io import Output\nfrom langflow.schema.data import Data\nfrom langflow.logging import logger\n\n# Import the actual mock tool templates from the MCP component\ntry:\n    from langflow.components.agents.mcp_component import MOCK_TOOL_TEMPLATES\nexcept ImportError:\n    logger.warning(\"Could not import MOCK_TOOL_TEMPLATES from mcp_component\")\n    MOCK_TOOL_TEMPLATES = {}\n\n\nclass MCPFramework(Component):\n    \"\"\"Unified framework for MCP tools from user input, catalog, or mock sources.\"\"\"\n\n    display_name = \"MCP Framework\"\n    description = \"Unified framework for selecting and configuring MCP tools from user specs, catalog, or mock templates\"\n    icon = \"layers\"\n    name = \"MCPFramework\"\n    category = \"Helpers\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"tool_request\",\n            display_name=\"Tool Request\",\n            info=\"Describe the MCP tool you need or provide JSON specification\",\n            required=True,\n            tool_mode=True,\n        ),\n        MessageTextInput(\n            name=\"tool_source\",\n            display_name=\"Tool Source\",\n            info=\"Source preference: 'user', 'catalog', 'mock', or 'auto' to decide automatically\",\n            value=\"auto\",\n            tool_mode=True,\n        ),\n        MultilineInput(\n            name=\"user_tool_spec\",\n            display_name=\"User Tool Specification\",\n            info=\"Optional: JSON specification for custom user-provided MCP tool\",\n            required=False,\n            tool_mode=True,\n        ),\n        BoolInput(\n            name=\"include_mock_fallback\",\n            display_name=\"Include Mock Fallback\",\n            info=\"Whether to provide mock fallback for development\",\n            value=True,\n            tool_mode=True,\n        ),\n        BoolInput(\n            name=\"validate_tool_spec\",\n            display_name=\"Validate Tool Spec\",\n            info=\"Whether to validate the generated tool specification\",\n            value=True,\n            tool_mode=True,\n        ),\n        BoolInput(\n            name=\"discovery_mode\",\n            display_name=\"Discovery Mode\",\n            info=\"Browse available tools instead of configuring specific tool\",\n            value=False,\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"MCP Tool Configuration\", name=\"mcp_config\", method=\"generate_mcp_config\"),\n    ]\n\n    def generate_mcp_config(self) -> Data:\n        \"\"\"Generate MCP tool configuration from user/catalog/mock sources.\"\"\"\n        try:\n            # Handle discovery mode - browse available tools\n            if self.discovery_mode:\n                return self._handle_discovery_mode()\n\n            # Parse tool request for configuration mode\n            tool_request = self.tool_request.strip()\n            source_preference = self.tool_source.lower()\n\n            # Determine tool source and generate configuration\n            if source_preference == \"user\" and self.user_tool_spec:\n                config = self._process_user_tool(tool_request, self.user_tool_spec)\n            elif source_preference == \"catalog\":\n                config = self._process_catalog_tool(tool_request)\n            elif source_preference == \"mock\":\n                config = self._process_mock_tool(tool_request)\n            else:  # auto mode\n                config = self._auto_select_tool_source(tool_request)\n\n            # Add mock fallback if requested\n            if self.include_mock_fallback and config.get(\"success\"):\n                config = self._add_mock_fallback(config)\n\n            # Validate if requested\n            if self.validate_tool_spec and config.get(\"success\"):\n                config = self._validate_tool_configuration(config)\n\n            # Generate conversation response\n            config[\"conversation_response\"] = self._format_framework_response(config)\n\n            return Data(data=config)\n\n        except Exception as e:\n            logger.error(f\"Error in MCP framework: {e}\")\n            return Data(data={\n                \"success\": False,\n                \"error\": str(e),\n                \"tool_config\": {},\n                \"message\": \"Failed to generate MCP tool configuration\"\n            })\n\n    def _process_user_tool(self, request: str, user_spec: str) -> Dict[str, Any]:\n        \"\"\"Process user-provided MCP tool specification.\"\"\"\n        try:\n            # Parse user specification\n            if user_spec.strip():\n                try:\n                    spec = json.loads(user_spec) if isinstance(user_spec, str) else user_spec\n                except json.JSONDecodeError:\n                    return {\n                        \"success\": False,\n                        \"error\": \"Invalid JSON format in user tool specification\",\n                        \"source\": \"user\"\n                    }\n            else:\n                # Generate from request description\n                spec = self._generate_tool_spec_from_description(request)\n\n            # Validate and normalize user spec\n            normalized_spec = self._normalize_user_tool_spec(spec)\n\n            return {\n                \"success\": True,\n                \"source\": \"user\",\n                \"tool_config\": normalized_spec,\n                \"original_spec\": spec,\n                \"message\": f\"Generated user MCP tool: {normalized_spec.get('tool_name', 'custom_tool')}\"\n            }\n\n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": f\"Error processing user tool: {e}\",\n                \"source\": \"user\"\n            }\n\n    def _process_catalog_tool(self, request: str) -> Dict[str, Any]:\n        \"\"\"Process tool from existing catalog/mock templates.\"\"\"\n        # Get existing mock templates from mcp_component.py structure\n        catalog_tools = self._get_catalog_tools()\n\n        # Find best match\n        best_match = self._find_best_catalog_match(request, catalog_tools)\n\n        if best_match:\n            tool_config = self._convert_catalog_to_config(best_match[\"tool_id\"], best_match[\"tool_data\"])\n            return {\n                \"success\": True,\n                \"source\": \"catalog\",\n                \"tool_config\": tool_config,\n                \"match_score\": best_match[\"score\"],\n                \"matched_tool\": best_match[\"tool_id\"],\n                \"message\": f\"Found catalog tool: {best_match['tool_data']['name']}\"\n            }\n        else:\n            return {\n                \"success\": False,\n                \"error\": \"No suitable tool found in catalog\",\n                \"source\": \"catalog\",\n                \"available_tools\": list(catalog_tools.keys())\n            }\n\n    def _process_mock_tool(self, request: str) -> Dict[str, Any]:\n        \"\"\"Generate a mock tool based on request description.\"\"\"\n        mock_config = self._generate_mock_tool_config(request)\n\n        return {\n            \"success\": True,\n            \"source\": \"mock\",\n            \"tool_config\": mock_config,\n            \"message\": f\"Generated mock tool: {mock_config.get('tool_name', 'mock_tool')}\"\n        }\n\n    def _auto_select_tool_source(self, request: str) -> Dict[str, Any]:\n        \"\"\"Automatically select the best tool source based on request.\"\"\"\n        request_lower = request.lower()\n\n        # Decision logic for source selection\n        if self.user_tool_spec and self.user_tool_spec.strip():\n            # User provided specification - use it\n            return self._process_user_tool(request, self.user_tool_spec)\n\n        # Check catalog first for existing tools\n        catalog_result = self._process_catalog_tool(request)\n        if catalog_result.get(\"success\") and catalog_result.get(\"match_score\", 0) > 0.7:\n            # High confidence catalog match\n            catalog_result[\"auto_selection_reason\"] = \"High confidence match in catalog\"\n            return catalog_result\n\n        # Healthcare-specific keywords suggest catalog/mock\n        healthcare_keywords = [\n            \"ehr\", \"emr\", \"fhir\", \"hl7\", \"patient\", \"clinical\", \"medical\", \"healthcare\",\n            \"prior authorization\", \"eligibility\", \"claims\", \"pharmacy\", \"drug\",\n            \"icd\", \"cpt\", \"diagnosis\", \"procedure\", \"medication\"\n        ]\n\n        if any(keyword in request_lower for keyword in healthcare_keywords):\n            # Try catalog first, then mock\n            if catalog_result.get(\"success\"):\n                catalog_result[\"auto_selection_reason\"] = \"Healthcare domain - using catalog\"\n                return catalog_result\n            else:\n                mock_result = self._process_mock_tool(request)\n                mock_result[\"auto_selection_reason\"] = \"Healthcare domain - generated mock\"\n                return mock_result\n\n        # Default to mock for custom requirements\n        mock_result = self._process_mock_tool(request)\n        mock_result[\"auto_selection_reason\"] = \"Custom requirement - generated mock\"\n        return mock_result\n\n    def _get_catalog_tools(self) -> Dict[str, Dict]:\n        \"\"\"Get available tools from catalog (based on actual mock templates).\"\"\"\n        # Use the actual MOCK_TOOL_TEMPLATES from mcp_component.py\n        catalog_tools = {}\n\n        for tool_id, template in MOCK_TOOL_TEMPLATES.items():\n            # Convert mock template to catalog format\n            catalog_tools[tool_id] = {\n                \"name\": template[\"name\"],\n                \"description\": template[\"description\"],\n                \"category\": self._infer_category_from_tool(tool_id, template),\n                \"domains\": self._infer_domains_from_tool(tool_id, template),\n                \"complexity\": self._infer_complexity_from_tool(template),\n                \"input_schema\": template.get(\"input_schema\", {}),\n                \"mock_response\": template.get(\"mock_response\", {}),\n                \"original_template\": template  # Keep reference to original\n            }\n\n        return catalog_tools\n\n    def _infer_category_from_tool(self, tool_id: str, template: Dict) -> str:\n        \"\"\"Infer category from tool ID and template.\"\"\"\n        if \"ehr\" in tool_id or \"patient\" in tool_id:\n            return \"Healthcare Integration\"\n        elif \"pharmacy\" in tool_id or \"claims\" in tool_id:\n            return \"Pharmacy & Claims\"\n        elif \"insurance\" in tool_id or \"eligibility\" in tool_id:\n            return \"Insurance & Benefits\"\n        elif \"prior_auth\" in tool_id or \"authorization\" in tool_id:\n            return \"Healthcare Workflow\"\n        elif \"coding\" in tool_id or \"icd\" in tool_id or \"cpt\" in tool_id:\n            return \"Medical Coding\"\n        else:\n            return \"Healthcare Tools\"\n\n    def _infer_domains_from_tool(self, tool_id: str, template: Dict) -> List[str]:\n        \"\"\"Infer domains from tool ID and template.\"\"\"\n        domains = []\n\n        # Extract domains from tool ID\n        if \"ehr\" in tool_id:\n            domains.extend([\"ehr\", \"patient_records\", \"clinical_data\"])\n        if \"pharmacy\" in tool_id:\n            domains.extend([\"pharmacy\", \"medications\", \"drug_interactions\"])\n        if \"insurance\" in tool_id:\n            domains.extend([\"insurance\", \"eligibility\", \"benefits\"])\n        if \"prior_auth\" in tool_id:\n            domains.extend([\"prior_authorization\", \"clinical_review\"])\n        if \"claims\" in tool_id:\n            domains.extend([\"claims\", \"billing\", \"reimbursement\"])\n\n        # Extract domains from description\n        description_lower = template.get(\"description\", \"\").lower()\n        if \"fhir\" in description_lower:\n            domains.append(\"fhir\")\n        if \"hipaa\" in description_lower:\n            domains.append(\"hipaa\")\n        if \"coding\" in description_lower:\n            domains.append(\"medical_coding\")\n\n        return list(set(domains)) if domains else [\"healthcare\"]\n\n    def _infer_complexity_from_tool(self, template: Dict) -> str:\n        \"\"\"Infer complexity from template structure.\"\"\"\n        input_schema = template.get(\"input_schema\", {})\n        num_inputs = len(input_schema)\n\n        if num_inputs <= 2:\n            return \"low\"\n        elif num_inputs <= 4:\n            return \"medium\"\n        else:\n            return \"high\"\n\n    def _find_best_catalog_match(self, request: str, catalog_tools: Dict) -> Optional[Dict]:\n        \"\"\"Find the best matching tool from catalog.\"\"\"\n        request_lower = request.lower()\n        best_match = None\n        best_score = 0\n\n        for tool_id, tool_data in catalog_tools.items():\n            score = 0\n\n            # Check name match\n            if any(word in tool_data[\"name\"].lower() for word in request_lower.split()):\n                score += 0.3\n\n            # Check description match\n            if any(word in tool_data[\"description\"].lower() for word in request_lower.split()):\n                score += 0.2\n\n            # Check domain match\n            for domain in tool_data.get(\"domains\", []):\n                if domain.lower() in request_lower:\n                    score += 0.4\n\n            # Specific keyword matching\n            if \"ehr\" in request_lower and \"ehr\" in tool_id:\n                score += 0.5\n            if \"prior auth\" in request_lower and \"prior_auth\" in tool_id:\n                score += 0.5\n            if \"coding\" in request_lower and \"coding\" in tool_id:\n                score += 0.5\n            if \"pharmacy\" in request_lower and \"pharmacy\" in tool_id:\n                score += 0.5\n            if \"eligibility\" in request_lower and \"eligibility\" in tool_id:\n                score += 0.5\n\n            if score > best_score:\n                best_score = score\n                best_match = {\n                    \"tool_id\": tool_id,\n                    \"tool_data\": tool_data,\n                    \"score\": score\n                }\n\n        return best_match if best_score > 0.3 else None\n\n    def _convert_catalog_to_config(self, tool_id: str, tool_data: Dict) -> Dict[str, Any]:\n        \"\"\"Convert catalog tool to genesis:mcp_tool configuration.\"\"\"\n        return {\n            \"type\": \"genesis:mcp_tool\",\n            \"tool_name\": tool_id,\n            \"description\": tool_data[\"description\"],\n            \"input_schema\": tool_data.get(\"input_schema\", {}),\n            \"mock_response\": tool_data.get(\"mock_response\", {}),\n            \"category\": tool_data.get(\"category\", \"Integration\"),\n            \"complexity\": tool_data.get(\"complexity\", \"medium\"),\n            \"healthcare_domains\": tool_data.get(\"domains\", []),\n            \"source\": \"catalog\"\n        }\n\n    def _generate_mock_tool_config(self, request: str) -> Dict[str, Any]:\n        \"\"\"Generate a mock tool configuration from request description.\"\"\"\n        # Extract key information from request\n        tool_name = self._extract_tool_name(request)\n\n        # Generate basic mock configuration\n        mock_config = {\n            \"type\": \"genesis:mcp_tool\",\n            \"tool_name\": tool_name,\n            \"description\": f\"Mock tool for {request}\",\n            \"input_schema\": self._generate_input_schema(request),\n            \"mock_response\": self._generate_mock_response(request),\n            \"category\": \"Custom Mock\",\n            \"complexity\": \"medium\",\n            \"source\": \"mock_generated\"\n        }\n\n        return mock_config\n\n    def _extract_tool_name(self, request: str) -> str:\n        \"\"\"Extract a suitable tool name from the request.\"\"\"\n        # Simple extraction logic - can be enhanced\n        words = request.lower().split()\n        # Remove common words\n        filtered_words = [w for w in words if w not in [\"a\", \"an\", \"the\", \"for\", \"to\", \"with\", \"tool\", \"integration\"]]\n        # Take first few significant words\n        name_words = filtered_words[:3] if len(filtered_words) >= 3 else filtered_words\n        return \"_\".join(name_words) + \"_tool\"\n\n    def _generate_input_schema(self, request: str) -> Dict[str, Any]:\n        \"\"\"Generate input schema based on request context.\"\"\"\n        request_lower = request.lower()\n        schema = {}\n\n        # Healthcare-specific schemas\n        if any(keyword in request_lower for keyword in [\"patient\", \"clinical\", \"medical\"]):\n            schema[\"patient_id\"] = {\"type\": \"string\", \"description\": \"Patient identifier\"}\n\n        if \"authorization\" in request_lower:\n            schema.update({\n                \"procedure_codes\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}},\n                \"diagnosis_codes\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}}\n            })\n\n        if \"eligibility\" in request_lower:\n            schema.update({\n                \"insurance_id\": {\"type\": \"string\", \"description\": \"Insurance member ID\"},\n                \"service_type\": {\"type\": \"string\", \"description\": \"Type of service\"}\n            })\n\n        # Default schema if nothing specific detected\n        if not schema:\n            schema = {\n                \"input_data\": {\"type\": \"string\", \"description\": \"Input data for processing\"},\n                \"options\": {\"type\": \"object\", \"description\": \"Optional parameters\"}\n            }\n\n        return schema\n\n    def _generate_mock_response(self, request: str) -> Dict[str, Any]:\n        \"\"\"Generate realistic mock response based on request context.\"\"\"\n        request_lower = request.lower()\n\n        # Healthcare responses\n        if \"authorization\" in request_lower:\n            return {\n                \"authorization_id\": \"AUTH-2024-\" + \"\".join(str(i) for i in range(6)),\n                \"status\": \"approved\",\n                \"approval_date\": \"2024-10-13\",\n                \"valid_through\": \"2024-12-31\"\n            }\n\n        if \"eligibility\" in request_lower:\n            return {\n                \"eligible\": True,\n                \"coverage_percentage\": 80,\n                \"deductible_remaining\": \"$250.00\",\n                \"verification_date\": \"2024-10-13\"\n            }\n\n        if \"patient\" in request_lower:\n            return {\n                \"patient_found\": True,\n                \"last_visit\": \"2024-09-15\",\n                \"active_conditions\": [\"Hypertension\", \"Type 2 Diabetes\"],\n                \"current_medications\": 3\n            }\n\n        # Default response\n        return {\n            \"status\": \"success\",\n            \"data\": {\"processed\": True, \"timestamp\": \"2024-10-13T10:30:00Z\"},\n            \"message\": \"Mock response generated successfully\"\n        }\n\n    def _normalize_user_tool_spec(self, spec: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Normalize user-provided tool specification to standard format.\"\"\"\n        normalized = {\n            \"type\": \"genesis:mcp_tool\",\n            \"tool_name\": spec.get(\"tool_name\", spec.get(\"name\", \"user_custom_tool\")),\n            \"description\": spec.get(\"description\", \"User-provided custom MCP tool\"),\n            \"source\": \"user_provided\"\n        }\n\n        # Copy other fields\n        for field in [\"input_schema\", \"mock_response\", \"category\", \"complexity\"]:\n            if field in spec:\n                normalized[field] = spec[field]\n\n        return normalized\n\n    def _generate_tool_spec_from_description(self, description: str) -> Dict[str, Any]:\n        \"\"\"Generate a tool spec from text description.\"\"\"\n        return {\n            \"tool_name\": self._extract_tool_name(description),\n            \"description\": description,\n            \"input_schema\": self._generate_input_schema(description),\n            \"mock_response\": self._generate_mock_response(description)\n        }\n\n    def _add_mock_fallback(self, config: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Add mock fallback configuration for development.\"\"\"\n        if config.get(\"success\") and \"tool_config\" in config:\n            tool_config = config[\"tool_config\"]\n\n            # Ensure mock response exists\n            if \"mock_response\" not in tool_config or not tool_config[\"mock_response\"]:\n                tool_config[\"mock_response\"] = self._generate_mock_response(\n                    tool_config.get(\"description\", \"\")\n                )\n\n            # Add fallback configuration\n            tool_config[\"fallback_config\"] = {\n                \"enable_mock_fallback\": True,\n                \"mock_timeout_ms\": 5000,\n                \"development_mode\": True,\n                \"mock_delay_ms\": 100  # Simulate network delay\n            }\n\n            config[\"mock_fallback_added\"] = True\n\n        return config\n\n    def _validate_tool_configuration(self, config: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Validate the generated tool configuration.\"\"\"\n        if not config.get(\"success\"):\n            return config\n\n        tool_config = config.get(\"tool_config\", {})\n        validation_errors = []\n\n        # Required fields validation\n        required_fields = [\"type\", \"tool_name\", \"description\"]\n        for field in required_fields:\n            if field not in tool_config:\n                validation_errors.append(f\"Missing required field: {field}\")\n\n        # Type validation\n        if tool_config.get(\"type\") != \"genesis:mcp_tool\":\n            validation_errors.append(\"Tool type must be 'genesis:mcp_tool'\")\n\n        # Tool name format validation\n        tool_name = tool_config.get(\"tool_name\", \"\")\n        if not tool_name.replace(\"_\", \"\").replace(\"-\", \"\").isalnum():\n            validation_errors.append(\"Tool name should contain only alphanumeric characters, underscores, and hyphens\")\n\n        # Schema validation\n        input_schema = tool_config.get(\"input_schema\", {})\n        if input_schema and not isinstance(input_schema, dict):\n            validation_errors.append(\"Input schema must be a dictionary\")\n\n        # Mock response validation\n        mock_response = tool_config.get(\"mock_response\", {})\n        if mock_response and not isinstance(mock_response, dict):\n            validation_errors.append(\"Mock response must be a dictionary\")\n\n        # Add validation results\n        config[\"validation\"] = {\n            \"valid\": len(validation_errors) == 0,\n            \"errors\": validation_errors,\n            \"warnings\": []\n        }\n\n        return config\n\n    def _format_framework_response(self, config: Dict[str, Any]) -> str:\n        \"\"\"Format a comprehensive response for the user.\"\"\"\n        if not config.get(\"success\"):\n            return f\"❌ **MCP Tool Configuration Failed**\\n\\nError: {config.get('error', 'Unknown error')}\"\n\n        tool_config = config.get(\"tool_config\", {})\n        source = config.get(\"source\", \"unknown\")\n\n        response = f\"🔧 **MCP Tool Configuration Generated**\\n\\n\"\n        response += f\"**Tool Name**: {tool_config.get('tool_name', 'Unknown')}\\n\"\n        response += f\"**Description**: {tool_config.get('description', 'No description')}\\n\"\n        response += f\"**Source**: {source.title()}\\n\"\n\n        # Add source-specific information\n        if source == \"catalog\":\n            response += f\"**Catalog Match**: {config.get('matched_tool', 'N/A')} (confidence: {config.get('match_score', 0):.1%})\\n\"\n        elif source == \"user\":\n            response += \"**User Specification**: Custom tool from user input\\n\"\n        elif source == \"mock\":\n            response += \"**Mock Generated**: Auto-generated mock tool\\n\"\n\n        if config.get(\"auto_selection_reason\"):\n            response += f\"**Auto Selection**: {config['auto_selection_reason']}\\n\"\n\n        response += \"\\n**Configuration**:\\n\"\n        response += f\"```yaml\\n\"\n        response += f\"type: {tool_config.get('type', 'genesis:mcp_tool')}\\n\"\n        response += f\"tool_name: {tool_config.get('tool_name')}\\n\"\n        response += f\"description: {tool_config.get('description')}\\n\"\n\n        if tool_config.get(\"input_schema\"):\n            response += f\"input_schema:\\n\"\n            for param, details in tool_config.get(\"input_schema\", {}).items():\n                response += f\"  {param}: {details.get('type', 'string')}\\n\"\n\n        response += \"```\\n\\n\"\n\n        # Mock fallback information\n        if config.get(\"mock_fallback_added\"):\n            response += \"✅ **Mock Fallback**: Development mode enabled with automatic fallback\\n\"\n\n        # Validation results\n        validation = config.get(\"validation\", {})\n        if validation:\n            if validation.get(\"valid\"):\n                response += \"✅ **Validation**: Configuration passed all validation checks\\n\"\n            else:\n                response += \"❌ **Validation Issues**:\\n\"\n                for error in validation.get(\"errors\", []):\n                    response += f\"• {error}\\n\"\n\n        response += \"\\n**Ready for use in agent specification** 🚀\"\n\n        return response\n\n    def _handle_discovery_mode(self) -> Data:\n        \"\"\"Handle discovery mode - browse available MCP tools like MCP_CATALOG.\"\"\"\n        try:\n            # Get all available tools from catalog\n            catalog_tools = self._get_catalog_tools()\n\n            # Filter by search query if provided\n            if self.tool_request and self.tool_request.strip():\n                filtered_tools = {}\n                query_lower = self.tool_request.lower()\n                for tool_id, tool_info in catalog_tools.items():\n                    if (query_lower in tool_info[\"name\"].lower() or\n                        query_lower in tool_info[\"description\"].lower() or\n                        any(query_lower in domain for domain in tool_info.get(\"domains\", []))):\n                        filtered_tools[tool_id] = tool_info\n                catalog_tools = filtered_tools\n\n            # Process tools into discovery format (similar to MCP_CATALOG)\n            processed_tools = self._process_tools_for_discovery(catalog_tools)\n\n            # Generate catalog-style response\n            catalog_info = {\n                \"total_tools\": len(processed_tools),\n                \"discovery_mode\": True,\n                \"tools\": processed_tools,\n                \"search_query\": self.tool_request or \"all\",\n                \"development_guidance\": {\n                    \"current_state\": \"All tools are production-ready with mock templates\",\n                    \"mock_mode\": \"Use mock templates for development and testing without actual MCP servers\",\n                    \"production_readiness\": \"Tools are ready for production with seamless MCP server integration\",\n                    \"testing_approach\": \"Specifications can be built and tested using mock responses\",\n                    \"migration_path\": \"Automatic fallback to live servers when available\"\n                },\n                \"healthcare_categories\": list(set(tool[\"category\"] for tool in processed_tools.values()))\n            }\n\n            return Data(data={\n                \"success\": True,\n                \"mode\": \"discovery\",\n                \"catalog\": catalog_info,\n                \"message\": f\"Found {len(processed_tools)} MCP tools\",\n                \"conversation_response\": self._format_discovery_response(catalog_info)\n            })\n\n        except Exception as e:\n            logger.error(f\"Error in discovery mode: {e}\")\n            return Data(data={\n                \"success\": False,\n                \"mode\": \"discovery\",\n                \"error\": str(e),\n                \"catalog\": {},\n                \"message\": \"Failed to load MCP tool catalog\"\n            })\n\n    def _process_tools_for_discovery(self, catalog_tools: Dict) -> Dict[str, Dict]:\n        \"\"\"Process catalog tools for discovery display.\"\"\"\n        processed_tools = {}\n\n        for tool_id, tool_data in catalog_tools.items():\n            # Enhance with categorization for discovery\n            category = self._categorize_discovery_tool(tool_id, tool_data)\n            complexity = self._assess_discovery_complexity(tool_data)\n            domains = self._extract_discovery_domains(tool_id, tool_data)\n\n            processed_tools[tool_id] = {\n                \"name\": tool_data.get(\"name\", tool_id.replace(\"_\", \" \").title()),\n                \"description\": tool_data.get(\"description\", \"Healthcare integration tool\"),\n                \"category\": category,\n                \"status\": \"production_ready\",\n                \"mock_available\": True,\n                \"healthcare_domains\": domains,\n                \"complexity\": complexity,\n                \"input_parameters\": len(tool_data.get(\"input_schema\", {})),\n                \"response_complexity\": self._count_nested_structures(tool_data.get(\"mock_response\", {}))\n            }\n\n        return processed_tools\n\n    def _categorize_discovery_tool(self, tool_id: str, template: Dict) -> str:\n        \"\"\"Categorize tool for discovery display.\"\"\"\n        tool_lower = tool_id.lower()\n        desc_lower = template.get(\"description\", \"\").lower()\n\n        if any(keyword in tool_lower for keyword in [\"ehr\", \"patient\", \"medical\", \"clinical\"]):\n            return \"Healthcare Integration\"\n        elif any(keyword in tool_lower for keyword in [\"pharmacy\", \"drug\", \"medication\"]):\n            return \"Pharmacy\"\n        elif any(keyword in tool_lower for keyword in [\"insurance\", \"eligibility\", \"member\"]):\n            return \"Insurance\"\n        elif any(keyword in tool_lower for keyword in [\"survey\", \"call\", \"feedback\"]):\n            return \"Patient Experience\"\n        elif any(keyword in tool_lower for keyword in [\"symptom\", \"nlp\", \"sentiment\"]):\n            return \"Clinical Analytics\"\n        elif \"claims\" in tool_lower:\n            return \"Claims Processing\"\n        else:\n            return \"Healthcare Tools\"\n\n    def _extract_discovery_domains(self, tool_id: str, template: Dict) -> List[str]:\n        \"\"\"Extract healthcare domains for discovery.\"\"\"\n        domains = []\n        tool_lower = tool_id.lower()\n        desc_lower = template.get(\"description\", \"\").lower()\n\n        domain_keywords = {\n            \"patient_records\": [\"patient\", \"ehr\", \"medical\", \"records\"],\n            \"clinical_data\": [\"clinical\", \"diagnosis\", \"treatment\"],\n            \"pharmacy\": [\"pharmacy\", \"drug\", \"medication\", \"prescription\"],\n            \"insurance\": [\"insurance\", \"eligibility\", \"benefits\", \"coverage\"],\n            \"prior_authorization\": [\"authorization\", \"prior\", \"auth\"],\n            \"billing\": [\"billing\", \"claims\", \"payment\"],\n            \"compliance\": [\"compliance\", \"hipaa\", \"audit\"],\n            \"patient_experience\": [\"survey\", \"feedback\", \"call\", \"experience\"],\n            \"analytics\": [\"sentiment\", \"nlp\", \"analysis\", \"metrics\"],\n            \"clinical_review\": [\"review\", \"assessment\", \"evaluation\"],\n            \"fhir\": [\"fhir\", \"hl7\", \"interoperability\"]\n        }\n\n        for domain, keywords in domain_keywords.items():\n            if any(keyword in tool_lower or keyword in desc_lower for keyword in keywords):\n                domains.append(domain)\n\n        return domains if domains else [\"healthcare_general\"]\n\n    def _assess_discovery_complexity(self, template: Dict) -> str:\n        \"\"\"Assess tool complexity for discovery.\"\"\"\n        input_schema = template.get(\"input_schema\", {})\n        mock_response = template.get(\"mock_response\", {})\n\n        param_count = len(input_schema)\n        response_complexity = self._count_nested_structures(mock_response)\n\n        if param_count >= 5 or response_complexity >= 3:\n            return \"high\"\n        elif param_count >= 3 or response_complexity >= 2:\n            return \"medium\"\n        else:\n            return \"low\"\n\n    def _format_discovery_response(self, catalog: Dict[str, Any]) -> str:\n        \"\"\"Format discovery mode response like MCP_CATALOG.\"\"\"\n        tools = catalog.get(\"tools\", {})\n        total = catalog.get(\"total_tools\", 0)\n\n        if total == 0:\n            search_query = catalog.get(\"search_query\", \"\")\n            if search_query and search_query != \"all\":\n                return f\"No MCP tools found matching '{search_query}'. Try a different search term or browse all tools.\"\n            return \"No MCP tools found in catalog.\"\n\n        response = f\"🔧 **MCP Healthcare Tools Discovery** ({total} tools available)\\n\\n\"\n        response += \"**Status**: All tools available with production-ready mock templates\\n\\n\"\n\n        # Group by categories\n        categories = {}\n        for tool_id, tool_info in tools.items():\n            category = tool_info.get(\"category\", \"Other\")\n            if category not in categories:\n                categories[category] = []\n            categories[category].append((tool_id, tool_info))\n\n        for category, category_tools in categories.items():\n            response += f\"### {category}\\n\"\n            for tool_id, tool_info in category_tools:\n                response += f\"**{tool_info['name']}** (`{tool_id}`)\\n\"\n                response += f\"- {tool_info['description']}\\n\"\n                response += f\"- Complexity: {tool_info.get('complexity', 'medium')} | \"\n                response += f\"Parameters: {tool_info.get('input_parameters', 0)} | \"\n                response += f\"Domains: {', '.join(tool_info.get('healthcare_domains', [])[:2])}\\n\\n\"\n\n        response += \"**💡 To configure a specific tool**:\\n\"\n        response += \"Use MCP_FRAMEWORK in configuration mode with the tool name or description.\\n\\n\"\n\n        response += \"**🚀 Development Ready**: All tools include comprehensive mock templates for testing without MCP servers.\"\n\n        return response\n"
              },
              "discovery_mode": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Discovery Mode",
                "dynamic": false,
                "info": "Browse available tools instead of configuring specific tool",
                "list": false,
                "list_add_label": "Add More",
                "name": "discovery_mode",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "include_mock_fallback": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Include Mock Fallback",
                "dynamic": false,
                "info": "Whether to provide mock fallback for development",
                "list": false,
                "list_add_label": "Add More",
                "name": "include_mock_fallback",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "tool_request": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Tool Request",
                "dynamic": false,
                "info": "Describe the MCP tool you need or provide JSON specification",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_request",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "tool_source": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Tool Source",
                "dynamic": false,
                "info": "Source preference: 'user', 'catalog', 'mock', or 'auto' to decide automatically",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_source",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "auto"
              },
              "tools_metadata": {
                "_input_type": "ToolsInput",
                "advanced": false,
                "display_name": "Actions",
                "dynamic": false,
                "info": "Modify tool names and descriptions to help agents understand when to use each tool.",
                "is_list": true,
                "list_add_label": "Add More",
                "name": "tools_metadata",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tools",
                "value": [
                  {
                    "args": {
                      "discovery_mode": {
                        "default": false,
                        "description": "Browse available tools instead of configuring specific tool",
                        "title": "Discovery Mode",
                        "type": "boolean"
                      },
                      "include_mock_fallback": {
                        "default": true,
                        "description": "Whether to provide mock fallback for development",
                        "title": "Include Mock Fallback",
                        "type": "boolean"
                      },
                      "tool_request": {
                        "description": "Describe the MCP tool you need or provide JSON specification",
                        "title": "Tool Request",
                        "type": "string"
                      },
                      "tool_source": {
                        "default": "auto",
                        "description": "Source preference: 'user', 'catalog', 'mock', or 'auto' to decide automatically",
                        "title": "Tool Source",
                        "type": "string"
                      },
                      "user_tool_spec": {
                        "default": "",
                        "description": "Optional: JSON specification for custom user-provided MCP tool",
                        "title": "User Tool Spec",
                        "type": "string"
                      },
                      "validate_tool_spec": {
                        "default": true,
                        "description": "Whether to validate the generated tool specification",
                        "title": "Validate Tool Spec",
                        "type": "boolean"
                      }
                    },
                    "description": "Unified framework for selecting and configuring MCP tools from user specs, catalog, or mock templates",
                    "display_description": "Unified framework for selecting and configuring MCP tools from user specs, catalog, or mock templates",
                    "display_name": "generate_mcp_config",
                    "name": "mcp_framework",
                    "readonly": false,
                    "status": true,
                    "tags": [
                      "generate_mcp_config"
                    ]
                  }
                ]
              },
              "user_tool_spec": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "User Tool Specification",
                "dynamic": false,
                "info": "Optional: JSON specification for custom user-provided MCP tool",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "user_tool_spec",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "validate_tool_spec": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Validate Tool Spec",
                "dynamic": false,
                "info": "Whether to validate the generated tool specification",
                "list": false,
                "list_add_label": "Add More",
                "name": "validate_tool_spec",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": true
          },
          "showNode": true,
          "type": "MCPFramework"
        },
        "dragging": false,
        "id": "MCPFramework-r9Y5c",
        "measured": {
          "height": 234,
          "width": 320
        },
        "position": {
          "x": 1217.402811885661,
          "y": 1499.0031265498612
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Agent-aQjuh",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Define the agent's instructions, then enter a task to complete using tools.",
            "display_name": "PROMPT GENERATOR",
            "documentation": "https://docs.langflow.org/agents",
            "edited": false,
            "field_order": [
              "agent_llm",
              "max_tokens",
              "model_kwargs",
              "model_name",
              "openai_api_base",
              "api_key",
              "temperature",
              "seed",
              "max_retries",
              "timeout",
              "system_prompt",
              "n_messages",
              "format_instructions",
              "output_schema",
              "tools",
              "input_value",
              "handle_parsing_errors",
              "verbose",
              "max_iterations",
              "agent_description",
              "add_current_date_tool"
            ],
            "frozen": false,
            "icon": "bot",
            "last_updated": "2025-10-14T18:20:26.232Z",
            "legacy": false,
            "lf_version": "1.6.3",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Toolset",
                "group_outputs": false,
                "hidden": null,
                "method": "to_toolkit",
                "name": "component_as_tool",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "add_current_date_tool": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Current Date",
                "dynamic": false,
                "info": "If true, will add a tool to the agent that returns the current date.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "add_current_date_tool",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "agent_description": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Agent Description [Deprecated]",
                "dynamic": false,
                "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "agent_description",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "A helpful assistant with access to the following tools:"
              },
              "agent_llm": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Model Provider",
                "dynamic": false,
                "external_options": {
                  "fields": {
                    "data": {
                      "node": {
                        "display_name": "Connect other models",
                        "icon": "CornerDownLeft",
                        "name": "connect_other_models"
                      }
                    }
                  }
                },
                "info": "The provider of the language model that the agent will use to generate responses.",
                "input_types": [],
                "name": "agent_llm",
                "options": [
                  "Anthropic",
                  "Google Generative AI",
                  "OpenAI",
                  "Azure OpenAI"
                ],
                "options_metadata": [
                  {
                    "icon": "Anthropic"
                  },
                  {
                    "icon": "GoogleGenerativeAI"
                  },
                  {
                    "icon": "OpenAI"
                  },
                  {
                    "icon": "Azure"
                  },
                  {
                    "icon": "brain"
                  }
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "refresh_button": false,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Azure OpenAI"
              },
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Azure Chat OpenAI API Key",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": false,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "api_version": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "API Version",
                "dynamic": false,
                "external_options": {},
                "info": "",
                "input_types": [],
                "name": "api_version",
                "options": [
                  "2025-02-01-preview",
                  "2025-01-01-preview",
                  "2024-12-01-preview",
                  "2024-10-01-preview",
                  "2024-09-01-preview",
                  "2024-08-01-preview",
                  "2024-07-01-preview",
                  "2024-06-01",
                  "2024-03-01-preview",
                  "2024-02-15-preview",
                  "2023-12-01-preview",
                  "2023-05-15"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "2024-06-01"
              },
              "azure_deployment": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Deployment Name",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "azure_deployment",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "gpt-4o"
              },
              "azure_endpoint": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Azure Endpoint",
                "dynamic": false,
                "info": "Your Azure endpoint, including the resource. Example: `https://example-resource.azure.openai.com/`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "azure_endpoint",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "https://openai-v2-lab.openai.azure.com/"
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nimport re\n\nfrom langchain_core.tools import StructuredTool\nfrom pydantic import ValidationError\n\nfrom langflow.base.agents.agent import LCToolsAgentComponent\nfrom langflow.base.agents.events import ExceptionWithMessageError\nfrom langflow.base.models.model_input_constants import (\n    ALL_PROVIDER_FIELDS,\n    MODEL_DYNAMIC_UPDATE_FIELDS,\n    MODEL_PROVIDERS_DICT,\n    MODELS_METADATA,\n)\nfrom langflow.base.models.model_utils import get_model_name\nfrom langflow.components.helpers.current_date import CurrentDateComponent\nfrom langflow.components.helpers.memory import MemoryComponent\nfrom langflow.components.langchain_utilities.tool_calling import (\n    ToolCallingAgentComponent,\n)\nfrom langflow.custom.custom_component.component import _get_component_toolkit\nfrom langflow.custom.utils import update_component_build_config\nfrom langflow.field_typing import Tool\nfrom langflow.helpers.base_model import build_model_from_schema\nfrom langflow.io import (\n    BoolInput,\n    DropdownInput,\n    IntInput,\n    MultilineInput,\n    Output,\n    TableInput,\n)\nfrom langflow.logging import logger\nfrom langflow.schema.data import Data\nfrom langflow.schema.dotdict import dotdict\nfrom langflow.schema.message import Message\nfrom langflow.schema.table import EditMode\n\n\ndef set_advanced_true(component_input):\n    component_input.advanced = True\n    return component_input\n\n\nMODEL_PROVIDERS_LIST = [\"Anthropic\", \"Google Generative AI\", \"OpenAI\", \"Azure OpenAI\"]\n\n\nclass AgentComponent(ToolCallingAgentComponent):\n    display_name: str = \"Agent\"\n    description: str = \"Define the agent's instructions, then enter a task to complete using tools.\"\n    documentation: str = \"https://docs.langflow.org/agents\"\n    icon = \"bot\"\n    beta = False\n    name = \"Agent\"\n\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\n\n    # Filter out json_mode from OpenAI inputs since we handle structured output differently\n    if \"OpenAI\" in MODEL_PROVIDERS_DICT:\n        openai_inputs_filtered = [\n            input_field\n            for input_field in MODEL_PROVIDERS_DICT[\"OpenAI\"][\"inputs\"]\n            if not (hasattr(input_field, \"name\") and input_field.name == \"json_mode\")\n        ]\n    else:\n        openai_inputs_filtered = []\n\n    inputs = [\n        DropdownInput(\n            name=\"agent_llm\",\n            display_name=\"Model Provider\",\n            info=\"The provider of the language model that the agent will use to generate responses.\",\n            options=[*MODEL_PROVIDERS_LIST],\n            value=\"OpenAI\",\n            real_time_refresh=True,\n            refresh_button=False,\n            input_types=[],\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST if key in MODELS_METADATA]\n            + [{\"icon\": \"brain\"}],\n            external_options={\n                \"fields\": {\n                    \"data\": {\n                        \"node\": {\n                            \"name\": \"connect_other_models\",\n                            \"display_name\": \"Connect other models\",\n                            \"icon\": \"CornerDownLeft\",\n                        }\n                    }\n                },\n            },\n        ),\n        *openai_inputs_filtered,\n        MultilineInput(\n            name=\"system_prompt\",\n            display_name=\"Agent Instructions\",\n            info=\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\",\n            value=\"You are a helpful assistant that can use tools to answer questions and perform tasks.\",\n            advanced=False,\n        ),\n        IntInput(\n            name=\"n_messages\",\n            display_name=\"Number of Chat History Messages\",\n            value=100,\n            info=\"Number of chat history messages to retrieve.\",\n            advanced=True,\n            show=True,\n        ),\n        MultilineInput(\n            name=\"format_instructions\",\n            display_name=\"Output Format Instructions\",\n            info=\"Generic Template for structured output formatting. Valid only with Structured response.\",\n            value=(\n                \"You are an AI that extracts structured JSON objects from unstructured text. \"\n                \"Use a predefined schema with expected types (str, int, float, bool, dict). \"\n                \"Extract ALL relevant instances that match the schema - if multiple patterns exist, capture them all. \"\n                \"Fill missing or ambiguous values with defaults: null for missing values. \"\n                \"Remove exact duplicates but keep variations that have different field values. \"\n                \"Always return valid JSON in the expected format, never throw errors. \"\n                \"If multiple objects can be extracted, return them all in the structured format.\"\n            ),\n            advanced=True,\n        ),\n        TableInput(\n            name=\"output_schema\",\n            display_name=\"Output Schema\",\n            info=(\n                \"Schema Validation: Define the structure and data types for structured output. \"\n                \"No validation if no output schema.\"\n            ),\n            advanced=True,\n            required=False,\n            value=[],\n            table_schema=[\n                {\n                    \"name\": \"name\",\n                    \"display_name\": \"Name\",\n                    \"type\": \"str\",\n                    \"description\": \"Specify the name of the output field.\",\n                    \"default\": \"field\",\n                    \"edit_mode\": EditMode.INLINE,\n                },\n                {\n                    \"name\": \"description\",\n                    \"display_name\": \"Description\",\n                    \"type\": \"str\",\n                    \"description\": \"Describe the purpose of the output field.\",\n                    \"default\": \"description of field\",\n                    \"edit_mode\": EditMode.POPOVER,\n                },\n                {\n                    \"name\": \"type\",\n                    \"display_name\": \"Type\",\n                    \"type\": \"str\",\n                    \"edit_mode\": EditMode.INLINE,\n                    \"description\": (\"Indicate the data type of the output field (e.g., str, int, float, bool, dict).\"),\n                    \"options\": [\"str\", \"int\", \"float\", \"bool\", \"dict\"],\n                    \"default\": \"str\",\n                },\n                {\n                    \"name\": \"multiple\",\n                    \"display_name\": \"As List\",\n                    \"type\": \"boolean\",\n                    \"description\": \"Set to True if this output field should be a list of the specified type.\",\n                    \"default\": \"False\",\n                    \"edit_mode\": EditMode.INLINE,\n                },\n            ],\n        ),\n        *LCToolsAgentComponent._base_inputs,\n        # removed memory inputs from agent component\n        # *memory_inputs,\n        BoolInput(\n            name=\"add_current_date_tool\",\n            display_name=\"Current Date\",\n            advanced=True,\n            info=\"If true, will add a tool to the agent that returns the current date.\",\n            value=True,\n        ),\n    ]\n    outputs = [\n        Output(name=\"response\", display_name=\"Response\", method=\"message_response\"),\n    ]\n\n    async def get_agent_requirements(self):\n        \"\"\"Get the agent requirements for the agent.\"\"\"\n        llm_model, display_name = await self.get_llm()\n        if llm_model is None:\n            msg = \"No language model selected. Please choose a model to proceed.\"\n            raise ValueError(msg)\n        self.model_name = get_model_name(llm_model, display_name=display_name)\n\n        # Get memory data\n        self.chat_history = await self.get_memory_data()\n        if isinstance(self.chat_history, Message):\n            self.chat_history = [self.chat_history]\n\n        # Add current date tool if enabled\n        if self.add_current_date_tool:\n            if not isinstance(self.tools, list):  # type: ignore[has-type]\n                self.tools = []\n            current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\n            if not isinstance(current_date_tool, StructuredTool):\n                msg = \"CurrentDateComponent must be converted to a StructuredTool\"\n                raise TypeError(msg)\n            self.tools.append(current_date_tool)\n        return llm_model, self.chat_history, self.tools\n\n    async def message_response(self) -> Message:\n        try:\n            llm_model, self.chat_history, self.tools = await self.get_agent_requirements()\n            # Set up and run agent\n            self.set(\n                llm=llm_model,\n                tools=self.tools or [],\n                chat_history=self.chat_history,\n                input_value=self.input_value,\n                system_prompt=self.system_prompt,\n            )\n            agent = self.create_agent_runnable()\n            result = await self.run_agent(agent)\n\n            # Store result for potential JSON output\n            self._agent_result = result\n\n        except (ValueError, TypeError, KeyError) as e:\n            await logger.aerror(f\"{type(e).__name__}: {e!s}\")\n            raise\n        except ExceptionWithMessageError as e:\n            await logger.aerror(f\"ExceptionWithMessageError occurred: {e}\")\n            raise\n        # Avoid catching blind Exception; let truly unexpected exceptions propagate\n        except Exception as e:\n            await logger.aerror(f\"Unexpected error: {e!s}\")\n            raise\n        else:\n            return result\n\n    def _preprocess_schema(self, schema):\n        \"\"\"Preprocess schema to ensure correct data types for build_model_from_schema.\"\"\"\n        processed_schema = []\n        for field in schema:\n            processed_field = {\n                \"name\": str(field.get(\"name\", \"field\")),\n                \"type\": str(field.get(\"type\", \"str\")),\n                \"description\": str(field.get(\"description\", \"\")),\n                \"multiple\": field.get(\"multiple\", False),\n            }\n            # Ensure multiple is handled correctly\n            if isinstance(processed_field[\"multiple\"], str):\n                processed_field[\"multiple\"] = processed_field[\"multiple\"].lower() in [\n                    \"true\",\n                    \"1\",\n                    \"t\",\n                    \"y\",\n                    \"yes\",\n                ]\n            processed_schema.append(processed_field)\n        return processed_schema\n\n    async def build_structured_output_base(self, content: str):\n        \"\"\"Build structured output with optional BaseModel validation.\"\"\"\n        json_pattern = r\"\\{.*\\}\"\n        schema_error_msg = \"Try setting an output schema\"\n\n        # Try to parse content as JSON first\n        json_data = None\n        try:\n            json_data = json.loads(content)\n        except json.JSONDecodeError:\n            json_match = re.search(json_pattern, content, re.DOTALL)\n            if json_match:\n                try:\n                    json_data = json.loads(json_match.group())\n                except json.JSONDecodeError:\n                    return {\"content\": content, \"error\": schema_error_msg}\n            else:\n                return {\"content\": content, \"error\": schema_error_msg}\n\n        # If no output schema provided, return parsed JSON without validation\n        if not hasattr(self, \"output_schema\") or not self.output_schema or len(self.output_schema) == 0:\n            return json_data\n\n        # Use BaseModel validation with schema\n        try:\n            processed_schema = self._preprocess_schema(self.output_schema)\n            output_model = build_model_from_schema(processed_schema)\n\n            # Validate against the schema\n            if isinstance(json_data, list):\n                # Multiple objects\n                validated_objects = []\n                for item in json_data:\n                    try:\n                        validated_obj = output_model.model_validate(item)\n                        validated_objects.append(validated_obj.model_dump())\n                    except ValidationError as e:\n                        await logger.aerror(f\"Validation error for item: {e}\")\n                        # Include invalid items with error info\n                        validated_objects.append({\"data\": item, \"validation_error\": str(e)})\n                return validated_objects\n\n            # Single object\n            try:\n                validated_obj = output_model.model_validate(json_data)\n                return [validated_obj.model_dump()]  # Return as list for consistency\n            except ValidationError as e:\n                await logger.aerror(f\"Validation error: {e}\")\n                return [{\"data\": json_data, \"validation_error\": str(e)}]\n\n        except (TypeError, ValueError) as e:\n            await logger.aerror(f\"Error building structured output: {e}\")\n            # Fallback to parsed JSON without validation\n            return json_data\n\n    async def json_response(self) -> Data:\n        \"\"\"Convert agent response to structured JSON Data output with schema validation.\"\"\"\n        # Always use structured chat agent for JSON response mode for better JSON formatting\n        try:\n            system_components = []\n\n            # 1. Agent Instructions (system_prompt)\n            agent_instructions = getattr(self, \"system_prompt\", \"\") or \"\"\n            if agent_instructions:\n                system_components.append(f\"{agent_instructions}\")\n\n            # 2. Format Instructions\n            format_instructions = getattr(self, \"format_instructions\", \"\") or \"\"\n            if format_instructions:\n                system_components.append(f\"Format instructions: {format_instructions}\")\n\n            # 3. Schema Information from BaseModel\n            if hasattr(self, \"output_schema\") and self.output_schema and len(self.output_schema) > 0:\n                try:\n                    processed_schema = self._preprocess_schema(self.output_schema)\n                    output_model = build_model_from_schema(processed_schema)\n                    schema_dict = output_model.model_json_schema()\n                    schema_info = (\n                        \"You are given some text that may include format instructions, \"\n                        \"explanations, or other content alongside a JSON schema.\\n\\n\"\n                        \"Your task:\\n\"\n                        \"- Extract only the JSON schema.\\n\"\n                        \"- Return it as valid JSON.\\n\"\n                        \"- Do not include format instructions, explanations, or extra text.\\n\\n\"\n                        \"Input:\\n\"\n                        f\"{json.dumps(schema_dict, indent=2)}\\n\\n\"\n                        \"Output (only JSON schema):\"\n                    )\n                    system_components.append(schema_info)\n                except (ValidationError, ValueError, TypeError, KeyError) as e:\n                    await logger.aerror(f\"Could not build schema for prompt: {e}\", exc_info=True)\n\n            # Combine all components\n            combined_instructions = \"\\n\\n\".join(system_components) if system_components else \"\"\n            llm_model, self.chat_history, self.tools = await self.get_agent_requirements()\n            self.set(\n                llm=llm_model,\n                tools=self.tools or [],\n                chat_history=self.chat_history,\n                input_value=self.input_value,\n                system_prompt=combined_instructions,\n            )\n\n            # Create and run structured chat agent\n            try:\n                structured_agent = self.create_agent_runnable()\n            except (NotImplementedError, ValueError, TypeError) as e:\n                await logger.aerror(f\"Error with structured chat agent: {e}\")\n                raise\n            try:\n                result = await self.run_agent(structured_agent)\n            except (\n                ExceptionWithMessageError,\n                ValueError,\n                TypeError,\n                RuntimeError,\n            ) as e:\n                await logger.aerror(f\"Error with structured agent result: {e}\")\n                raise\n            # Extract content from structured agent result\n            if hasattr(result, \"content\"):\n                content = result.content\n            elif hasattr(result, \"text\"):\n                content = result.text\n            else:\n                content = str(result)\n\n        except (\n            ExceptionWithMessageError,\n            ValueError,\n            TypeError,\n            NotImplementedError,\n            AttributeError,\n        ) as e:\n            await logger.aerror(f\"Error with structured chat agent: {e}\")\n            # Fallback to regular agent\n            content_str = \"No content returned from agent\"\n            return Data(data={\"content\": content_str, \"error\": str(e)})\n\n        # Process with structured output validation\n        try:\n            structured_output = await self.build_structured_output_base(content)\n\n            # Handle different output formats\n            if isinstance(structured_output, list) and structured_output:\n                if len(structured_output) == 1:\n                    return Data(data=structured_output[0])\n                return Data(data={\"results\": structured_output})\n            if isinstance(structured_output, dict):\n                return Data(data=structured_output)\n            return Data(data={\"content\": content})\n\n        except (ValueError, TypeError) as e:\n            await logger.aerror(f\"Error in structured output processing: {e}\")\n            return Data(data={\"content\": content, \"error\": str(e)})\n\n    async def get_memory_data(self):\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\n        messages = (\n            await MemoryComponent(**self.get_base_args())\n            .set(\n                session_id=self.graph.session_id,\n                order=\"Ascending\",\n                n_messages=self.n_messages,\n            )\n            .retrieve_messages()\n        )\n        return [\n            message for message in messages if getattr(message, \"id\", None) != getattr(self.input_value, \"id\", None)\n        ]\n\n    async def get_llm(self):\n        if not isinstance(self.agent_llm, str):\n            return self.agent_llm, None\n\n        try:\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n            if not provider_info:\n                msg = f\"Invalid model provider: {self.agent_llm}\"\n                raise ValueError(msg)\n\n            component_class = provider_info.get(\"component_class\")\n            display_name = component_class.display_name\n            inputs = provider_info.get(\"inputs\")\n            prefix = provider_info.get(\"prefix\", \"\")\n\n            return self._build_llm_model(component_class, inputs, prefix), display_name\n\n        except (AttributeError, ValueError, TypeError, RuntimeError) as e:\n            await logger.aerror(f\"Error building {self.agent_llm} language model: {e!s}\")\n            msg = f\"Failed to initialize language model: {e!s}\"\n            raise ValueError(msg) from e\n\n    def _build_llm_model(self, component, inputs, prefix=\"\"):\n        model_kwargs = {}\n        for input_ in inputs:\n            if hasattr(self, f\"{prefix}{input_.name}\"):\n                model_kwargs[input_.name] = getattr(self, f\"{prefix}{input_.name}\")\n        return component.set(**model_kwargs).build_model()\n\n    def set_component_params(self, component):\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n        if provider_info:\n            inputs = provider_info.get(\"inputs\")\n            prefix = provider_info.get(\"prefix\")\n            # Filter out json_mode and only use attributes that exist on this component\n            model_kwargs = {}\n            for input_ in inputs:\n                if hasattr(self, f\"{prefix}{input_.name}\"):\n                    model_kwargs[input_.name] = getattr(self, f\"{prefix}{input_.name}\")\n\n            return component.set(**model_kwargs)\n        return component\n\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\n        \"\"\"Delete specified fields from build_config.\"\"\"\n        for field in fields:\n            build_config.pop(field, None)\n\n    def update_input_types(self, build_config: dotdict) -> dotdict:\n        \"\"\"Update input types for all fields in build_config.\"\"\"\n        for key, value in build_config.items():\n            if isinstance(value, dict):\n                if value.get(\"input_types\") is None:\n                    build_config[key][\"input_types\"] = []\n            elif hasattr(value, \"input_types\") and value.input_types is None:\n                value.input_types = []\n        return build_config\n\n    async def update_build_config(\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\n    ) -> dotdict:\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\n        # Existing logic for updating build_config\n        if field_name in (\"agent_llm\",):\n            build_config[\"agent_llm\"][\"value\"] = field_value\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\n            if provider_info:\n                component_class = provider_info.get(\"component_class\")\n                if component_class and hasattr(component_class, \"update_build_config\"):\n                    # Call the component class's update_build_config method\n                    build_config = await update_component_build_config(\n                        component_class, build_config, field_value, \"model_name\"\n                    )\n\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\n                provider: (\n                    MODEL_PROVIDERS_DICT[provider][\"fields\"],\n                    [\n                        MODEL_PROVIDERS_DICT[other_provider][\"fields\"]\n                        for other_provider in MODEL_PROVIDERS_DICT\n                        if other_provider != provider\n                    ],\n                )\n                for provider in MODEL_PROVIDERS_DICT\n            }\n            if field_value in provider_configs:\n                fields_to_add, fields_to_delete = provider_configs[field_value]\n\n                # Delete fields from other providers\n                for fields in fields_to_delete:\n                    self.delete_fields(build_config, fields)\n\n                # Add provider-specific fields\n                build_config.update(fields_to_add)\n                # Reset input types for agent_llm\n                build_config[\"agent_llm\"][\"input_types\"] = []\n                build_config[\"agent_llm\"][\"display_name\"] = \"Model Provider\"\n            elif field_value == \"connect_other_models\":\n                # Delete all provider fields\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\n                # # Update with custom component\n                custom_component = DropdownInput(\n                    name=\"agent_llm\",\n                    display_name=\"Language Model\",\n                    info=\"The provider of the language model that the agent will use to generate responses.\",\n                    options=[*MODEL_PROVIDERS_LIST],\n                    real_time_refresh=True,\n                    refresh_button=False,\n                    input_types=[\"LanguageModel\"],\n                    placeholder=\"Awaiting model input.\",\n                    options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST if key in MODELS_METADATA],\n                    external_options={\n                        \"fields\": {\n                            \"data\": {\n                                \"node\": {\n                                    \"name\": \"connect_other_models\",\n                                    \"display_name\": \"Connect other models\",\n                                    \"icon\": \"CornerDownLeft\",\n                                },\n                            }\n                        },\n                    },\n                )\n                build_config.update({\"agent_llm\": custom_component.to_dict()})\n            # Update input types for all fields\n            build_config = self.update_input_types(build_config)\n\n            # Validate required keys\n            default_keys = [\n                \"code\",\n                \"_type\",\n                \"agent_llm\",\n                \"tools\",\n                \"input_value\",\n                \"add_current_date_tool\",\n                \"system_prompt\",\n                \"agent_description\",\n                \"max_iterations\",\n                \"handle_parsing_errors\",\n                \"verbose\",\n            ]\n            missing_keys = [key for key in default_keys if key not in build_config]\n            if missing_keys:\n                msg = f\"Missing required keys in build_config: {missing_keys}\"\n                raise ValueError(msg)\n        if (\n            isinstance(self.agent_llm, str)\n            and self.agent_llm in MODEL_PROVIDERS_DICT\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\n        ):\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n            if provider_info:\n                component_class = provider_info.get(\"component_class\")\n                component_class = self.set_component_params(component_class)\n                prefix = provider_info.get(\"prefix\")\n                if component_class and hasattr(component_class, \"update_build_config\"):\n                    # Call each component class's update_build_config method\n                    # remove the prefix from the field_name\n                    if isinstance(field_name, str) and isinstance(prefix, str):\n                        field_name = field_name.replace(prefix, \"\")\n                    build_config = await update_component_build_config(\n                        component_class, build_config, field_value, \"model_name\"\n                    )\n        return dotdict({k: v.to_dict() if hasattr(v, \"to_dict\") else v for k, v in build_config.items()})\n\n    async def _get_tools(self) -> list[Tool]:\n        component_toolkit = _get_component_toolkit()\n        tools_names = self._build_tools_names()\n        agent_description = self.get_tool_description()\n        # TODO: Agent Description Depreciated Feature to be removed\n        description = f\"{agent_description}{tools_names}\"\n        tools = component_toolkit(component=self).get_tools(\n            tool_name=\"Call_Agent\",\n            tool_description=description,\n            callbacks=self.get_langchain_callbacks(),\n        )\n        if hasattr(self, \"tools_metadata\"):\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\n        return tools\n"
              },
              "format_instructions": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Output Format Instructions",
                "dynamic": false,
                "info": "Generic Template for structured output formatting. Valid only with Structured response.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "format_instructions",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "You are an AI that extracts structured JSON objects from unstructured text. Use a predefined schema with expected types (str, int, float, bool, dict). Extract ALL relevant instances that match the schema - if multiple patterns exist, capture them all. Fill missing or ambiguous values with defaults: null for missing values. Remove exact duplicates but keep variations that have different field values. Always return valid JSON in the expected format, never throw errors. If multiple objects can be extracted, return them all in the structured format."
              },
              "handle_parsing_errors": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Handle Parse Errors",
                "dynamic": false,
                "info": "Should the Agent fix errors when reading user input for better processing?",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "handle_parsing_errors",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "The input provided by the user for the agent to process.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "max_iterations": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Iterations",
                "dynamic": false,
                "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "max_iterations",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 15
              },
              "max_tokens": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Tokens",
                "dynamic": false,
                "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "max_tokens",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "n_messages": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Chat History Messages",
                "dynamic": false,
                "info": "Number of chat history messages to retrieve.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "n_messages",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 100
              },
              "output_schema": {
                "_input_type": "TableInput",
                "advanced": true,
                "display_name": "Output Schema",
                "dynamic": false,
                "info": "Schema Validation: Define the structure and data types for structured output. No validation if no output schema.",
                "input_types": [],
                "is_list": true,
                "list_add_label": "Add More",
                "name": "output_schema",
                "placeholder": "",
                "required": false,
                "show": true,
                "table_icon": "Table",
                "table_schema": {
                  "columns": [
                    {
                      "default": "field",
                      "description": "Specify the name of the output field.",
                      "disable_edit": false,
                      "display_name": "Name",
                      "edit_mode": "inline",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "name",
                      "sortable": true,
                      "type": "str"
                    },
                    {
                      "default": "description of field",
                      "description": "Describe the purpose of the output field.",
                      "disable_edit": false,
                      "display_name": "Description",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "description",
                      "sortable": true,
                      "type": "str"
                    },
                    {
                      "default": "str",
                      "description": "Indicate the data type of the output field (e.g., str, int, float, bool, dict).",
                      "disable_edit": false,
                      "display_name": "Type",
                      "edit_mode": "inline",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "type",
                      "options": [
                        "str",
                        "int",
                        "float",
                        "bool",
                        "dict"
                      ],
                      "sortable": true,
                      "type": "str"
                    },
                    {
                      "default": false,
                      "description": "Set to True if this output field should be a list of the specified type.",
                      "disable_edit": false,
                      "display_name": "As List",
                      "edit_mode": "inline",
                      "filterable": true,
                      "formatter": "boolean",
                      "hidden": false,
                      "name": "multiple",
                      "sortable": true,
                      "type": "boolean"
                    }
                  ]
                },
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "trigger_icon": "Table",
                "trigger_text": "Open table",
                "type": "table",
                "value": []
              },
              "system_prompt": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Agent Instructions",
                "dynamic": false,
                "info": "System Prompt: Initial instructions and context provided to guide the agent's behavior.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_prompt",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "<role>\nYou are an Intelligent Prompt Generator Agent specialized in creating custom prompts for healthcare AI agents. Your expertise includes healthcare domains, medical terminology, compliance requirements, and professional prompt engineering for clinical workflows.\n</role>\n\n<objective>\nGenerate comprehensive, tailored prompts for healthcare AI agents based on their specific goals, descriptions, and domain requirements. Each generated prompt should provide clear guidance, professional standards, and healthcare-specific context to ensure consistent, compliant, and effective agent performance.\n</objective>\n\n<instructions>\n\n## Input Analysis\nYou will receive:\n- **Agent Goal**: The primary objective of the agent\n- **Agent Description**: Detailed description of agent functionality\n- **Agent Name**: The name of the agent\n- **Healthcare Domain**: The specific healthcare area (clinical-documentation, prior-authorization, etc.)\n- **Custom Context**: Any additional requirements or constraints\n\n## Prompt Generation Process\n\n### 1. Role Definition Section\nCreate a clear role section that:\n- Establishes the agent as a healthcare specialist\n- References the specific goal and domain\n- Includes relevant medical/clinical expertise\n- Maintains professional healthcare identity\n\n### 2. Objectives Section\nDefine primary objectives that:\n- Directly align with the provided agent goal\n- Include specific, actionable responsibilities\n- Reference healthcare standards and best practices\n- Emphasize patient safety and care quality\n\n### 3. Healthcare Context Section\nProvide domain-specific context including:\n- Relevant medical terminology and standards\n- Industry regulations (HIPAA, CMS guidelines)\n- Clinical workflows and protocols\n- Healthcare compliance requirements\n\n### 4. Detailed Instructions Section\nCreate comprehensive instructions covering:\n- Step-by-step task guidance\n- Domain-specific procedures and protocols\n- Quality assurance requirements\n- Professional communication standards\n\n### 5. Compliance Guidelines Section\nInclude healthcare compliance requirements:\n- HIPAA privacy and security protocols\n- Patient data protection standards\n- Healthcare regulatory compliance\n- Audit and documentation requirements\n\n### 6. Error Handling Section\nProvide error management guidance:\n- Input validation procedures\n- Error identification and categorization\n- Recovery and escalation protocols\n- User communication during errors\n\n### 7. Output Format Section\nDefine output structure requirements:\n- Professional formatting standards\n- Healthcare terminology usage\n- Required information completeness\n- Documentation and reporting formats\n\n## Healthcare Domain Specializations\n\n### Clinical Documentation\n- SOAP note structure and medical terminology\n- Clinical coding requirements (ICD-10, CPT)\n- Medical record accuracy and completeness\n- Provider documentation standards\n\n### Prior Authorization\n- Medical necessity criteria and documentation\n- Payer-specific requirements and timelines\n- Clinical justification and evidence\n- Authorization tracking and follow-up\n\n### Patient Experience\n- Patient-centered communication protocols\n- Care coordination and transition planning\n- Engagement strategies and satisfaction metrics\n- Cultural sensitivity and accessibility\n\n### Medical Coding\n- Coding accuracy and compliance standards\n- Official coding guidelines and conventions\n- Documentation review and query procedures\n- Billing and reimbursement support\n\n### Quality Measures\n- Healthcare quality metrics and reporting\n- Performance improvement protocols\n- Data accuracy and validation requirements\n- Regulatory compliance monitoring\n\n### Care Coordination\n- Interdisciplinary team communication\n- Care plan development and management\n- Resource coordination and referral management\n- Patient advocacy and support services\n\n## Response Format\n\nProvide your response as structured YAML with the generated prompt content:\n\n```yaml\nprompt_content: |\n  <role>\n  [Agent role definition with healthcare expertise]\n  </role>\n\n  <objectives>\n  [Primary objectives aligned with agent goal]\n  </objectives>\n\n  <healthcare_context>\n  [Domain-specific healthcare context and standards]\n  </healthcare_context>\n\n  <instructions>\n  [Detailed step-by-step guidance and procedures]\n  </instructions>\n\n  <compliance>\n  [Healthcare compliance and regulatory requirements]\n  </compliance>\n\n  <error_handling>\n  [Error management and recovery protocols]\n  </error_handling>\n\n  <output_format>\n  [Professional output formatting requirements]\n  </output_format>\n\nmetadata:\n  domain: [healthcare_domain]\n  sections: [number_of_sections]\n  compliance_included: true\n  word_count: [approximate_word_count]\n\nsummary: |\n  Brief summary of the generated prompt's key features and healthcare focus areas.\n```\n\n## Quality Standards\n\nEnsure every generated prompt:\n- Uses appropriate medical terminology\n- Maintains professional healthcare tone\n- Includes specific, actionable guidance\n- References relevant healthcare standards\n- Emphasizes patient safety and privacy\n- Provides comprehensive error handling\n- Supports regulatory compliance\n\n</instructions>\n\nRemember: Generate prompts that create knowledgeable, compliant, and effective healthcare AI agents that maintain the highest standards of patient care and professional practice!\n"
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": true,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "Controls randomness. Lower values are more deterministic, higher values are more creative.",
                "input_types": [],
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 2,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.7
              },
              "tools": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Tools",
                "dynamic": false,
                "info": "These are the tools that the agent can use to help with tasks.",
                "input_types": [
                  "Tool"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "tools",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "tools_metadata": {
                "_input_type": "ToolsInput",
                "advanced": false,
                "display_name": "Actions",
                "dynamic": false,
                "info": "Modify tool names and descriptions to help agents understand when to use each tool.",
                "is_list": true,
                "list_add_label": "Add More",
                "name": "tools_metadata",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tools",
                "value": [
                  {
                    "args": {
                      "input_value": {
                        "default": "",
                        "description": "The input provided by the user for the agent to process.",
                        "title": "Input Value",
                        "type": "string"
                      }
                    },
                    "description": "A helpful assistant with access to the following tools:",
                    "display_description": "Define the agent's instructions, then enter a task to complete using tools.",
                    "display_name": "message_response",
                    "name": "prompt_generator",
                    "readonly": false,
                    "status": true,
                    "tags": [
                      "Call_Agent"
                    ]
                  }
                ]
              },
              "verbose": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Verbose",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "verbose",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": true
          },
          "showNode": true,
          "type": "Agent"
        },
        "dragging": false,
        "id": "Agent-aQjuh",
        "measured": {
          "height": 757,
          "width": 320
        },
        "position": {
          "x": 1217.919317311766,
          "y": 1790.5034155395422
        },
        "selected": true,
        "type": "genericNode"
      }
    ],
    "viewport": {
      "x": -250.79013685267603,
      "y": -493.9991799169302,
      "zoom": 0.5328264689903687
    }
  },
  "description": "Updated Agent Builder",
  "endpoint_name": null,
  "id": "01752477-a7b3-4622-8420-36d4a6b81476",
  "is_component": false,
  "last_tested_version": "1.6.3",
  "name": "BuilderAgent",
  "tags": []
}
